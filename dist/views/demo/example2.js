require('views/demo/example2.css');
var views = views || {};
views.demo = views.demo || {};
views.demo.example2 = (() => {
  var __create = Object.create;
  var __defProp = Object.defineProperty;
  var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
  var __getOwnPropNames = Object.getOwnPropertyNames;
  var __getProtoOf = Object.getPrototypeOf;
  var __hasOwnProp = Object.prototype.hasOwnProperty;
  var __require = /* @__PURE__ */ ((x) => typeof require !== "undefined" ? require : typeof Proxy !== "undefined" ? new Proxy(x, {
    get: (a, b) => (typeof require !== "undefined" ? require : a)[b]
  }) : x)(function(x) {
    if (typeof require !== "undefined")
      return require.apply(this, arguments);
    throw new Error('Dynamic require of "' + x + '" is not supported');
  });
  var __commonJS = (cb, mod) => function __require2() {
    return mod || (0, cb[__getOwnPropNames(cb)[0]])((mod = { exports: {} }).exports, mod), mod.exports;
  };
  var __export = (target, all) => {
    for (var name in all)
      __defProp(target, name, { get: all[name], enumerable: true });
  };
  var __copyProps = (to, from, except, desc) => {
    if (from && typeof from === "object" || typeof from === "function") {
      for (let key of __getOwnPropNames(from))
        if (!__hasOwnProp.call(to, key) && key !== except)
          __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
    }
    return to;
  };
  var __toESM = (mod, isNodeMode, target) => (target = mod != null ? __create(__getProtoOf(mod)) : {}, __copyProps(isNodeMode || !mod || !mod.__esModule ? __defProp(target, "default", { value: mod, enumerable: true }) : target, mod));
  var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);

  // node_modules/echarts/node_modules/tslib/tslib.js
  var require_tslib = __commonJS({
    "node_modules/echarts/node_modules/tslib/tslib.js"(exports, module) {
      var __extends3;
      var __assign3;
      var __rest3;
      var __decorate3;
      var __param3;
      var __metadata3;
      var __awaiter3;
      var __generator3;
      var __exportStar3;
      var __values3;
      var __read3;
      var __spread3;
      var __spreadArrays3;
      var __spreadArray3;
      var __await3;
      var __asyncGenerator3;
      var __asyncDelegator3;
      var __asyncValues3;
      var __makeTemplateObject3;
      var __importStar3;
      var __importDefault3;
      var __classPrivateFieldGet3;
      var __classPrivateFieldSet3;
      var __createBinding3;
      (function(factory) {
        var root = typeof global === "object" ? global : typeof self === "object" ? self : typeof this === "object" ? this : {};
        if (typeof define === "function" && define.amd) {
          define("tslib", ["exports"], function(exports2) {
            factory(createExporter(root, createExporter(exports2)));
          });
        } else if (typeof module === "object" && typeof module.exports === "object") {
          factory(createExporter(root, createExporter(module.exports)));
        } else {
          factory(createExporter(root));
        }
        function createExporter(exports2, previous) {
          if (exports2 !== root) {
            if (typeof Object.create === "function") {
              Object.defineProperty(exports2, "__esModule", { value: true });
            } else {
              exports2.__esModule = true;
            }
          }
          return function(id, v) {
            return exports2[id] = previous ? previous(id, v) : v;
          };
        }
      })(function(exporter) {
        var extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d, b) {
          d.__proto__ = b;
        } || function(d, b) {
          for (var p in b)
            if (Object.prototype.hasOwnProperty.call(b, p))
              d[p] = b[p];
        };
        __extends3 = function(d, b) {
          if (typeof b !== "function" && b !== null)
            throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
          extendStatics(d, b);
          function __() {
            this.constructor = d;
          }
          d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
        };
        __assign3 = Object.assign || function(t) {
          for (var s, i = 1, n = arguments.length; i < n; i++) {
            s = arguments[i];
            for (var p in s)
              if (Object.prototype.hasOwnProperty.call(s, p))
                t[p] = s[p];
          }
          return t;
        };
        __rest3 = function(s, e2) {
          var t = {};
          for (var p in s)
            if (Object.prototype.hasOwnProperty.call(s, p) && e2.indexOf(p) < 0)
              t[p] = s[p];
          if (s != null && typeof Object.getOwnPropertySymbols === "function")
            for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
              if (e2.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))
                t[p[i]] = s[p[i]];
            }
          return t;
        };
        __decorate3 = function(decorators, target, key, desc) {
          var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
          if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
            r = Reflect.decorate(decorators, target, key, desc);
          else
            for (var i = decorators.length - 1; i >= 0; i--)
              if (d = decorators[i])
                r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
          return c > 3 && r && Object.defineProperty(target, key, r), r;
        };
        __param3 = function(paramIndex, decorator) {
          return function(target, key) {
            decorator(target, key, paramIndex);
          };
        };
        __metadata3 = function(metadataKey, metadataValue) {
          if (typeof Reflect === "object" && typeof Reflect.metadata === "function")
            return Reflect.metadata(metadataKey, metadataValue);
        };
        __awaiter3 = function(thisArg, _arguments, P, generator) {
          function adopt(value) {
            return value instanceof P ? value : new P(function(resolve) {
              resolve(value);
            });
          }
          return new (P || (P = Promise))(function(resolve, reject) {
            function fulfilled(value) {
              try {
                step(generator.next(value));
              } catch (e2) {
                reject(e2);
              }
            }
            function rejected(value) {
              try {
                step(generator["throw"](value));
              } catch (e2) {
                reject(e2);
              }
            }
            function step(result) {
              result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
            }
            step((generator = generator.apply(thisArg, _arguments || [])).next());
          });
        };
        __generator3 = function(thisArg, body) {
          var _ = { label: 0, sent: function() {
            if (t[0] & 1)
              throw t[1];
            return t[1];
          }, trys: [], ops: [] }, f, y, t, g;
          return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() {
            return this;
          }), g;
          function verb(n) {
            return function(v) {
              return step([n, v]);
            };
          }
          function step(op) {
            if (f)
              throw new TypeError("Generator is already executing.");
            while (_)
              try {
                if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done)
                  return t;
                if (y = 0, t)
                  op = [op[0] & 2, t.value];
                switch (op[0]) {
                  case 0:
                  case 1:
                    t = op;
                    break;
                  case 4:
                    _.label++;
                    return { value: op[1], done: false };
                  case 5:
                    _.label++;
                    y = op[1];
                    op = [0];
                    continue;
                  case 7:
                    op = _.ops.pop();
                    _.trys.pop();
                    continue;
                  default:
                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) {
                      _ = 0;
                      continue;
                    }
                    if (op[0] === 3 && (!t || op[1] > t[0] && op[1] < t[3])) {
                      _.label = op[1];
                      break;
                    }
                    if (op[0] === 6 && _.label < t[1]) {
                      _.label = t[1];
                      t = op;
                      break;
                    }
                    if (t && _.label < t[2]) {
                      _.label = t[2];
                      _.ops.push(op);
                      break;
                    }
                    if (t[2])
                      _.ops.pop();
                    _.trys.pop();
                    continue;
                }
                op = body.call(thisArg, _);
              } catch (e2) {
                op = [6, e2];
                y = 0;
              } finally {
                f = t = 0;
              }
            if (op[0] & 5)
              throw op[1];
            return { value: op[0] ? op[1] : void 0, done: true };
          }
        };
        __exportStar3 = function(m2, o) {
          for (var p in m2)
            if (p !== "default" && !Object.prototype.hasOwnProperty.call(o, p))
              __createBinding3(o, m2, p);
        };
        __createBinding3 = Object.create ? function(o, m2, k, k2) {
          if (k2 === void 0)
            k2 = k;
          Object.defineProperty(o, k2, { enumerable: true, get: function() {
            return m2[k];
          } });
        } : function(o, m2, k, k2) {
          if (k2 === void 0)
            k2 = k;
          o[k2] = m2[k];
        };
        __values3 = function(o) {
          var s = typeof Symbol === "function" && Symbol.iterator, m2 = s && o[s], i = 0;
          if (m2)
            return m2.call(o);
          if (o && typeof o.length === "number")
            return {
              next: function() {
                if (o && i >= o.length)
                  o = void 0;
                return { value: o && o[i++], done: !o };
              }
            };
          throw new TypeError(s ? "Object is not iterable." : "Symbol.iterator is not defined.");
        };
        __read3 = function(o, n) {
          var m2 = typeof Symbol === "function" && o[Symbol.iterator];
          if (!m2)
            return o;
          var i = m2.call(o), r, ar = [], e2;
          try {
            while ((n === void 0 || n-- > 0) && !(r = i.next()).done)
              ar.push(r.value);
          } catch (error2) {
            e2 = { error: error2 };
          } finally {
            try {
              if (r && !r.done && (m2 = i["return"]))
                m2.call(i);
            } finally {
              if (e2)
                throw e2.error;
            }
          }
          return ar;
        };
        __spread3 = function() {
          for (var ar = [], i = 0; i < arguments.length; i++)
            ar = ar.concat(__read3(arguments[i]));
          return ar;
        };
        __spreadArrays3 = function() {
          for (var s = 0, i = 0, il = arguments.length; i < il; i++)
            s += arguments[i].length;
          for (var r = Array(s), k = 0, i = 0; i < il; i++)
            for (var a = arguments[i], j = 0, jl = a.length; j < jl; j++, k++)
              r[k] = a[j];
          return r;
        };
        __spreadArray3 = function(to, from, pack) {
          if (pack || arguments.length === 2)
            for (var i = 0, l = from.length, ar; i < l; i++) {
              if (ar || !(i in from)) {
                if (!ar)
                  ar = Array.prototype.slice.call(from, 0, i);
                ar[i] = from[i];
              }
            }
          return to.concat(ar || from);
        };
        __await3 = function(v) {
          return this instanceof __await3 ? (this.v = v, this) : new __await3(v);
        };
        __asyncGenerator3 = function(thisArg, _arguments, generator) {
          if (!Symbol.asyncIterator)
            throw new TypeError("Symbol.asyncIterator is not defined.");
          var g = generator.apply(thisArg, _arguments || []), i, q = [];
          return i = {}, verb("next"), verb("throw"), verb("return"), i[Symbol.asyncIterator] = function() {
            return this;
          }, i;
          function verb(n) {
            if (g[n])
              i[n] = function(v) {
                return new Promise(function(a, b) {
                  q.push([n, v, a, b]) > 1 || resume(n, v);
                });
              };
          }
          function resume(n, v) {
            try {
              step(g[n](v));
            } catch (e2) {
              settle(q[0][3], e2);
            }
          }
          function step(r) {
            r.value instanceof __await3 ? Promise.resolve(r.value.v).then(fulfill, reject) : settle(q[0][2], r);
          }
          function fulfill(value) {
            resume("next", value);
          }
          function reject(value) {
            resume("throw", value);
          }
          function settle(f, v) {
            if (f(v), q.shift(), q.length)
              resume(q[0][0], q[0][1]);
          }
        };
        __asyncDelegator3 = function(o) {
          var i, p;
          return i = {}, verb("next"), verb("throw", function(e2) {
            throw e2;
          }), verb("return"), i[Symbol.iterator] = function() {
            return this;
          }, i;
          function verb(n, f) {
            i[n] = o[n] ? function(v) {
              return (p = !p) ? { value: __await3(o[n](v)), done: n === "return" } : f ? f(v) : v;
            } : f;
          }
        };
        __asyncValues3 = function(o) {
          if (!Symbol.asyncIterator)
            throw new TypeError("Symbol.asyncIterator is not defined.");
          var m2 = o[Symbol.asyncIterator], i;
          return m2 ? m2.call(o) : (o = typeof __values3 === "function" ? __values3(o) : o[Symbol.iterator](), i = {}, verb("next"), verb("throw"), verb("return"), i[Symbol.asyncIterator] = function() {
            return this;
          }, i);
          function verb(n) {
            i[n] = o[n] && function(v) {
              return new Promise(function(resolve, reject) {
                v = o[n](v), settle(resolve, reject, v.done, v.value);
              });
            };
          }
          function settle(resolve, reject, d, v) {
            Promise.resolve(v).then(function(v4) {
              resolve({ value: v4, done: d });
            }, reject);
          }
        };
        __makeTemplateObject3 = function(cooked, raw) {
          if (Object.defineProperty) {
            Object.defineProperty(cooked, "raw", { value: raw });
          } else {
            cooked.raw = raw;
          }
          return cooked;
        };
        var __setModuleDefault = Object.create ? function(o, v) {
          Object.defineProperty(o, "default", { enumerable: true, value: v });
        } : function(o, v) {
          o["default"] = v;
        };
        __importStar3 = function(mod) {
          if (mod && mod.__esModule)
            return mod;
          var result = {};
          if (mod != null) {
            for (var k in mod)
              if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k))
                __createBinding3(result, mod, k);
          }
          __setModuleDefault(result, mod);
          return result;
        };
        __importDefault3 = function(mod) {
          return mod && mod.__esModule ? mod : { "default": mod };
        };
        __classPrivateFieldGet3 = function(receiver, state, kind, f) {
          if (kind === "a" && !f)
            throw new TypeError("Private accessor was defined without a getter");
          if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver))
            throw new TypeError("Cannot read private member from an object whose class did not declare it");
          return kind === "m" ? f : kind === "a" ? f.call(receiver) : f ? f.value : state.get(receiver);
        };
        __classPrivateFieldSet3 = function(receiver, state, value, kind, f) {
          if (kind === "m")
            throw new TypeError("Private method is not writable");
          if (kind === "a" && !f)
            throw new TypeError("Private accessor was defined without a setter");
          if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver))
            throw new TypeError("Cannot write private member to an object whose class did not declare it");
          return kind === "a" ? f.call(receiver, value) : f ? f.value = value : state.set(receiver, value), value;
        };
        exporter("__extends", __extends3);
        exporter("__assign", __assign3);
        exporter("__rest", __rest3);
        exporter("__decorate", __decorate3);
        exporter("__param", __param3);
        exporter("__metadata", __metadata3);
        exporter("__awaiter", __awaiter3);
        exporter("__generator", __generator3);
        exporter("__exportStar", __exportStar3);
        exporter("__createBinding", __createBinding3);
        exporter("__values", __values3);
        exporter("__read", __read3);
        exporter("__spread", __spread3);
        exporter("__spreadArrays", __spreadArrays3);
        exporter("__spreadArray", __spreadArray3);
        exporter("__await", __await3);
        exporter("__asyncGenerator", __asyncGenerator3);
        exporter("__asyncDelegator", __asyncDelegator3);
        exporter("__asyncValues", __asyncValues3);
        exporter("__makeTemplateObject", __makeTemplateObject3);
        exporter("__importStar", __importStar3);
        exporter("__importDefault", __importDefault3);
        exporter("__classPrivateFieldGet", __classPrivateFieldGet3);
        exporter("__classPrivateFieldSet", __classPrivateFieldSet3);
      });
    }
  });

  // node_modules/zrender/node_modules/tslib/tslib.js
  var require_tslib2 = __commonJS({
    "node_modules/zrender/node_modules/tslib/tslib.js"(exports, module) {
      var __extends3;
      var __assign3;
      var __rest3;
      var __decorate3;
      var __param3;
      var __metadata3;
      var __awaiter3;
      var __generator3;
      var __exportStar3;
      var __values3;
      var __read3;
      var __spread3;
      var __spreadArrays3;
      var __spreadArray3;
      var __await3;
      var __asyncGenerator3;
      var __asyncDelegator3;
      var __asyncValues3;
      var __makeTemplateObject3;
      var __importStar3;
      var __importDefault3;
      var __classPrivateFieldGet3;
      var __classPrivateFieldSet3;
      var __createBinding3;
      (function(factory) {
        var root = typeof global === "object" ? global : typeof self === "object" ? self : typeof this === "object" ? this : {};
        if (typeof define === "function" && define.amd) {
          define("tslib", ["exports"], function(exports2) {
            factory(createExporter(root, createExporter(exports2)));
          });
        } else if (typeof module === "object" && typeof module.exports === "object") {
          factory(createExporter(root, createExporter(module.exports)));
        } else {
          factory(createExporter(root));
        }
        function createExporter(exports2, previous) {
          if (exports2 !== root) {
            if (typeof Object.create === "function") {
              Object.defineProperty(exports2, "__esModule", { value: true });
            } else {
              exports2.__esModule = true;
            }
          }
          return function(id, v) {
            return exports2[id] = previous ? previous(id, v) : v;
          };
        }
      })(function(exporter) {
        var extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d, b) {
          d.__proto__ = b;
        } || function(d, b) {
          for (var p in b)
            if (Object.prototype.hasOwnProperty.call(b, p))
              d[p] = b[p];
        };
        __extends3 = function(d, b) {
          if (typeof b !== "function" && b !== null)
            throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
          extendStatics(d, b);
          function __() {
            this.constructor = d;
          }
          d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
        };
        __assign3 = Object.assign || function(t) {
          for (var s, i = 1, n = arguments.length; i < n; i++) {
            s = arguments[i];
            for (var p in s)
              if (Object.prototype.hasOwnProperty.call(s, p))
                t[p] = s[p];
          }
          return t;
        };
        __rest3 = function(s, e2) {
          var t = {};
          for (var p in s)
            if (Object.prototype.hasOwnProperty.call(s, p) && e2.indexOf(p) < 0)
              t[p] = s[p];
          if (s != null && typeof Object.getOwnPropertySymbols === "function")
            for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
              if (e2.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))
                t[p[i]] = s[p[i]];
            }
          return t;
        };
        __decorate3 = function(decorators, target, key, desc) {
          var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
          if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
            r = Reflect.decorate(decorators, target, key, desc);
          else
            for (var i = decorators.length - 1; i >= 0; i--)
              if (d = decorators[i])
                r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
          return c > 3 && r && Object.defineProperty(target, key, r), r;
        };
        __param3 = function(paramIndex, decorator) {
          return function(target, key) {
            decorator(target, key, paramIndex);
          };
        };
        __metadata3 = function(metadataKey, metadataValue) {
          if (typeof Reflect === "object" && typeof Reflect.metadata === "function")
            return Reflect.metadata(metadataKey, metadataValue);
        };
        __awaiter3 = function(thisArg, _arguments, P, generator) {
          function adopt(value) {
            return value instanceof P ? value : new P(function(resolve) {
              resolve(value);
            });
          }
          return new (P || (P = Promise))(function(resolve, reject) {
            function fulfilled(value) {
              try {
                step(generator.next(value));
              } catch (e2) {
                reject(e2);
              }
            }
            function rejected(value) {
              try {
                step(generator["throw"](value));
              } catch (e2) {
                reject(e2);
              }
            }
            function step(result) {
              result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
            }
            step((generator = generator.apply(thisArg, _arguments || [])).next());
          });
        };
        __generator3 = function(thisArg, body) {
          var _ = { label: 0, sent: function() {
            if (t[0] & 1)
              throw t[1];
            return t[1];
          }, trys: [], ops: [] }, f, y, t, g;
          return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() {
            return this;
          }), g;
          function verb(n) {
            return function(v) {
              return step([n, v]);
            };
          }
          function step(op) {
            if (f)
              throw new TypeError("Generator is already executing.");
            while (_)
              try {
                if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done)
                  return t;
                if (y = 0, t)
                  op = [op[0] & 2, t.value];
                switch (op[0]) {
                  case 0:
                  case 1:
                    t = op;
                    break;
                  case 4:
                    _.label++;
                    return { value: op[1], done: false };
                  case 5:
                    _.label++;
                    y = op[1];
                    op = [0];
                    continue;
                  case 7:
                    op = _.ops.pop();
                    _.trys.pop();
                    continue;
                  default:
                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) {
                      _ = 0;
                      continue;
                    }
                    if (op[0] === 3 && (!t || op[1] > t[0] && op[1] < t[3])) {
                      _.label = op[1];
                      break;
                    }
                    if (op[0] === 6 && _.label < t[1]) {
                      _.label = t[1];
                      t = op;
                      break;
                    }
                    if (t && _.label < t[2]) {
                      _.label = t[2];
                      _.ops.push(op);
                      break;
                    }
                    if (t[2])
                      _.ops.pop();
                    _.trys.pop();
                    continue;
                }
                op = body.call(thisArg, _);
              } catch (e2) {
                op = [6, e2];
                y = 0;
              } finally {
                f = t = 0;
              }
            if (op[0] & 5)
              throw op[1];
            return { value: op[0] ? op[1] : void 0, done: true };
          }
        };
        __exportStar3 = function(m2, o) {
          for (var p in m2)
            if (p !== "default" && !Object.prototype.hasOwnProperty.call(o, p))
              __createBinding3(o, m2, p);
        };
        __createBinding3 = Object.create ? function(o, m2, k, k2) {
          if (k2 === void 0)
            k2 = k;
          Object.defineProperty(o, k2, { enumerable: true, get: function() {
            return m2[k];
          } });
        } : function(o, m2, k, k2) {
          if (k2 === void 0)
            k2 = k;
          o[k2] = m2[k];
        };
        __values3 = function(o) {
          var s = typeof Symbol === "function" && Symbol.iterator, m2 = s && o[s], i = 0;
          if (m2)
            return m2.call(o);
          if (o && typeof o.length === "number")
            return {
              next: function() {
                if (o && i >= o.length)
                  o = void 0;
                return { value: o && o[i++], done: !o };
              }
            };
          throw new TypeError(s ? "Object is not iterable." : "Symbol.iterator is not defined.");
        };
        __read3 = function(o, n) {
          var m2 = typeof Symbol === "function" && o[Symbol.iterator];
          if (!m2)
            return o;
          var i = m2.call(o), r, ar = [], e2;
          try {
            while ((n === void 0 || n-- > 0) && !(r = i.next()).done)
              ar.push(r.value);
          } catch (error2) {
            e2 = { error: error2 };
          } finally {
            try {
              if (r && !r.done && (m2 = i["return"]))
                m2.call(i);
            } finally {
              if (e2)
                throw e2.error;
            }
          }
          return ar;
        };
        __spread3 = function() {
          for (var ar = [], i = 0; i < arguments.length; i++)
            ar = ar.concat(__read3(arguments[i]));
          return ar;
        };
        __spreadArrays3 = function() {
          for (var s = 0, i = 0, il = arguments.length; i < il; i++)
            s += arguments[i].length;
          for (var r = Array(s), k = 0, i = 0; i < il; i++)
            for (var a = arguments[i], j = 0, jl = a.length; j < jl; j++, k++)
              r[k] = a[j];
          return r;
        };
        __spreadArray3 = function(to, from, pack) {
          if (pack || arguments.length === 2)
            for (var i = 0, l = from.length, ar; i < l; i++) {
              if (ar || !(i in from)) {
                if (!ar)
                  ar = Array.prototype.slice.call(from, 0, i);
                ar[i] = from[i];
              }
            }
          return to.concat(ar || from);
        };
        __await3 = function(v) {
          return this instanceof __await3 ? (this.v = v, this) : new __await3(v);
        };
        __asyncGenerator3 = function(thisArg, _arguments, generator) {
          if (!Symbol.asyncIterator)
            throw new TypeError("Symbol.asyncIterator is not defined.");
          var g = generator.apply(thisArg, _arguments || []), i, q = [];
          return i = {}, verb("next"), verb("throw"), verb("return"), i[Symbol.asyncIterator] = function() {
            return this;
          }, i;
          function verb(n) {
            if (g[n])
              i[n] = function(v) {
                return new Promise(function(a, b) {
                  q.push([n, v, a, b]) > 1 || resume(n, v);
                });
              };
          }
          function resume(n, v) {
            try {
              step(g[n](v));
            } catch (e2) {
              settle(q[0][3], e2);
            }
          }
          function step(r) {
            r.value instanceof __await3 ? Promise.resolve(r.value.v).then(fulfill, reject) : settle(q[0][2], r);
          }
          function fulfill(value) {
            resume("next", value);
          }
          function reject(value) {
            resume("throw", value);
          }
          function settle(f, v) {
            if (f(v), q.shift(), q.length)
              resume(q[0][0], q[0][1]);
          }
        };
        __asyncDelegator3 = function(o) {
          var i, p;
          return i = {}, verb("next"), verb("throw", function(e2) {
            throw e2;
          }), verb("return"), i[Symbol.iterator] = function() {
            return this;
          }, i;
          function verb(n, f) {
            i[n] = o[n] ? function(v) {
              return (p = !p) ? { value: __await3(o[n](v)), done: n === "return" } : f ? f(v) : v;
            } : f;
          }
        };
        __asyncValues3 = function(o) {
          if (!Symbol.asyncIterator)
            throw new TypeError("Symbol.asyncIterator is not defined.");
          var m2 = o[Symbol.asyncIterator], i;
          return m2 ? m2.call(o) : (o = typeof __values3 === "function" ? __values3(o) : o[Symbol.iterator](), i = {}, verb("next"), verb("throw"), verb("return"), i[Symbol.asyncIterator] = function() {
            return this;
          }, i);
          function verb(n) {
            i[n] = o[n] && function(v) {
              return new Promise(function(resolve, reject) {
                v = o[n](v), settle(resolve, reject, v.done, v.value);
              });
            };
          }
          function settle(resolve, reject, d, v) {
            Promise.resolve(v).then(function(v4) {
              resolve({ value: v4, done: d });
            }, reject);
          }
        };
        __makeTemplateObject3 = function(cooked, raw) {
          if (Object.defineProperty) {
            Object.defineProperty(cooked, "raw", { value: raw });
          } else {
            cooked.raw = raw;
          }
          return cooked;
        };
        var __setModuleDefault = Object.create ? function(o, v) {
          Object.defineProperty(o, "default", { enumerable: true, value: v });
        } : function(o, v) {
          o["default"] = v;
        };
        __importStar3 = function(mod) {
          if (mod && mod.__esModule)
            return mod;
          var result = {};
          if (mod != null) {
            for (var k in mod)
              if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k))
                __createBinding3(result, mod, k);
          }
          __setModuleDefault(result, mod);
          return result;
        };
        __importDefault3 = function(mod) {
          return mod && mod.__esModule ? mod : { "default": mod };
        };
        __classPrivateFieldGet3 = function(receiver, state, kind, f) {
          if (kind === "a" && !f)
            throw new TypeError("Private accessor was defined without a getter");
          if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver))
            throw new TypeError("Cannot read private member from an object whose class did not declare it");
          return kind === "m" ? f : kind === "a" ? f.call(receiver) : f ? f.value : state.get(receiver);
        };
        __classPrivateFieldSet3 = function(receiver, state, value, kind, f) {
          if (kind === "m")
            throw new TypeError("Private method is not writable");
          if (kind === "a" && !f)
            throw new TypeError("Private accessor was defined without a setter");
          if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver))
            throw new TypeError("Cannot write private member to an object whose class did not declare it");
          return kind === "a" ? f.call(receiver, value) : f ? f.value = value : state.set(receiver, value), value;
        };
        exporter("__extends", __extends3);
        exporter("__assign", __assign3);
        exporter("__rest", __rest3);
        exporter("__decorate", __decorate3);
        exporter("__param", __param3);
        exporter("__metadata", __metadata3);
        exporter("__awaiter", __awaiter3);
        exporter("__generator", __generator3);
        exporter("__exportStar", __exportStar3);
        exporter("__createBinding", __createBinding3);
        exporter("__values", __values3);
        exporter("__read", __read3);
        exporter("__spread", __spread3);
        exporter("__spreadArrays", __spreadArrays3);
        exporter("__spreadArray", __spreadArray3);
        exporter("__await", __await3);
        exporter("__asyncGenerator", __asyncGenerator3);
        exporter("__asyncDelegator", __asyncDelegator3);
        exporter("__asyncValues", __asyncValues3);
        exporter("__makeTemplateObject", __makeTemplateObject3);
        exporter("__importStar", __importStar3);
        exporter("__importDefault", __importDefault3);
        exporter("__classPrivateFieldGet", __classPrivateFieldGet3);
        exporter("__classPrivateFieldSet", __classPrivateFieldSet3);
      });
    }
  });

  // src/assets/tinymce/langs/zh_CN.js
  var require_zh_CN = __commonJS({
    "src/assets/tinymce/langs/zh_CN.js"() {
      tinymce.addI18n("zh_CN", {
        "Redo": "重做",
        "Undo": "撤销",
        "Cut": "剪切",
        "Copy": "复制",
        "Paste": "粘贴",
        "Select all": "全选",
        "New document": "新文件",
        "Ok": "确定",
        "Cancel": "取消",
        "Visual aids": "网格线",
        "Bold": "粗体",
        "Italic": "斜体",
        "Underline": "下划线",
        "Strikethrough": "删除线",
        "Superscript": "上标",
        "Subscript": "下标",
        "Clear formatting": "清除格式",
        "Align left": "左边对齐",
        "Align center": "中间对齐",
        "Align right": "右边对齐",
        "Justify": "两端对齐",
        "Bullet list": "项目符号",
        "Numbered list": "编号列表",
        "Decrease indent": "减少缩进",
        "Increase indent": "增加缩进",
        "Close": "关闭",
        "Formats": "格式",
        "Your browser doesn't support direct access to the clipboard. Please use the Ctrl+X/C/V keyboard shortcuts instead.": "你的浏览器不支持打开剪贴板，请使用Ctrl+X/C/V等快捷键。",
        "Headers": "标题",
        "Header 1": "标题1",
        "Header 2": "标题2",
        "Header 3": "标题3",
        "Header 4": "标题4",
        "Header 5": "标题5",
        "Header 6": "标题6",
        "Headings": "标题",
        "Heading 1": "标题1",
        "Heading 2": "标题2",
        "Heading 3": "标题3",
        "Heading 4": "标题4",
        "Heading 5": "标题5",
        "Heading 6": "标题6",
        "Preformatted": "预先格式化的",
        "Div": "Div",
        "Pre": "Pre",
        "Code": "代码",
        "Paragraph": "段落",
        "Blockquote": "引文区块",
        "Inline": "文本",
        "Blocks": "基块",
        "Paste is now in plain text mode. Contents will now be pasted as plain text until you toggle this option off.": "当前为纯文本粘贴模式，再次点击可以回到普通粘贴模式。",
        "Fonts": "字体",
        "Font Sizes": "字号",
        "Class": "类型",
        "Browse for an image": "浏览图像",
        "OR": "或",
        "Drop an image here": "拖放一张图像至此",
        "Upload": "上传",
        "Block": "块",
        "Align": "对齐",
        "Default": "默认",
        "Circle": "空心圆",
        "Disc": "实心圆",
        "Square": "方块",
        "Lower Alpha": "小写英文字母",
        "Lower Greek": "小写希腊字母",
        "Lower Roman": "小写罗马字母",
        "Upper Alpha": "大写英文字母",
        "Upper Roman": "大写罗马字母",
        "Anchor...": "锚点...",
        "Name": "名称",
        "Id": "标识符",
        "Id should start with a letter, followed only by letters, numbers, dashes, dots, colons or underscores.": "标识符应该以字母开头，后跟字母、数字、破折号、点、冒号或下划线。",
        "You have unsaved changes are you sure you want to navigate away?": "你还有文档尚未保存，确定要离开？",
        "Restore last draft": "恢复上次的草稿",
        "Special character...": "特殊字符...",
        "Source code": "源代码",
        "Insert/Edit code sample": "插入/编辑代码示例",
        "Language": "语言",
        "Code sample...": "示例代码...",
        "Color Picker": "选色器",
        "R": "R",
        "G": "G",
        "B": "B",
        "Left to right": "从左到右",
        "Right to left": "从右到左",
        "Emoticons...": "表情符号...",
        "Metadata and Document Properties": "元数据和文档属性",
        "Title": "标题",
        "Keywords": "关键词",
        "Description": "描述",
        "Robots": "机器人",
        "Author": "作者",
        "Encoding": "编码",
        "Fullscreen": "全屏",
        "Action": "操作",
        "Shortcut": "快捷键",
        "Help": "帮助",
        "Address": "地址",
        "Focus to menubar": "移动焦点到菜单栏",
        "Focus to toolbar": "移动焦点到工具栏",
        "Focus to element path": "移动焦点到元素路径",
        "Focus to contextual toolbar": "移动焦点到上下文菜单",
        "Insert link (if link plugin activated)": "插入链接 (如果链接插件已激活)",
        "Save (if save plugin activated)": "保存(如果保存插件已激活)",
        "Find (if searchreplace plugin activated)": "查找(如果查找替换插件已激活)",
        "Plugins installed ({0}):": "已安装插件 ({0}):",
        "Premium plugins:": "优秀插件：",
        "Learn more...": "了解更多...",
        "You are using {0}": "你正在使用 {0}",
        "Plugins": "插件",
        "Handy Shortcuts": "快捷键",
        "Horizontal line": "水平分割线",
        "Insert/edit image": "插入/编辑图片",
        "Image description": "图片描述",
        "Source": "地址",
        "Dimensions": "大小",
        "Constrain proportions": "保持纵横比",
        "General": "普通",
        "Advanced": "高级",
        "Style": "样式",
        "Vertical space": "垂直边距",
        "Horizontal space": "水平边距",
        "Border": "边框",
        "Insert image": "插入图片",
        "Image...": "图片...",
        "Image list": "图片列表",
        "Rotate counterclockwise": "逆时针旋转",
        "Rotate clockwise": "顺时针旋转",
        "Flip vertically": "垂直翻转",
        "Flip horizontally": "水平翻转",
        "Edit image": "编辑图片",
        "Image options": "图片选项",
        "Zoom in": "放大",
        "Zoom out": "缩小",
        "Crop": "裁剪",
        "Resize": "调整大小",
        "Orientation": "方向",
        "Brightness": "亮度",
        "Sharpen": "锐化",
        "Contrast": "对比度",
        "Color levels": "颜色层次",
        "Gamma": "伽马值",
        "Invert": "反转",
        "Apply": "应用",
        "Back": "后退",
        "Insert date/time": "插入日期/时间",
        "Date/time": "日期/时间",
        "Insert/Edit Link": "插入/编辑链接",
        "Insert/edit link": "插入/编辑链接",
        "Text to display": "显示文字",
        "Url": "地址",
        "Open link in...": "链接打开位置...",
        "Current window": "当前窗口",
        "None": "无",
        "New window": "在新窗口打开",
        "Remove link": "删除链接",
        "Anchors": "锚点",
        "Link...": "链接...",
        "Paste or type a link": "粘贴或输入链接",
        "The URL you entered seems to be an email address. Do you want to add the required mailto: prefix?": "你所填写的URL地址为邮件地址，需要加上mailto:前缀吗？",
        "The URL you entered seems to be an external link. Do you want to add the required http:// prefix?": "你所填写的URL地址属于外部链接，需要加上http://:前缀吗？",
        "Link list": "链接列表",
        "Insert video": "插入视频",
        "Insert/edit video": "插入/编辑视频",
        "Insert/edit media": "插入/编辑媒体",
        "Alternative source": "镜像",
        "Alternative source URL": "替代来源网址",
        "Media poster (Image URL)": "封面(图片地址)",
        "Paste your embed code below:": "将内嵌代码粘贴在下面:",
        "Embed": "内嵌",
        "Media...": "多媒体...",
        "Nonbreaking space": "不间断空格",
        "Page break": "分页符",
        "Paste as text": "粘贴为文本",
        "Preview": "预览",
        "Print...": "打印...",
        "Save": "保存",
        "Find": "查找",
        "Replace with": "替换为",
        "Replace": "替换",
        "Replace all": "全部替换",
        "Previous": "上一个",
        "Next": "下一个",
        "Find and replace...": "查找并替换...",
        "Could not find the specified string.": "未找到搜索内容.",
        "Match case": "区分大小写",
        "Find whole words only": "全字匹配",
        "Spell check": "拼写检查",
        "Ignore": "忽略",
        "Ignore all": "全部忽略",
        "Finish": "完成",
        "Add to Dictionary": "添加到字典",
        "Insert table": "插入表格",
        "Table properties": "表格属性",
        "Delete table": "删除表格",
        "Cell": "单元格",
        "Row": "行",
        "Column": "列",
        "Cell properties": "单元格属性",
        "Merge cells": "合并单元格",
        "Split cell": "拆分单元格",
        "Insert row before": "在上方插入",
        "Insert row after": "在下方插入",
        "Delete row": "删除行",
        "Row properties": "行属性",
        "Cut row": "剪切行",
        "Copy row": "复制行",
        "Paste row before": "粘贴到上方",
        "Paste row after": "粘贴到下方",
        "Insert column before": "在左侧插入",
        "Insert column after": "在右侧插入",
        "Delete column": "删除列",
        "Cols": "列",
        "Rows": "行",
        "Width": "宽",
        "Height": "高",
        "Cell spacing": "单元格外间距",
        "Cell padding": "单元格内边距",
        "Show caption": "显示标题",
        "Left": "左对齐",
        "Center": "居中",
        "Right": "右对齐",
        "Cell type": "单元格类型",
        "Scope": "范围",
        "Alignment": "对齐方式",
        "H Align": "水平对齐",
        "V Align": "垂直对齐",
        "Top": "顶部对齐",
        "Middle": "垂直居中",
        "Bottom": "底部对齐",
        "Header cell": "表头单元格",
        "Row group": "行组",
        "Column group": "列组",
        "Row type": "行类型",
        "Header": "表头",
        "Body": "表体",
        "Footer": "表尾",
        "Border color": "边框颜色",
        "Insert template...": "插入模板...",
        "Templates": "模板",
        "Template": "模板",
        "Text color": "文字颜色",
        "Background color": "背景色",
        "Custom...": "自定义...",
        "Custom color": "自定义颜色",
        "No color": "无",
        "Remove color": "移除颜色",
        "Table of Contents": "内容列表",
        "Show blocks": "显示区块边框",
        "Show invisible characters": "显示不可见字符",
        "Word count": "字数",
        "Count": "计数",
        "Document": "文档",
        "Selection": "选择",
        "Words": "单词",
        "Words: {0}": "字数：{0}",
        "{0} words": "{0} 字",
        "File": "文件",
        "Edit": "编辑",
        "Insert": "插入",
        "View": "视图",
        "Format": "格式",
        "Table": "表格",
        "Tools": "工具",
        "Powered by {0}": "由{0}驱动",
        "Rich Text Area. Press ALT-F9 for menu. Press ALT-F10 for toolbar. Press ALT-0 for help": "在编辑区按ALT-F9打开菜单，按ALT-F10打开工具栏，按ALT-0查看帮助",
        "Image title": "图片标题",
        "Border width": "边框宽度",
        "Border style": "边框样式",
        "Error": "错误",
        "Warn": "警告",
        "Valid": "有效",
        "To open the popup, press Shift+Enter": "按Shitf+Enter键打开对话框",
        "Rich Text Area. Press ALT-0 for help.": "编辑区。按Alt+0键打开帮助。",
        "System Font": "系统字体",
        "Failed to upload image: {0}": "图片上传失败: {0}",
        "Failed to load plugin: {0} from url {1}": "插件加载失败: {0} 来自链接 {1}",
        "Failed to load plugin url: {0}": "插件加载失败 链接: {0}",
        "Failed to initialize plugin: {0}": "插件初始化失败: {0}",
        "example": "示例",
        "Search": "搜索",
        "All": "全部",
        "Currency": "货币",
        "Text": "文字",
        "Quotations": "引用",
        "Mathematical": "数学",
        "Extended Latin": "拉丁语扩充",
        "Symbols": "符号",
        "Arrows": "箭头",
        "User Defined": "自定义",
        "dollar sign": "美元符号",
        "currency sign": "货币符号",
        "euro-currency sign": "欧元符号",
        "colon sign": "冒号",
        "cruzeiro sign": "克鲁赛罗币符号",
        "french franc sign": "法郎符号",
        "lira sign": "里拉符号",
        "mill sign": "密尔符号",
        "naira sign": "奈拉符号",
        "peseta sign": "比塞塔符号",
        "rupee sign": "卢比符号",
        "won sign": "韩元符号",
        "new sheqel sign": "新谢克尔符号",
        "dong sign": "越南盾符号",
        "kip sign": "老挝基普符号",
        "tugrik sign": "图格里克符号",
        "drachma sign": "德拉克马符号",
        "german penny symbol": "德国便士符号",
        "peso sign": "比索符号",
        "guarani sign": "瓜拉尼符号",
        "austral sign": "澳元符号",
        "hryvnia sign": "格里夫尼亚符号",
        "cedi sign": "塞地符号",
        "livre tournois sign": "里弗弗尔符号",
        "spesmilo sign": "spesmilo符号",
        "tenge sign": "坚戈符号",
        "indian rupee sign": "印度卢比",
        "turkish lira sign": "土耳其里拉",
        "nordic mark sign": "北欧马克",
        "manat sign": "马纳特符号",
        "ruble sign": "卢布符号",
        "yen character": "日元字样",
        "yuan character": "人民币元字样",
        "yuan character, in hong kong and taiwan": "元字样（港台地区）",
        "yen/yuan character variant one": "元字样（大写）",
        "Loading emoticons...": "加载表情符号...",
        "Could not load emoticons": "不能加载表情符号",
        "People": "人类",
        "Animals and Nature": "动物和自然",
        "Food and Drink": "食物和饮品",
        "Activity": "活动",
        "Travel and Places": "旅游和地点",
        "Objects": "物件",
        "Flags": "旗帜",
        "Characters": "字符",
        "Characters (no spaces)": "字符(无空格)",
        "{0} characters": "{0} 个字符",
        "Error: Form submit field collision.": "错误: 表单提交字段冲突。",
        "Error: No form element found.": "错误: 没有表单控件。",
        "Update": "更新",
        "Color swatch": "颜色样本",
        "Turquoise": "青绿色",
        "Green": "绿色",
        "Blue": "蓝色",
        "Purple": "紫色",
        "Navy Blue": "海军蓝",
        "Dark Turquoise": "深蓝绿色",
        "Dark Green": "深绿色",
        "Medium Blue": "中蓝色",
        "Medium Purple": "中紫色",
        "Midnight Blue": "深蓝色",
        "Yellow": "黄色",
        "Orange": "橙色",
        "Red": "红色",
        "Light Gray": "浅灰色",
        "Gray": "灰色",
        "Dark Yellow": "暗黄色",
        "Dark Orange": "深橙色",
        "Dark Red": "深红色",
        "Medium Gray": "中灰色",
        "Dark Gray": "深灰色",
        "Light Green": "浅绿色",
        "Light Yellow": "浅黄色",
        "Light Red": "浅红色",
        "Light Purple": "浅紫色",
        "Light Blue": "浅蓝色",
        "Dark Purple": "深紫色",
        "Dark Blue": "深蓝色",
        "Black": "黑色",
        "White": "白色",
        "Switch to or from fullscreen mode": "切换全屏模式",
        "Open help dialog": "打开帮助对话框",
        "history": "历史",
        "styles": "样式",
        "formatting": "格式化",
        "alignment": "对齐",
        "indentation": "缩进",
        "permanent pen": "记号笔",
        "comments": "备注",
        "Format Painter": "格式刷",
        "Insert/edit iframe": "插入/编辑框架",
        "Capitalization": "大写",
        "lowercase": "小写",
        "UPPERCASE": "大写",
        "Title Case": "首字母大写",
        "Permanent Pen Properties": "永久笔属性",
        "Permanent pen properties...": "永久笔属性...",
        "Font": "字体",
        "Size": "字号",
        "More...": "更多...",
        "Spellcheck Language": "拼写检查语言",
        "Select...": "选择...",
        "Preferences": "首选项",
        "Yes": "是",
        "No": "否",
        "Keyboard Navigation": "键盘指引",
        "Version": "版本",
        "Anchor": "锚点",
        "Special character": "特殊符号",
        "Code sample": "代码示例",
        "Color": "颜色",
        "Emoticons": "表情",
        "Document properties": "文档属性",
        "Image": "图片",
        "Insert link": "插入链接",
        "Target": "打开方式",
        "Link": "链接",
        "Poster": "封面",
        "Media": "媒体",
        "Print": "打印",
        "Prev": "上一个",
        "Find and replace": "查找和替换",
        "Whole words": "全字匹配",
        "Spellcheck": "拼写检查",
        "Caption": "标题",
        "Insert template": "插入模板"
      });
    }
  });

  // node_modules/codemirror/lib/codemirror.js
  var require_codemirror = __commonJS({
    "node_modules/codemirror/lib/codemirror.js"(exports, module) {
      (function(global2, factory) {
        typeof exports === "object" && typeof module !== "undefined" ? module.exports = factory() : typeof define === "function" && define.amd ? define(factory) : (global2 = global2 || self, global2.CodeMirror = factory());
      })(exports, function() {
        "use strict";
        var userAgent = navigator.userAgent;
        var platform2 = navigator.platform;
        var gecko = /gecko\/\d/i.test(userAgent);
        var ie_upto10 = /MSIE \d/.test(userAgent);
        var ie_11up = /Trident\/(?:[7-9]|\d{2,})\..*rv:(\d+)/.exec(userAgent);
        var edge = /Edge\/(\d+)/.exec(userAgent);
        var ie = ie_upto10 || ie_11up || edge;
        var ie_version = ie && (ie_upto10 ? document.documentMode || 6 : +(edge || ie_11up)[1]);
        var webkit = !edge && /WebKit\//.test(userAgent);
        var qtwebkit = webkit && /Qt\/\d+\.\d+/.test(userAgent);
        var chrome = !edge && /Chrome\/(\d+)/.exec(userAgent);
        var chrome_version = chrome && +chrome[1];
        var presto = /Opera\//.test(userAgent);
        var safari = /Apple Computer/.test(navigator.vendor);
        var mac_geMountainLion = /Mac OS X 1\d\D([8-9]|\d\d)\D/.test(userAgent);
        var phantom = /PhantomJS/.test(userAgent);
        var ios = safari && (/Mobile\/\w+/.test(userAgent) || navigator.maxTouchPoints > 2);
        var android = /Android/.test(userAgent);
        var mobile = ios || android || /webOS|BlackBerry|Opera Mini|Opera Mobi|IEMobile/i.test(userAgent);
        var mac = ios || /Mac/.test(platform2);
        var chromeOS = /\bCrOS\b/.test(userAgent);
        var windows = /win/i.test(platform2);
        var presto_version = presto && userAgent.match(/Version\/(\d*\.\d*)/);
        if (presto_version) {
          presto_version = Number(presto_version[1]);
        }
        if (presto_version && presto_version >= 15) {
          presto = false;
          webkit = true;
        }
        var flipCtrlCmd = mac && (qtwebkit || presto && (presto_version == null || presto_version < 12.11));
        var captureRightClick = gecko || ie && ie_version >= 9;
        function classTest(cls) {
          return new RegExp("(^|\\s)" + cls + "(?:$|\\s)\\s*");
        }
        var rmClass = function(node, cls) {
          var current = node.className;
          var match = classTest(cls).exec(current);
          if (match) {
            var after = current.slice(match.index + match[0].length);
            node.className = current.slice(0, match.index) + (after ? match[1] + after : "");
          }
        };
        function removeChildren(e2) {
          for (var count2 = e2.childNodes.length; count2 > 0; --count2) {
            e2.removeChild(e2.firstChild);
          }
          return e2;
        }
        function removeChildrenAndAdd(parent, e2) {
          return removeChildren(parent).appendChild(e2);
        }
        function elt(tag, content, className, style) {
          var e2 = document.createElement(tag);
          if (className) {
            e2.className = className;
          }
          if (style) {
            e2.style.cssText = style;
          }
          if (typeof content == "string") {
            e2.appendChild(document.createTextNode(content));
          } else if (content) {
            for (var i2 = 0; i2 < content.length; ++i2) {
              e2.appendChild(content[i2]);
            }
          }
          return e2;
        }
        function eltP(tag, content, className, style) {
          var e2 = elt(tag, content, className, style);
          e2.setAttribute("role", "presentation");
          return e2;
        }
        var range;
        if (document.createRange) {
          range = function(node, start2, end2, endNode) {
            var r = document.createRange();
            r.setEnd(endNode || node, end2);
            r.setStart(node, start2);
            return r;
          };
        } else {
          range = function(node, start2, end2) {
            var r = document.body.createTextRange();
            try {
              r.moveToElementText(node.parentNode);
            } catch (e2) {
              return r;
            }
            r.collapse(true);
            r.moveEnd("character", end2);
            r.moveStart("character", start2);
            return r;
          };
        }
        function contains(parent, child) {
          if (child.nodeType == 3) {
            child = child.parentNode;
          }
          if (parent.contains) {
            return parent.contains(child);
          }
          do {
            if (child.nodeType == 11) {
              child = child.host;
            }
            if (child == parent) {
              return true;
            }
          } while (child = child.parentNode);
        }
        function activeElt(doc2) {
          var activeElement;
          try {
            activeElement = doc2.activeElement;
          } catch (e2) {
            activeElement = doc2.body || null;
          }
          while (activeElement && activeElement.shadowRoot && activeElement.shadowRoot.activeElement) {
            activeElement = activeElement.shadowRoot.activeElement;
          }
          return activeElement;
        }
        function addClass(node, cls) {
          var current = node.className;
          if (!classTest(cls).test(current)) {
            node.className += (current ? " " : "") + cls;
          }
        }
        function joinClasses(a, b) {
          var as = a.split(" ");
          for (var i2 = 0; i2 < as.length; i2++) {
            if (as[i2] && !classTest(as[i2]).test(b)) {
              b += " " + as[i2];
            }
          }
          return b;
        }
        var selectInput = function(node) {
          node.select();
        };
        if (ios) {
          selectInput = function(node) {
            node.selectionStart = 0;
            node.selectionEnd = node.value.length;
          };
        } else if (ie) {
          selectInput = function(node) {
            try {
              node.select();
            } catch (_e) {
            }
          };
        }
        function doc(cm) {
          return cm.display.wrapper.ownerDocument;
        }
        function win(cm) {
          return doc(cm).defaultView;
        }
        function bind3(f) {
          var args = Array.prototype.slice.call(arguments, 1);
          return function() {
            return f.apply(null, args);
          };
        }
        function copyObj(obj, target, overwrite) {
          if (!target) {
            target = {};
          }
          for (var prop2 in obj) {
            if (obj.hasOwnProperty(prop2) && (overwrite !== false || !target.hasOwnProperty(prop2))) {
              target[prop2] = obj[prop2];
            }
          }
          return target;
        }
        function countColumn(string, end2, tabSize, startIndex, startValue) {
          if (end2 == null) {
            end2 = string.search(/[^\s\u00a0]/);
            if (end2 == -1) {
              end2 = string.length;
            }
          }
          for (var i2 = startIndex || 0, n = startValue || 0; ; ) {
            var nextTab = string.indexOf("	", i2);
            if (nextTab < 0 || nextTab >= end2) {
              return n + (end2 - i2);
            }
            n += nextTab - i2;
            n += tabSize - n % tabSize;
            i2 = nextTab + 1;
          }
        }
        var Delayed = function() {
          this.id = null;
          this.f = null;
          this.time = 0;
          this.handler = bind3(this.onTimeout, this);
        };
        Delayed.prototype.onTimeout = function(self2) {
          self2.id = 0;
          if (self2.time <= +new Date()) {
            self2.f();
          } else {
            setTimeout(self2.handler, self2.time - +new Date());
          }
        };
        Delayed.prototype.set = function(ms, f) {
          this.f = f;
          var time = +new Date() + ms;
          if (!this.id || time < this.time) {
            clearTimeout(this.id);
            this.id = setTimeout(this.handler, ms);
            this.time = time;
          }
        };
        function indexOf2(array, elt2) {
          for (var i2 = 0; i2 < array.length; ++i2) {
            if (array[i2] == elt2) {
              return i2;
            }
          }
          return -1;
        }
        var scrollerGap = 50;
        var Pass = { toString: function() {
          return "CodeMirror.Pass";
        } };
        var sel_dontScroll = { scroll: false }, sel_mouse = { origin: "*mouse" }, sel_move = { origin: "+move" };
        function findColumn(string, goal, tabSize) {
          for (var pos = 0, col = 0; ; ) {
            var nextTab = string.indexOf("	", pos);
            if (nextTab == -1) {
              nextTab = string.length;
            }
            var skipped = nextTab - pos;
            if (nextTab == string.length || col + skipped >= goal) {
              return pos + Math.min(skipped, goal - col);
            }
            col += nextTab - pos;
            col += tabSize - col % tabSize;
            pos = nextTab + 1;
            if (col >= goal) {
              return pos;
            }
          }
        }
        var spaceStrs = [""];
        function spaceStr(n) {
          while (spaceStrs.length <= n) {
            spaceStrs.push(lst(spaceStrs) + " ");
          }
          return spaceStrs[n];
        }
        function lst(arr) {
          return arr[arr.length - 1];
        }
        function map3(array, f) {
          var out2 = [];
          for (var i2 = 0; i2 < array.length; i2++) {
            out2[i2] = f(array[i2], i2);
          }
          return out2;
        }
        function insertSorted(array, value, score) {
          var pos = 0, priority = score(value);
          while (pos < array.length && score(array[pos]) <= priority) {
            pos++;
          }
          array.splice(pos, 0, value);
        }
        function nothing() {
        }
        function createObj(base2, props) {
          var inst;
          if (Object.create) {
            inst = Object.create(base2);
          } else {
            nothing.prototype = base2;
            inst = new nothing();
          }
          if (props) {
            copyObj(props, inst);
          }
          return inst;
        }
        var nonASCIISingleCaseWordChar = /[\u00df\u0587\u0590-\u05f4\u0600-\u06ff\u3040-\u309f\u30a0-\u30ff\u3400-\u4db5\u4e00-\u9fcc\uac00-\ud7af]/;
        function isWordCharBasic(ch) {
          return /\w/.test(ch) || ch > "" && (ch.toUpperCase() != ch.toLowerCase() || nonASCIISingleCaseWordChar.test(ch));
        }
        function isWordChar(ch, helper) {
          if (!helper) {
            return isWordCharBasic(ch);
          }
          if (helper.source.indexOf("\\w") > -1 && isWordCharBasic(ch)) {
            return true;
          }
          return helper.test(ch);
        }
        function isEmpty(obj) {
          for (var n in obj) {
            if (obj.hasOwnProperty(n) && obj[n]) {
              return false;
            }
          }
          return true;
        }
        var extendingChars = /[\u0300-\u036f\u0483-\u0489\u0591-\u05bd\u05bf\u05c1\u05c2\u05c4\u05c5\u05c7\u0610-\u061a\u064b-\u065e\u0670\u06d6-\u06dc\u06de-\u06e4\u06e7\u06e8\u06ea-\u06ed\u0711\u0730-\u074a\u07a6-\u07b0\u07eb-\u07f3\u0816-\u0819\u081b-\u0823\u0825-\u0827\u0829-\u082d\u0900-\u0902\u093c\u0941-\u0948\u094d\u0951-\u0955\u0962\u0963\u0981\u09bc\u09be\u09c1-\u09c4\u09cd\u09d7\u09e2\u09e3\u0a01\u0a02\u0a3c\u0a41\u0a42\u0a47\u0a48\u0a4b-\u0a4d\u0a51\u0a70\u0a71\u0a75\u0a81\u0a82\u0abc\u0ac1-\u0ac5\u0ac7\u0ac8\u0acd\u0ae2\u0ae3\u0b01\u0b3c\u0b3e\u0b3f\u0b41-\u0b44\u0b4d\u0b56\u0b57\u0b62\u0b63\u0b82\u0bbe\u0bc0\u0bcd\u0bd7\u0c3e-\u0c40\u0c46-\u0c48\u0c4a-\u0c4d\u0c55\u0c56\u0c62\u0c63\u0cbc\u0cbf\u0cc2\u0cc6\u0ccc\u0ccd\u0cd5\u0cd6\u0ce2\u0ce3\u0d3e\u0d41-\u0d44\u0d4d\u0d57\u0d62\u0d63\u0dca\u0dcf\u0dd2-\u0dd4\u0dd6\u0ddf\u0e31\u0e34-\u0e3a\u0e47-\u0e4e\u0eb1\u0eb4-\u0eb9\u0ebb\u0ebc\u0ec8-\u0ecd\u0f18\u0f19\u0f35\u0f37\u0f39\u0f71-\u0f7e\u0f80-\u0f84\u0f86\u0f87\u0f90-\u0f97\u0f99-\u0fbc\u0fc6\u102d-\u1030\u1032-\u1037\u1039\u103a\u103d\u103e\u1058\u1059\u105e-\u1060\u1071-\u1074\u1082\u1085\u1086\u108d\u109d\u135f\u1712-\u1714\u1732-\u1734\u1752\u1753\u1772\u1773\u17b7-\u17bd\u17c6\u17c9-\u17d3\u17dd\u180b-\u180d\u18a9\u1920-\u1922\u1927\u1928\u1932\u1939-\u193b\u1a17\u1a18\u1a56\u1a58-\u1a5e\u1a60\u1a62\u1a65-\u1a6c\u1a73-\u1a7c\u1a7f\u1b00-\u1b03\u1b34\u1b36-\u1b3a\u1b3c\u1b42\u1b6b-\u1b73\u1b80\u1b81\u1ba2-\u1ba5\u1ba8\u1ba9\u1c2c-\u1c33\u1c36\u1c37\u1cd0-\u1cd2\u1cd4-\u1ce0\u1ce2-\u1ce8\u1ced\u1dc0-\u1de6\u1dfd-\u1dff\u200c\u200d\u20d0-\u20f0\u2cef-\u2cf1\u2de0-\u2dff\u302a-\u302f\u3099\u309a\ua66f-\ua672\ua67c\ua67d\ua6f0\ua6f1\ua802\ua806\ua80b\ua825\ua826\ua8c4\ua8e0-\ua8f1\ua926-\ua92d\ua947-\ua951\ua980-\ua982\ua9b3\ua9b6-\ua9b9\ua9bc\uaa29-\uaa2e\uaa31\uaa32\uaa35\uaa36\uaa43\uaa4c\uaab0\uaab2-\uaab4\uaab7\uaab8\uaabe\uaabf\uaac1\uabe5\uabe8\uabed\udc00-\udfff\ufb1e\ufe00-\ufe0f\ufe20-\ufe26\uff9e\uff9f]/;
        function isExtendingChar(ch) {
          return ch.charCodeAt(0) >= 768 && extendingChars.test(ch);
        }
        function skipExtendingChars(str, pos, dir3) {
          while ((dir3 < 0 ? pos > 0 : pos < str.length) && isExtendingChar(str.charAt(pos))) {
            pos += dir3;
          }
          return pos;
        }
        function findFirst(pred, from, to) {
          var dir3 = from > to ? -1 : 1;
          for (; ; ) {
            if (from == to) {
              return from;
            }
            var midF = (from + to) / 2, mid = dir3 < 0 ? Math.ceil(midF) : Math.floor(midF);
            if (mid == from) {
              return pred(mid) ? from : to;
            }
            if (pred(mid)) {
              to = mid;
            } else {
              from = mid + dir3;
            }
          }
        }
        function iterateBidiSections(order, from, to, f) {
          if (!order) {
            return f(from, to, "ltr", 0);
          }
          var found = false;
          for (var i2 = 0; i2 < order.length; ++i2) {
            var part = order[i2];
            if (part.from < to && part.to > from || from == to && part.to == from) {
              f(Math.max(part.from, from), Math.min(part.to, to), part.level == 1 ? "rtl" : "ltr", i2);
              found = true;
            }
          }
          if (!found) {
            f(from, to, "ltr");
          }
        }
        var bidiOther = null;
        function getBidiPartAt(order, ch, sticky) {
          var found;
          bidiOther = null;
          for (var i2 = 0; i2 < order.length; ++i2) {
            var cur = order[i2];
            if (cur.from < ch && cur.to > ch) {
              return i2;
            }
            if (cur.to == ch) {
              if (cur.from != cur.to && sticky == "before") {
                found = i2;
              } else {
                bidiOther = i2;
              }
            }
            if (cur.from == ch) {
              if (cur.from != cur.to && sticky != "before") {
                found = i2;
              } else {
                bidiOther = i2;
              }
            }
          }
          return found != null ? found : bidiOther;
        }
        var bidiOrdering = function() {
          var lowTypes = "bbbbbbbbbtstwsbbbbbbbbbbbbbbssstwNN%%%NNNNNN,N,N1111111111NNNNNNNLLLLLLLLLLLLLLLLLLLLLLLLLLNNNNNNLLLLLLLLLLLLLLLLLLLLLLLLLLNNNNbbbbbbsbbbbbbbbbbbbbbbbbbbbbbbbbb,N%%%%NNNNLNNNNN%%11NLNNN1LNNNNNLLLLLLLLLLLLLLLLLLLLLLLNLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLN";
          var arabicTypes = "nnnnnnNNr%%r,rNNmmmmmmmmmmmrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrmmmmmmmmmmmmmmmmmmmmmnnnnnnnnnn%nnrrrmrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrmmmmmmmnNmmmmmmrrmmNmmmmrr1111111111";
          function charType(code) {
            if (code <= 247) {
              return lowTypes.charAt(code);
            } else if (1424 <= code && code <= 1524) {
              return "R";
            } else if (1536 <= code && code <= 1785) {
              return arabicTypes.charAt(code - 1536);
            } else if (1774 <= code && code <= 2220) {
              return "r";
            } else if (8192 <= code && code <= 8203) {
              return "w";
            } else if (code == 8204) {
              return "b";
            } else {
              return "L";
            }
          }
          var bidiRE = /[\u0590-\u05f4\u0600-\u06ff\u0700-\u08ac]/;
          var isNeutral = /[stwN]/, isStrong = /[LRr]/, countsAsLeft = /[Lb1n]/, countsAsNum = /[1n]/;
          function BidiSpan(level, from, to) {
            this.level = level;
            this.from = from;
            this.to = to;
          }
          return function(str, direction) {
            var outerType = direction == "ltr" ? "L" : "R";
            if (str.length == 0 || direction == "ltr" && !bidiRE.test(str)) {
              return false;
            }
            var len2 = str.length, types = [];
            for (var i2 = 0; i2 < len2; ++i2) {
              types.push(charType(str.charCodeAt(i2)));
            }
            for (var i$12 = 0, prev = outerType; i$12 < len2; ++i$12) {
              var type = types[i$12];
              if (type == "m") {
                types[i$12] = prev;
              } else {
                prev = type;
              }
            }
            for (var i$22 = 0, cur = outerType; i$22 < len2; ++i$22) {
              var type$1 = types[i$22];
              if (type$1 == "1" && cur == "r") {
                types[i$22] = "n";
              } else if (isStrong.test(type$1)) {
                cur = type$1;
                if (type$1 == "r") {
                  types[i$22] = "R";
                }
              }
            }
            for (var i$3 = 1, prev$1 = types[0]; i$3 < len2 - 1; ++i$3) {
              var type$2 = types[i$3];
              if (type$2 == "+" && prev$1 == "1" && types[i$3 + 1] == "1") {
                types[i$3] = "1";
              } else if (type$2 == "," && prev$1 == types[i$3 + 1] && (prev$1 == "1" || prev$1 == "n")) {
                types[i$3] = prev$1;
              }
              prev$1 = type$2;
            }
            for (var i$4 = 0; i$4 < len2; ++i$4) {
              var type$3 = types[i$4];
              if (type$3 == ",") {
                types[i$4] = "N";
              } else if (type$3 == "%") {
                var end2 = void 0;
                for (end2 = i$4 + 1; end2 < len2 && types[end2] == "%"; ++end2) {
                }
                var replace = i$4 && types[i$4 - 1] == "!" || end2 < len2 && types[end2] == "1" ? "1" : "N";
                for (var j = i$4; j < end2; ++j) {
                  types[j] = replace;
                }
                i$4 = end2 - 1;
              }
            }
            for (var i$5 = 0, cur$1 = outerType; i$5 < len2; ++i$5) {
              var type$4 = types[i$5];
              if (cur$1 == "L" && type$4 == "1") {
                types[i$5] = "L";
              } else if (isStrong.test(type$4)) {
                cur$1 = type$4;
              }
            }
            for (var i$6 = 0; i$6 < len2; ++i$6) {
              if (isNeutral.test(types[i$6])) {
                var end$1 = void 0;
                for (end$1 = i$6 + 1; end$1 < len2 && isNeutral.test(types[end$1]); ++end$1) {
                }
                var before = (i$6 ? types[i$6 - 1] : outerType) == "L";
                var after = (end$1 < len2 ? types[end$1] : outerType) == "L";
                var replace$1 = before == after ? before ? "L" : "R" : outerType;
                for (var j$1 = i$6; j$1 < end$1; ++j$1) {
                  types[j$1] = replace$1;
                }
                i$6 = end$1 - 1;
              }
            }
            var order = [], m2;
            for (var i$7 = 0; i$7 < len2; ) {
              if (countsAsLeft.test(types[i$7])) {
                var start2 = i$7;
                for (++i$7; i$7 < len2 && countsAsLeft.test(types[i$7]); ++i$7) {
                }
                order.push(new BidiSpan(0, start2, i$7));
              } else {
                var pos = i$7, at = order.length, isRTL = direction == "rtl" ? 1 : 0;
                for (++i$7; i$7 < len2 && types[i$7] != "L"; ++i$7) {
                }
                for (var j$2 = pos; j$2 < i$7; ) {
                  if (countsAsNum.test(types[j$2])) {
                    if (pos < j$2) {
                      order.splice(at, 0, new BidiSpan(1, pos, j$2));
                      at += isRTL;
                    }
                    var nstart = j$2;
                    for (++j$2; j$2 < i$7 && countsAsNum.test(types[j$2]); ++j$2) {
                    }
                    order.splice(at, 0, new BidiSpan(2, nstart, j$2));
                    at += isRTL;
                    pos = j$2;
                  } else {
                    ++j$2;
                  }
                }
                if (pos < i$7) {
                  order.splice(at, 0, new BidiSpan(1, pos, i$7));
                }
              }
            }
            if (direction == "ltr") {
              if (order[0].level == 1 && (m2 = str.match(/^\s+/))) {
                order[0].from = m2[0].length;
                order.unshift(new BidiSpan(0, 0, m2[0].length));
              }
              if (lst(order).level == 1 && (m2 = str.match(/\s+$/))) {
                lst(order).to -= m2[0].length;
                order.push(new BidiSpan(0, len2 - m2[0].length, len2));
              }
            }
            return direction == "rtl" ? order.reverse() : order;
          };
        }();
        function getOrder(line, direction) {
          var order = line.order;
          if (order == null) {
            order = line.order = bidiOrdering(line.text, direction);
          }
          return order;
        }
        var noHandlers = [];
        var on = function(emitter, type, f) {
          if (emitter.addEventListener) {
            emitter.addEventListener(type, f, false);
          } else if (emitter.attachEvent) {
            emitter.attachEvent("on" + type, f);
          } else {
            var map4 = emitter._handlers || (emitter._handlers = {});
            map4[type] = (map4[type] || noHandlers).concat(f);
          }
        };
        function getHandlers(emitter, type) {
          return emitter._handlers && emitter._handlers[type] || noHandlers;
        }
        function off(emitter, type, f) {
          if (emitter.removeEventListener) {
            emitter.removeEventListener(type, f, false);
          } else if (emitter.detachEvent) {
            emitter.detachEvent("on" + type, f);
          } else {
            var map4 = emitter._handlers, arr = map4 && map4[type];
            if (arr) {
              var index = indexOf2(arr, f);
              if (index > -1) {
                map4[type] = arr.slice(0, index).concat(arr.slice(index + 1));
              }
            }
          }
        }
        function signal(emitter, type) {
          var handlers3 = getHandlers(emitter, type);
          if (!handlers3.length) {
            return;
          }
          var args = Array.prototype.slice.call(arguments, 2);
          for (var i2 = 0; i2 < handlers3.length; ++i2) {
            handlers3[i2].apply(null, args);
          }
        }
        function signalDOMEvent(cm, e2, override) {
          if (typeof e2 == "string") {
            e2 = { type: e2, preventDefault: function() {
              this.defaultPrevented = true;
            } };
          }
          signal(cm, override || e2.type, cm, e2);
          return e_defaultPrevented(e2) || e2.codemirrorIgnore;
        }
        function signalCursorActivity(cm) {
          var arr = cm._handlers && cm._handlers.cursorActivity;
          if (!arr) {
            return;
          }
          var set3 = cm.curOp.cursorActivityHandlers || (cm.curOp.cursorActivityHandlers = []);
          for (var i2 = 0; i2 < arr.length; ++i2) {
            if (indexOf2(set3, arr[i2]) == -1) {
              set3.push(arr[i2]);
            }
          }
        }
        function hasHandler(emitter, type) {
          return getHandlers(emitter, type).length > 0;
        }
        function eventMixin(ctor) {
          ctor.prototype.on = function(type, f) {
            on(this, type, f);
          };
          ctor.prototype.off = function(type, f) {
            off(this, type, f);
          };
        }
        function e_preventDefault(e2) {
          if (e2.preventDefault) {
            e2.preventDefault();
          } else {
            e2.returnValue = false;
          }
        }
        function e_stopPropagation(e2) {
          if (e2.stopPropagation) {
            e2.stopPropagation();
          } else {
            e2.cancelBubble = true;
          }
        }
        function e_defaultPrevented(e2) {
          return e2.defaultPrevented != null ? e2.defaultPrevented : e2.returnValue == false;
        }
        function e_stop(e2) {
          e_preventDefault(e2);
          e_stopPropagation(e2);
        }
        function e_target(e2) {
          return e2.target || e2.srcElement;
        }
        function e_button(e2) {
          var b = e2.which;
          if (b == null) {
            if (e2.button & 1) {
              b = 1;
            } else if (e2.button & 2) {
              b = 3;
            } else if (e2.button & 4) {
              b = 2;
            }
          }
          if (mac && e2.ctrlKey && b == 1) {
            b = 3;
          }
          return b;
        }
        var dragAndDrop = function() {
          if (ie && ie_version < 9) {
            return false;
          }
          var div2 = elt("div");
          return "draggable" in div2 || "dragDrop" in div2;
        }();
        var zwspSupported;
        function zeroWidthElement(measure) {
          if (zwspSupported == null) {
            var test = elt("span", "​");
            removeChildrenAndAdd(measure, elt("span", [test, document.createTextNode("x")]));
            if (measure.firstChild.offsetHeight != 0) {
              zwspSupported = test.offsetWidth <= 1 && test.offsetHeight > 2 && !(ie && ie_version < 8);
            }
          }
          var node = zwspSupported ? elt("span", "​") : elt("span", " ", null, "display: inline-block; width: 1px; margin-right: -1px");
          node.setAttribute("cm-text", "");
          return node;
        }
        var badBidiRects;
        function hasBadBidiRects(measure) {
          if (badBidiRects != null) {
            return badBidiRects;
          }
          var txt = removeChildrenAndAdd(measure, document.createTextNode("AخA"));
          var r0 = range(txt, 0, 1).getBoundingClientRect();
          var r1 = range(txt, 1, 2).getBoundingClientRect();
          removeChildren(measure);
          if (!r0 || r0.left == r0.right) {
            return false;
          }
          return badBidiRects = r1.right - r0.right < 3;
        }
        var splitLinesAuto = "\n\nb".split(/\n/).length != 3 ? function(string) {
          var pos = 0, result = [], l = string.length;
          while (pos <= l) {
            var nl = string.indexOf("\n", pos);
            if (nl == -1) {
              nl = string.length;
            }
            var line = string.slice(pos, string.charAt(nl - 1) == "\r" ? nl - 1 : nl);
            var rt2 = line.indexOf("\r");
            if (rt2 != -1) {
              result.push(line.slice(0, rt2));
              pos += rt2 + 1;
            } else {
              result.push(line);
              pos = nl + 1;
            }
          }
          return result;
        } : function(string) {
          return string.split(/\r\n?|\n/);
        };
        var hasSelection = window.getSelection ? function(te) {
          try {
            return te.selectionStart != te.selectionEnd;
          } catch (e2) {
            return false;
          }
        } : function(te) {
          var range2;
          try {
            range2 = te.ownerDocument.selection.createRange();
          } catch (e2) {
          }
          if (!range2 || range2.parentElement() != te) {
            return false;
          }
          return range2.compareEndPoints("StartToEnd", range2) != 0;
        };
        var hasCopyEvent = function() {
          var e2 = elt("div");
          if ("oncopy" in e2) {
            return true;
          }
          e2.setAttribute("oncopy", "return;");
          return typeof e2.oncopy == "function";
        }();
        var badZoomedRects = null;
        function hasBadZoomedRects(measure) {
          if (badZoomedRects != null) {
            return badZoomedRects;
          }
          var node = removeChildrenAndAdd(measure, elt("span", "x"));
          var normal = node.getBoundingClientRect();
          var fromRange = range(node, 0, 1).getBoundingClientRect();
          return badZoomedRects = Math.abs(normal.left - fromRange.left) > 1;
        }
        var modes = {}, mimeModes = {};
        function defineMode(name, mode) {
          if (arguments.length > 2) {
            mode.dependencies = Array.prototype.slice.call(arguments, 2);
          }
          modes[name] = mode;
        }
        function defineMIME(mime, spec) {
          mimeModes[mime] = spec;
        }
        function resolveMode(spec) {
          if (typeof spec == "string" && mimeModes.hasOwnProperty(spec)) {
            spec = mimeModes[spec];
          } else if (spec && typeof spec.name == "string" && mimeModes.hasOwnProperty(spec.name)) {
            var found = mimeModes[spec.name];
            if (typeof found == "string") {
              found = { name: found };
            }
            spec = createObj(found, spec);
            spec.name = found.name;
          } else if (typeof spec == "string" && /^[\w\-]+\/[\w\-]+\+xml$/.test(spec)) {
            return resolveMode("application/xml");
          } else if (typeof spec == "string" && /^[\w\-]+\/[\w\-]+\+json$/.test(spec)) {
            return resolveMode("application/json");
          }
          if (typeof spec == "string") {
            return { name: spec };
          } else {
            return spec || { name: "null" };
          }
        }
        function getMode(options, spec) {
          spec = resolveMode(spec);
          var mfactory = modes[spec.name];
          if (!mfactory) {
            return getMode(options, "text/plain");
          }
          var modeObj = mfactory(options, spec);
          if (modeExtensions.hasOwnProperty(spec.name)) {
            var exts = modeExtensions[spec.name];
            for (var prop2 in exts) {
              if (!exts.hasOwnProperty(prop2)) {
                continue;
              }
              if (modeObj.hasOwnProperty(prop2)) {
                modeObj["_" + prop2] = modeObj[prop2];
              }
              modeObj[prop2] = exts[prop2];
            }
          }
          modeObj.name = spec.name;
          if (spec.helperType) {
            modeObj.helperType = spec.helperType;
          }
          if (spec.modeProps) {
            for (var prop$1 in spec.modeProps) {
              modeObj[prop$1] = spec.modeProps[prop$1];
            }
          }
          return modeObj;
        }
        var modeExtensions = {};
        function extendMode(mode, properties) {
          var exts = modeExtensions.hasOwnProperty(mode) ? modeExtensions[mode] : modeExtensions[mode] = {};
          copyObj(properties, exts);
        }
        function copyState(mode, state) {
          if (state === true) {
            return state;
          }
          if (mode.copyState) {
            return mode.copyState(state);
          }
          var nstate = {};
          for (var n in state) {
            var val = state[n];
            if (val instanceof Array) {
              val = val.concat([]);
            }
            nstate[n] = val;
          }
          return nstate;
        }
        function innerMode(mode, state) {
          var info;
          while (mode.innerMode) {
            info = mode.innerMode(state);
            if (!info || info.mode == mode) {
              break;
            }
            state = info.state;
            mode = info.mode;
          }
          return info || { mode, state };
        }
        function startState(mode, a1, a2) {
          return mode.startState ? mode.startState(a1, a2) : true;
        }
        var StringStream = function(string, tabSize, lineOracle) {
          this.pos = this.start = 0;
          this.string = string;
          this.tabSize = tabSize || 8;
          this.lastColumnPos = this.lastColumnValue = 0;
          this.lineStart = 0;
          this.lineOracle = lineOracle;
        };
        StringStream.prototype.eol = function() {
          return this.pos >= this.string.length;
        };
        StringStream.prototype.sol = function() {
          return this.pos == this.lineStart;
        };
        StringStream.prototype.peek = function() {
          return this.string.charAt(this.pos) || void 0;
        };
        StringStream.prototype.next = function() {
          if (this.pos < this.string.length) {
            return this.string.charAt(this.pos++);
          }
        };
        StringStream.prototype.eat = function(match) {
          var ch = this.string.charAt(this.pos);
          var ok;
          if (typeof match == "string") {
            ok = ch == match;
          } else {
            ok = ch && (match.test ? match.test(ch) : match(ch));
          }
          if (ok) {
            ++this.pos;
            return ch;
          }
        };
        StringStream.prototype.eatWhile = function(match) {
          var start2 = this.pos;
          while (this.eat(match)) {
          }
          return this.pos > start2;
        };
        StringStream.prototype.eatSpace = function() {
          var start2 = this.pos;
          while (/[\s\u00a0]/.test(this.string.charAt(this.pos))) {
            ++this.pos;
          }
          return this.pos > start2;
        };
        StringStream.prototype.skipToEnd = function() {
          this.pos = this.string.length;
        };
        StringStream.prototype.skipTo = function(ch) {
          var found = this.string.indexOf(ch, this.pos);
          if (found > -1) {
            this.pos = found;
            return true;
          }
        };
        StringStream.prototype.backUp = function(n) {
          this.pos -= n;
        };
        StringStream.prototype.column = function() {
          if (this.lastColumnPos < this.start) {
            this.lastColumnValue = countColumn(this.string, this.start, this.tabSize, this.lastColumnPos, this.lastColumnValue);
            this.lastColumnPos = this.start;
          }
          return this.lastColumnValue - (this.lineStart ? countColumn(this.string, this.lineStart, this.tabSize) : 0);
        };
        StringStream.prototype.indentation = function() {
          return countColumn(this.string, null, this.tabSize) - (this.lineStart ? countColumn(this.string, this.lineStart, this.tabSize) : 0);
        };
        StringStream.prototype.match = function(pattern, consume, caseInsensitive) {
          if (typeof pattern == "string") {
            var cased = function(str) {
              return caseInsensitive ? str.toLowerCase() : str;
            };
            var substr = this.string.substr(this.pos, pattern.length);
            if (cased(substr) == cased(pattern)) {
              if (consume !== false) {
                this.pos += pattern.length;
              }
              return true;
            }
          } else {
            var match = this.string.slice(this.pos).match(pattern);
            if (match && match.index > 0) {
              return null;
            }
            if (match && consume !== false) {
              this.pos += match[0].length;
            }
            return match;
          }
        };
        StringStream.prototype.current = function() {
          return this.string.slice(this.start, this.pos);
        };
        StringStream.prototype.hideFirstChars = function(n, inner23) {
          this.lineStart += n;
          try {
            return inner23();
          } finally {
            this.lineStart -= n;
          }
        };
        StringStream.prototype.lookAhead = function(n) {
          var oracle = this.lineOracle;
          return oracle && oracle.lookAhead(n);
        };
        StringStream.prototype.baseToken = function() {
          var oracle = this.lineOracle;
          return oracle && oracle.baseToken(this.pos);
        };
        function getLine(doc2, n) {
          n -= doc2.first;
          if (n < 0 || n >= doc2.size) {
            throw new Error("There is no line " + (n + doc2.first) + " in the document.");
          }
          var chunk = doc2;
          while (!chunk.lines) {
            for (var i2 = 0; ; ++i2) {
              var child = chunk.children[i2], sz = child.chunkSize();
              if (n < sz) {
                chunk = child;
                break;
              }
              n -= sz;
            }
          }
          return chunk.lines[n];
        }
        function getBetween(doc2, start2, end2) {
          var out2 = [], n = start2.line;
          doc2.iter(start2.line, end2.line + 1, function(line) {
            var text = line.text;
            if (n == end2.line) {
              text = text.slice(0, end2.ch);
            }
            if (n == start2.line) {
              text = text.slice(start2.ch);
            }
            out2.push(text);
            ++n;
          });
          return out2;
        }
        function getLines(doc2, from, to) {
          var out2 = [];
          doc2.iter(from, to, function(line) {
            out2.push(line.text);
          });
          return out2;
        }
        function updateLineHeight(line, height) {
          var diff = height - line.height;
          if (diff) {
            for (var n = line; n; n = n.parent) {
              n.height += diff;
            }
          }
        }
        function lineNo(line) {
          if (line.parent == null) {
            return null;
          }
          var cur = line.parent, no = indexOf2(cur.lines, line);
          for (var chunk = cur.parent; chunk; cur = chunk, chunk = chunk.parent) {
            for (var i2 = 0; ; ++i2) {
              if (chunk.children[i2] == cur) {
                break;
              }
              no += chunk.children[i2].chunkSize();
            }
          }
          return no + cur.first;
        }
        function lineAtHeight(chunk, h) {
          var n = chunk.first;
          outer:
            do {
              for (var i$12 = 0; i$12 < chunk.children.length; ++i$12) {
                var child = chunk.children[i$12], ch = child.height;
                if (h < ch) {
                  chunk = child;
                  continue outer;
                }
                h -= ch;
                n += child.chunkSize();
              }
              return n;
            } while (!chunk.lines);
          var i2 = 0;
          for (; i2 < chunk.lines.length; ++i2) {
            var line = chunk.lines[i2], lh = line.height;
            if (h < lh) {
              break;
            }
            h -= lh;
          }
          return n + i2;
        }
        function isLine(doc2, l) {
          return l >= doc2.first && l < doc2.first + doc2.size;
        }
        function lineNumberFor(options, i2) {
          return String(options.lineNumberFormatter(i2 + options.firstLineNumber));
        }
        function Pos(line, ch, sticky) {
          if (sticky === void 0)
            sticky = null;
          if (!(this instanceof Pos)) {
            return new Pos(line, ch, sticky);
          }
          this.line = line;
          this.ch = ch;
          this.sticky = sticky;
        }
        function cmp(a, b) {
          return a.line - b.line || a.ch - b.ch;
        }
        function equalCursorPos(a, b) {
          return a.sticky == b.sticky && cmp(a, b) == 0;
        }
        function copyPos(x) {
          return Pos(x.line, x.ch);
        }
        function maxPos(a, b) {
          return cmp(a, b) < 0 ? b : a;
        }
        function minPos(a, b) {
          return cmp(a, b) < 0 ? a : b;
        }
        function clipLine(doc2, n) {
          return Math.max(doc2.first, Math.min(n, doc2.first + doc2.size - 1));
        }
        function clipPos(doc2, pos) {
          if (pos.line < doc2.first) {
            return Pos(doc2.first, 0);
          }
          var last = doc2.first + doc2.size - 1;
          if (pos.line > last) {
            return Pos(last, getLine(doc2, last).text.length);
          }
          return clipToLen(pos, getLine(doc2, pos.line).text.length);
        }
        function clipToLen(pos, linelen) {
          var ch = pos.ch;
          if (ch == null || ch > linelen) {
            return Pos(pos.line, linelen);
          } else if (ch < 0) {
            return Pos(pos.line, 0);
          } else {
            return pos;
          }
        }
        function clipPosArray(doc2, array) {
          var out2 = [];
          for (var i2 = 0; i2 < array.length; i2++) {
            out2[i2] = clipPos(doc2, array[i2]);
          }
          return out2;
        }
        var SavedContext = function(state, lookAhead) {
          this.state = state;
          this.lookAhead = lookAhead;
        };
        var Context = function(doc2, state, line, lookAhead) {
          this.state = state;
          this.doc = doc2;
          this.line = line;
          this.maxLookAhead = lookAhead || 0;
          this.baseTokens = null;
          this.baseTokenPos = 1;
        };
        Context.prototype.lookAhead = function(n) {
          var line = this.doc.getLine(this.line + n);
          if (line != null && n > this.maxLookAhead) {
            this.maxLookAhead = n;
          }
          return line;
        };
        Context.prototype.baseToken = function(n) {
          if (!this.baseTokens) {
            return null;
          }
          while (this.baseTokens[this.baseTokenPos] <= n) {
            this.baseTokenPos += 2;
          }
          var type = this.baseTokens[this.baseTokenPos + 1];
          return {
            type: type && type.replace(/( |^)overlay .*/, ""),
            size: this.baseTokens[this.baseTokenPos] - n
          };
        };
        Context.prototype.nextLine = function() {
          this.line++;
          if (this.maxLookAhead > 0) {
            this.maxLookAhead--;
          }
        };
        Context.fromSaved = function(doc2, saved, line) {
          if (saved instanceof SavedContext) {
            return new Context(doc2, copyState(doc2.mode, saved.state), line, saved.lookAhead);
          } else {
            return new Context(doc2, copyState(doc2.mode, saved), line);
          }
        };
        Context.prototype.save = function(copy3) {
          var state = copy3 !== false ? copyState(this.doc.mode, this.state) : this.state;
          return this.maxLookAhead > 0 ? new SavedContext(state, this.maxLookAhead) : state;
        };
        function highlightLine(cm, line, context, forceToEnd) {
          var st = [cm.state.modeGen], lineClasses = {};
          runMode(cm, line.text, cm.doc.mode, context, function(end2, style) {
            return st.push(end2, style);
          }, lineClasses, forceToEnd);
          var state = context.state;
          var loop = function(o2) {
            context.baseTokens = st;
            var overlay = cm.state.overlays[o2], i2 = 1, at = 0;
            context.state = true;
            runMode(cm, line.text, overlay.mode, context, function(end2, style) {
              var start2 = i2;
              while (at < end2) {
                var i_end = st[i2];
                if (i_end > end2) {
                  st.splice(i2, 1, end2, st[i2 + 1], i_end);
                }
                i2 += 2;
                at = Math.min(end2, i_end);
              }
              if (!style) {
                return;
              }
              if (overlay.opaque) {
                st.splice(start2, i2 - start2, end2, "overlay " + style);
                i2 = start2 + 2;
              } else {
                for (; start2 < i2; start2 += 2) {
                  var cur = st[start2 + 1];
                  st[start2 + 1] = (cur ? cur + " " : "") + "overlay " + style;
                }
              }
            }, lineClasses);
            context.state = state;
            context.baseTokens = null;
            context.baseTokenPos = 1;
          };
          for (var o = 0; o < cm.state.overlays.length; ++o)
            loop(o);
          return { styles: st, classes: lineClasses.bgClass || lineClasses.textClass ? lineClasses : null };
        }
        function getLineStyles(cm, line, updateFrontier) {
          if (!line.styles || line.styles[0] != cm.state.modeGen) {
            var context = getContextBefore(cm, lineNo(line));
            var resetState = line.text.length > cm.options.maxHighlightLength && copyState(cm.doc.mode, context.state);
            var result = highlightLine(cm, line, context);
            if (resetState) {
              context.state = resetState;
            }
            line.stateAfter = context.save(!resetState);
            line.styles = result.styles;
            if (result.classes) {
              line.styleClasses = result.classes;
            } else if (line.styleClasses) {
              line.styleClasses = null;
            }
            if (updateFrontier === cm.doc.highlightFrontier) {
              cm.doc.modeFrontier = Math.max(cm.doc.modeFrontier, ++cm.doc.highlightFrontier);
            }
          }
          return line.styles;
        }
        function getContextBefore(cm, n, precise) {
          var doc2 = cm.doc, display = cm.display;
          if (!doc2.mode.startState) {
            return new Context(doc2, true, n);
          }
          var start2 = findStartLine(cm, n, precise);
          var saved = start2 > doc2.first && getLine(doc2, start2 - 1).stateAfter;
          var context = saved ? Context.fromSaved(doc2, saved, start2) : new Context(doc2, startState(doc2.mode), start2);
          doc2.iter(start2, n, function(line) {
            processLine(cm, line.text, context);
            var pos = context.line;
            line.stateAfter = pos == n - 1 || pos % 5 == 0 || pos >= display.viewFrom && pos < display.viewTo ? context.save() : null;
            context.nextLine();
          });
          if (precise) {
            doc2.modeFrontier = context.line;
          }
          return context;
        }
        function processLine(cm, text, context, startAt) {
          var mode = cm.doc.mode;
          var stream = new StringStream(text, cm.options.tabSize, context);
          stream.start = stream.pos = startAt || 0;
          if (text == "") {
            callBlankLine(mode, context.state);
          }
          while (!stream.eol()) {
            readToken(mode, stream, context.state);
            stream.start = stream.pos;
          }
        }
        function callBlankLine(mode, state) {
          if (mode.blankLine) {
            return mode.blankLine(state);
          }
          if (!mode.innerMode) {
            return;
          }
          var inner23 = innerMode(mode, state);
          if (inner23.mode.blankLine) {
            return inner23.mode.blankLine(inner23.state);
          }
        }
        function readToken(mode, stream, state, inner23) {
          for (var i2 = 0; i2 < 10; i2++) {
            if (inner23) {
              inner23[0] = innerMode(mode, state).mode;
            }
            var style = mode.token(stream, state);
            if (stream.pos > stream.start) {
              return style;
            }
          }
          throw new Error("Mode " + mode.name + " failed to advance stream.");
        }
        var Token = function(stream, type, state) {
          this.start = stream.start;
          this.end = stream.pos;
          this.string = stream.current();
          this.type = type || null;
          this.state = state;
        };
        function takeToken(cm, pos, precise, asArray) {
          var doc2 = cm.doc, mode = doc2.mode, style;
          pos = clipPos(doc2, pos);
          var line = getLine(doc2, pos.line), context = getContextBefore(cm, pos.line, precise);
          var stream = new StringStream(line.text, cm.options.tabSize, context), tokens;
          if (asArray) {
            tokens = [];
          }
          while ((asArray || stream.pos < pos.ch) && !stream.eol()) {
            stream.start = stream.pos;
            style = readToken(mode, stream, context.state);
            if (asArray) {
              tokens.push(new Token(stream, style, copyState(doc2.mode, context.state)));
            }
          }
          return asArray ? tokens : new Token(stream, style, context.state);
        }
        function extractLineClasses(type, output) {
          if (type) {
            for (; ; ) {
              var lineClass = type.match(/(?:^|\s+)line-(background-)?(\S+)/);
              if (!lineClass) {
                break;
              }
              type = type.slice(0, lineClass.index) + type.slice(lineClass.index + lineClass[0].length);
              var prop2 = lineClass[1] ? "bgClass" : "textClass";
              if (output[prop2] == null) {
                output[prop2] = lineClass[2];
              } else if (!new RegExp("(?:^|\\s)" + lineClass[2] + "(?:$|\\s)").test(output[prop2])) {
                output[prop2] += " " + lineClass[2];
              }
            }
          }
          return type;
        }
        function runMode(cm, text, mode, context, f, lineClasses, forceToEnd) {
          var flattenSpans = mode.flattenSpans;
          if (flattenSpans == null) {
            flattenSpans = cm.options.flattenSpans;
          }
          var curStart = 0, curStyle = null;
          var stream = new StringStream(text, cm.options.tabSize, context), style;
          var inner23 = cm.options.addModeClass && [null];
          if (text == "") {
            extractLineClasses(callBlankLine(mode, context.state), lineClasses);
          }
          while (!stream.eol()) {
            if (stream.pos > cm.options.maxHighlightLength) {
              flattenSpans = false;
              if (forceToEnd) {
                processLine(cm, text, context, stream.pos);
              }
              stream.pos = text.length;
              style = null;
            } else {
              style = extractLineClasses(readToken(mode, stream, context.state, inner23), lineClasses);
            }
            if (inner23) {
              var mName = inner23[0].name;
              if (mName) {
                style = "m-" + (style ? mName + " " + style : mName);
              }
            }
            if (!flattenSpans || curStyle != style) {
              while (curStart < stream.start) {
                curStart = Math.min(stream.start, curStart + 5e3);
                f(curStart, curStyle);
              }
              curStyle = style;
            }
            stream.start = stream.pos;
          }
          while (curStart < stream.pos) {
            var pos = Math.min(stream.pos, curStart + 5e3);
            f(pos, curStyle);
            curStart = pos;
          }
        }
        function findStartLine(cm, n, precise) {
          var minindent, minline, doc2 = cm.doc;
          var lim = precise ? -1 : n - (cm.doc.mode.innerMode ? 1e3 : 100);
          for (var search = n; search > lim; --search) {
            if (search <= doc2.first) {
              return doc2.first;
            }
            var line = getLine(doc2, search - 1), after = line.stateAfter;
            if (after && (!precise || search + (after instanceof SavedContext ? after.lookAhead : 0) <= doc2.modeFrontier)) {
              return search;
            }
            var indented = countColumn(line.text, null, cm.options.tabSize);
            if (minline == null || minindent > indented) {
              minline = search - 1;
              minindent = indented;
            }
          }
          return minline;
        }
        function retreatFrontier(doc2, n) {
          doc2.modeFrontier = Math.min(doc2.modeFrontier, n);
          if (doc2.highlightFrontier < n - 10) {
            return;
          }
          var start2 = doc2.first;
          for (var line = n - 1; line > start2; line--) {
            var saved = getLine(doc2, line).stateAfter;
            if (saved && (!(saved instanceof SavedContext) || line + saved.lookAhead < n)) {
              start2 = line + 1;
              break;
            }
          }
          doc2.highlightFrontier = Math.min(doc2.highlightFrontier, start2);
        }
        var sawReadOnlySpans = false, sawCollapsedSpans = false;
        function seeReadOnlySpans() {
          sawReadOnlySpans = true;
        }
        function seeCollapsedSpans() {
          sawCollapsedSpans = true;
        }
        function MarkedSpan(marker, from, to) {
          this.marker = marker;
          this.from = from;
          this.to = to;
        }
        function getMarkedSpanFor(spans, marker) {
          if (spans) {
            for (var i2 = 0; i2 < spans.length; ++i2) {
              var span = spans[i2];
              if (span.marker == marker) {
                return span;
              }
            }
          }
        }
        function removeMarkedSpan(spans, span) {
          var r;
          for (var i2 = 0; i2 < spans.length; ++i2) {
            if (spans[i2] != span) {
              (r || (r = [])).push(spans[i2]);
            }
          }
          return r;
        }
        function addMarkedSpan(line, span, op) {
          var inThisOp = op && window.WeakSet && (op.markedSpans || (op.markedSpans = /* @__PURE__ */ new WeakSet()));
          if (inThisOp && line.markedSpans && inThisOp.has(line.markedSpans)) {
            line.markedSpans.push(span);
          } else {
            line.markedSpans = line.markedSpans ? line.markedSpans.concat([span]) : [span];
            if (inThisOp) {
              inThisOp.add(line.markedSpans);
            }
          }
          span.marker.attachLine(line);
        }
        function markedSpansBefore(old, startCh, isInsert) {
          var nw;
          if (old) {
            for (var i2 = 0; i2 < old.length; ++i2) {
              var span = old[i2], marker = span.marker;
              var startsBefore = span.from == null || (marker.inclusiveLeft ? span.from <= startCh : span.from < startCh);
              if (startsBefore || span.from == startCh && marker.type == "bookmark" && (!isInsert || !span.marker.insertLeft)) {
                var endsAfter = span.to == null || (marker.inclusiveRight ? span.to >= startCh : span.to > startCh);
                (nw || (nw = [])).push(new MarkedSpan(marker, span.from, endsAfter ? null : span.to));
              }
            }
          }
          return nw;
        }
        function markedSpansAfter(old, endCh, isInsert) {
          var nw;
          if (old) {
            for (var i2 = 0; i2 < old.length; ++i2) {
              var span = old[i2], marker = span.marker;
              var endsAfter = span.to == null || (marker.inclusiveRight ? span.to >= endCh : span.to > endCh);
              if (endsAfter || span.from == endCh && marker.type == "bookmark" && (!isInsert || span.marker.insertLeft)) {
                var startsBefore = span.from == null || (marker.inclusiveLeft ? span.from <= endCh : span.from < endCh);
                (nw || (nw = [])).push(new MarkedSpan(marker, startsBefore ? null : span.from - endCh, span.to == null ? null : span.to - endCh));
              }
            }
          }
          return nw;
        }
        function stretchSpansOverChange(doc2, change) {
          if (change.full) {
            return null;
          }
          var oldFirst = isLine(doc2, change.from.line) && getLine(doc2, change.from.line).markedSpans;
          var oldLast = isLine(doc2, change.to.line) && getLine(doc2, change.to.line).markedSpans;
          if (!oldFirst && !oldLast) {
            return null;
          }
          var startCh = change.from.ch, endCh = change.to.ch, isInsert = cmp(change.from, change.to) == 0;
          var first = markedSpansBefore(oldFirst, startCh, isInsert);
          var last = markedSpansAfter(oldLast, endCh, isInsert);
          var sameLine = change.text.length == 1, offset = lst(change.text).length + (sameLine ? startCh : 0);
          if (first) {
            for (var i2 = 0; i2 < first.length; ++i2) {
              var span = first[i2];
              if (span.to == null) {
                var found = getMarkedSpanFor(last, span.marker);
                if (!found) {
                  span.to = startCh;
                } else if (sameLine) {
                  span.to = found.to == null ? null : found.to + offset;
                }
              }
            }
          }
          if (last) {
            for (var i$12 = 0; i$12 < last.length; ++i$12) {
              var span$1 = last[i$12];
              if (span$1.to != null) {
                span$1.to += offset;
              }
              if (span$1.from == null) {
                var found$1 = getMarkedSpanFor(first, span$1.marker);
                if (!found$1) {
                  span$1.from = offset;
                  if (sameLine) {
                    (first || (first = [])).push(span$1);
                  }
                }
              } else {
                span$1.from += offset;
                if (sameLine) {
                  (first || (first = [])).push(span$1);
                }
              }
            }
          }
          if (first) {
            first = clearEmptySpans(first);
          }
          if (last && last != first) {
            last = clearEmptySpans(last);
          }
          var newMarkers = [first];
          if (!sameLine) {
            var gap = change.text.length - 2, gapMarkers;
            if (gap > 0 && first) {
              for (var i$22 = 0; i$22 < first.length; ++i$22) {
                if (first[i$22].to == null) {
                  (gapMarkers || (gapMarkers = [])).push(new MarkedSpan(first[i$22].marker, null, null));
                }
              }
            }
            for (var i$3 = 0; i$3 < gap; ++i$3) {
              newMarkers.push(gapMarkers);
            }
            newMarkers.push(last);
          }
          return newMarkers;
        }
        function clearEmptySpans(spans) {
          for (var i2 = 0; i2 < spans.length; ++i2) {
            var span = spans[i2];
            if (span.from != null && span.from == span.to && span.marker.clearWhenEmpty !== false) {
              spans.splice(i2--, 1);
            }
          }
          if (!spans.length) {
            return null;
          }
          return spans;
        }
        function removeReadOnlyRanges(doc2, from, to) {
          var markers = null;
          doc2.iter(from.line, to.line + 1, function(line) {
            if (line.markedSpans) {
              for (var i3 = 0; i3 < line.markedSpans.length; ++i3) {
                var mark = line.markedSpans[i3].marker;
                if (mark.readOnly && (!markers || indexOf2(markers, mark) == -1)) {
                  (markers || (markers = [])).push(mark);
                }
              }
            }
          });
          if (!markers) {
            return null;
          }
          var parts = [{ from, to }];
          for (var i2 = 0; i2 < markers.length; ++i2) {
            var mk = markers[i2], m2 = mk.find(0);
            for (var j = 0; j < parts.length; ++j) {
              var p = parts[j];
              if (cmp(p.to, m2.from) < 0 || cmp(p.from, m2.to) > 0) {
                continue;
              }
              var newParts = [j, 1], dfrom = cmp(p.from, m2.from), dto = cmp(p.to, m2.to);
              if (dfrom < 0 || !mk.inclusiveLeft && !dfrom) {
                newParts.push({ from: p.from, to: m2.from });
              }
              if (dto > 0 || !mk.inclusiveRight && !dto) {
                newParts.push({ from: m2.to, to: p.to });
              }
              parts.splice.apply(parts, newParts);
              j += newParts.length - 3;
            }
          }
          return parts;
        }
        function detachMarkedSpans(line) {
          var spans = line.markedSpans;
          if (!spans) {
            return;
          }
          for (var i2 = 0; i2 < spans.length; ++i2) {
            spans[i2].marker.detachLine(line);
          }
          line.markedSpans = null;
        }
        function attachMarkedSpans(line, spans) {
          if (!spans) {
            return;
          }
          for (var i2 = 0; i2 < spans.length; ++i2) {
            spans[i2].marker.attachLine(line);
          }
          line.markedSpans = spans;
        }
        function extraLeft(marker) {
          return marker.inclusiveLeft ? -1 : 0;
        }
        function extraRight(marker) {
          return marker.inclusiveRight ? 1 : 0;
        }
        function compareCollapsedMarkers(a, b) {
          var lenDiff = a.lines.length - b.lines.length;
          if (lenDiff != 0) {
            return lenDiff;
          }
          var aPos = a.find(), bPos = b.find();
          var fromCmp = cmp(aPos.from, bPos.from) || extraLeft(a) - extraLeft(b);
          if (fromCmp) {
            return -fromCmp;
          }
          var toCmp = cmp(aPos.to, bPos.to) || extraRight(a) - extraRight(b);
          if (toCmp) {
            return toCmp;
          }
          return b.id - a.id;
        }
        function collapsedSpanAtSide(line, start2) {
          var sps = sawCollapsedSpans && line.markedSpans, found;
          if (sps) {
            for (var sp = void 0, i2 = 0; i2 < sps.length; ++i2) {
              sp = sps[i2];
              if (sp.marker.collapsed && (start2 ? sp.from : sp.to) == null && (!found || compareCollapsedMarkers(found, sp.marker) < 0)) {
                found = sp.marker;
              }
            }
          }
          return found;
        }
        function collapsedSpanAtStart(line) {
          return collapsedSpanAtSide(line, true);
        }
        function collapsedSpanAtEnd(line) {
          return collapsedSpanAtSide(line, false);
        }
        function collapsedSpanAround(line, ch) {
          var sps = sawCollapsedSpans && line.markedSpans, found;
          if (sps) {
            for (var i2 = 0; i2 < sps.length; ++i2) {
              var sp = sps[i2];
              if (sp.marker.collapsed && (sp.from == null || sp.from < ch) && (sp.to == null || sp.to > ch) && (!found || compareCollapsedMarkers(found, sp.marker) < 0)) {
                found = sp.marker;
              }
            }
          }
          return found;
        }
        function conflictingCollapsedRange(doc2, lineNo2, from, to, marker) {
          var line = getLine(doc2, lineNo2);
          var sps = sawCollapsedSpans && line.markedSpans;
          if (sps) {
            for (var i2 = 0; i2 < sps.length; ++i2) {
              var sp = sps[i2];
              if (!sp.marker.collapsed) {
                continue;
              }
              var found = sp.marker.find(0);
              var fromCmp = cmp(found.from, from) || extraLeft(sp.marker) - extraLeft(marker);
              var toCmp = cmp(found.to, to) || extraRight(sp.marker) - extraRight(marker);
              if (fromCmp >= 0 && toCmp <= 0 || fromCmp <= 0 && toCmp >= 0) {
                continue;
              }
              if (fromCmp <= 0 && (sp.marker.inclusiveRight && marker.inclusiveLeft ? cmp(found.to, from) >= 0 : cmp(found.to, from) > 0) || fromCmp >= 0 && (sp.marker.inclusiveRight && marker.inclusiveLeft ? cmp(found.from, to) <= 0 : cmp(found.from, to) < 0)) {
                return true;
              }
            }
          }
        }
        function visualLine(line) {
          var merged;
          while (merged = collapsedSpanAtStart(line)) {
            line = merged.find(-1, true).line;
          }
          return line;
        }
        function visualLineEnd(line) {
          var merged;
          while (merged = collapsedSpanAtEnd(line)) {
            line = merged.find(1, true).line;
          }
          return line;
        }
        function visualLineContinued(line) {
          var merged, lines;
          while (merged = collapsedSpanAtEnd(line)) {
            line = merged.find(1, true).line;
            (lines || (lines = [])).push(line);
          }
          return lines;
        }
        function visualLineNo(doc2, lineN) {
          var line = getLine(doc2, lineN), vis = visualLine(line);
          if (line == vis) {
            return lineN;
          }
          return lineNo(vis);
        }
        function visualLineEndNo(doc2, lineN) {
          if (lineN > doc2.lastLine()) {
            return lineN;
          }
          var line = getLine(doc2, lineN), merged;
          if (!lineIsHidden(doc2, line)) {
            return lineN;
          }
          while (merged = collapsedSpanAtEnd(line)) {
            line = merged.find(1, true).line;
          }
          return lineNo(line) + 1;
        }
        function lineIsHidden(doc2, line) {
          var sps = sawCollapsedSpans && line.markedSpans;
          if (sps) {
            for (var sp = void 0, i2 = 0; i2 < sps.length; ++i2) {
              sp = sps[i2];
              if (!sp.marker.collapsed) {
                continue;
              }
              if (sp.from == null) {
                return true;
              }
              if (sp.marker.widgetNode) {
                continue;
              }
              if (sp.from == 0 && sp.marker.inclusiveLeft && lineIsHiddenInner(doc2, line, sp)) {
                return true;
              }
            }
          }
        }
        function lineIsHiddenInner(doc2, line, span) {
          if (span.to == null) {
            var end2 = span.marker.find(1, true);
            return lineIsHiddenInner(doc2, end2.line, getMarkedSpanFor(end2.line.markedSpans, span.marker));
          }
          if (span.marker.inclusiveRight && span.to == line.text.length) {
            return true;
          }
          for (var sp = void 0, i2 = 0; i2 < line.markedSpans.length; ++i2) {
            sp = line.markedSpans[i2];
            if (sp.marker.collapsed && !sp.marker.widgetNode && sp.from == span.to && (sp.to == null || sp.to != span.from) && (sp.marker.inclusiveLeft || span.marker.inclusiveRight) && lineIsHiddenInner(doc2, line, sp)) {
              return true;
            }
          }
        }
        function heightAtLine(lineObj) {
          lineObj = visualLine(lineObj);
          var h = 0, chunk = lineObj.parent;
          for (var i2 = 0; i2 < chunk.lines.length; ++i2) {
            var line = chunk.lines[i2];
            if (line == lineObj) {
              break;
            } else {
              h += line.height;
            }
          }
          for (var p = chunk.parent; p; chunk = p, p = chunk.parent) {
            for (var i$12 = 0; i$12 < p.children.length; ++i$12) {
              var cur = p.children[i$12];
              if (cur == chunk) {
                break;
              } else {
                h += cur.height;
              }
            }
          }
          return h;
        }
        function lineLength(line) {
          if (line.height == 0) {
            return 0;
          }
          var len2 = line.text.length, merged, cur = line;
          while (merged = collapsedSpanAtStart(cur)) {
            var found = merged.find(0, true);
            cur = found.from.line;
            len2 += found.from.ch - found.to.ch;
          }
          cur = line;
          while (merged = collapsedSpanAtEnd(cur)) {
            var found$1 = merged.find(0, true);
            len2 -= cur.text.length - found$1.from.ch;
            cur = found$1.to.line;
            len2 += cur.text.length - found$1.to.ch;
          }
          return len2;
        }
        function findMaxLine(cm) {
          var d = cm.display, doc2 = cm.doc;
          d.maxLine = getLine(doc2, doc2.first);
          d.maxLineLength = lineLength(d.maxLine);
          d.maxLineChanged = true;
          doc2.iter(function(line) {
            var len2 = lineLength(line);
            if (len2 > d.maxLineLength) {
              d.maxLineLength = len2;
              d.maxLine = line;
            }
          });
        }
        var Line3 = function(text, markedSpans, estimateHeight2) {
          this.text = text;
          attachMarkedSpans(this, markedSpans);
          this.height = estimateHeight2 ? estimateHeight2(this) : 1;
        };
        Line3.prototype.lineNo = function() {
          return lineNo(this);
        };
        eventMixin(Line3);
        function updateLine(line, text, markedSpans, estimateHeight2) {
          line.text = text;
          if (line.stateAfter) {
            line.stateAfter = null;
          }
          if (line.styles) {
            line.styles = null;
          }
          if (line.order != null) {
            line.order = null;
          }
          detachMarkedSpans(line);
          attachMarkedSpans(line, markedSpans);
          var estHeight = estimateHeight2 ? estimateHeight2(line) : 1;
          if (estHeight != line.height) {
            updateLineHeight(line, estHeight);
          }
        }
        function cleanUpLine(line) {
          line.parent = null;
          detachMarkedSpans(line);
        }
        var styleToClassCache = {}, styleToClassCacheWithMode = {};
        function interpretTokenStyle(style, options) {
          if (!style || /^\s*$/.test(style)) {
            return null;
          }
          var cache = options.addModeClass ? styleToClassCacheWithMode : styleToClassCache;
          return cache[style] || (cache[style] = style.replace(/\S+/g, "cm-$&"));
        }
        function buildLineContent(cm, lineView) {
          var content = eltP("span", null, null, webkit ? "padding-right: .1px" : null);
          var builder = {
            pre: eltP("pre", [content], "CodeMirror-line"),
            content,
            col: 0,
            pos: 0,
            cm,
            trailingSpace: false,
            splitSpaces: cm.getOption("lineWrapping")
          };
          lineView.measure = {};
          for (var i2 = 0; i2 <= (lineView.rest ? lineView.rest.length : 0); i2++) {
            var line = i2 ? lineView.rest[i2 - 1] : lineView.line, order = void 0;
            builder.pos = 0;
            builder.addToken = buildToken;
            if (hasBadBidiRects(cm.display.measure) && (order = getOrder(line, cm.doc.direction))) {
              builder.addToken = buildTokenBadBidi(builder.addToken, order);
            }
            builder.map = [];
            var allowFrontierUpdate = lineView != cm.display.externalMeasured && lineNo(line);
            insertLineContent(line, builder, getLineStyles(cm, line, allowFrontierUpdate));
            if (line.styleClasses) {
              if (line.styleClasses.bgClass) {
                builder.bgClass = joinClasses(line.styleClasses.bgClass, builder.bgClass || "");
              }
              if (line.styleClasses.textClass) {
                builder.textClass = joinClasses(line.styleClasses.textClass, builder.textClass || "");
              }
            }
            if (builder.map.length == 0) {
              builder.map.push(0, 0, builder.content.appendChild(zeroWidthElement(cm.display.measure)));
            }
            if (i2 == 0) {
              lineView.measure.map = builder.map;
              lineView.measure.cache = {};
            } else {
              (lineView.measure.maps || (lineView.measure.maps = [])).push(builder.map);
              (lineView.measure.caches || (lineView.measure.caches = [])).push({});
            }
          }
          if (webkit) {
            var last = builder.content.lastChild;
            if (/\bcm-tab\b/.test(last.className) || last.querySelector && last.querySelector(".cm-tab")) {
              builder.content.className = "cm-tab-wrap-hack";
            }
          }
          signal(cm, "renderLine", cm, lineView.line, builder.pre);
          if (builder.pre.className) {
            builder.textClass = joinClasses(builder.pre.className, builder.textClass || "");
          }
          return builder;
        }
        function defaultSpecialCharPlaceholder(ch) {
          var token = elt("span", "•", "cm-invalidchar");
          token.title = "\\u" + ch.charCodeAt(0).toString(16);
          token.setAttribute("aria-label", token.title);
          return token;
        }
        function buildToken(builder, text, style, startStyle, endStyle, css, attributes) {
          if (!text) {
            return;
          }
          var displayText = builder.splitSpaces ? splitSpaces(text, builder.trailingSpace) : text;
          var special = builder.cm.state.specialChars, mustWrap = false;
          var content;
          if (!special.test(text)) {
            builder.col += text.length;
            content = document.createTextNode(displayText);
            builder.map.push(builder.pos, builder.pos + text.length, content);
            if (ie && ie_version < 9) {
              mustWrap = true;
            }
            builder.pos += text.length;
          } else {
            content = document.createDocumentFragment();
            var pos = 0;
            while (true) {
              special.lastIndex = pos;
              var m2 = special.exec(text);
              var skipped = m2 ? m2.index - pos : text.length - pos;
              if (skipped) {
                var txt = document.createTextNode(displayText.slice(pos, pos + skipped));
                if (ie && ie_version < 9) {
                  content.appendChild(elt("span", [txt]));
                } else {
                  content.appendChild(txt);
                }
                builder.map.push(builder.pos, builder.pos + skipped, txt);
                builder.col += skipped;
                builder.pos += skipped;
              }
              if (!m2) {
                break;
              }
              pos += skipped + 1;
              var txt$1 = void 0;
              if (m2[0] == "	") {
                var tabSize = builder.cm.options.tabSize, tabWidth = tabSize - builder.col % tabSize;
                txt$1 = content.appendChild(elt("span", spaceStr(tabWidth), "cm-tab"));
                txt$1.setAttribute("role", "presentation");
                txt$1.setAttribute("cm-text", "	");
                builder.col += tabWidth;
              } else if (m2[0] == "\r" || m2[0] == "\n") {
                txt$1 = content.appendChild(elt("span", m2[0] == "\r" ? "␍" : "␤", "cm-invalidchar"));
                txt$1.setAttribute("cm-text", m2[0]);
                builder.col += 1;
              } else {
                txt$1 = builder.cm.options.specialCharPlaceholder(m2[0]);
                txt$1.setAttribute("cm-text", m2[0]);
                if (ie && ie_version < 9) {
                  content.appendChild(elt("span", [txt$1]));
                } else {
                  content.appendChild(txt$1);
                }
                builder.col += 1;
              }
              builder.map.push(builder.pos, builder.pos + 1, txt$1);
              builder.pos++;
            }
          }
          builder.trailingSpace = displayText.charCodeAt(text.length - 1) == 32;
          if (style || startStyle || endStyle || mustWrap || css || attributes) {
            var fullStyle = style || "";
            if (startStyle) {
              fullStyle += startStyle;
            }
            if (endStyle) {
              fullStyle += endStyle;
            }
            var token = elt("span", [content], fullStyle, css);
            if (attributes) {
              for (var attr in attributes) {
                if (attributes.hasOwnProperty(attr) && attr != "style" && attr != "class") {
                  token.setAttribute(attr, attributes[attr]);
                }
              }
            }
            return builder.content.appendChild(token);
          }
          builder.content.appendChild(content);
        }
        function splitSpaces(text, trailingBefore) {
          if (text.length > 1 && !/  /.test(text)) {
            return text;
          }
          var spaceBefore = trailingBefore, result = "";
          for (var i2 = 0; i2 < text.length; i2++) {
            var ch = text.charAt(i2);
            if (ch == " " && spaceBefore && (i2 == text.length - 1 || text.charCodeAt(i2 + 1) == 32)) {
              ch = " ";
            }
            result += ch;
            spaceBefore = ch == " ";
          }
          return result;
        }
        function buildTokenBadBidi(inner23, order) {
          return function(builder, text, style, startStyle, endStyle, css, attributes) {
            style = style ? style + " cm-force-border" : "cm-force-border";
            var start2 = builder.pos, end2 = start2 + text.length;
            for (; ; ) {
              var part = void 0;
              for (var i2 = 0; i2 < order.length; i2++) {
                part = order[i2];
                if (part.to > start2 && part.from <= start2) {
                  break;
                }
              }
              if (part.to >= end2) {
                return inner23(builder, text, style, startStyle, endStyle, css, attributes);
              }
              inner23(builder, text.slice(0, part.to - start2), style, startStyle, null, css, attributes);
              startStyle = null;
              text = text.slice(part.to - start2);
              start2 = part.to;
            }
          };
        }
        function buildCollapsedSpan(builder, size, marker, ignoreWidget) {
          var widget = !ignoreWidget && marker.widgetNode;
          if (widget) {
            builder.map.push(builder.pos, builder.pos + size, widget);
          }
          if (!ignoreWidget && builder.cm.display.input.needsContentAttribute) {
            if (!widget) {
              widget = builder.content.appendChild(document.createElement("span"));
            }
            widget.setAttribute("cm-marker", marker.id);
          }
          if (widget) {
            builder.cm.display.input.setUneditable(widget);
            builder.content.appendChild(widget);
          }
          builder.pos += size;
          builder.trailingSpace = false;
        }
        function insertLineContent(line, builder, styles) {
          var spans = line.markedSpans, allText = line.text, at = 0;
          if (!spans) {
            for (var i$12 = 1; i$12 < styles.length; i$12 += 2) {
              builder.addToken(builder, allText.slice(at, at = styles[i$12]), interpretTokenStyle(styles[i$12 + 1], builder.cm.options));
            }
            return;
          }
          var len2 = allText.length, pos = 0, i2 = 1, text = "", style, css;
          var nextChange = 0, spanStyle, spanEndStyle, spanStartStyle, collapsed, attributes;
          for (; ; ) {
            if (nextChange == pos) {
              spanStyle = spanEndStyle = spanStartStyle = css = "";
              attributes = null;
              collapsed = null;
              nextChange = Infinity;
              var foundBookmarks = [], endStyles = void 0;
              for (var j = 0; j < spans.length; ++j) {
                var sp = spans[j], m2 = sp.marker;
                if (m2.type == "bookmark" && sp.from == pos && m2.widgetNode) {
                  foundBookmarks.push(m2);
                } else if (sp.from <= pos && (sp.to == null || sp.to > pos || m2.collapsed && sp.to == pos && sp.from == pos)) {
                  if (sp.to != null && sp.to != pos && nextChange > sp.to) {
                    nextChange = sp.to;
                    spanEndStyle = "";
                  }
                  if (m2.className) {
                    spanStyle += " " + m2.className;
                  }
                  if (m2.css) {
                    css = (css ? css + ";" : "") + m2.css;
                  }
                  if (m2.startStyle && sp.from == pos) {
                    spanStartStyle += " " + m2.startStyle;
                  }
                  if (m2.endStyle && sp.to == nextChange) {
                    (endStyles || (endStyles = [])).push(m2.endStyle, sp.to);
                  }
                  if (m2.title) {
                    (attributes || (attributes = {})).title = m2.title;
                  }
                  if (m2.attributes) {
                    for (var attr in m2.attributes) {
                      (attributes || (attributes = {}))[attr] = m2.attributes[attr];
                    }
                  }
                  if (m2.collapsed && (!collapsed || compareCollapsedMarkers(collapsed.marker, m2) < 0)) {
                    collapsed = sp;
                  }
                } else if (sp.from > pos && nextChange > sp.from) {
                  nextChange = sp.from;
                }
              }
              if (endStyles) {
                for (var j$1 = 0; j$1 < endStyles.length; j$1 += 2) {
                  if (endStyles[j$1 + 1] == nextChange) {
                    spanEndStyle += " " + endStyles[j$1];
                  }
                }
              }
              if (!collapsed || collapsed.from == pos) {
                for (var j$2 = 0; j$2 < foundBookmarks.length; ++j$2) {
                  buildCollapsedSpan(builder, 0, foundBookmarks[j$2]);
                }
              }
              if (collapsed && (collapsed.from || 0) == pos) {
                buildCollapsedSpan(builder, (collapsed.to == null ? len2 + 1 : collapsed.to) - pos, collapsed.marker, collapsed.from == null);
                if (collapsed.to == null) {
                  return;
                }
                if (collapsed.to == pos) {
                  collapsed = false;
                }
              }
            }
            if (pos >= len2) {
              break;
            }
            var upto = Math.min(len2, nextChange);
            while (true) {
              if (text) {
                var end2 = pos + text.length;
                if (!collapsed) {
                  var tokenText = end2 > upto ? text.slice(0, upto - pos) : text;
                  builder.addToken(builder, tokenText, style ? style + spanStyle : spanStyle, spanStartStyle, pos + tokenText.length == nextChange ? spanEndStyle : "", css, attributes);
                }
                if (end2 >= upto) {
                  text = text.slice(upto - pos);
                  pos = upto;
                  break;
                }
                pos = end2;
                spanStartStyle = "";
              }
              text = allText.slice(at, at = styles[i2++]);
              style = interpretTokenStyle(styles[i2++], builder.cm.options);
            }
          }
        }
        function LineView2(doc2, line, lineN) {
          this.line = line;
          this.rest = visualLineContinued(line);
          this.size = this.rest ? lineNo(lst(this.rest)) - lineN + 1 : 1;
          this.node = this.text = null;
          this.hidden = lineIsHidden(doc2, line);
        }
        function buildViewArray(cm, from, to) {
          var array = [], nextPos;
          for (var pos = from; pos < to; pos = nextPos) {
            var view = new LineView2(cm.doc, getLine(cm.doc, pos), pos);
            nextPos = pos + view.size;
            array.push(view);
          }
          return array;
        }
        var operationGroup = null;
        function pushOperation(op) {
          if (operationGroup) {
            operationGroup.ops.push(op);
          } else {
            op.ownsGroup = operationGroup = {
              ops: [op],
              delayedCallbacks: []
            };
          }
        }
        function fireCallbacksForOps(group) {
          var callbacks = group.delayedCallbacks, i2 = 0;
          do {
            for (; i2 < callbacks.length; i2++) {
              callbacks[i2].call(null);
            }
            for (var j = 0; j < group.ops.length; j++) {
              var op = group.ops[j];
              if (op.cursorActivityHandlers) {
                while (op.cursorActivityCalled < op.cursorActivityHandlers.length) {
                  op.cursorActivityHandlers[op.cursorActivityCalled++].call(null, op.cm);
                }
              }
            }
          } while (i2 < callbacks.length);
        }
        function finishOperation(op, endCb) {
          var group = op.ownsGroup;
          if (!group) {
            return;
          }
          try {
            fireCallbacksForOps(group);
          } finally {
            operationGroup = null;
            endCb(group);
          }
        }
        var orphanDelayedCallbacks = null;
        function signalLater(emitter, type) {
          var arr = getHandlers(emitter, type);
          if (!arr.length) {
            return;
          }
          var args = Array.prototype.slice.call(arguments, 2), list;
          if (operationGroup) {
            list = operationGroup.delayedCallbacks;
          } else if (orphanDelayedCallbacks) {
            list = orphanDelayedCallbacks;
          } else {
            list = orphanDelayedCallbacks = [];
            setTimeout(fireOrphanDelayed, 0);
          }
          var loop = function(i3) {
            list.push(function() {
              return arr[i3].apply(null, args);
            });
          };
          for (var i2 = 0; i2 < arr.length; ++i2)
            loop(i2);
        }
        function fireOrphanDelayed() {
          var delayed = orphanDelayedCallbacks;
          orphanDelayedCallbacks = null;
          for (var i2 = 0; i2 < delayed.length; ++i2) {
            delayed[i2]();
          }
        }
        function updateLineForChanges(cm, lineView, lineN, dims) {
          for (var j = 0; j < lineView.changes.length; j++) {
            var type = lineView.changes[j];
            if (type == "text") {
              updateLineText(cm, lineView);
            } else if (type == "gutter") {
              updateLineGutter(cm, lineView, lineN, dims);
            } else if (type == "class") {
              updateLineClasses(cm, lineView);
            } else if (type == "widget") {
              updateLineWidgets(cm, lineView, dims);
            }
          }
          lineView.changes = null;
        }
        function ensureLineWrapped(lineView) {
          if (lineView.node == lineView.text) {
            lineView.node = elt("div", null, null, "position: relative");
            if (lineView.text.parentNode) {
              lineView.text.parentNode.replaceChild(lineView.node, lineView.text);
            }
            lineView.node.appendChild(lineView.text);
            if (ie && ie_version < 8) {
              lineView.node.style.zIndex = 2;
            }
          }
          return lineView.node;
        }
        function updateLineBackground(cm, lineView) {
          var cls = lineView.bgClass ? lineView.bgClass + " " + (lineView.line.bgClass || "") : lineView.line.bgClass;
          if (cls) {
            cls += " CodeMirror-linebackground";
          }
          if (lineView.background) {
            if (cls) {
              lineView.background.className = cls;
            } else {
              lineView.background.parentNode.removeChild(lineView.background);
              lineView.background = null;
            }
          } else if (cls) {
            var wrap = ensureLineWrapped(lineView);
            lineView.background = wrap.insertBefore(elt("div", null, cls), wrap.firstChild);
            cm.display.input.setUneditable(lineView.background);
          }
        }
        function getLineContent(cm, lineView) {
          var ext = cm.display.externalMeasured;
          if (ext && ext.line == lineView.line) {
            cm.display.externalMeasured = null;
            lineView.measure = ext.measure;
            return ext.built;
          }
          return buildLineContent(cm, lineView);
        }
        function updateLineText(cm, lineView) {
          var cls = lineView.text.className;
          var built = getLineContent(cm, lineView);
          if (lineView.text == lineView.node) {
            lineView.node = built.pre;
          }
          lineView.text.parentNode.replaceChild(built.pre, lineView.text);
          lineView.text = built.pre;
          if (built.bgClass != lineView.bgClass || built.textClass != lineView.textClass) {
            lineView.bgClass = built.bgClass;
            lineView.textClass = built.textClass;
            updateLineClasses(cm, lineView);
          } else if (cls) {
            lineView.text.className = cls;
          }
        }
        function updateLineClasses(cm, lineView) {
          updateLineBackground(cm, lineView);
          if (lineView.line.wrapClass) {
            ensureLineWrapped(lineView).className = lineView.line.wrapClass;
          } else if (lineView.node != lineView.text) {
            lineView.node.className = "";
          }
          var textClass = lineView.textClass ? lineView.textClass + " " + (lineView.line.textClass || "") : lineView.line.textClass;
          lineView.text.className = textClass || "";
        }
        function updateLineGutter(cm, lineView, lineN, dims) {
          if (lineView.gutter) {
            lineView.node.removeChild(lineView.gutter);
            lineView.gutter = null;
          }
          if (lineView.gutterBackground) {
            lineView.node.removeChild(lineView.gutterBackground);
            lineView.gutterBackground = null;
          }
          if (lineView.line.gutterClass) {
            var wrap = ensureLineWrapped(lineView);
            lineView.gutterBackground = elt("div", null, "CodeMirror-gutter-background " + lineView.line.gutterClass, "left: " + (cm.options.fixedGutter ? dims.fixedPos : -dims.gutterTotalWidth) + "px; width: " + dims.gutterTotalWidth + "px");
            cm.display.input.setUneditable(lineView.gutterBackground);
            wrap.insertBefore(lineView.gutterBackground, lineView.text);
          }
          var markers = lineView.line.gutterMarkers;
          if (cm.options.lineNumbers || markers) {
            var wrap$1 = ensureLineWrapped(lineView);
            var gutterWrap = lineView.gutter = elt("div", null, "CodeMirror-gutter-wrapper", "left: " + (cm.options.fixedGutter ? dims.fixedPos : -dims.gutterTotalWidth) + "px");
            gutterWrap.setAttribute("aria-hidden", "true");
            cm.display.input.setUneditable(gutterWrap);
            wrap$1.insertBefore(gutterWrap, lineView.text);
            if (lineView.line.gutterClass) {
              gutterWrap.className += " " + lineView.line.gutterClass;
            }
            if (cm.options.lineNumbers && (!markers || !markers["CodeMirror-linenumbers"])) {
              lineView.lineNumber = gutterWrap.appendChild(elt("div", lineNumberFor(cm.options, lineN), "CodeMirror-linenumber CodeMirror-gutter-elt", "left: " + dims.gutterLeft["CodeMirror-linenumbers"] + "px; width: " + cm.display.lineNumInnerWidth + "px"));
            }
            if (markers) {
              for (var k = 0; k < cm.display.gutterSpecs.length; ++k) {
                var id = cm.display.gutterSpecs[k].className, found = markers.hasOwnProperty(id) && markers[id];
                if (found) {
                  gutterWrap.appendChild(elt("div", [found], "CodeMirror-gutter-elt", "left: " + dims.gutterLeft[id] + "px; width: " + dims.gutterWidth[id] + "px"));
                }
              }
            }
          }
        }
        function updateLineWidgets(cm, lineView, dims) {
          if (lineView.alignable) {
            lineView.alignable = null;
          }
          var isWidget = classTest("CodeMirror-linewidget");
          for (var node = lineView.node.firstChild, next = void 0; node; node = next) {
            next = node.nextSibling;
            if (isWidget.test(node.className)) {
              lineView.node.removeChild(node);
            }
          }
          insertLineWidgets(cm, lineView, dims);
        }
        function buildLineElement(cm, lineView, lineN, dims) {
          var built = getLineContent(cm, lineView);
          lineView.text = lineView.node = built.pre;
          if (built.bgClass) {
            lineView.bgClass = built.bgClass;
          }
          if (built.textClass) {
            lineView.textClass = built.textClass;
          }
          updateLineClasses(cm, lineView);
          updateLineGutter(cm, lineView, lineN, dims);
          insertLineWidgets(cm, lineView, dims);
          return lineView.node;
        }
        function insertLineWidgets(cm, lineView, dims) {
          insertLineWidgetsFor(cm, lineView.line, lineView, dims, true);
          if (lineView.rest) {
            for (var i2 = 0; i2 < lineView.rest.length; i2++) {
              insertLineWidgetsFor(cm, lineView.rest[i2], lineView, dims, false);
            }
          }
        }
        function insertLineWidgetsFor(cm, line, lineView, dims, allowAbove) {
          if (!line.widgets) {
            return;
          }
          var wrap = ensureLineWrapped(lineView);
          for (var i2 = 0, ws = line.widgets; i2 < ws.length; ++i2) {
            var widget = ws[i2], node = elt("div", [widget.node], "CodeMirror-linewidget" + (widget.className ? " " + widget.className : ""));
            if (!widget.handleMouseEvents) {
              node.setAttribute("cm-ignore-events", "true");
            }
            positionLineWidget(widget, node, lineView, dims);
            cm.display.input.setUneditable(node);
            if (allowAbove && widget.above) {
              wrap.insertBefore(node, lineView.gutter || lineView.text);
            } else {
              wrap.appendChild(node);
            }
            signalLater(widget, "redraw");
          }
        }
        function positionLineWidget(widget, node, lineView, dims) {
          if (widget.noHScroll) {
            (lineView.alignable || (lineView.alignable = [])).push(node);
            var width = dims.wrapperWidth;
            node.style.left = dims.fixedPos + "px";
            if (!widget.coverGutter) {
              width -= dims.gutterTotalWidth;
              node.style.paddingLeft = dims.gutterTotalWidth + "px";
            }
            node.style.width = width + "px";
          }
          if (widget.coverGutter) {
            node.style.zIndex = 5;
            node.style.position = "relative";
            if (!widget.noHScroll) {
              node.style.marginLeft = -dims.gutterTotalWidth + "px";
            }
          }
        }
        function widgetHeight(widget) {
          if (widget.height != null) {
            return widget.height;
          }
          var cm = widget.doc.cm;
          if (!cm) {
            return 0;
          }
          if (!contains(document.body, widget.node)) {
            var parentStyle = "position: relative;";
            if (widget.coverGutter) {
              parentStyle += "margin-left: -" + cm.display.gutters.offsetWidth + "px;";
            }
            if (widget.noHScroll) {
              parentStyle += "width: " + cm.display.wrapper.clientWidth + "px;";
            }
            removeChildrenAndAdd(cm.display.measure, elt("div", [widget.node], null, parentStyle));
          }
          return widget.height = widget.node.parentNode.offsetHeight;
        }
        function eventInWidget(display, e2) {
          for (var n = e_target(e2); n != display.wrapper; n = n.parentNode) {
            if (!n || n.nodeType == 1 && n.getAttribute("cm-ignore-events") == "true" || n.parentNode == display.sizer && n != display.mover) {
              return true;
            }
          }
        }
        function paddingTop(display) {
          return display.lineSpace.offsetTop;
        }
        function paddingVert(display) {
          return display.mover.offsetHeight - display.lineSpace.offsetHeight;
        }
        function paddingH(display) {
          if (display.cachedPaddingH) {
            return display.cachedPaddingH;
          }
          var e2 = removeChildrenAndAdd(display.measure, elt("pre", "x", "CodeMirror-line-like"));
          var style = window.getComputedStyle ? window.getComputedStyle(e2) : e2.currentStyle;
          var data = { left: parseInt(style.paddingLeft), right: parseInt(style.paddingRight) };
          if (!isNaN(data.left) && !isNaN(data.right)) {
            display.cachedPaddingH = data;
          }
          return data;
        }
        function scrollGap(cm) {
          return scrollerGap - cm.display.nativeBarWidth;
        }
        function displayWidth(cm) {
          return cm.display.scroller.clientWidth - scrollGap(cm) - cm.display.barWidth;
        }
        function displayHeight(cm) {
          return cm.display.scroller.clientHeight - scrollGap(cm) - cm.display.barHeight;
        }
        function ensureLineHeights(cm, lineView, rect) {
          var wrapping = cm.options.lineWrapping;
          var curWidth = wrapping && displayWidth(cm);
          if (!lineView.measure.heights || wrapping && lineView.measure.width != curWidth) {
            var heights = lineView.measure.heights = [];
            if (wrapping) {
              lineView.measure.width = curWidth;
              var rects = lineView.text.firstChild.getClientRects();
              for (var i2 = 0; i2 < rects.length - 1; i2++) {
                var cur = rects[i2], next = rects[i2 + 1];
                if (Math.abs(cur.bottom - next.bottom) > 2) {
                  heights.push((cur.bottom + next.top) / 2 - rect.top);
                }
              }
            }
            heights.push(rect.bottom - rect.top);
          }
        }
        function mapFromLineView(lineView, line, lineN) {
          if (lineView.line == line) {
            return { map: lineView.measure.map, cache: lineView.measure.cache };
          }
          if (lineView.rest) {
            for (var i2 = 0; i2 < lineView.rest.length; i2++) {
              if (lineView.rest[i2] == line) {
                return { map: lineView.measure.maps[i2], cache: lineView.measure.caches[i2] };
              }
            }
            for (var i$12 = 0; i$12 < lineView.rest.length; i$12++) {
              if (lineNo(lineView.rest[i$12]) > lineN) {
                return { map: lineView.measure.maps[i$12], cache: lineView.measure.caches[i$12], before: true };
              }
            }
          }
        }
        function updateExternalMeasurement(cm, line) {
          line = visualLine(line);
          var lineN = lineNo(line);
          var view = cm.display.externalMeasured = new LineView2(cm.doc, line, lineN);
          view.lineN = lineN;
          var built = view.built = buildLineContent(cm, view);
          view.text = built.pre;
          removeChildrenAndAdd(cm.display.lineMeasure, built.pre);
          return view;
        }
        function measureChar(cm, line, ch, bias) {
          return measureCharPrepared(cm, prepareMeasureForLine(cm, line), ch, bias);
        }
        function findViewForLine(cm, lineN) {
          if (lineN >= cm.display.viewFrom && lineN < cm.display.viewTo) {
            return cm.display.view[findViewIndex(cm, lineN)];
          }
          var ext = cm.display.externalMeasured;
          if (ext && lineN >= ext.lineN && lineN < ext.lineN + ext.size) {
            return ext;
          }
        }
        function prepareMeasureForLine(cm, line) {
          var lineN = lineNo(line);
          var view = findViewForLine(cm, lineN);
          if (view && !view.text) {
            view = null;
          } else if (view && view.changes) {
            updateLineForChanges(cm, view, lineN, getDimensions(cm));
            cm.curOp.forceUpdate = true;
          }
          if (!view) {
            view = updateExternalMeasurement(cm, line);
          }
          var info = mapFromLineView(view, line, lineN);
          return {
            line,
            view,
            rect: null,
            map: info.map,
            cache: info.cache,
            before: info.before,
            hasHeights: false
          };
        }
        function measureCharPrepared(cm, prepared, ch, bias, varHeight) {
          if (prepared.before) {
            ch = -1;
          }
          var key = ch + (bias || ""), found;
          if (prepared.cache.hasOwnProperty(key)) {
            found = prepared.cache[key];
          } else {
            if (!prepared.rect) {
              prepared.rect = prepared.view.text.getBoundingClientRect();
            }
            if (!prepared.hasHeights) {
              ensureLineHeights(cm, prepared.view, prepared.rect);
              prepared.hasHeights = true;
            }
            found = measureCharInner(cm, prepared, ch, bias);
            if (!found.bogus) {
              prepared.cache[key] = found;
            }
          }
          return {
            left: found.left,
            right: found.right,
            top: varHeight ? found.rtop : found.top,
            bottom: varHeight ? found.rbottom : found.bottom
          };
        }
        var nullRect = { left: 0, right: 0, top: 0, bottom: 0 };
        function nodeAndOffsetInLineMap(map4, ch, bias) {
          var node, start2, end2, collapse, mStart, mEnd;
          for (var i2 = 0; i2 < map4.length; i2 += 3) {
            mStart = map4[i2];
            mEnd = map4[i2 + 1];
            if (ch < mStart) {
              start2 = 0;
              end2 = 1;
              collapse = "left";
            } else if (ch < mEnd) {
              start2 = ch - mStart;
              end2 = start2 + 1;
            } else if (i2 == map4.length - 3 || ch == mEnd && map4[i2 + 3] > ch) {
              end2 = mEnd - mStart;
              start2 = end2 - 1;
              if (ch >= mEnd) {
                collapse = "right";
              }
            }
            if (start2 != null) {
              node = map4[i2 + 2];
              if (mStart == mEnd && bias == (node.insertLeft ? "left" : "right")) {
                collapse = bias;
              }
              if (bias == "left" && start2 == 0) {
                while (i2 && map4[i2 - 2] == map4[i2 - 3] && map4[i2 - 1].insertLeft) {
                  node = map4[(i2 -= 3) + 2];
                  collapse = "left";
                }
              }
              if (bias == "right" && start2 == mEnd - mStart) {
                while (i2 < map4.length - 3 && map4[i2 + 3] == map4[i2 + 4] && !map4[i2 + 5].insertLeft) {
                  node = map4[(i2 += 3) + 2];
                  collapse = "right";
                }
              }
              break;
            }
          }
          return { node, start: start2, end: end2, collapse, coverStart: mStart, coverEnd: mEnd };
        }
        function getUsefulRect(rects, bias) {
          var rect = nullRect;
          if (bias == "left") {
            for (var i2 = 0; i2 < rects.length; i2++) {
              if ((rect = rects[i2]).left != rect.right) {
                break;
              }
            }
          } else {
            for (var i$12 = rects.length - 1; i$12 >= 0; i$12--) {
              if ((rect = rects[i$12]).left != rect.right) {
                break;
              }
            }
          }
          return rect;
        }
        function measureCharInner(cm, prepared, ch, bias) {
          var place = nodeAndOffsetInLineMap(prepared.map, ch, bias);
          var node = place.node, start2 = place.start, end2 = place.end, collapse = place.collapse;
          var rect;
          if (node.nodeType == 3) {
            for (var i$12 = 0; i$12 < 4; i$12++) {
              while (start2 && isExtendingChar(prepared.line.text.charAt(place.coverStart + start2))) {
                --start2;
              }
              while (place.coverStart + end2 < place.coverEnd && isExtendingChar(prepared.line.text.charAt(place.coverStart + end2))) {
                ++end2;
              }
              if (ie && ie_version < 9 && start2 == 0 && end2 == place.coverEnd - place.coverStart) {
                rect = node.parentNode.getBoundingClientRect();
              } else {
                rect = getUsefulRect(range(node, start2, end2).getClientRects(), bias);
              }
              if (rect.left || rect.right || start2 == 0) {
                break;
              }
              end2 = start2;
              start2 = start2 - 1;
              collapse = "right";
            }
            if (ie && ie_version < 11) {
              rect = maybeUpdateRectForZooming(cm.display.measure, rect);
            }
          } else {
            if (start2 > 0) {
              collapse = bias = "right";
            }
            var rects;
            if (cm.options.lineWrapping && (rects = node.getClientRects()).length > 1) {
              rect = rects[bias == "right" ? rects.length - 1 : 0];
            } else {
              rect = node.getBoundingClientRect();
            }
          }
          if (ie && ie_version < 9 && !start2 && (!rect || !rect.left && !rect.right)) {
            var rSpan = node.parentNode.getClientRects()[0];
            if (rSpan) {
              rect = { left: rSpan.left, right: rSpan.left + charWidth(cm.display), top: rSpan.top, bottom: rSpan.bottom };
            } else {
              rect = nullRect;
            }
          }
          var rtop = rect.top - prepared.rect.top, rbot = rect.bottom - prepared.rect.top;
          var mid = (rtop + rbot) / 2;
          var heights = prepared.view.measure.heights;
          var i2 = 0;
          for (; i2 < heights.length - 1; i2++) {
            if (mid < heights[i2]) {
              break;
            }
          }
          var top = i2 ? heights[i2 - 1] : 0, bot = heights[i2];
          var result = {
            left: (collapse == "right" ? rect.right : rect.left) - prepared.rect.left,
            right: (collapse == "left" ? rect.left : rect.right) - prepared.rect.left,
            top,
            bottom: bot
          };
          if (!rect.left && !rect.right) {
            result.bogus = true;
          }
          if (!cm.options.singleCursorHeightPerLine) {
            result.rtop = rtop;
            result.rbottom = rbot;
          }
          return result;
        }
        function maybeUpdateRectForZooming(measure, rect) {
          if (!window.screen || screen.logicalXDPI == null || screen.logicalXDPI == screen.deviceXDPI || !hasBadZoomedRects(measure)) {
            return rect;
          }
          var scaleX = screen.logicalXDPI / screen.deviceXDPI;
          var scaleY = screen.logicalYDPI / screen.deviceYDPI;
          return {
            left: rect.left * scaleX,
            right: rect.right * scaleX,
            top: rect.top * scaleY,
            bottom: rect.bottom * scaleY
          };
        }
        function clearLineMeasurementCacheFor(lineView) {
          if (lineView.measure) {
            lineView.measure.cache = {};
            lineView.measure.heights = null;
            if (lineView.rest) {
              for (var i2 = 0; i2 < lineView.rest.length; i2++) {
                lineView.measure.caches[i2] = {};
              }
            }
          }
        }
        function clearLineMeasurementCache(cm) {
          cm.display.externalMeasure = null;
          removeChildren(cm.display.lineMeasure);
          for (var i2 = 0; i2 < cm.display.view.length; i2++) {
            clearLineMeasurementCacheFor(cm.display.view[i2]);
          }
        }
        function clearCaches(cm) {
          clearLineMeasurementCache(cm);
          cm.display.cachedCharWidth = cm.display.cachedTextHeight = cm.display.cachedPaddingH = null;
          if (!cm.options.lineWrapping) {
            cm.display.maxLineChanged = true;
          }
          cm.display.lineNumChars = null;
        }
        function pageScrollX(doc2) {
          if (chrome && android) {
            return -(doc2.body.getBoundingClientRect().left - parseInt(getComputedStyle(doc2.body).marginLeft));
          }
          return doc2.defaultView.pageXOffset || (doc2.documentElement || doc2.body).scrollLeft;
        }
        function pageScrollY(doc2) {
          if (chrome && android) {
            return -(doc2.body.getBoundingClientRect().top - parseInt(getComputedStyle(doc2.body).marginTop));
          }
          return doc2.defaultView.pageYOffset || (doc2.documentElement || doc2.body).scrollTop;
        }
        function widgetTopHeight(lineObj) {
          var ref = visualLine(lineObj);
          var widgets = ref.widgets;
          var height = 0;
          if (widgets) {
            for (var i2 = 0; i2 < widgets.length; ++i2) {
              if (widgets[i2].above) {
                height += widgetHeight(widgets[i2]);
              }
            }
          }
          return height;
        }
        function intoCoordSystem(cm, lineObj, rect, context, includeWidgets) {
          if (!includeWidgets) {
            var height = widgetTopHeight(lineObj);
            rect.top += height;
            rect.bottom += height;
          }
          if (context == "line") {
            return rect;
          }
          if (!context) {
            context = "local";
          }
          var yOff = heightAtLine(lineObj);
          if (context == "local") {
            yOff += paddingTop(cm.display);
          } else {
            yOff -= cm.display.viewOffset;
          }
          if (context == "page" || context == "window") {
            var lOff = cm.display.lineSpace.getBoundingClientRect();
            yOff += lOff.top + (context == "window" ? 0 : pageScrollY(doc(cm)));
            var xOff = lOff.left + (context == "window" ? 0 : pageScrollX(doc(cm)));
            rect.left += xOff;
            rect.right += xOff;
          }
          rect.top += yOff;
          rect.bottom += yOff;
          return rect;
        }
        function fromCoordSystem(cm, coords, context) {
          if (context == "div") {
            return coords;
          }
          var left = coords.left, top = coords.top;
          if (context == "page") {
            left -= pageScrollX(doc(cm));
            top -= pageScrollY(doc(cm));
          } else if (context == "local" || !context) {
            var localBox = cm.display.sizer.getBoundingClientRect();
            left += localBox.left;
            top += localBox.top;
          }
          var lineSpaceBox = cm.display.lineSpace.getBoundingClientRect();
          return { left: left - lineSpaceBox.left, top: top - lineSpaceBox.top };
        }
        function charCoords(cm, pos, context, lineObj, bias) {
          if (!lineObj) {
            lineObj = getLine(cm.doc, pos.line);
          }
          return intoCoordSystem(cm, lineObj, measureChar(cm, lineObj, pos.ch, bias), context);
        }
        function cursorCoords(cm, pos, context, lineObj, preparedMeasure, varHeight) {
          lineObj = lineObj || getLine(cm.doc, pos.line);
          if (!preparedMeasure) {
            preparedMeasure = prepareMeasureForLine(cm, lineObj);
          }
          function get2(ch2, right) {
            var m2 = measureCharPrepared(cm, preparedMeasure, ch2, right ? "right" : "left", varHeight);
            if (right) {
              m2.left = m2.right;
            } else {
              m2.right = m2.left;
            }
            return intoCoordSystem(cm, lineObj, m2, context);
          }
          var order = getOrder(lineObj, cm.doc.direction), ch = pos.ch, sticky = pos.sticky;
          if (ch >= lineObj.text.length) {
            ch = lineObj.text.length;
            sticky = "before";
          } else if (ch <= 0) {
            ch = 0;
            sticky = "after";
          }
          if (!order) {
            return get2(sticky == "before" ? ch - 1 : ch, sticky == "before");
          }
          function getBidi(ch2, partPos2, invert2) {
            var part = order[partPos2], right = part.level == 1;
            return get2(invert2 ? ch2 - 1 : ch2, right != invert2);
          }
          var partPos = getBidiPartAt(order, ch, sticky);
          var other = bidiOther;
          var val = getBidi(ch, partPos, sticky == "before");
          if (other != null) {
            val.other = getBidi(ch, other, sticky != "before");
          }
          return val;
        }
        function estimateCoords(cm, pos) {
          var left = 0;
          pos = clipPos(cm.doc, pos);
          if (!cm.options.lineWrapping) {
            left = charWidth(cm.display) * pos.ch;
          }
          var lineObj = getLine(cm.doc, pos.line);
          var top = heightAtLine(lineObj) + paddingTop(cm.display);
          return { left, right: left, top, bottom: top + lineObj.height };
        }
        function PosWithInfo(line, ch, sticky, outside, xRel) {
          var pos = Pos(line, ch, sticky);
          pos.xRel = xRel;
          if (outside) {
            pos.outside = outside;
          }
          return pos;
        }
        function coordsChar(cm, x, y) {
          var doc2 = cm.doc;
          y += cm.display.viewOffset;
          if (y < 0) {
            return PosWithInfo(doc2.first, 0, null, -1, -1);
          }
          var lineN = lineAtHeight(doc2, y), last = doc2.first + doc2.size - 1;
          if (lineN > last) {
            return PosWithInfo(doc2.first + doc2.size - 1, getLine(doc2, last).text.length, null, 1, 1);
          }
          if (x < 0) {
            x = 0;
          }
          var lineObj = getLine(doc2, lineN);
          for (; ; ) {
            var found = coordsCharInner(cm, lineObj, lineN, x, y);
            var collapsed = collapsedSpanAround(lineObj, found.ch + (found.xRel > 0 || found.outside > 0 ? 1 : 0));
            if (!collapsed) {
              return found;
            }
            var rangeEnd = collapsed.find(1);
            if (rangeEnd.line == lineN) {
              return rangeEnd;
            }
            lineObj = getLine(doc2, lineN = rangeEnd.line);
          }
        }
        function wrappedLineExtent(cm, lineObj, preparedMeasure, y) {
          y -= widgetTopHeight(lineObj);
          var end2 = lineObj.text.length;
          var begin = findFirst(function(ch) {
            return measureCharPrepared(cm, preparedMeasure, ch - 1).bottom <= y;
          }, end2, 0);
          end2 = findFirst(function(ch) {
            return measureCharPrepared(cm, preparedMeasure, ch).top > y;
          }, begin, end2);
          return { begin, end: end2 };
        }
        function wrappedLineExtentChar(cm, lineObj, preparedMeasure, target) {
          if (!preparedMeasure) {
            preparedMeasure = prepareMeasureForLine(cm, lineObj);
          }
          var targetTop = intoCoordSystem(cm, lineObj, measureCharPrepared(cm, preparedMeasure, target), "line").top;
          return wrappedLineExtent(cm, lineObj, preparedMeasure, targetTop);
        }
        function boxIsAfter(box2, x, y, left) {
          return box2.bottom <= y ? false : box2.top > y ? true : (left ? box2.left : box2.right) > x;
        }
        function coordsCharInner(cm, lineObj, lineNo2, x, y) {
          y -= heightAtLine(lineObj);
          var preparedMeasure = prepareMeasureForLine(cm, lineObj);
          var widgetHeight2 = widgetTopHeight(lineObj);
          var begin = 0, end2 = lineObj.text.length, ltr = true;
          var order = getOrder(lineObj, cm.doc.direction);
          if (order) {
            var part = (cm.options.lineWrapping ? coordsBidiPartWrapped : coordsBidiPart)(cm, lineObj, lineNo2, preparedMeasure, order, x, y);
            ltr = part.level != 1;
            begin = ltr ? part.from : part.to - 1;
            end2 = ltr ? part.to : part.from - 1;
          }
          var chAround = null, boxAround = null;
          var ch = findFirst(function(ch2) {
            var box2 = measureCharPrepared(cm, preparedMeasure, ch2);
            box2.top += widgetHeight2;
            box2.bottom += widgetHeight2;
            if (!boxIsAfter(box2, x, y, false)) {
              return false;
            }
            if (box2.top <= y && box2.left <= x) {
              chAround = ch2;
              boxAround = box2;
            }
            return true;
          }, begin, end2);
          var baseX, sticky, outside = false;
          if (boxAround) {
            var atLeft = x - boxAround.left < boxAround.right - x, atStart = atLeft == ltr;
            ch = chAround + (atStart ? 0 : 1);
            sticky = atStart ? "after" : "before";
            baseX = atLeft ? boxAround.left : boxAround.right;
          } else {
            if (!ltr && (ch == end2 || ch == begin)) {
              ch++;
            }
            sticky = ch == 0 ? "after" : ch == lineObj.text.length ? "before" : measureCharPrepared(cm, preparedMeasure, ch - (ltr ? 1 : 0)).bottom + widgetHeight2 <= y == ltr ? "after" : "before";
            var coords = cursorCoords(cm, Pos(lineNo2, ch, sticky), "line", lineObj, preparedMeasure);
            baseX = coords.left;
            outside = y < coords.top ? -1 : y >= coords.bottom ? 1 : 0;
          }
          ch = skipExtendingChars(lineObj.text, ch, 1);
          return PosWithInfo(lineNo2, ch, sticky, outside, x - baseX);
        }
        function coordsBidiPart(cm, lineObj, lineNo2, preparedMeasure, order, x, y) {
          var index = findFirst(function(i2) {
            var part2 = order[i2], ltr2 = part2.level != 1;
            return boxIsAfter(cursorCoords(cm, Pos(lineNo2, ltr2 ? part2.to : part2.from, ltr2 ? "before" : "after"), "line", lineObj, preparedMeasure), x, y, true);
          }, 0, order.length - 1);
          var part = order[index];
          if (index > 0) {
            var ltr = part.level != 1;
            var start2 = cursorCoords(cm, Pos(lineNo2, ltr ? part.from : part.to, ltr ? "after" : "before"), "line", lineObj, preparedMeasure);
            if (boxIsAfter(start2, x, y, true) && start2.top > y) {
              part = order[index - 1];
            }
          }
          return part;
        }
        function coordsBidiPartWrapped(cm, lineObj, _lineNo, preparedMeasure, order, x, y) {
          var ref = wrappedLineExtent(cm, lineObj, preparedMeasure, y);
          var begin = ref.begin;
          var end2 = ref.end;
          if (/\s/.test(lineObj.text.charAt(end2 - 1))) {
            end2--;
          }
          var part = null, closestDist = null;
          for (var i2 = 0; i2 < order.length; i2++) {
            var p = order[i2];
            if (p.from >= end2 || p.to <= begin) {
              continue;
            }
            var ltr = p.level != 1;
            var endX = measureCharPrepared(cm, preparedMeasure, ltr ? Math.min(end2, p.to) - 1 : Math.max(begin, p.from)).right;
            var dist3 = endX < x ? x - endX + 1e9 : endX - x;
            if (!part || closestDist > dist3) {
              part = p;
              closestDist = dist3;
            }
          }
          if (!part) {
            part = order[order.length - 1];
          }
          if (part.from < begin) {
            part = { from: begin, to: part.to, level: part.level };
          }
          if (part.to > end2) {
            part = { from: part.from, to: end2, level: part.level };
          }
          return part;
        }
        var measureText;
        function textHeight(display) {
          if (display.cachedTextHeight != null) {
            return display.cachedTextHeight;
          }
          if (measureText == null) {
            measureText = elt("pre", null, "CodeMirror-line-like");
            for (var i2 = 0; i2 < 49; ++i2) {
              measureText.appendChild(document.createTextNode("x"));
              measureText.appendChild(elt("br"));
            }
            measureText.appendChild(document.createTextNode("x"));
          }
          removeChildrenAndAdd(display.measure, measureText);
          var height = measureText.offsetHeight / 50;
          if (height > 3) {
            display.cachedTextHeight = height;
          }
          removeChildren(display.measure);
          return height || 1;
        }
        function charWidth(display) {
          if (display.cachedCharWidth != null) {
            return display.cachedCharWidth;
          }
          var anchor = elt("span", "xxxxxxxxxx");
          var pre = elt("pre", [anchor], "CodeMirror-line-like");
          removeChildrenAndAdd(display.measure, pre);
          var rect = anchor.getBoundingClientRect(), width = (rect.right - rect.left) / 10;
          if (width > 2) {
            display.cachedCharWidth = width;
          }
          return width || 10;
        }
        function getDimensions(cm) {
          var d = cm.display, left = {}, width = {};
          var gutterLeft = d.gutters.clientLeft;
          for (var n = d.gutters.firstChild, i2 = 0; n; n = n.nextSibling, ++i2) {
            var id = cm.display.gutterSpecs[i2].className;
            left[id] = n.offsetLeft + n.clientLeft + gutterLeft;
            width[id] = n.clientWidth;
          }
          return {
            fixedPos: compensateForHScroll(d),
            gutterTotalWidth: d.gutters.offsetWidth,
            gutterLeft: left,
            gutterWidth: width,
            wrapperWidth: d.wrapper.clientWidth
          };
        }
        function compensateForHScroll(display) {
          return display.scroller.getBoundingClientRect().left - display.sizer.getBoundingClientRect().left;
        }
        function estimateHeight(cm) {
          var th = textHeight(cm.display), wrapping = cm.options.lineWrapping;
          var perLine = wrapping && Math.max(5, cm.display.scroller.clientWidth / charWidth(cm.display) - 3);
          return function(line) {
            if (lineIsHidden(cm.doc, line)) {
              return 0;
            }
            var widgetsHeight = 0;
            if (line.widgets) {
              for (var i2 = 0; i2 < line.widgets.length; i2++) {
                if (line.widgets[i2].height) {
                  widgetsHeight += line.widgets[i2].height;
                }
              }
            }
            if (wrapping) {
              return widgetsHeight + (Math.ceil(line.text.length / perLine) || 1) * th;
            } else {
              return widgetsHeight + th;
            }
          };
        }
        function estimateLineHeights(cm) {
          var doc2 = cm.doc, est = estimateHeight(cm);
          doc2.iter(function(line) {
            var estHeight = est(line);
            if (estHeight != line.height) {
              updateLineHeight(line, estHeight);
            }
          });
        }
        function posFromMouse(cm, e2, liberal, forRect) {
          var display = cm.display;
          if (!liberal && e_target(e2).getAttribute("cm-not-content") == "true") {
            return null;
          }
          var x, y, space = display.lineSpace.getBoundingClientRect();
          try {
            x = e2.clientX - space.left;
            y = e2.clientY - space.top;
          } catch (e$1) {
            return null;
          }
          var coords = coordsChar(cm, x, y), line;
          if (forRect && coords.xRel > 0 && (line = getLine(cm.doc, coords.line).text).length == coords.ch) {
            var colDiff = countColumn(line, line.length, cm.options.tabSize) - line.length;
            coords = Pos(coords.line, Math.max(0, Math.round((x - paddingH(cm.display).left) / charWidth(cm.display)) - colDiff));
          }
          return coords;
        }
        function findViewIndex(cm, n) {
          if (n >= cm.display.viewTo) {
            return null;
          }
          n -= cm.display.viewFrom;
          if (n < 0) {
            return null;
          }
          var view = cm.display.view;
          for (var i2 = 0; i2 < view.length; i2++) {
            n -= view[i2].size;
            if (n < 0) {
              return i2;
            }
          }
        }
        function regChange(cm, from, to, lendiff) {
          if (from == null) {
            from = cm.doc.first;
          }
          if (to == null) {
            to = cm.doc.first + cm.doc.size;
          }
          if (!lendiff) {
            lendiff = 0;
          }
          var display = cm.display;
          if (lendiff && to < display.viewTo && (display.updateLineNumbers == null || display.updateLineNumbers > from)) {
            display.updateLineNumbers = from;
          }
          cm.curOp.viewChanged = true;
          if (from >= display.viewTo) {
            if (sawCollapsedSpans && visualLineNo(cm.doc, from) < display.viewTo) {
              resetView(cm);
            }
          } else if (to <= display.viewFrom) {
            if (sawCollapsedSpans && visualLineEndNo(cm.doc, to + lendiff) > display.viewFrom) {
              resetView(cm);
            } else {
              display.viewFrom += lendiff;
              display.viewTo += lendiff;
            }
          } else if (from <= display.viewFrom && to >= display.viewTo) {
            resetView(cm);
          } else if (from <= display.viewFrom) {
            var cut = viewCuttingPoint(cm, to, to + lendiff, 1);
            if (cut) {
              display.view = display.view.slice(cut.index);
              display.viewFrom = cut.lineN;
              display.viewTo += lendiff;
            } else {
              resetView(cm);
            }
          } else if (to >= display.viewTo) {
            var cut$1 = viewCuttingPoint(cm, from, from, -1);
            if (cut$1) {
              display.view = display.view.slice(0, cut$1.index);
              display.viewTo = cut$1.lineN;
            } else {
              resetView(cm);
            }
          } else {
            var cutTop = viewCuttingPoint(cm, from, from, -1);
            var cutBot = viewCuttingPoint(cm, to, to + lendiff, 1);
            if (cutTop && cutBot) {
              display.view = display.view.slice(0, cutTop.index).concat(buildViewArray(cm, cutTop.lineN, cutBot.lineN)).concat(display.view.slice(cutBot.index));
              display.viewTo += lendiff;
            } else {
              resetView(cm);
            }
          }
          var ext = display.externalMeasured;
          if (ext) {
            if (to < ext.lineN) {
              ext.lineN += lendiff;
            } else if (from < ext.lineN + ext.size) {
              display.externalMeasured = null;
            }
          }
        }
        function regLineChange(cm, line, type) {
          cm.curOp.viewChanged = true;
          var display = cm.display, ext = cm.display.externalMeasured;
          if (ext && line >= ext.lineN && line < ext.lineN + ext.size) {
            display.externalMeasured = null;
          }
          if (line < display.viewFrom || line >= display.viewTo) {
            return;
          }
          var lineView = display.view[findViewIndex(cm, line)];
          if (lineView.node == null) {
            return;
          }
          var arr = lineView.changes || (lineView.changes = []);
          if (indexOf2(arr, type) == -1) {
            arr.push(type);
          }
        }
        function resetView(cm) {
          cm.display.viewFrom = cm.display.viewTo = cm.doc.first;
          cm.display.view = [];
          cm.display.viewOffset = 0;
        }
        function viewCuttingPoint(cm, oldN, newN, dir3) {
          var index = findViewIndex(cm, oldN), diff, view = cm.display.view;
          if (!sawCollapsedSpans || newN == cm.doc.first + cm.doc.size) {
            return { index, lineN: newN };
          }
          var n = cm.display.viewFrom;
          for (var i2 = 0; i2 < index; i2++) {
            n += view[i2].size;
          }
          if (n != oldN) {
            if (dir3 > 0) {
              if (index == view.length - 1) {
                return null;
              }
              diff = n + view[index].size - oldN;
              index++;
            } else {
              diff = n - oldN;
            }
            oldN += diff;
            newN += diff;
          }
          while (visualLineNo(cm.doc, newN) != newN) {
            if (index == (dir3 < 0 ? 0 : view.length - 1)) {
              return null;
            }
            newN += dir3 * view[index - (dir3 < 0 ? 1 : 0)].size;
            index += dir3;
          }
          return { index, lineN: newN };
        }
        function adjustView(cm, from, to) {
          var display = cm.display, view = display.view;
          if (view.length == 0 || from >= display.viewTo || to <= display.viewFrom) {
            display.view = buildViewArray(cm, from, to);
            display.viewFrom = from;
          } else {
            if (display.viewFrom > from) {
              display.view = buildViewArray(cm, from, display.viewFrom).concat(display.view);
            } else if (display.viewFrom < from) {
              display.view = display.view.slice(findViewIndex(cm, from));
            }
            display.viewFrom = from;
            if (display.viewTo < to) {
              display.view = display.view.concat(buildViewArray(cm, display.viewTo, to));
            } else if (display.viewTo > to) {
              display.view = display.view.slice(0, findViewIndex(cm, to));
            }
          }
          display.viewTo = to;
        }
        function countDirtyView(cm) {
          var view = cm.display.view, dirty = 0;
          for (var i2 = 0; i2 < view.length; i2++) {
            var lineView = view[i2];
            if (!lineView.hidden && (!lineView.node || lineView.changes)) {
              ++dirty;
            }
          }
          return dirty;
        }
        function updateSelection(cm) {
          cm.display.input.showSelection(cm.display.input.prepareSelection());
        }
        function prepareSelection(cm, primary) {
          if (primary === void 0)
            primary = true;
          var doc2 = cm.doc, result = {};
          var curFragment = result.cursors = document.createDocumentFragment();
          var selFragment = result.selection = document.createDocumentFragment();
          var customCursor = cm.options.$customCursor;
          if (customCursor) {
            primary = true;
          }
          for (var i2 = 0; i2 < doc2.sel.ranges.length; i2++) {
            if (!primary && i2 == doc2.sel.primIndex) {
              continue;
            }
            var range2 = doc2.sel.ranges[i2];
            if (range2.from().line >= cm.display.viewTo || range2.to().line < cm.display.viewFrom) {
              continue;
            }
            var collapsed = range2.empty();
            if (customCursor) {
              var head = customCursor(cm, range2);
              if (head) {
                drawSelectionCursor(cm, head, curFragment);
              }
            } else if (collapsed || cm.options.showCursorWhenSelecting) {
              drawSelectionCursor(cm, range2.head, curFragment);
            }
            if (!collapsed) {
              drawSelectionRange(cm, range2, selFragment);
            }
          }
          return result;
        }
        function drawSelectionCursor(cm, head, output) {
          var pos = cursorCoords(cm, head, "div", null, null, !cm.options.singleCursorHeightPerLine);
          var cursor = output.appendChild(elt("div", " ", "CodeMirror-cursor"));
          cursor.style.left = pos.left + "px";
          cursor.style.top = pos.top + "px";
          cursor.style.height = Math.max(0, pos.bottom - pos.top) * cm.options.cursorHeight + "px";
          if (/\bcm-fat-cursor\b/.test(cm.getWrapperElement().className)) {
            var charPos = charCoords(cm, head, "div", null, null);
            var width = charPos.right - charPos.left;
            cursor.style.width = (width > 0 ? width : cm.defaultCharWidth()) + "px";
          }
          if (pos.other) {
            var otherCursor = output.appendChild(elt("div", " ", "CodeMirror-cursor CodeMirror-secondarycursor"));
            otherCursor.style.display = "";
            otherCursor.style.left = pos.other.left + "px";
            otherCursor.style.top = pos.other.top + "px";
            otherCursor.style.height = (pos.other.bottom - pos.other.top) * 0.85 + "px";
          }
        }
        function cmpCoords(a, b) {
          return a.top - b.top || a.left - b.left;
        }
        function drawSelectionRange(cm, range2, output) {
          var display = cm.display, doc2 = cm.doc;
          var fragment = document.createDocumentFragment();
          var padding = paddingH(cm.display), leftSide = padding.left;
          var rightSide = Math.max(display.sizerWidth, displayWidth(cm) - display.sizer.offsetLeft) - padding.right;
          var docLTR = doc2.direction == "ltr";
          function add2(left, top, width, bottom) {
            if (top < 0) {
              top = 0;
            }
            top = Math.round(top);
            bottom = Math.round(bottom);
            fragment.appendChild(elt("div", null, "CodeMirror-selected", "position: absolute; left: " + left + "px;\n                             top: " + top + "px; width: " + (width == null ? rightSide - left : width) + "px;\n                             height: " + (bottom - top) + "px"));
          }
          function drawForLine(line, fromArg, toArg) {
            var lineObj = getLine(doc2, line);
            var lineLen = lineObj.text.length;
            var start2, end2;
            function coords(ch, bias) {
              return charCoords(cm, Pos(line, ch), "div", lineObj, bias);
            }
            function wrapX(pos, dir3, side) {
              var extent3 = wrappedLineExtentChar(cm, lineObj, null, pos);
              var prop2 = dir3 == "ltr" == (side == "after") ? "left" : "right";
              var ch = side == "after" ? extent3.begin : extent3.end - (/\s/.test(lineObj.text.charAt(extent3.end - 1)) ? 2 : 1);
              return coords(ch, prop2)[prop2];
            }
            var order = getOrder(lineObj, doc2.direction);
            iterateBidiSections(order, fromArg || 0, toArg == null ? lineLen : toArg, function(from, to, dir3, i2) {
              var ltr = dir3 == "ltr";
              var fromPos = coords(from, ltr ? "left" : "right");
              var toPos = coords(to - 1, ltr ? "right" : "left");
              var openStart = fromArg == null && from == 0, openEnd = toArg == null && to == lineLen;
              var first = i2 == 0, last = !order || i2 == order.length - 1;
              if (toPos.top - fromPos.top <= 3) {
                var openLeft = (docLTR ? openStart : openEnd) && first;
                var openRight = (docLTR ? openEnd : openStart) && last;
                var left = openLeft ? leftSide : (ltr ? fromPos : toPos).left;
                var right = openRight ? rightSide : (ltr ? toPos : fromPos).right;
                add2(left, fromPos.top, right - left, fromPos.bottom);
              } else {
                var topLeft, topRight, botLeft, botRight;
                if (ltr) {
                  topLeft = docLTR && openStart && first ? leftSide : fromPos.left;
                  topRight = docLTR ? rightSide : wrapX(from, dir3, "before");
                  botLeft = docLTR ? leftSide : wrapX(to, dir3, "after");
                  botRight = docLTR && openEnd && last ? rightSide : toPos.right;
                } else {
                  topLeft = !docLTR ? leftSide : wrapX(from, dir3, "before");
                  topRight = !docLTR && openStart && first ? rightSide : fromPos.right;
                  botLeft = !docLTR && openEnd && last ? leftSide : toPos.left;
                  botRight = !docLTR ? rightSide : wrapX(to, dir3, "after");
                }
                add2(topLeft, fromPos.top, topRight - topLeft, fromPos.bottom);
                if (fromPos.bottom < toPos.top) {
                  add2(leftSide, fromPos.bottom, null, toPos.top);
                }
                add2(botLeft, toPos.top, botRight - botLeft, toPos.bottom);
              }
              if (!start2 || cmpCoords(fromPos, start2) < 0) {
                start2 = fromPos;
              }
              if (cmpCoords(toPos, start2) < 0) {
                start2 = toPos;
              }
              if (!end2 || cmpCoords(fromPos, end2) < 0) {
                end2 = fromPos;
              }
              if (cmpCoords(toPos, end2) < 0) {
                end2 = toPos;
              }
            });
            return { start: start2, end: end2 };
          }
          var sFrom = range2.from(), sTo = range2.to();
          if (sFrom.line == sTo.line) {
            drawForLine(sFrom.line, sFrom.ch, sTo.ch);
          } else {
            var fromLine2 = getLine(doc2, sFrom.line), toLine = getLine(doc2, sTo.line);
            var singleVLine = visualLine(fromLine2) == visualLine(toLine);
            var leftEnd = drawForLine(sFrom.line, sFrom.ch, singleVLine ? fromLine2.text.length + 1 : null).end;
            var rightStart = drawForLine(sTo.line, singleVLine ? 0 : null, sTo.ch).start;
            if (singleVLine) {
              if (leftEnd.top < rightStart.top - 2) {
                add2(leftEnd.right, leftEnd.top, null, leftEnd.bottom);
                add2(leftSide, rightStart.top, rightStart.left, rightStart.bottom);
              } else {
                add2(leftEnd.right, leftEnd.top, rightStart.left - leftEnd.right, leftEnd.bottom);
              }
            }
            if (leftEnd.bottom < rightStart.top) {
              add2(leftSide, leftEnd.bottom, null, rightStart.top);
            }
          }
          output.appendChild(fragment);
        }
        function restartBlink(cm) {
          if (!cm.state.focused) {
            return;
          }
          var display = cm.display;
          clearInterval(display.blinker);
          var on2 = true;
          display.cursorDiv.style.visibility = "";
          if (cm.options.cursorBlinkRate > 0) {
            display.blinker = setInterval(function() {
              if (!cm.hasFocus()) {
                onBlur(cm);
              }
              display.cursorDiv.style.visibility = (on2 = !on2) ? "" : "hidden";
            }, cm.options.cursorBlinkRate);
          } else if (cm.options.cursorBlinkRate < 0) {
            display.cursorDiv.style.visibility = "hidden";
          }
        }
        function ensureFocus(cm) {
          if (!cm.hasFocus()) {
            cm.display.input.focus();
            if (!cm.state.focused) {
              onFocus(cm);
            }
          }
        }
        function delayBlurEvent(cm) {
          cm.state.delayingBlurEvent = true;
          setTimeout(function() {
            if (cm.state.delayingBlurEvent) {
              cm.state.delayingBlurEvent = false;
              if (cm.state.focused) {
                onBlur(cm);
              }
            }
          }, 100);
        }
        function onFocus(cm, e2) {
          if (cm.state.delayingBlurEvent && !cm.state.draggingText) {
            cm.state.delayingBlurEvent = false;
          }
          if (cm.options.readOnly == "nocursor") {
            return;
          }
          if (!cm.state.focused) {
            signal(cm, "focus", cm, e2);
            cm.state.focused = true;
            addClass(cm.display.wrapper, "CodeMirror-focused");
            if (!cm.curOp && cm.display.selForContextMenu != cm.doc.sel) {
              cm.display.input.reset();
              if (webkit) {
                setTimeout(function() {
                  return cm.display.input.reset(true);
                }, 20);
              }
            }
            cm.display.input.receivedFocus();
          }
          restartBlink(cm);
        }
        function onBlur(cm, e2) {
          if (cm.state.delayingBlurEvent) {
            return;
          }
          if (cm.state.focused) {
            signal(cm, "blur", cm, e2);
            cm.state.focused = false;
            rmClass(cm.display.wrapper, "CodeMirror-focused");
          }
          clearInterval(cm.display.blinker);
          setTimeout(function() {
            if (!cm.state.focused) {
              cm.display.shift = false;
            }
          }, 150);
        }
        function updateHeightsInViewport(cm) {
          var display = cm.display;
          var prevBottom = display.lineDiv.offsetTop;
          var viewTop = Math.max(0, display.scroller.getBoundingClientRect().top);
          var oldHeight = display.lineDiv.getBoundingClientRect().top;
          var mustScroll = 0;
          for (var i2 = 0; i2 < display.view.length; i2++) {
            var cur = display.view[i2], wrapping = cm.options.lineWrapping;
            var height = void 0, width = 0;
            if (cur.hidden) {
              continue;
            }
            oldHeight += cur.line.height;
            if (ie && ie_version < 8) {
              var bot = cur.node.offsetTop + cur.node.offsetHeight;
              height = bot - prevBottom;
              prevBottom = bot;
            } else {
              var box2 = cur.node.getBoundingClientRect();
              height = box2.bottom - box2.top;
              if (!wrapping && cur.text.firstChild) {
                width = cur.text.firstChild.getBoundingClientRect().right - box2.left - 1;
              }
            }
            var diff = cur.line.height - height;
            if (diff > 5e-3 || diff < -5e-3) {
              if (oldHeight < viewTop) {
                mustScroll -= diff;
              }
              updateLineHeight(cur.line, height);
              updateWidgetHeight(cur.line);
              if (cur.rest) {
                for (var j = 0; j < cur.rest.length; j++) {
                  updateWidgetHeight(cur.rest[j]);
                }
              }
            }
            if (width > cm.display.sizerWidth) {
              var chWidth = Math.ceil(width / charWidth(cm.display));
              if (chWidth > cm.display.maxLineLength) {
                cm.display.maxLineLength = chWidth;
                cm.display.maxLine = cur.line;
                cm.display.maxLineChanged = true;
              }
            }
          }
          if (Math.abs(mustScroll) > 2) {
            display.scroller.scrollTop += mustScroll;
          }
        }
        function updateWidgetHeight(line) {
          if (line.widgets) {
            for (var i2 = 0; i2 < line.widgets.length; ++i2) {
              var w = line.widgets[i2], parent = w.node.parentNode;
              if (parent) {
                w.height = parent.offsetHeight;
              }
            }
          }
        }
        function visibleLines(display, doc2, viewport) {
          var top = viewport && viewport.top != null ? Math.max(0, viewport.top) : display.scroller.scrollTop;
          top = Math.floor(top - paddingTop(display));
          var bottom = viewport && viewport.bottom != null ? viewport.bottom : top + display.wrapper.clientHeight;
          var from = lineAtHeight(doc2, top), to = lineAtHeight(doc2, bottom);
          if (viewport && viewport.ensure) {
            var ensureFrom = viewport.ensure.from.line, ensureTo = viewport.ensure.to.line;
            if (ensureFrom < from) {
              from = ensureFrom;
              to = lineAtHeight(doc2, heightAtLine(getLine(doc2, ensureFrom)) + display.wrapper.clientHeight);
            } else if (Math.min(ensureTo, doc2.lastLine()) >= to) {
              from = lineAtHeight(doc2, heightAtLine(getLine(doc2, ensureTo)) - display.wrapper.clientHeight);
              to = ensureTo;
            }
          }
          return { from, to: Math.max(to, from + 1) };
        }
        function maybeScrollWindow(cm, rect) {
          if (signalDOMEvent(cm, "scrollCursorIntoView")) {
            return;
          }
          var display = cm.display, box2 = display.sizer.getBoundingClientRect(), doScroll = null;
          var doc2 = display.wrapper.ownerDocument;
          if (rect.top + box2.top < 0) {
            doScroll = true;
          } else if (rect.bottom + box2.top > (doc2.defaultView.innerHeight || doc2.documentElement.clientHeight)) {
            doScroll = false;
          }
          if (doScroll != null && !phantom) {
            var scrollNode = elt("div", "​", null, "position: absolute;\n                         top: " + (rect.top - display.viewOffset - paddingTop(cm.display)) + "px;\n                         height: " + (rect.bottom - rect.top + scrollGap(cm) + display.barHeight) + "px;\n                         left: " + rect.left + "px; width: " + Math.max(2, rect.right - rect.left) + "px;");
            cm.display.lineSpace.appendChild(scrollNode);
            scrollNode.scrollIntoView(doScroll);
            cm.display.lineSpace.removeChild(scrollNode);
          }
        }
        function scrollPosIntoView(cm, pos, end2, margin) {
          if (margin == null) {
            margin = 0;
          }
          var rect;
          if (!cm.options.lineWrapping && pos == end2) {
            end2 = pos.sticky == "before" ? Pos(pos.line, pos.ch + 1, "before") : pos;
            pos = pos.ch ? Pos(pos.line, pos.sticky == "before" ? pos.ch - 1 : pos.ch, "after") : pos;
          }
          for (var limit = 0; limit < 5; limit++) {
            var changed = false;
            var coords = cursorCoords(cm, pos);
            var endCoords = !end2 || end2 == pos ? coords : cursorCoords(cm, end2);
            rect = {
              left: Math.min(coords.left, endCoords.left),
              top: Math.min(coords.top, endCoords.top) - margin,
              right: Math.max(coords.left, endCoords.left),
              bottom: Math.max(coords.bottom, endCoords.bottom) + margin
            };
            var scrollPos = calculateScrollPos(cm, rect);
            var startTop = cm.doc.scrollTop, startLeft = cm.doc.scrollLeft;
            if (scrollPos.scrollTop != null) {
              updateScrollTop(cm, scrollPos.scrollTop);
              if (Math.abs(cm.doc.scrollTop - startTop) > 1) {
                changed = true;
              }
            }
            if (scrollPos.scrollLeft != null) {
              setScrollLeft(cm, scrollPos.scrollLeft);
              if (Math.abs(cm.doc.scrollLeft - startLeft) > 1) {
                changed = true;
              }
            }
            if (!changed) {
              break;
            }
          }
          return rect;
        }
        function scrollIntoView(cm, rect) {
          var scrollPos = calculateScrollPos(cm, rect);
          if (scrollPos.scrollTop != null) {
            updateScrollTop(cm, scrollPos.scrollTop);
          }
          if (scrollPos.scrollLeft != null) {
            setScrollLeft(cm, scrollPos.scrollLeft);
          }
        }
        function calculateScrollPos(cm, rect) {
          var display = cm.display, snapMargin = textHeight(cm.display);
          if (rect.top < 0) {
            rect.top = 0;
          }
          var screentop = cm.curOp && cm.curOp.scrollTop != null ? cm.curOp.scrollTop : display.scroller.scrollTop;
          var screen2 = displayHeight(cm), result = {};
          if (rect.bottom - rect.top > screen2) {
            rect.bottom = rect.top + screen2;
          }
          var docBottom = cm.doc.height + paddingVert(display);
          var atTop = rect.top < snapMargin, atBottom = rect.bottom > docBottom - snapMargin;
          if (rect.top < screentop) {
            result.scrollTop = atTop ? 0 : rect.top;
          } else if (rect.bottom > screentop + screen2) {
            var newTop = Math.min(rect.top, (atBottom ? docBottom : rect.bottom) - screen2);
            if (newTop != screentop) {
              result.scrollTop = newTop;
            }
          }
          var gutterSpace = cm.options.fixedGutter ? 0 : display.gutters.offsetWidth;
          var screenleft = cm.curOp && cm.curOp.scrollLeft != null ? cm.curOp.scrollLeft : display.scroller.scrollLeft - gutterSpace;
          var screenw = displayWidth(cm) - display.gutters.offsetWidth;
          var tooWide = rect.right - rect.left > screenw;
          if (tooWide) {
            rect.right = rect.left + screenw;
          }
          if (rect.left < 10) {
            result.scrollLeft = 0;
          } else if (rect.left < screenleft) {
            result.scrollLeft = Math.max(0, rect.left + gutterSpace - (tooWide ? 0 : 10));
          } else if (rect.right > screenw + screenleft - 3) {
            result.scrollLeft = rect.right + (tooWide ? 0 : 10) - screenw;
          }
          return result;
        }
        function addToScrollTop(cm, top) {
          if (top == null) {
            return;
          }
          resolveScrollToPos(cm);
          cm.curOp.scrollTop = (cm.curOp.scrollTop == null ? cm.doc.scrollTop : cm.curOp.scrollTop) + top;
        }
        function ensureCursorVisible(cm) {
          resolveScrollToPos(cm);
          var cur = cm.getCursor();
          cm.curOp.scrollToPos = { from: cur, to: cur, margin: cm.options.cursorScrollMargin };
        }
        function scrollToCoords(cm, x, y) {
          if (x != null || y != null) {
            resolveScrollToPos(cm);
          }
          if (x != null) {
            cm.curOp.scrollLeft = x;
          }
          if (y != null) {
            cm.curOp.scrollTop = y;
          }
        }
        function scrollToRange(cm, range2) {
          resolveScrollToPos(cm);
          cm.curOp.scrollToPos = range2;
        }
        function resolveScrollToPos(cm) {
          var range2 = cm.curOp.scrollToPos;
          if (range2) {
            cm.curOp.scrollToPos = null;
            var from = estimateCoords(cm, range2.from), to = estimateCoords(cm, range2.to);
            scrollToCoordsRange(cm, from, to, range2.margin);
          }
        }
        function scrollToCoordsRange(cm, from, to, margin) {
          var sPos = calculateScrollPos(cm, {
            left: Math.min(from.left, to.left),
            top: Math.min(from.top, to.top) - margin,
            right: Math.max(from.right, to.right),
            bottom: Math.max(from.bottom, to.bottom) + margin
          });
          scrollToCoords(cm, sPos.scrollLeft, sPos.scrollTop);
        }
        function updateScrollTop(cm, val) {
          if (Math.abs(cm.doc.scrollTop - val) < 2) {
            return;
          }
          if (!gecko) {
            updateDisplaySimple(cm, { top: val });
          }
          setScrollTop(cm, val, true);
          if (gecko) {
            updateDisplaySimple(cm);
          }
          startWorker(cm, 100);
        }
        function setScrollTop(cm, val, forceScroll) {
          val = Math.max(0, Math.min(cm.display.scroller.scrollHeight - cm.display.scroller.clientHeight, val));
          if (cm.display.scroller.scrollTop == val && !forceScroll) {
            return;
          }
          cm.doc.scrollTop = val;
          cm.display.scrollbars.setScrollTop(val);
          if (cm.display.scroller.scrollTop != val) {
            cm.display.scroller.scrollTop = val;
          }
        }
        function setScrollLeft(cm, val, isScroller, forceScroll) {
          val = Math.max(0, Math.min(val, cm.display.scroller.scrollWidth - cm.display.scroller.clientWidth));
          if ((isScroller ? val == cm.doc.scrollLeft : Math.abs(cm.doc.scrollLeft - val) < 2) && !forceScroll) {
            return;
          }
          cm.doc.scrollLeft = val;
          alignHorizontally(cm);
          if (cm.display.scroller.scrollLeft != val) {
            cm.display.scroller.scrollLeft = val;
          }
          cm.display.scrollbars.setScrollLeft(val);
        }
        function measureForScrollbars(cm) {
          var d = cm.display, gutterW = d.gutters.offsetWidth;
          var docH = Math.round(cm.doc.height + paddingVert(cm.display));
          return {
            clientHeight: d.scroller.clientHeight,
            viewHeight: d.wrapper.clientHeight,
            scrollWidth: d.scroller.scrollWidth,
            clientWidth: d.scroller.clientWidth,
            viewWidth: d.wrapper.clientWidth,
            barLeft: cm.options.fixedGutter ? gutterW : 0,
            docHeight: docH,
            scrollHeight: docH + scrollGap(cm) + d.barHeight,
            nativeBarWidth: d.nativeBarWidth,
            gutterWidth: gutterW
          };
        }
        var NativeScrollbars = function(place, scroll, cm) {
          this.cm = cm;
          var vert = this.vert = elt("div", [elt("div", null, null, "min-width: 1px")], "CodeMirror-vscrollbar");
          var horiz = this.horiz = elt("div", [elt("div", null, null, "height: 100%; min-height: 1px")], "CodeMirror-hscrollbar");
          vert.tabIndex = horiz.tabIndex = -1;
          place(vert);
          place(horiz);
          on(vert, "scroll", function() {
            if (vert.clientHeight) {
              scroll(vert.scrollTop, "vertical");
            }
          });
          on(horiz, "scroll", function() {
            if (horiz.clientWidth) {
              scroll(horiz.scrollLeft, "horizontal");
            }
          });
          this.checkedZeroWidth = false;
          if (ie && ie_version < 8) {
            this.horiz.style.minHeight = this.vert.style.minWidth = "18px";
          }
        };
        NativeScrollbars.prototype.update = function(measure) {
          var needsH = measure.scrollWidth > measure.clientWidth + 1;
          var needsV = measure.scrollHeight > measure.clientHeight + 1;
          var sWidth = measure.nativeBarWidth;
          if (needsV) {
            this.vert.style.display = "block";
            this.vert.style.bottom = needsH ? sWidth + "px" : "0";
            var totalHeight = measure.viewHeight - (needsH ? sWidth : 0);
            this.vert.firstChild.style.height = Math.max(0, measure.scrollHeight - measure.clientHeight + totalHeight) + "px";
          } else {
            this.vert.scrollTop = 0;
            this.vert.style.display = "";
            this.vert.firstChild.style.height = "0";
          }
          if (needsH) {
            this.horiz.style.display = "block";
            this.horiz.style.right = needsV ? sWidth + "px" : "0";
            this.horiz.style.left = measure.barLeft + "px";
            var totalWidth = measure.viewWidth - measure.barLeft - (needsV ? sWidth : 0);
            this.horiz.firstChild.style.width = Math.max(0, measure.scrollWidth - measure.clientWidth + totalWidth) + "px";
          } else {
            this.horiz.style.display = "";
            this.horiz.firstChild.style.width = "0";
          }
          if (!this.checkedZeroWidth && measure.clientHeight > 0) {
            if (sWidth == 0) {
              this.zeroWidthHack();
            }
            this.checkedZeroWidth = true;
          }
          return { right: needsV ? sWidth : 0, bottom: needsH ? sWidth : 0 };
        };
        NativeScrollbars.prototype.setScrollLeft = function(pos) {
          if (this.horiz.scrollLeft != pos) {
            this.horiz.scrollLeft = pos;
          }
          if (this.disableHoriz) {
            this.enableZeroWidthBar(this.horiz, this.disableHoriz, "horiz");
          }
        };
        NativeScrollbars.prototype.setScrollTop = function(pos) {
          if (this.vert.scrollTop != pos) {
            this.vert.scrollTop = pos;
          }
          if (this.disableVert) {
            this.enableZeroWidthBar(this.vert, this.disableVert, "vert");
          }
        };
        NativeScrollbars.prototype.zeroWidthHack = function() {
          var w = mac && !mac_geMountainLion ? "12px" : "18px";
          this.horiz.style.height = this.vert.style.width = w;
          this.horiz.style.visibility = this.vert.style.visibility = "hidden";
          this.disableHoriz = new Delayed();
          this.disableVert = new Delayed();
        };
        NativeScrollbars.prototype.enableZeroWidthBar = function(bar, delay, type) {
          bar.style.visibility = "";
          function maybeDisable() {
            var box2 = bar.getBoundingClientRect();
            var elt2 = type == "vert" ? document.elementFromPoint(box2.right - 1, (box2.top + box2.bottom) / 2) : document.elementFromPoint((box2.right + box2.left) / 2, box2.bottom - 1);
            if (elt2 != bar) {
              bar.style.visibility = "hidden";
            } else {
              delay.set(1e3, maybeDisable);
            }
          }
          delay.set(1e3, maybeDisable);
        };
        NativeScrollbars.prototype.clear = function() {
          var parent = this.horiz.parentNode;
          parent.removeChild(this.horiz);
          parent.removeChild(this.vert);
        };
        var NullScrollbars = function() {
        };
        NullScrollbars.prototype.update = function() {
          return { bottom: 0, right: 0 };
        };
        NullScrollbars.prototype.setScrollLeft = function() {
        };
        NullScrollbars.prototype.setScrollTop = function() {
        };
        NullScrollbars.prototype.clear = function() {
        };
        function updateScrollbars(cm, measure) {
          if (!measure) {
            measure = measureForScrollbars(cm);
          }
          var startWidth = cm.display.barWidth, startHeight = cm.display.barHeight;
          updateScrollbarsInner(cm, measure);
          for (var i2 = 0; i2 < 4 && startWidth != cm.display.barWidth || startHeight != cm.display.barHeight; i2++) {
            if (startWidth != cm.display.barWidth && cm.options.lineWrapping) {
              updateHeightsInViewport(cm);
            }
            updateScrollbarsInner(cm, measureForScrollbars(cm));
            startWidth = cm.display.barWidth;
            startHeight = cm.display.barHeight;
          }
        }
        function updateScrollbarsInner(cm, measure) {
          var d = cm.display;
          var sizes = d.scrollbars.update(measure);
          d.sizer.style.paddingRight = (d.barWidth = sizes.right) + "px";
          d.sizer.style.paddingBottom = (d.barHeight = sizes.bottom) + "px";
          d.heightForcer.style.borderBottom = sizes.bottom + "px solid transparent";
          if (sizes.right && sizes.bottom) {
            d.scrollbarFiller.style.display = "block";
            d.scrollbarFiller.style.height = sizes.bottom + "px";
            d.scrollbarFiller.style.width = sizes.right + "px";
          } else {
            d.scrollbarFiller.style.display = "";
          }
          if (sizes.bottom && cm.options.coverGutterNextToScrollbar && cm.options.fixedGutter) {
            d.gutterFiller.style.display = "block";
            d.gutterFiller.style.height = sizes.bottom + "px";
            d.gutterFiller.style.width = measure.gutterWidth + "px";
          } else {
            d.gutterFiller.style.display = "";
          }
        }
        var scrollbarModel = { "native": NativeScrollbars, "null": NullScrollbars };
        function initScrollbars(cm) {
          if (cm.display.scrollbars) {
            cm.display.scrollbars.clear();
            if (cm.display.scrollbars.addClass) {
              rmClass(cm.display.wrapper, cm.display.scrollbars.addClass);
            }
          }
          cm.display.scrollbars = new scrollbarModel[cm.options.scrollbarStyle](function(node) {
            cm.display.wrapper.insertBefore(node, cm.display.scrollbarFiller);
            on(node, "mousedown", function() {
              if (cm.state.focused) {
                setTimeout(function() {
                  return cm.display.input.focus();
                }, 0);
              }
            });
            node.setAttribute("cm-not-content", "true");
          }, function(pos, axis) {
            if (axis == "horizontal") {
              setScrollLeft(cm, pos);
            } else {
              updateScrollTop(cm, pos);
            }
          }, cm);
          if (cm.display.scrollbars.addClass) {
            addClass(cm.display.wrapper, cm.display.scrollbars.addClass);
          }
        }
        var nextOpId = 0;
        function startOperation(cm) {
          cm.curOp = {
            cm,
            viewChanged: false,
            startHeight: cm.doc.height,
            forceUpdate: false,
            updateInput: 0,
            typing: false,
            changeObjs: null,
            cursorActivityHandlers: null,
            cursorActivityCalled: 0,
            selectionChanged: false,
            updateMaxLine: false,
            scrollLeft: null,
            scrollTop: null,
            scrollToPos: null,
            focus: false,
            id: ++nextOpId,
            markArrays: null
          };
          pushOperation(cm.curOp);
        }
        function endOperation(cm) {
          var op = cm.curOp;
          if (op) {
            finishOperation(op, function(group) {
              for (var i2 = 0; i2 < group.ops.length; i2++) {
                group.ops[i2].cm.curOp = null;
              }
              endOperations(group);
            });
          }
        }
        function endOperations(group) {
          var ops = group.ops;
          for (var i2 = 0; i2 < ops.length; i2++) {
            endOperation_R1(ops[i2]);
          }
          for (var i$12 = 0; i$12 < ops.length; i$12++) {
            endOperation_W1(ops[i$12]);
          }
          for (var i$22 = 0; i$22 < ops.length; i$22++) {
            endOperation_R2(ops[i$22]);
          }
          for (var i$3 = 0; i$3 < ops.length; i$3++) {
            endOperation_W2(ops[i$3]);
          }
          for (var i$4 = 0; i$4 < ops.length; i$4++) {
            endOperation_finish(ops[i$4]);
          }
        }
        function endOperation_R1(op) {
          var cm = op.cm, display = cm.display;
          maybeClipScrollbars(cm);
          if (op.updateMaxLine) {
            findMaxLine(cm);
          }
          op.mustUpdate = op.viewChanged || op.forceUpdate || op.scrollTop != null || op.scrollToPos && (op.scrollToPos.from.line < display.viewFrom || op.scrollToPos.to.line >= display.viewTo) || display.maxLineChanged && cm.options.lineWrapping;
          op.update = op.mustUpdate && new DisplayUpdate(cm, op.mustUpdate && { top: op.scrollTop, ensure: op.scrollToPos }, op.forceUpdate);
        }
        function endOperation_W1(op) {
          op.updatedDisplay = op.mustUpdate && updateDisplayIfNeeded(op.cm, op.update);
        }
        function endOperation_R2(op) {
          var cm = op.cm, display = cm.display;
          if (op.updatedDisplay) {
            updateHeightsInViewport(cm);
          }
          op.barMeasure = measureForScrollbars(cm);
          if (display.maxLineChanged && !cm.options.lineWrapping) {
            op.adjustWidthTo = measureChar(cm, display.maxLine, display.maxLine.text.length).left + 3;
            cm.display.sizerWidth = op.adjustWidthTo;
            op.barMeasure.scrollWidth = Math.max(display.scroller.clientWidth, display.sizer.offsetLeft + op.adjustWidthTo + scrollGap(cm) + cm.display.barWidth);
            op.maxScrollLeft = Math.max(0, display.sizer.offsetLeft + op.adjustWidthTo - displayWidth(cm));
          }
          if (op.updatedDisplay || op.selectionChanged) {
            op.preparedSelection = display.input.prepareSelection();
          }
        }
        function endOperation_W2(op) {
          var cm = op.cm;
          if (op.adjustWidthTo != null) {
            cm.display.sizer.style.minWidth = op.adjustWidthTo + "px";
            if (op.maxScrollLeft < cm.doc.scrollLeft) {
              setScrollLeft(cm, Math.min(cm.display.scroller.scrollLeft, op.maxScrollLeft), true);
            }
            cm.display.maxLineChanged = false;
          }
          var takeFocus = op.focus && op.focus == activeElt(doc(cm));
          if (op.preparedSelection) {
            cm.display.input.showSelection(op.preparedSelection, takeFocus);
          }
          if (op.updatedDisplay || op.startHeight != cm.doc.height) {
            updateScrollbars(cm, op.barMeasure);
          }
          if (op.updatedDisplay) {
            setDocumentHeight(cm, op.barMeasure);
          }
          if (op.selectionChanged) {
            restartBlink(cm);
          }
          if (cm.state.focused && op.updateInput) {
            cm.display.input.reset(op.typing);
          }
          if (takeFocus) {
            ensureFocus(op.cm);
          }
        }
        function endOperation_finish(op) {
          var cm = op.cm, display = cm.display, doc2 = cm.doc;
          if (op.updatedDisplay) {
            postUpdateDisplay(cm, op.update);
          }
          if (display.wheelStartX != null && (op.scrollTop != null || op.scrollLeft != null || op.scrollToPos)) {
            display.wheelStartX = display.wheelStartY = null;
          }
          if (op.scrollTop != null) {
            setScrollTop(cm, op.scrollTop, op.forceScroll);
          }
          if (op.scrollLeft != null) {
            setScrollLeft(cm, op.scrollLeft, true, true);
          }
          if (op.scrollToPos) {
            var rect = scrollPosIntoView(cm, clipPos(doc2, op.scrollToPos.from), clipPos(doc2, op.scrollToPos.to), op.scrollToPos.margin);
            maybeScrollWindow(cm, rect);
          }
          var hidden = op.maybeHiddenMarkers, unhidden = op.maybeUnhiddenMarkers;
          if (hidden) {
            for (var i2 = 0; i2 < hidden.length; ++i2) {
              if (!hidden[i2].lines.length) {
                signal(hidden[i2], "hide");
              }
            }
          }
          if (unhidden) {
            for (var i$12 = 0; i$12 < unhidden.length; ++i$12) {
              if (unhidden[i$12].lines.length) {
                signal(unhidden[i$12], "unhide");
              }
            }
          }
          if (display.wrapper.offsetHeight) {
            doc2.scrollTop = cm.display.scroller.scrollTop;
          }
          if (op.changeObjs) {
            signal(cm, "changes", cm, op.changeObjs);
          }
          if (op.update) {
            op.update.finish();
          }
        }
        function runInOp(cm, f) {
          if (cm.curOp) {
            return f();
          }
          startOperation(cm);
          try {
            return f();
          } finally {
            endOperation(cm);
          }
        }
        function operation(cm, f) {
          return function() {
            if (cm.curOp) {
              return f.apply(cm, arguments);
            }
            startOperation(cm);
            try {
              return f.apply(cm, arguments);
            } finally {
              endOperation(cm);
            }
          };
        }
        function methodOp(f) {
          return function() {
            if (this.curOp) {
              return f.apply(this, arguments);
            }
            startOperation(this);
            try {
              return f.apply(this, arguments);
            } finally {
              endOperation(this);
            }
          };
        }
        function docMethodOp(f) {
          return function() {
            var cm = this.cm;
            if (!cm || cm.curOp) {
              return f.apply(this, arguments);
            }
            startOperation(cm);
            try {
              return f.apply(this, arguments);
            } finally {
              endOperation(cm);
            }
          };
        }
        function startWorker(cm, time) {
          if (cm.doc.highlightFrontier < cm.display.viewTo) {
            cm.state.highlight.set(time, bind3(highlightWorker, cm));
          }
        }
        function highlightWorker(cm) {
          var doc2 = cm.doc;
          if (doc2.highlightFrontier >= cm.display.viewTo) {
            return;
          }
          var end2 = +new Date() + cm.options.workTime;
          var context = getContextBefore(cm, doc2.highlightFrontier);
          var changedLines = [];
          doc2.iter(context.line, Math.min(doc2.first + doc2.size, cm.display.viewTo + 500), function(line) {
            if (context.line >= cm.display.viewFrom) {
              var oldStyles = line.styles;
              var resetState = line.text.length > cm.options.maxHighlightLength ? copyState(doc2.mode, context.state) : null;
              var highlighted = highlightLine(cm, line, context, true);
              if (resetState) {
                context.state = resetState;
              }
              line.styles = highlighted.styles;
              var oldCls = line.styleClasses, newCls = highlighted.classes;
              if (newCls) {
                line.styleClasses = newCls;
              } else if (oldCls) {
                line.styleClasses = null;
              }
              var ischange = !oldStyles || oldStyles.length != line.styles.length || oldCls != newCls && (!oldCls || !newCls || oldCls.bgClass != newCls.bgClass || oldCls.textClass != newCls.textClass);
              for (var i2 = 0; !ischange && i2 < oldStyles.length; ++i2) {
                ischange = oldStyles[i2] != line.styles[i2];
              }
              if (ischange) {
                changedLines.push(context.line);
              }
              line.stateAfter = context.save();
              context.nextLine();
            } else {
              if (line.text.length <= cm.options.maxHighlightLength) {
                processLine(cm, line.text, context);
              }
              line.stateAfter = context.line % 5 == 0 ? context.save() : null;
              context.nextLine();
            }
            if (+new Date() > end2) {
              startWorker(cm, cm.options.workDelay);
              return true;
            }
          });
          doc2.highlightFrontier = context.line;
          doc2.modeFrontier = Math.max(doc2.modeFrontier, context.line);
          if (changedLines.length) {
            runInOp(cm, function() {
              for (var i2 = 0; i2 < changedLines.length; i2++) {
                regLineChange(cm, changedLines[i2], "text");
              }
            });
          }
        }
        var DisplayUpdate = function(cm, viewport, force) {
          var display = cm.display;
          this.viewport = viewport;
          this.visible = visibleLines(display, cm.doc, viewport);
          this.editorIsHidden = !display.wrapper.offsetWidth;
          this.wrapperHeight = display.wrapper.clientHeight;
          this.wrapperWidth = display.wrapper.clientWidth;
          this.oldDisplayWidth = displayWidth(cm);
          this.force = force;
          this.dims = getDimensions(cm);
          this.events = [];
        };
        DisplayUpdate.prototype.signal = function(emitter, type) {
          if (hasHandler(emitter, type)) {
            this.events.push(arguments);
          }
        };
        DisplayUpdate.prototype.finish = function() {
          for (var i2 = 0; i2 < this.events.length; i2++) {
            signal.apply(null, this.events[i2]);
          }
        };
        function maybeClipScrollbars(cm) {
          var display = cm.display;
          if (!display.scrollbarsClipped && display.scroller.offsetWidth) {
            display.nativeBarWidth = display.scroller.offsetWidth - display.scroller.clientWidth;
            display.heightForcer.style.height = scrollGap(cm) + "px";
            display.sizer.style.marginBottom = -display.nativeBarWidth + "px";
            display.sizer.style.borderRightWidth = scrollGap(cm) + "px";
            display.scrollbarsClipped = true;
          }
        }
        function selectionSnapshot(cm) {
          if (cm.hasFocus()) {
            return null;
          }
          var active = activeElt(doc(cm));
          if (!active || !contains(cm.display.lineDiv, active)) {
            return null;
          }
          var result = { activeElt: active };
          if (window.getSelection) {
            var sel = win(cm).getSelection();
            if (sel.anchorNode && sel.extend && contains(cm.display.lineDiv, sel.anchorNode)) {
              result.anchorNode = sel.anchorNode;
              result.anchorOffset = sel.anchorOffset;
              result.focusNode = sel.focusNode;
              result.focusOffset = sel.focusOffset;
            }
          }
          return result;
        }
        function restoreSelection(snapshot) {
          if (!snapshot || !snapshot.activeElt || snapshot.activeElt == activeElt(snapshot.activeElt.ownerDocument)) {
            return;
          }
          snapshot.activeElt.focus();
          if (!/^(INPUT|TEXTAREA)$/.test(snapshot.activeElt.nodeName) && snapshot.anchorNode && contains(document.body, snapshot.anchorNode) && contains(document.body, snapshot.focusNode)) {
            var doc2 = snapshot.activeElt.ownerDocument;
            var sel = doc2.defaultView.getSelection(), range2 = doc2.createRange();
            range2.setEnd(snapshot.anchorNode, snapshot.anchorOffset);
            range2.collapse(false);
            sel.removeAllRanges();
            sel.addRange(range2);
            sel.extend(snapshot.focusNode, snapshot.focusOffset);
          }
        }
        function updateDisplayIfNeeded(cm, update) {
          var display = cm.display, doc2 = cm.doc;
          if (update.editorIsHidden) {
            resetView(cm);
            return false;
          }
          if (!update.force && update.visible.from >= display.viewFrom && update.visible.to <= display.viewTo && (display.updateLineNumbers == null || display.updateLineNumbers >= display.viewTo) && display.renderedView == display.view && countDirtyView(cm) == 0) {
            return false;
          }
          if (maybeUpdateLineNumberWidth(cm)) {
            resetView(cm);
            update.dims = getDimensions(cm);
          }
          var end2 = doc2.first + doc2.size;
          var from = Math.max(update.visible.from - cm.options.viewportMargin, doc2.first);
          var to = Math.min(end2, update.visible.to + cm.options.viewportMargin);
          if (display.viewFrom < from && from - display.viewFrom < 20) {
            from = Math.max(doc2.first, display.viewFrom);
          }
          if (display.viewTo > to && display.viewTo - to < 20) {
            to = Math.min(end2, display.viewTo);
          }
          if (sawCollapsedSpans) {
            from = visualLineNo(cm.doc, from);
            to = visualLineEndNo(cm.doc, to);
          }
          var different = from != display.viewFrom || to != display.viewTo || display.lastWrapHeight != update.wrapperHeight || display.lastWrapWidth != update.wrapperWidth;
          adjustView(cm, from, to);
          display.viewOffset = heightAtLine(getLine(cm.doc, display.viewFrom));
          cm.display.mover.style.top = display.viewOffset + "px";
          var toUpdate = countDirtyView(cm);
          if (!different && toUpdate == 0 && !update.force && display.renderedView == display.view && (display.updateLineNumbers == null || display.updateLineNumbers >= display.viewTo)) {
            return false;
          }
          var selSnapshot = selectionSnapshot(cm);
          if (toUpdate > 4) {
            display.lineDiv.style.display = "none";
          }
          patchDisplay(cm, display.updateLineNumbers, update.dims);
          if (toUpdate > 4) {
            display.lineDiv.style.display = "";
          }
          display.renderedView = display.view;
          restoreSelection(selSnapshot);
          removeChildren(display.cursorDiv);
          removeChildren(display.selectionDiv);
          display.gutters.style.height = display.sizer.style.minHeight = 0;
          if (different) {
            display.lastWrapHeight = update.wrapperHeight;
            display.lastWrapWidth = update.wrapperWidth;
            startWorker(cm, 400);
          }
          display.updateLineNumbers = null;
          return true;
        }
        function postUpdateDisplay(cm, update) {
          var viewport = update.viewport;
          for (var first = true; ; first = false) {
            if (!first || !cm.options.lineWrapping || update.oldDisplayWidth == displayWidth(cm)) {
              if (viewport && viewport.top != null) {
                viewport = { top: Math.min(cm.doc.height + paddingVert(cm.display) - displayHeight(cm), viewport.top) };
              }
              update.visible = visibleLines(cm.display, cm.doc, viewport);
              if (update.visible.from >= cm.display.viewFrom && update.visible.to <= cm.display.viewTo) {
                break;
              }
            } else if (first) {
              update.visible = visibleLines(cm.display, cm.doc, viewport);
            }
            if (!updateDisplayIfNeeded(cm, update)) {
              break;
            }
            updateHeightsInViewport(cm);
            var barMeasure = measureForScrollbars(cm);
            updateSelection(cm);
            updateScrollbars(cm, barMeasure);
            setDocumentHeight(cm, barMeasure);
            update.force = false;
          }
          update.signal(cm, "update", cm);
          if (cm.display.viewFrom != cm.display.reportedViewFrom || cm.display.viewTo != cm.display.reportedViewTo) {
            update.signal(cm, "viewportChange", cm, cm.display.viewFrom, cm.display.viewTo);
            cm.display.reportedViewFrom = cm.display.viewFrom;
            cm.display.reportedViewTo = cm.display.viewTo;
          }
        }
        function updateDisplaySimple(cm, viewport) {
          var update = new DisplayUpdate(cm, viewport);
          if (updateDisplayIfNeeded(cm, update)) {
            updateHeightsInViewport(cm);
            postUpdateDisplay(cm, update);
            var barMeasure = measureForScrollbars(cm);
            updateSelection(cm);
            updateScrollbars(cm, barMeasure);
            setDocumentHeight(cm, barMeasure);
            update.finish();
          }
        }
        function patchDisplay(cm, updateNumbersFrom, dims) {
          var display = cm.display, lineNumbers = cm.options.lineNumbers;
          var container = display.lineDiv, cur = container.firstChild;
          function rm(node2) {
            var next = node2.nextSibling;
            if (webkit && mac && cm.display.currentWheelTarget == node2) {
              node2.style.display = "none";
            } else {
              node2.parentNode.removeChild(node2);
            }
            return next;
          }
          var view = display.view, lineN = display.viewFrom;
          for (var i2 = 0; i2 < view.length; i2++) {
            var lineView = view[i2];
            if (lineView.hidden)
              ;
            else if (!lineView.node || lineView.node.parentNode != container) {
              var node = buildLineElement(cm, lineView, lineN, dims);
              container.insertBefore(node, cur);
            } else {
              while (cur != lineView.node) {
                cur = rm(cur);
              }
              var updateNumber = lineNumbers && updateNumbersFrom != null && updateNumbersFrom <= lineN && lineView.lineNumber;
              if (lineView.changes) {
                if (indexOf2(lineView.changes, "gutter") > -1) {
                  updateNumber = false;
                }
                updateLineForChanges(cm, lineView, lineN, dims);
              }
              if (updateNumber) {
                removeChildren(lineView.lineNumber);
                lineView.lineNumber.appendChild(document.createTextNode(lineNumberFor(cm.options, lineN)));
              }
              cur = lineView.node.nextSibling;
            }
            lineN += lineView.size;
          }
          while (cur) {
            cur = rm(cur);
          }
        }
        function updateGutterSpace(display) {
          var width = display.gutters.offsetWidth;
          display.sizer.style.marginLeft = width + "px";
          signalLater(display, "gutterChanged", display);
        }
        function setDocumentHeight(cm, measure) {
          cm.display.sizer.style.minHeight = measure.docHeight + "px";
          cm.display.heightForcer.style.top = measure.docHeight + "px";
          cm.display.gutters.style.height = measure.docHeight + cm.display.barHeight + scrollGap(cm) + "px";
        }
        function alignHorizontally(cm) {
          var display = cm.display, view = display.view;
          if (!display.alignWidgets && (!display.gutters.firstChild || !cm.options.fixedGutter)) {
            return;
          }
          var comp = compensateForHScroll(display) - display.scroller.scrollLeft + cm.doc.scrollLeft;
          var gutterW = display.gutters.offsetWidth, left = comp + "px";
          for (var i2 = 0; i2 < view.length; i2++) {
            if (!view[i2].hidden) {
              if (cm.options.fixedGutter) {
                if (view[i2].gutter) {
                  view[i2].gutter.style.left = left;
                }
                if (view[i2].gutterBackground) {
                  view[i2].gutterBackground.style.left = left;
                }
              }
              var align = view[i2].alignable;
              if (align) {
                for (var j = 0; j < align.length; j++) {
                  align[j].style.left = left;
                }
              }
            }
          }
          if (cm.options.fixedGutter) {
            display.gutters.style.left = comp + gutterW + "px";
          }
        }
        function maybeUpdateLineNumberWidth(cm) {
          if (!cm.options.lineNumbers) {
            return false;
          }
          var doc2 = cm.doc, last = lineNumberFor(cm.options, doc2.first + doc2.size - 1), display = cm.display;
          if (last.length != display.lineNumChars) {
            var test = display.measure.appendChild(elt("div", [elt("div", last)], "CodeMirror-linenumber CodeMirror-gutter-elt"));
            var innerW = test.firstChild.offsetWidth, padding = test.offsetWidth - innerW;
            display.lineGutter.style.width = "";
            display.lineNumInnerWidth = Math.max(innerW, display.lineGutter.offsetWidth - padding) + 1;
            display.lineNumWidth = display.lineNumInnerWidth + padding;
            display.lineNumChars = display.lineNumInnerWidth ? last.length : -1;
            display.lineGutter.style.width = display.lineNumWidth + "px";
            updateGutterSpace(cm.display);
            return true;
          }
          return false;
        }
        function getGutters(gutters, lineNumbers) {
          var result = [], sawLineNumbers = false;
          for (var i2 = 0; i2 < gutters.length; i2++) {
            var name = gutters[i2], style = null;
            if (typeof name != "string") {
              style = name.style;
              name = name.className;
            }
            if (name == "CodeMirror-linenumbers") {
              if (!lineNumbers) {
                continue;
              } else {
                sawLineNumbers = true;
              }
            }
            result.push({ className: name, style });
          }
          if (lineNumbers && !sawLineNumbers) {
            result.push({ className: "CodeMirror-linenumbers", style: null });
          }
          return result;
        }
        function renderGutters(display) {
          var gutters = display.gutters, specs = display.gutterSpecs;
          removeChildren(gutters);
          display.lineGutter = null;
          for (var i2 = 0; i2 < specs.length; ++i2) {
            var ref = specs[i2];
            var className = ref.className;
            var style = ref.style;
            var gElt = gutters.appendChild(elt("div", null, "CodeMirror-gutter " + className));
            if (style) {
              gElt.style.cssText = style;
            }
            if (className == "CodeMirror-linenumbers") {
              display.lineGutter = gElt;
              gElt.style.width = (display.lineNumWidth || 1) + "px";
            }
          }
          gutters.style.display = specs.length ? "" : "none";
          updateGutterSpace(display);
        }
        function updateGutters(cm) {
          renderGutters(cm.display);
          regChange(cm);
          alignHorizontally(cm);
        }
        function Display(place, doc2, input, options) {
          var d = this;
          this.input = input;
          d.scrollbarFiller = elt("div", null, "CodeMirror-scrollbar-filler");
          d.scrollbarFiller.setAttribute("cm-not-content", "true");
          d.gutterFiller = elt("div", null, "CodeMirror-gutter-filler");
          d.gutterFiller.setAttribute("cm-not-content", "true");
          d.lineDiv = eltP("div", null, "CodeMirror-code");
          d.selectionDiv = elt("div", null, null, "position: relative; z-index: 1");
          d.cursorDiv = elt("div", null, "CodeMirror-cursors");
          d.measure = elt("div", null, "CodeMirror-measure");
          d.lineMeasure = elt("div", null, "CodeMirror-measure");
          d.lineSpace = eltP("div", [d.measure, d.lineMeasure, d.selectionDiv, d.cursorDiv, d.lineDiv], null, "position: relative; outline: none");
          var lines = eltP("div", [d.lineSpace], "CodeMirror-lines");
          d.mover = elt("div", [lines], null, "position: relative");
          d.sizer = elt("div", [d.mover], "CodeMirror-sizer");
          d.sizerWidth = null;
          d.heightForcer = elt("div", null, null, "position: absolute; height: " + scrollerGap + "px; width: 1px;");
          d.gutters = elt("div", null, "CodeMirror-gutters");
          d.lineGutter = null;
          d.scroller = elt("div", [d.sizer, d.heightForcer, d.gutters], "CodeMirror-scroll");
          d.scroller.setAttribute("tabIndex", "-1");
          d.wrapper = elt("div", [d.scrollbarFiller, d.gutterFiller, d.scroller], "CodeMirror");
          d.wrapper.setAttribute("translate", "no");
          if (ie && ie_version < 8) {
            d.gutters.style.zIndex = -1;
            d.scroller.style.paddingRight = 0;
          }
          if (!webkit && !(gecko && mobile)) {
            d.scroller.draggable = true;
          }
          if (place) {
            if (place.appendChild) {
              place.appendChild(d.wrapper);
            } else {
              place(d.wrapper);
            }
          }
          d.viewFrom = d.viewTo = doc2.first;
          d.reportedViewFrom = d.reportedViewTo = doc2.first;
          d.view = [];
          d.renderedView = null;
          d.externalMeasured = null;
          d.viewOffset = 0;
          d.lastWrapHeight = d.lastWrapWidth = 0;
          d.updateLineNumbers = null;
          d.nativeBarWidth = d.barHeight = d.barWidth = 0;
          d.scrollbarsClipped = false;
          d.lineNumWidth = d.lineNumInnerWidth = d.lineNumChars = null;
          d.alignWidgets = false;
          d.cachedCharWidth = d.cachedTextHeight = d.cachedPaddingH = null;
          d.maxLine = null;
          d.maxLineLength = 0;
          d.maxLineChanged = false;
          d.wheelDX = d.wheelDY = d.wheelStartX = d.wheelStartY = null;
          d.shift = false;
          d.selForContextMenu = null;
          d.activeTouch = null;
          d.gutterSpecs = getGutters(options.gutters, options.lineNumbers);
          renderGutters(d);
          input.init(d);
        }
        var wheelSamples = 0, wheelPixelsPerUnit = null;
        if (ie) {
          wheelPixelsPerUnit = -0.53;
        } else if (gecko) {
          wheelPixelsPerUnit = 15;
        } else if (chrome) {
          wheelPixelsPerUnit = -0.7;
        } else if (safari) {
          wheelPixelsPerUnit = -1 / 3;
        }
        function wheelEventDelta(e2) {
          var dx = e2.wheelDeltaX, dy = e2.wheelDeltaY;
          if (dx == null && e2.detail && e2.axis == e2.HORIZONTAL_AXIS) {
            dx = e2.detail;
          }
          if (dy == null && e2.detail && e2.axis == e2.VERTICAL_AXIS) {
            dy = e2.detail;
          } else if (dy == null) {
            dy = e2.wheelDelta;
          }
          return { x: dx, y: dy };
        }
        function wheelEventPixels(e2) {
          var delta = wheelEventDelta(e2);
          delta.x *= wheelPixelsPerUnit;
          delta.y *= wheelPixelsPerUnit;
          return delta;
        }
        function onScrollWheel(cm, e2) {
          if (chrome && chrome_version == 102) {
            if (cm.display.chromeScrollHack == null) {
              cm.display.sizer.style.pointerEvents = "none";
            } else {
              clearTimeout(cm.display.chromeScrollHack);
            }
            cm.display.chromeScrollHack = setTimeout(function() {
              cm.display.chromeScrollHack = null;
              cm.display.sizer.style.pointerEvents = "";
            }, 100);
          }
          var delta = wheelEventDelta(e2), dx = delta.x, dy = delta.y;
          var pixelsPerUnit = wheelPixelsPerUnit;
          if (e2.deltaMode === 0) {
            dx = e2.deltaX;
            dy = e2.deltaY;
            pixelsPerUnit = 1;
          }
          var display = cm.display, scroll = display.scroller;
          var canScrollX = scroll.scrollWidth > scroll.clientWidth;
          var canScrollY = scroll.scrollHeight > scroll.clientHeight;
          if (!(dx && canScrollX || dy && canScrollY)) {
            return;
          }
          if (dy && mac && webkit) {
            outer:
              for (var cur = e2.target, view = display.view; cur != scroll; cur = cur.parentNode) {
                for (var i2 = 0; i2 < view.length; i2++) {
                  if (view[i2].node == cur) {
                    cm.display.currentWheelTarget = cur;
                    break outer;
                  }
                }
              }
          }
          if (dx && !gecko && !presto && pixelsPerUnit != null) {
            if (dy && canScrollY) {
              updateScrollTop(cm, Math.max(0, scroll.scrollTop + dy * pixelsPerUnit));
            }
            setScrollLeft(cm, Math.max(0, scroll.scrollLeft + dx * pixelsPerUnit));
            if (!dy || dy && canScrollY) {
              e_preventDefault(e2);
            }
            display.wheelStartX = null;
            return;
          }
          if (dy && pixelsPerUnit != null) {
            var pixels = dy * pixelsPerUnit;
            var top = cm.doc.scrollTop, bot = top + display.wrapper.clientHeight;
            if (pixels < 0) {
              top = Math.max(0, top + pixels - 50);
            } else {
              bot = Math.min(cm.doc.height, bot + pixels + 50);
            }
            updateDisplaySimple(cm, { top, bottom: bot });
          }
          if (wheelSamples < 20 && e2.deltaMode !== 0) {
            if (display.wheelStartX == null) {
              display.wheelStartX = scroll.scrollLeft;
              display.wheelStartY = scroll.scrollTop;
              display.wheelDX = dx;
              display.wheelDY = dy;
              setTimeout(function() {
                if (display.wheelStartX == null) {
                  return;
                }
                var movedX = scroll.scrollLeft - display.wheelStartX;
                var movedY = scroll.scrollTop - display.wheelStartY;
                var sample = movedY && display.wheelDY && movedY / display.wheelDY || movedX && display.wheelDX && movedX / display.wheelDX;
                display.wheelStartX = display.wheelStartY = null;
                if (!sample) {
                  return;
                }
                wheelPixelsPerUnit = (wheelPixelsPerUnit * wheelSamples + sample) / (wheelSamples + 1);
                ++wheelSamples;
              }, 200);
            } else {
              display.wheelDX += dx;
              display.wheelDY += dy;
            }
          }
        }
        var Selection = function(ranges, primIndex) {
          this.ranges = ranges;
          this.primIndex = primIndex;
        };
        Selection.prototype.primary = function() {
          return this.ranges[this.primIndex];
        };
        Selection.prototype.equals = function(other) {
          if (other == this) {
            return true;
          }
          if (other.primIndex != this.primIndex || other.ranges.length != this.ranges.length) {
            return false;
          }
          for (var i2 = 0; i2 < this.ranges.length; i2++) {
            var here = this.ranges[i2], there = other.ranges[i2];
            if (!equalCursorPos(here.anchor, there.anchor) || !equalCursorPos(here.head, there.head)) {
              return false;
            }
          }
          return true;
        };
        Selection.prototype.deepCopy = function() {
          var out2 = [];
          for (var i2 = 0; i2 < this.ranges.length; i2++) {
            out2[i2] = new Range(copyPos(this.ranges[i2].anchor), copyPos(this.ranges[i2].head));
          }
          return new Selection(out2, this.primIndex);
        };
        Selection.prototype.somethingSelected = function() {
          for (var i2 = 0; i2 < this.ranges.length; i2++) {
            if (!this.ranges[i2].empty()) {
              return true;
            }
          }
          return false;
        };
        Selection.prototype.contains = function(pos, end2) {
          if (!end2) {
            end2 = pos;
          }
          for (var i2 = 0; i2 < this.ranges.length; i2++) {
            var range2 = this.ranges[i2];
            if (cmp(end2, range2.from()) >= 0 && cmp(pos, range2.to()) <= 0) {
              return i2;
            }
          }
          return -1;
        };
        var Range = function(anchor, head) {
          this.anchor = anchor;
          this.head = head;
        };
        Range.prototype.from = function() {
          return minPos(this.anchor, this.head);
        };
        Range.prototype.to = function() {
          return maxPos(this.anchor, this.head);
        };
        Range.prototype.empty = function() {
          return this.head.line == this.anchor.line && this.head.ch == this.anchor.ch;
        };
        function normalizeSelection(cm, ranges, primIndex) {
          var mayTouch = cm && cm.options.selectionsMayTouch;
          var prim = ranges[primIndex];
          ranges.sort(function(a, b) {
            return cmp(a.from(), b.from());
          });
          primIndex = indexOf2(ranges, prim);
          for (var i2 = 1; i2 < ranges.length; i2++) {
            var cur = ranges[i2], prev = ranges[i2 - 1];
            var diff = cmp(prev.to(), cur.from());
            if (mayTouch && !cur.empty() ? diff > 0 : diff >= 0) {
              var from = minPos(prev.from(), cur.from()), to = maxPos(prev.to(), cur.to());
              var inv = prev.empty() ? cur.from() == cur.head : prev.from() == prev.head;
              if (i2 <= primIndex) {
                --primIndex;
              }
              ranges.splice(--i2, 2, new Range(inv ? to : from, inv ? from : to));
            }
          }
          return new Selection(ranges, primIndex);
        }
        function simpleSelection(anchor, head) {
          return new Selection([new Range(anchor, head || anchor)], 0);
        }
        function changeEnd(change) {
          if (!change.text) {
            return change.to;
          }
          return Pos(change.from.line + change.text.length - 1, lst(change.text).length + (change.text.length == 1 ? change.from.ch : 0));
        }
        function adjustForChange(pos, change) {
          if (cmp(pos, change.from) < 0) {
            return pos;
          }
          if (cmp(pos, change.to) <= 0) {
            return changeEnd(change);
          }
          var line = pos.line + change.text.length - (change.to.line - change.from.line) - 1, ch = pos.ch;
          if (pos.line == change.to.line) {
            ch += changeEnd(change).ch - change.to.ch;
          }
          return Pos(line, ch);
        }
        function computeSelAfterChange(doc2, change) {
          var out2 = [];
          for (var i2 = 0; i2 < doc2.sel.ranges.length; i2++) {
            var range2 = doc2.sel.ranges[i2];
            out2.push(new Range(adjustForChange(range2.anchor, change), adjustForChange(range2.head, change)));
          }
          return normalizeSelection(doc2.cm, out2, doc2.sel.primIndex);
        }
        function offsetPos(pos, old, nw) {
          if (pos.line == old.line) {
            return Pos(nw.line, pos.ch - old.ch + nw.ch);
          } else {
            return Pos(nw.line + (pos.line - old.line), pos.ch);
          }
        }
        function computeReplacedSel(doc2, changes, hint) {
          var out2 = [];
          var oldPrev = Pos(doc2.first, 0), newPrev = oldPrev;
          for (var i2 = 0; i2 < changes.length; i2++) {
            var change = changes[i2];
            var from = offsetPos(change.from, oldPrev, newPrev);
            var to = offsetPos(changeEnd(change), oldPrev, newPrev);
            oldPrev = change.to;
            newPrev = to;
            if (hint == "around") {
              var range2 = doc2.sel.ranges[i2], inv = cmp(range2.head, range2.anchor) < 0;
              out2[i2] = new Range(inv ? to : from, inv ? from : to);
            } else {
              out2[i2] = new Range(from, from);
            }
          }
          return new Selection(out2, doc2.sel.primIndex);
        }
        function loadMode(cm) {
          cm.doc.mode = getMode(cm.options, cm.doc.modeOption);
          resetModeState(cm);
        }
        function resetModeState(cm) {
          cm.doc.iter(function(line) {
            if (line.stateAfter) {
              line.stateAfter = null;
            }
            if (line.styles) {
              line.styles = null;
            }
          });
          cm.doc.modeFrontier = cm.doc.highlightFrontier = cm.doc.first;
          startWorker(cm, 100);
          cm.state.modeGen++;
          if (cm.curOp) {
            regChange(cm);
          }
        }
        function isWholeLineUpdate(doc2, change) {
          return change.from.ch == 0 && change.to.ch == 0 && lst(change.text) == "" && (!doc2.cm || doc2.cm.options.wholeLineUpdateBefore);
        }
        function updateDoc(doc2, change, markedSpans, estimateHeight2) {
          function spansFor(n) {
            return markedSpans ? markedSpans[n] : null;
          }
          function update(line, text2, spans) {
            updateLine(line, text2, spans, estimateHeight2);
            signalLater(line, "change", line, change);
          }
          function linesFor(start2, end2) {
            var result = [];
            for (var i2 = start2; i2 < end2; ++i2) {
              result.push(new Line3(text[i2], spansFor(i2), estimateHeight2));
            }
            return result;
          }
          var from = change.from, to = change.to, text = change.text;
          var firstLine = getLine(doc2, from.line), lastLine = getLine(doc2, to.line);
          var lastText = lst(text), lastSpans = spansFor(text.length - 1), nlines = to.line - from.line;
          if (change.full) {
            doc2.insert(0, linesFor(0, text.length));
            doc2.remove(text.length, doc2.size - text.length);
          } else if (isWholeLineUpdate(doc2, change)) {
            var added = linesFor(0, text.length - 1);
            update(lastLine, lastLine.text, lastSpans);
            if (nlines) {
              doc2.remove(from.line, nlines);
            }
            if (added.length) {
              doc2.insert(from.line, added);
            }
          } else if (firstLine == lastLine) {
            if (text.length == 1) {
              update(firstLine, firstLine.text.slice(0, from.ch) + lastText + firstLine.text.slice(to.ch), lastSpans);
            } else {
              var added$1 = linesFor(1, text.length - 1);
              added$1.push(new Line3(lastText + firstLine.text.slice(to.ch), lastSpans, estimateHeight2));
              update(firstLine, firstLine.text.slice(0, from.ch) + text[0], spansFor(0));
              doc2.insert(from.line + 1, added$1);
            }
          } else if (text.length == 1) {
            update(firstLine, firstLine.text.slice(0, from.ch) + text[0] + lastLine.text.slice(to.ch), spansFor(0));
            doc2.remove(from.line + 1, nlines);
          } else {
            update(firstLine, firstLine.text.slice(0, from.ch) + text[0], spansFor(0));
            update(lastLine, lastText + lastLine.text.slice(to.ch), lastSpans);
            var added$2 = linesFor(1, text.length - 1);
            if (nlines > 1) {
              doc2.remove(from.line + 1, nlines - 1);
            }
            doc2.insert(from.line + 1, added$2);
          }
          signalLater(doc2, "change", doc2, change);
        }
        function linkedDocs(doc2, f, sharedHistOnly) {
          function propagate(doc3, skip, sharedHist) {
            if (doc3.linked) {
              for (var i2 = 0; i2 < doc3.linked.length; ++i2) {
                var rel = doc3.linked[i2];
                if (rel.doc == skip) {
                  continue;
                }
                var shared = sharedHist && rel.sharedHist;
                if (sharedHistOnly && !shared) {
                  continue;
                }
                f(rel.doc, shared);
                propagate(rel.doc, doc3, shared);
              }
            }
          }
          propagate(doc2, null, true);
        }
        function attachDoc(cm, doc2) {
          if (doc2.cm) {
            throw new Error("This document is already in use.");
          }
          cm.doc = doc2;
          doc2.cm = cm;
          estimateLineHeights(cm);
          loadMode(cm);
          setDirectionClass(cm);
          cm.options.direction = doc2.direction;
          if (!cm.options.lineWrapping) {
            findMaxLine(cm);
          }
          cm.options.mode = doc2.modeOption;
          regChange(cm);
        }
        function setDirectionClass(cm) {
          (cm.doc.direction == "rtl" ? addClass : rmClass)(cm.display.lineDiv, "CodeMirror-rtl");
        }
        function directionChanged(cm) {
          runInOp(cm, function() {
            setDirectionClass(cm);
            regChange(cm);
          });
        }
        function History(prev) {
          this.done = [];
          this.undone = [];
          this.undoDepth = prev ? prev.undoDepth : Infinity;
          this.lastModTime = this.lastSelTime = 0;
          this.lastOp = this.lastSelOp = null;
          this.lastOrigin = this.lastSelOrigin = null;
          this.generation = this.maxGeneration = prev ? prev.maxGeneration : 1;
        }
        function historyChangeFromChange(doc2, change) {
          var histChange = { from: copyPos(change.from), to: changeEnd(change), text: getBetween(doc2, change.from, change.to) };
          attachLocalSpans(doc2, histChange, change.from.line, change.to.line + 1);
          linkedDocs(doc2, function(doc3) {
            return attachLocalSpans(doc3, histChange, change.from.line, change.to.line + 1);
          }, true);
          return histChange;
        }
        function clearSelectionEvents(array) {
          while (array.length) {
            var last = lst(array);
            if (last.ranges) {
              array.pop();
            } else {
              break;
            }
          }
        }
        function lastChangeEvent(hist, force) {
          if (force) {
            clearSelectionEvents(hist.done);
            return lst(hist.done);
          } else if (hist.done.length && !lst(hist.done).ranges) {
            return lst(hist.done);
          } else if (hist.done.length > 1 && !hist.done[hist.done.length - 2].ranges) {
            hist.done.pop();
            return lst(hist.done);
          }
        }
        function addChangeToHistory(doc2, change, selAfter, opId) {
          var hist = doc2.history;
          hist.undone.length = 0;
          var time = +new Date(), cur;
          var last;
          if ((hist.lastOp == opId || hist.lastOrigin == change.origin && change.origin && (change.origin.charAt(0) == "+" && hist.lastModTime > time - (doc2.cm ? doc2.cm.options.historyEventDelay : 500) || change.origin.charAt(0) == "*")) && (cur = lastChangeEvent(hist, hist.lastOp == opId))) {
            last = lst(cur.changes);
            if (cmp(change.from, change.to) == 0 && cmp(change.from, last.to) == 0) {
              last.to = changeEnd(change);
            } else {
              cur.changes.push(historyChangeFromChange(doc2, change));
            }
          } else {
            var before = lst(hist.done);
            if (!before || !before.ranges) {
              pushSelectionToHistory(doc2.sel, hist.done);
            }
            cur = {
              changes: [historyChangeFromChange(doc2, change)],
              generation: hist.generation
            };
            hist.done.push(cur);
            while (hist.done.length > hist.undoDepth) {
              hist.done.shift();
              if (!hist.done[0].ranges) {
                hist.done.shift();
              }
            }
          }
          hist.done.push(selAfter);
          hist.generation = ++hist.maxGeneration;
          hist.lastModTime = hist.lastSelTime = time;
          hist.lastOp = hist.lastSelOp = opId;
          hist.lastOrigin = hist.lastSelOrigin = change.origin;
          if (!last) {
            signal(doc2, "historyAdded");
          }
        }
        function selectionEventCanBeMerged(doc2, origin, prev, sel) {
          var ch = origin.charAt(0);
          return ch == "*" || ch == "+" && prev.ranges.length == sel.ranges.length && prev.somethingSelected() == sel.somethingSelected() && new Date() - doc2.history.lastSelTime <= (doc2.cm ? doc2.cm.options.historyEventDelay : 500);
        }
        function addSelectionToHistory(doc2, sel, opId, options) {
          var hist = doc2.history, origin = options && options.origin;
          if (opId == hist.lastSelOp || origin && hist.lastSelOrigin == origin && (hist.lastModTime == hist.lastSelTime && hist.lastOrigin == origin || selectionEventCanBeMerged(doc2, origin, lst(hist.done), sel))) {
            hist.done[hist.done.length - 1] = sel;
          } else {
            pushSelectionToHistory(sel, hist.done);
          }
          hist.lastSelTime = +new Date();
          hist.lastSelOrigin = origin;
          hist.lastSelOp = opId;
          if (options && options.clearRedo !== false) {
            clearSelectionEvents(hist.undone);
          }
        }
        function pushSelectionToHistory(sel, dest) {
          var top = lst(dest);
          if (!(top && top.ranges && top.equals(sel))) {
            dest.push(sel);
          }
        }
        function attachLocalSpans(doc2, change, from, to) {
          var existing = change["spans_" + doc2.id], n = 0;
          doc2.iter(Math.max(doc2.first, from), Math.min(doc2.first + doc2.size, to), function(line) {
            if (line.markedSpans) {
              (existing || (existing = change["spans_" + doc2.id] = {}))[n] = line.markedSpans;
            }
            ++n;
          });
        }
        function removeClearedSpans(spans) {
          if (!spans) {
            return null;
          }
          var out2;
          for (var i2 = 0; i2 < spans.length; ++i2) {
            if (spans[i2].marker.explicitlyCleared) {
              if (!out2) {
                out2 = spans.slice(0, i2);
              }
            } else if (out2) {
              out2.push(spans[i2]);
            }
          }
          return !out2 ? spans : out2.length ? out2 : null;
        }
        function getOldSpans(doc2, change) {
          var found = change["spans_" + doc2.id];
          if (!found) {
            return null;
          }
          var nw = [];
          for (var i2 = 0; i2 < change.text.length; ++i2) {
            nw.push(removeClearedSpans(found[i2]));
          }
          return nw;
        }
        function mergeOldSpans(doc2, change) {
          var old = getOldSpans(doc2, change);
          var stretched = stretchSpansOverChange(doc2, change);
          if (!old) {
            return stretched;
          }
          if (!stretched) {
            return old;
          }
          for (var i2 = 0; i2 < old.length; ++i2) {
            var oldCur = old[i2], stretchCur = stretched[i2];
            if (oldCur && stretchCur) {
              spans:
                for (var j = 0; j < stretchCur.length; ++j) {
                  var span = stretchCur[j];
                  for (var k = 0; k < oldCur.length; ++k) {
                    if (oldCur[k].marker == span.marker) {
                      continue spans;
                    }
                  }
                  oldCur.push(span);
                }
            } else if (stretchCur) {
              old[i2] = stretchCur;
            }
          }
          return old;
        }
        function copyHistoryArray(events, newGroup, instantiateSel) {
          var copy3 = [];
          for (var i2 = 0; i2 < events.length; ++i2) {
            var event = events[i2];
            if (event.ranges) {
              copy3.push(instantiateSel ? Selection.prototype.deepCopy.call(event) : event);
              continue;
            }
            var changes = event.changes, newChanges = [];
            copy3.push({ changes: newChanges });
            for (var j = 0; j < changes.length; ++j) {
              var change = changes[j], m2 = void 0;
              newChanges.push({ from: change.from, to: change.to, text: change.text });
              if (newGroup) {
                for (var prop2 in change) {
                  if (m2 = prop2.match(/^spans_(\d+)$/)) {
                    if (indexOf2(newGroup, Number(m2[1])) > -1) {
                      lst(newChanges)[prop2] = change[prop2];
                      delete change[prop2];
                    }
                  }
                }
              }
            }
          }
          return copy3;
        }
        function extendRange(range2, head, other, extend2) {
          if (extend2) {
            var anchor = range2.anchor;
            if (other) {
              var posBefore = cmp(head, anchor) < 0;
              if (posBefore != cmp(other, anchor) < 0) {
                anchor = head;
                head = other;
              } else if (posBefore != cmp(head, other) < 0) {
                head = other;
              }
            }
            return new Range(anchor, head);
          } else {
            return new Range(other || head, head);
          }
        }
        function extendSelection(doc2, head, other, options, extend2) {
          if (extend2 == null) {
            extend2 = doc2.cm && (doc2.cm.display.shift || doc2.extend);
          }
          setSelection(doc2, new Selection([extendRange(doc2.sel.primary(), head, other, extend2)], 0), options);
        }
        function extendSelections(doc2, heads, options) {
          var out2 = [];
          var extend2 = doc2.cm && (doc2.cm.display.shift || doc2.extend);
          for (var i2 = 0; i2 < doc2.sel.ranges.length; i2++) {
            out2[i2] = extendRange(doc2.sel.ranges[i2], heads[i2], null, extend2);
          }
          var newSel = normalizeSelection(doc2.cm, out2, doc2.sel.primIndex);
          setSelection(doc2, newSel, options);
        }
        function replaceOneSelection(doc2, i2, range2, options) {
          var ranges = doc2.sel.ranges.slice(0);
          ranges[i2] = range2;
          setSelection(doc2, normalizeSelection(doc2.cm, ranges, doc2.sel.primIndex), options);
        }
        function setSimpleSelection(doc2, anchor, head, options) {
          setSelection(doc2, simpleSelection(anchor, head), options);
        }
        function filterSelectionChange(doc2, sel, options) {
          var obj = {
            ranges: sel.ranges,
            update: function(ranges) {
              this.ranges = [];
              for (var i2 = 0; i2 < ranges.length; i2++) {
                this.ranges[i2] = new Range(clipPos(doc2, ranges[i2].anchor), clipPos(doc2, ranges[i2].head));
              }
            },
            origin: options && options.origin
          };
          signal(doc2, "beforeSelectionChange", doc2, obj);
          if (doc2.cm) {
            signal(doc2.cm, "beforeSelectionChange", doc2.cm, obj);
          }
          if (obj.ranges != sel.ranges) {
            return normalizeSelection(doc2.cm, obj.ranges, obj.ranges.length - 1);
          } else {
            return sel;
          }
        }
        function setSelectionReplaceHistory(doc2, sel, options) {
          var done = doc2.history.done, last = lst(done);
          if (last && last.ranges) {
            done[done.length - 1] = sel;
            setSelectionNoUndo(doc2, sel, options);
          } else {
            setSelection(doc2, sel, options);
          }
        }
        function setSelection(doc2, sel, options) {
          setSelectionNoUndo(doc2, sel, options);
          addSelectionToHistory(doc2, doc2.sel, doc2.cm ? doc2.cm.curOp.id : NaN, options);
        }
        function setSelectionNoUndo(doc2, sel, options) {
          if (hasHandler(doc2, "beforeSelectionChange") || doc2.cm && hasHandler(doc2.cm, "beforeSelectionChange")) {
            sel = filterSelectionChange(doc2, sel, options);
          }
          var bias = options && options.bias || (cmp(sel.primary().head, doc2.sel.primary().head) < 0 ? -1 : 1);
          setSelectionInner(doc2, skipAtomicInSelection(doc2, sel, bias, true));
          if (!(options && options.scroll === false) && doc2.cm && doc2.cm.getOption("readOnly") != "nocursor") {
            ensureCursorVisible(doc2.cm);
          }
        }
        function setSelectionInner(doc2, sel) {
          if (sel.equals(doc2.sel)) {
            return;
          }
          doc2.sel = sel;
          if (doc2.cm) {
            doc2.cm.curOp.updateInput = 1;
            doc2.cm.curOp.selectionChanged = true;
            signalCursorActivity(doc2.cm);
          }
          signalLater(doc2, "cursorActivity", doc2);
        }
        function reCheckSelection(doc2) {
          setSelectionInner(doc2, skipAtomicInSelection(doc2, doc2.sel, null, false));
        }
        function skipAtomicInSelection(doc2, sel, bias, mayClear) {
          var out2;
          for (var i2 = 0; i2 < sel.ranges.length; i2++) {
            var range2 = sel.ranges[i2];
            var old = sel.ranges.length == doc2.sel.ranges.length && doc2.sel.ranges[i2];
            var newAnchor = skipAtomic(doc2, range2.anchor, old && old.anchor, bias, mayClear);
            var newHead = range2.head == range2.anchor ? newAnchor : skipAtomic(doc2, range2.head, old && old.head, bias, mayClear);
            if (out2 || newAnchor != range2.anchor || newHead != range2.head) {
              if (!out2) {
                out2 = sel.ranges.slice(0, i2);
              }
              out2[i2] = new Range(newAnchor, newHead);
            }
          }
          return out2 ? normalizeSelection(doc2.cm, out2, sel.primIndex) : sel;
        }
        function skipAtomicInner(doc2, pos, oldPos, dir3, mayClear) {
          var line = getLine(doc2, pos.line);
          if (line.markedSpans) {
            for (var i2 = 0; i2 < line.markedSpans.length; ++i2) {
              var sp = line.markedSpans[i2], m2 = sp.marker;
              var preventCursorLeft = "selectLeft" in m2 ? !m2.selectLeft : m2.inclusiveLeft;
              var preventCursorRight = "selectRight" in m2 ? !m2.selectRight : m2.inclusiveRight;
              if ((sp.from == null || (preventCursorLeft ? sp.from <= pos.ch : sp.from < pos.ch)) && (sp.to == null || (preventCursorRight ? sp.to >= pos.ch : sp.to > pos.ch))) {
                if (mayClear) {
                  signal(m2, "beforeCursorEnter");
                  if (m2.explicitlyCleared) {
                    if (!line.markedSpans) {
                      break;
                    } else {
                      --i2;
                      continue;
                    }
                  }
                }
                if (!m2.atomic) {
                  continue;
                }
                if (oldPos) {
                  var near = m2.find(dir3 < 0 ? 1 : -1), diff = void 0;
                  if (dir3 < 0 ? preventCursorRight : preventCursorLeft) {
                    near = movePos(doc2, near, -dir3, near && near.line == pos.line ? line : null);
                  }
                  if (near && near.line == pos.line && (diff = cmp(near, oldPos)) && (dir3 < 0 ? diff < 0 : diff > 0)) {
                    return skipAtomicInner(doc2, near, pos, dir3, mayClear);
                  }
                }
                var far = m2.find(dir3 < 0 ? -1 : 1);
                if (dir3 < 0 ? preventCursorLeft : preventCursorRight) {
                  far = movePos(doc2, far, dir3, far.line == pos.line ? line : null);
                }
                return far ? skipAtomicInner(doc2, far, pos, dir3, mayClear) : null;
              }
            }
          }
          return pos;
        }
        function skipAtomic(doc2, pos, oldPos, bias, mayClear) {
          var dir3 = bias || 1;
          var found = skipAtomicInner(doc2, pos, oldPos, dir3, mayClear) || !mayClear && skipAtomicInner(doc2, pos, oldPos, dir3, true) || skipAtomicInner(doc2, pos, oldPos, -dir3, mayClear) || !mayClear && skipAtomicInner(doc2, pos, oldPos, -dir3, true);
          if (!found) {
            doc2.cantEdit = true;
            return Pos(doc2.first, 0);
          }
          return found;
        }
        function movePos(doc2, pos, dir3, line) {
          if (dir3 < 0 && pos.ch == 0) {
            if (pos.line > doc2.first) {
              return clipPos(doc2, Pos(pos.line - 1));
            } else {
              return null;
            }
          } else if (dir3 > 0 && pos.ch == (line || getLine(doc2, pos.line)).text.length) {
            if (pos.line < doc2.first + doc2.size - 1) {
              return Pos(pos.line + 1, 0);
            } else {
              return null;
            }
          } else {
            return new Pos(pos.line, pos.ch + dir3);
          }
        }
        function selectAll(cm) {
          cm.setSelection(Pos(cm.firstLine(), 0), Pos(cm.lastLine()), sel_dontScroll);
        }
        function filterChange(doc2, change, update) {
          var obj = {
            canceled: false,
            from: change.from,
            to: change.to,
            text: change.text,
            origin: change.origin,
            cancel: function() {
              return obj.canceled = true;
            }
          };
          if (update) {
            obj.update = function(from, to, text, origin) {
              if (from) {
                obj.from = clipPos(doc2, from);
              }
              if (to) {
                obj.to = clipPos(doc2, to);
              }
              if (text) {
                obj.text = text;
              }
              if (origin !== void 0) {
                obj.origin = origin;
              }
            };
          }
          signal(doc2, "beforeChange", doc2, obj);
          if (doc2.cm) {
            signal(doc2.cm, "beforeChange", doc2.cm, obj);
          }
          if (obj.canceled) {
            if (doc2.cm) {
              doc2.cm.curOp.updateInput = 2;
            }
            return null;
          }
          return { from: obj.from, to: obj.to, text: obj.text, origin: obj.origin };
        }
        function makeChange(doc2, change, ignoreReadOnly) {
          if (doc2.cm) {
            if (!doc2.cm.curOp) {
              return operation(doc2.cm, makeChange)(doc2, change, ignoreReadOnly);
            }
            if (doc2.cm.state.suppressEdits) {
              return;
            }
          }
          if (hasHandler(doc2, "beforeChange") || doc2.cm && hasHandler(doc2.cm, "beforeChange")) {
            change = filterChange(doc2, change, true);
            if (!change) {
              return;
            }
          }
          var split2 = sawReadOnlySpans && !ignoreReadOnly && removeReadOnlyRanges(doc2, change.from, change.to);
          if (split2) {
            for (var i2 = split2.length - 1; i2 >= 0; --i2) {
              makeChangeInner(doc2, { from: split2[i2].from, to: split2[i2].to, text: i2 ? [""] : change.text, origin: change.origin });
            }
          } else {
            makeChangeInner(doc2, change);
          }
        }
        function makeChangeInner(doc2, change) {
          if (change.text.length == 1 && change.text[0] == "" && cmp(change.from, change.to) == 0) {
            return;
          }
          var selAfter = computeSelAfterChange(doc2, change);
          addChangeToHistory(doc2, change, selAfter, doc2.cm ? doc2.cm.curOp.id : NaN);
          makeChangeSingleDoc(doc2, change, selAfter, stretchSpansOverChange(doc2, change));
          var rebased = [];
          linkedDocs(doc2, function(doc3, sharedHist) {
            if (!sharedHist && indexOf2(rebased, doc3.history) == -1) {
              rebaseHist(doc3.history, change);
              rebased.push(doc3.history);
            }
            makeChangeSingleDoc(doc3, change, null, stretchSpansOverChange(doc3, change));
          });
        }
        function makeChangeFromHistory(doc2, type, allowSelectionOnly) {
          var suppress = doc2.cm && doc2.cm.state.suppressEdits;
          if (suppress && !allowSelectionOnly) {
            return;
          }
          var hist = doc2.history, event, selAfter = doc2.sel;
          var source = type == "undo" ? hist.done : hist.undone, dest = type == "undo" ? hist.undone : hist.done;
          var i2 = 0;
          for (; i2 < source.length; i2++) {
            event = source[i2];
            if (allowSelectionOnly ? event.ranges && !event.equals(doc2.sel) : !event.ranges) {
              break;
            }
          }
          if (i2 == source.length) {
            return;
          }
          hist.lastOrigin = hist.lastSelOrigin = null;
          for (; ; ) {
            event = source.pop();
            if (event.ranges) {
              pushSelectionToHistory(event, dest);
              if (allowSelectionOnly && !event.equals(doc2.sel)) {
                setSelection(doc2, event, { clearRedo: false });
                return;
              }
              selAfter = event;
            } else if (suppress) {
              source.push(event);
              return;
            } else {
              break;
            }
          }
          var antiChanges = [];
          pushSelectionToHistory(selAfter, dest);
          dest.push({ changes: antiChanges, generation: hist.generation });
          hist.generation = event.generation || ++hist.maxGeneration;
          var filter2 = hasHandler(doc2, "beforeChange") || doc2.cm && hasHandler(doc2.cm, "beforeChange");
          var loop = function(i3) {
            var change = event.changes[i3];
            change.origin = type;
            if (filter2 && !filterChange(doc2, change, false)) {
              source.length = 0;
              return {};
            }
            antiChanges.push(historyChangeFromChange(doc2, change));
            var after = i3 ? computeSelAfterChange(doc2, change) : lst(source);
            makeChangeSingleDoc(doc2, change, after, mergeOldSpans(doc2, change));
            if (!i3 && doc2.cm) {
              doc2.cm.scrollIntoView({ from: change.from, to: changeEnd(change) });
            }
            var rebased = [];
            linkedDocs(doc2, function(doc3, sharedHist) {
              if (!sharedHist && indexOf2(rebased, doc3.history) == -1) {
                rebaseHist(doc3.history, change);
                rebased.push(doc3.history);
              }
              makeChangeSingleDoc(doc3, change, null, mergeOldSpans(doc3, change));
            });
          };
          for (var i$12 = event.changes.length - 1; i$12 >= 0; --i$12) {
            var returned = loop(i$12);
            if (returned)
              return returned.v;
          }
        }
        function shiftDoc(doc2, distance2) {
          if (distance2 == 0) {
            return;
          }
          doc2.first += distance2;
          doc2.sel = new Selection(map3(doc2.sel.ranges, function(range2) {
            return new Range(Pos(range2.anchor.line + distance2, range2.anchor.ch), Pos(range2.head.line + distance2, range2.head.ch));
          }), doc2.sel.primIndex);
          if (doc2.cm) {
            regChange(doc2.cm, doc2.first, doc2.first - distance2, distance2);
            for (var d = doc2.cm.display, l = d.viewFrom; l < d.viewTo; l++) {
              regLineChange(doc2.cm, l, "gutter");
            }
          }
        }
        function makeChangeSingleDoc(doc2, change, selAfter, spans) {
          if (doc2.cm && !doc2.cm.curOp) {
            return operation(doc2.cm, makeChangeSingleDoc)(doc2, change, selAfter, spans);
          }
          if (change.to.line < doc2.first) {
            shiftDoc(doc2, change.text.length - 1 - (change.to.line - change.from.line));
            return;
          }
          if (change.from.line > doc2.lastLine()) {
            return;
          }
          if (change.from.line < doc2.first) {
            var shift = change.text.length - 1 - (doc2.first - change.from.line);
            shiftDoc(doc2, shift);
            change = {
              from: Pos(doc2.first, 0),
              to: Pos(change.to.line + shift, change.to.ch),
              text: [lst(change.text)],
              origin: change.origin
            };
          }
          var last = doc2.lastLine();
          if (change.to.line > last) {
            change = {
              from: change.from,
              to: Pos(last, getLine(doc2, last).text.length),
              text: [change.text[0]],
              origin: change.origin
            };
          }
          change.removed = getBetween(doc2, change.from, change.to);
          if (!selAfter) {
            selAfter = computeSelAfterChange(doc2, change);
          }
          if (doc2.cm) {
            makeChangeSingleDocInEditor(doc2.cm, change, spans);
          } else {
            updateDoc(doc2, change, spans);
          }
          setSelectionNoUndo(doc2, selAfter, sel_dontScroll);
          if (doc2.cantEdit && skipAtomic(doc2, Pos(doc2.firstLine(), 0))) {
            doc2.cantEdit = false;
          }
        }
        function makeChangeSingleDocInEditor(cm, change, spans) {
          var doc2 = cm.doc, display = cm.display, from = change.from, to = change.to;
          var recomputeMaxLength = false, checkWidthStart = from.line;
          if (!cm.options.lineWrapping) {
            checkWidthStart = lineNo(visualLine(getLine(doc2, from.line)));
            doc2.iter(checkWidthStart, to.line + 1, function(line) {
              if (line == display.maxLine) {
                recomputeMaxLength = true;
                return true;
              }
            });
          }
          if (doc2.sel.contains(change.from, change.to) > -1) {
            signalCursorActivity(cm);
          }
          updateDoc(doc2, change, spans, estimateHeight(cm));
          if (!cm.options.lineWrapping) {
            doc2.iter(checkWidthStart, from.line + change.text.length, function(line) {
              var len2 = lineLength(line);
              if (len2 > display.maxLineLength) {
                display.maxLine = line;
                display.maxLineLength = len2;
                display.maxLineChanged = true;
                recomputeMaxLength = false;
              }
            });
            if (recomputeMaxLength) {
              cm.curOp.updateMaxLine = true;
            }
          }
          retreatFrontier(doc2, from.line);
          startWorker(cm, 400);
          var lendiff = change.text.length - (to.line - from.line) - 1;
          if (change.full) {
            regChange(cm);
          } else if (from.line == to.line && change.text.length == 1 && !isWholeLineUpdate(cm.doc, change)) {
            regLineChange(cm, from.line, "text");
          } else {
            regChange(cm, from.line, to.line + 1, lendiff);
          }
          var changesHandler = hasHandler(cm, "changes"), changeHandler = hasHandler(cm, "change");
          if (changeHandler || changesHandler) {
            var obj = {
              from,
              to,
              text: change.text,
              removed: change.removed,
              origin: change.origin
            };
            if (changeHandler) {
              signalLater(cm, "change", cm, obj);
            }
            if (changesHandler) {
              (cm.curOp.changeObjs || (cm.curOp.changeObjs = [])).push(obj);
            }
          }
          cm.display.selForContextMenu = null;
        }
        function replaceRange(doc2, code, from, to, origin) {
          var assign;
          if (!to) {
            to = from;
          }
          if (cmp(to, from) < 0) {
            assign = [to, from], from = assign[0], to = assign[1];
          }
          if (typeof code == "string") {
            code = doc2.splitLines(code);
          }
          makeChange(doc2, { from, to, text: code, origin });
        }
        function rebaseHistSelSingle(pos, from, to, diff) {
          if (to < pos.line) {
            pos.line += diff;
          } else if (from < pos.line) {
            pos.line = from;
            pos.ch = 0;
          }
        }
        function rebaseHistArray(array, from, to, diff) {
          for (var i2 = 0; i2 < array.length; ++i2) {
            var sub2 = array[i2], ok = true;
            if (sub2.ranges) {
              if (!sub2.copied) {
                sub2 = array[i2] = sub2.deepCopy();
                sub2.copied = true;
              }
              for (var j = 0; j < sub2.ranges.length; j++) {
                rebaseHistSelSingle(sub2.ranges[j].anchor, from, to, diff);
                rebaseHistSelSingle(sub2.ranges[j].head, from, to, diff);
              }
              continue;
            }
            for (var j$1 = 0; j$1 < sub2.changes.length; ++j$1) {
              var cur = sub2.changes[j$1];
              if (to < cur.from.line) {
                cur.from = Pos(cur.from.line + diff, cur.from.ch);
                cur.to = Pos(cur.to.line + diff, cur.to.ch);
              } else if (from <= cur.to.line) {
                ok = false;
                break;
              }
            }
            if (!ok) {
              array.splice(0, i2 + 1);
              i2 = 0;
            }
          }
        }
        function rebaseHist(hist, change) {
          var from = change.from.line, to = change.to.line, diff = change.text.length - (to - from) - 1;
          rebaseHistArray(hist.done, from, to, diff);
          rebaseHistArray(hist.undone, from, to, diff);
        }
        function changeLine(doc2, handle, changeType, op) {
          var no = handle, line = handle;
          if (typeof handle == "number") {
            line = getLine(doc2, clipLine(doc2, handle));
          } else {
            no = lineNo(handle);
          }
          if (no == null) {
            return null;
          }
          if (op(line, no) && doc2.cm) {
            regLineChange(doc2.cm, no, changeType);
          }
          return line;
        }
        function LeafChunk(lines) {
          this.lines = lines;
          this.parent = null;
          var height = 0;
          for (var i2 = 0; i2 < lines.length; ++i2) {
            lines[i2].parent = this;
            height += lines[i2].height;
          }
          this.height = height;
        }
        LeafChunk.prototype = {
          chunkSize: function() {
            return this.lines.length;
          },
          removeInner: function(at, n) {
            for (var i2 = at, e2 = at + n; i2 < e2; ++i2) {
              var line = this.lines[i2];
              this.height -= line.height;
              cleanUpLine(line);
              signalLater(line, "delete");
            }
            this.lines.splice(at, n);
          },
          collapse: function(lines) {
            lines.push.apply(lines, this.lines);
          },
          insertInner: function(at, lines, height) {
            this.height += height;
            this.lines = this.lines.slice(0, at).concat(lines).concat(this.lines.slice(at));
            for (var i2 = 0; i2 < lines.length; ++i2) {
              lines[i2].parent = this;
            }
          },
          iterN: function(at, n, op) {
            for (var e2 = at + n; at < e2; ++at) {
              if (op(this.lines[at])) {
                return true;
              }
            }
          }
        };
        function BranchChunk(children) {
          this.children = children;
          var size = 0, height = 0;
          for (var i2 = 0; i2 < children.length; ++i2) {
            var ch = children[i2];
            size += ch.chunkSize();
            height += ch.height;
            ch.parent = this;
          }
          this.size = size;
          this.height = height;
          this.parent = null;
        }
        BranchChunk.prototype = {
          chunkSize: function() {
            return this.size;
          },
          removeInner: function(at, n) {
            this.size -= n;
            for (var i2 = 0; i2 < this.children.length; ++i2) {
              var child = this.children[i2], sz = child.chunkSize();
              if (at < sz) {
                var rm = Math.min(n, sz - at), oldHeight = child.height;
                child.removeInner(at, rm);
                this.height -= oldHeight - child.height;
                if (sz == rm) {
                  this.children.splice(i2--, 1);
                  child.parent = null;
                }
                if ((n -= rm) == 0) {
                  break;
                }
                at = 0;
              } else {
                at -= sz;
              }
            }
            if (this.size - n < 25 && (this.children.length > 1 || !(this.children[0] instanceof LeafChunk))) {
              var lines = [];
              this.collapse(lines);
              this.children = [new LeafChunk(lines)];
              this.children[0].parent = this;
            }
          },
          collapse: function(lines) {
            for (var i2 = 0; i2 < this.children.length; ++i2) {
              this.children[i2].collapse(lines);
            }
          },
          insertInner: function(at, lines, height) {
            this.size += lines.length;
            this.height += height;
            for (var i2 = 0; i2 < this.children.length; ++i2) {
              var child = this.children[i2], sz = child.chunkSize();
              if (at <= sz) {
                child.insertInner(at, lines, height);
                if (child.lines && child.lines.length > 50) {
                  var remaining = child.lines.length % 25 + 25;
                  for (var pos = remaining; pos < child.lines.length; ) {
                    var leaf = new LeafChunk(child.lines.slice(pos, pos += 25));
                    child.height -= leaf.height;
                    this.children.splice(++i2, 0, leaf);
                    leaf.parent = this;
                  }
                  child.lines = child.lines.slice(0, remaining);
                  this.maybeSpill();
                }
                break;
              }
              at -= sz;
            }
          },
          maybeSpill: function() {
            if (this.children.length <= 10) {
              return;
            }
            var me = this;
            do {
              var spilled = me.children.splice(me.children.length - 5, 5);
              var sibling = new BranchChunk(spilled);
              if (!me.parent) {
                var copy3 = new BranchChunk(me.children);
                copy3.parent = me;
                me.children = [copy3, sibling];
                me = copy3;
              } else {
                me.size -= sibling.size;
                me.height -= sibling.height;
                var myIndex = indexOf2(me.parent.children, me);
                me.parent.children.splice(myIndex + 1, 0, sibling);
              }
              sibling.parent = me.parent;
            } while (me.children.length > 10);
            me.parent.maybeSpill();
          },
          iterN: function(at, n, op) {
            for (var i2 = 0; i2 < this.children.length; ++i2) {
              var child = this.children[i2], sz = child.chunkSize();
              if (at < sz) {
                var used = Math.min(n, sz - at);
                if (child.iterN(at, used, op)) {
                  return true;
                }
                if ((n -= used) == 0) {
                  break;
                }
                at = 0;
              } else {
                at -= sz;
              }
            }
          }
        };
        var LineWidget = function(doc2, node, options) {
          if (options) {
            for (var opt in options) {
              if (options.hasOwnProperty(opt)) {
                this[opt] = options[opt];
              }
            }
          }
          this.doc = doc2;
          this.node = node;
        };
        LineWidget.prototype.clear = function() {
          var cm = this.doc.cm, ws = this.line.widgets, line = this.line, no = lineNo(line);
          if (no == null || !ws) {
            return;
          }
          for (var i2 = 0; i2 < ws.length; ++i2) {
            if (ws[i2] == this) {
              ws.splice(i2--, 1);
            }
          }
          if (!ws.length) {
            line.widgets = null;
          }
          var height = widgetHeight(this);
          updateLineHeight(line, Math.max(0, line.height - height));
          if (cm) {
            runInOp(cm, function() {
              adjustScrollWhenAboveVisible(cm, line, -height);
              regLineChange(cm, no, "widget");
            });
            signalLater(cm, "lineWidgetCleared", cm, this, no);
          }
        };
        LineWidget.prototype.changed = function() {
          var this$1 = this;
          var oldH = this.height, cm = this.doc.cm, line = this.line;
          this.height = null;
          var diff = widgetHeight(this) - oldH;
          if (!diff) {
            return;
          }
          if (!lineIsHidden(this.doc, line)) {
            updateLineHeight(line, line.height + diff);
          }
          if (cm) {
            runInOp(cm, function() {
              cm.curOp.forceUpdate = true;
              adjustScrollWhenAboveVisible(cm, line, diff);
              signalLater(cm, "lineWidgetChanged", cm, this$1, lineNo(line));
            });
          }
        };
        eventMixin(LineWidget);
        function adjustScrollWhenAboveVisible(cm, line, diff) {
          if (heightAtLine(line) < (cm.curOp && cm.curOp.scrollTop || cm.doc.scrollTop)) {
            addToScrollTop(cm, diff);
          }
        }
        function addLineWidget(doc2, handle, node, options) {
          var widget = new LineWidget(doc2, node, options);
          var cm = doc2.cm;
          if (cm && widget.noHScroll) {
            cm.display.alignWidgets = true;
          }
          changeLine(doc2, handle, "widget", function(line) {
            var widgets = line.widgets || (line.widgets = []);
            if (widget.insertAt == null) {
              widgets.push(widget);
            } else {
              widgets.splice(Math.min(widgets.length, Math.max(0, widget.insertAt)), 0, widget);
            }
            widget.line = line;
            if (cm && !lineIsHidden(doc2, line)) {
              var aboveVisible = heightAtLine(line) < doc2.scrollTop;
              updateLineHeight(line, line.height + widgetHeight(widget));
              if (aboveVisible) {
                addToScrollTop(cm, widget.height);
              }
              cm.curOp.forceUpdate = true;
            }
            return true;
          });
          if (cm) {
            signalLater(cm, "lineWidgetAdded", cm, widget, typeof handle == "number" ? handle : lineNo(handle));
          }
          return widget;
        }
        var nextMarkerId = 0;
        var TextMarker = function(doc2, type) {
          this.lines = [];
          this.type = type;
          this.doc = doc2;
          this.id = ++nextMarkerId;
        };
        TextMarker.prototype.clear = function() {
          if (this.explicitlyCleared) {
            return;
          }
          var cm = this.doc.cm, withOp = cm && !cm.curOp;
          if (withOp) {
            startOperation(cm);
          }
          if (hasHandler(this, "clear")) {
            var found = this.find();
            if (found) {
              signalLater(this, "clear", found.from, found.to);
            }
          }
          var min3 = null, max3 = null;
          for (var i2 = 0; i2 < this.lines.length; ++i2) {
            var line = this.lines[i2];
            var span = getMarkedSpanFor(line.markedSpans, this);
            if (cm && !this.collapsed) {
              regLineChange(cm, lineNo(line), "text");
            } else if (cm) {
              if (span.to != null) {
                max3 = lineNo(line);
              }
              if (span.from != null) {
                min3 = lineNo(line);
              }
            }
            line.markedSpans = removeMarkedSpan(line.markedSpans, span);
            if (span.from == null && this.collapsed && !lineIsHidden(this.doc, line) && cm) {
              updateLineHeight(line, textHeight(cm.display));
            }
          }
          if (cm && this.collapsed && !cm.options.lineWrapping) {
            for (var i$12 = 0; i$12 < this.lines.length; ++i$12) {
              var visual = visualLine(this.lines[i$12]), len2 = lineLength(visual);
              if (len2 > cm.display.maxLineLength) {
                cm.display.maxLine = visual;
                cm.display.maxLineLength = len2;
                cm.display.maxLineChanged = true;
              }
            }
          }
          if (min3 != null && cm && this.collapsed) {
            regChange(cm, min3, max3 + 1);
          }
          this.lines.length = 0;
          this.explicitlyCleared = true;
          if (this.atomic && this.doc.cantEdit) {
            this.doc.cantEdit = false;
            if (cm) {
              reCheckSelection(cm.doc);
            }
          }
          if (cm) {
            signalLater(cm, "markerCleared", cm, this, min3, max3);
          }
          if (withOp) {
            endOperation(cm);
          }
          if (this.parent) {
            this.parent.clear();
          }
        };
        TextMarker.prototype.find = function(side, lineObj) {
          if (side == null && this.type == "bookmark") {
            side = 1;
          }
          var from, to;
          for (var i2 = 0; i2 < this.lines.length; ++i2) {
            var line = this.lines[i2];
            var span = getMarkedSpanFor(line.markedSpans, this);
            if (span.from != null) {
              from = Pos(lineObj ? line : lineNo(line), span.from);
              if (side == -1) {
                return from;
              }
            }
            if (span.to != null) {
              to = Pos(lineObj ? line : lineNo(line), span.to);
              if (side == 1) {
                return to;
              }
            }
          }
          return from && { from, to };
        };
        TextMarker.prototype.changed = function() {
          var this$1 = this;
          var pos = this.find(-1, true), widget = this, cm = this.doc.cm;
          if (!pos || !cm) {
            return;
          }
          runInOp(cm, function() {
            var line = pos.line, lineN = lineNo(pos.line);
            var view = findViewForLine(cm, lineN);
            if (view) {
              clearLineMeasurementCacheFor(view);
              cm.curOp.selectionChanged = cm.curOp.forceUpdate = true;
            }
            cm.curOp.updateMaxLine = true;
            if (!lineIsHidden(widget.doc, line) && widget.height != null) {
              var oldHeight = widget.height;
              widget.height = null;
              var dHeight = widgetHeight(widget) - oldHeight;
              if (dHeight) {
                updateLineHeight(line, line.height + dHeight);
              }
            }
            signalLater(cm, "markerChanged", cm, this$1);
          });
        };
        TextMarker.prototype.attachLine = function(line) {
          if (!this.lines.length && this.doc.cm) {
            var op = this.doc.cm.curOp;
            if (!op.maybeHiddenMarkers || indexOf2(op.maybeHiddenMarkers, this) == -1) {
              (op.maybeUnhiddenMarkers || (op.maybeUnhiddenMarkers = [])).push(this);
            }
          }
          this.lines.push(line);
        };
        TextMarker.prototype.detachLine = function(line) {
          this.lines.splice(indexOf2(this.lines, line), 1);
          if (!this.lines.length && this.doc.cm) {
            var op = this.doc.cm.curOp;
            (op.maybeHiddenMarkers || (op.maybeHiddenMarkers = [])).push(this);
          }
        };
        eventMixin(TextMarker);
        function markText(doc2, from, to, options, type) {
          if (options && options.shared) {
            return markTextShared(doc2, from, to, options, type);
          }
          if (doc2.cm && !doc2.cm.curOp) {
            return operation(doc2.cm, markText)(doc2, from, to, options, type);
          }
          var marker = new TextMarker(doc2, type), diff = cmp(from, to);
          if (options) {
            copyObj(options, marker, false);
          }
          if (diff > 0 || diff == 0 && marker.clearWhenEmpty !== false) {
            return marker;
          }
          if (marker.replacedWith) {
            marker.collapsed = true;
            marker.widgetNode = eltP("span", [marker.replacedWith], "CodeMirror-widget");
            if (!options.handleMouseEvents) {
              marker.widgetNode.setAttribute("cm-ignore-events", "true");
            }
            if (options.insertLeft) {
              marker.widgetNode.insertLeft = true;
            }
          }
          if (marker.collapsed) {
            if (conflictingCollapsedRange(doc2, from.line, from, to, marker) || from.line != to.line && conflictingCollapsedRange(doc2, to.line, from, to, marker)) {
              throw new Error("Inserting collapsed marker partially overlapping an existing one");
            }
            seeCollapsedSpans();
          }
          if (marker.addToHistory) {
            addChangeToHistory(doc2, { from, to, origin: "markText" }, doc2.sel, NaN);
          }
          var curLine = from.line, cm = doc2.cm, updateMaxLine;
          doc2.iter(curLine, to.line + 1, function(line) {
            if (cm && marker.collapsed && !cm.options.lineWrapping && visualLine(line) == cm.display.maxLine) {
              updateMaxLine = true;
            }
            if (marker.collapsed && curLine != from.line) {
              updateLineHeight(line, 0);
            }
            addMarkedSpan(line, new MarkedSpan(marker, curLine == from.line ? from.ch : null, curLine == to.line ? to.ch : null), doc2.cm && doc2.cm.curOp);
            ++curLine;
          });
          if (marker.collapsed) {
            doc2.iter(from.line, to.line + 1, function(line) {
              if (lineIsHidden(doc2, line)) {
                updateLineHeight(line, 0);
              }
            });
          }
          if (marker.clearOnEnter) {
            on(marker, "beforeCursorEnter", function() {
              return marker.clear();
            });
          }
          if (marker.readOnly) {
            seeReadOnlySpans();
            if (doc2.history.done.length || doc2.history.undone.length) {
              doc2.clearHistory();
            }
          }
          if (marker.collapsed) {
            marker.id = ++nextMarkerId;
            marker.atomic = true;
          }
          if (cm) {
            if (updateMaxLine) {
              cm.curOp.updateMaxLine = true;
            }
            if (marker.collapsed) {
              regChange(cm, from.line, to.line + 1);
            } else if (marker.className || marker.startStyle || marker.endStyle || marker.css || marker.attributes || marker.title) {
              for (var i2 = from.line; i2 <= to.line; i2++) {
                regLineChange(cm, i2, "text");
              }
            }
            if (marker.atomic) {
              reCheckSelection(cm.doc);
            }
            signalLater(cm, "markerAdded", cm, marker);
          }
          return marker;
        }
        var SharedTextMarker = function(markers, primary) {
          this.markers = markers;
          this.primary = primary;
          for (var i2 = 0; i2 < markers.length; ++i2) {
            markers[i2].parent = this;
          }
        };
        SharedTextMarker.prototype.clear = function() {
          if (this.explicitlyCleared) {
            return;
          }
          this.explicitlyCleared = true;
          for (var i2 = 0; i2 < this.markers.length; ++i2) {
            this.markers[i2].clear();
          }
          signalLater(this, "clear");
        };
        SharedTextMarker.prototype.find = function(side, lineObj) {
          return this.primary.find(side, lineObj);
        };
        eventMixin(SharedTextMarker);
        function markTextShared(doc2, from, to, options, type) {
          options = copyObj(options);
          options.shared = false;
          var markers = [markText(doc2, from, to, options, type)], primary = markers[0];
          var widget = options.widgetNode;
          linkedDocs(doc2, function(doc3) {
            if (widget) {
              options.widgetNode = widget.cloneNode(true);
            }
            markers.push(markText(doc3, clipPos(doc3, from), clipPos(doc3, to), options, type));
            for (var i2 = 0; i2 < doc3.linked.length; ++i2) {
              if (doc3.linked[i2].isParent) {
                return;
              }
            }
            primary = lst(markers);
          });
          return new SharedTextMarker(markers, primary);
        }
        function findSharedMarkers(doc2) {
          return doc2.findMarks(Pos(doc2.first, 0), doc2.clipPos(Pos(doc2.lastLine())), function(m2) {
            return m2.parent;
          });
        }
        function copySharedMarkers(doc2, markers) {
          for (var i2 = 0; i2 < markers.length; i2++) {
            var marker = markers[i2], pos = marker.find();
            var mFrom = doc2.clipPos(pos.from), mTo = doc2.clipPos(pos.to);
            if (cmp(mFrom, mTo)) {
              var subMark = markText(doc2, mFrom, mTo, marker.primary, marker.primary.type);
              marker.markers.push(subMark);
              subMark.parent = marker;
            }
          }
        }
        function detachSharedMarkers(markers) {
          var loop = function(i3) {
            var marker = markers[i3], linked = [marker.primary.doc];
            linkedDocs(marker.primary.doc, function(d) {
              return linked.push(d);
            });
            for (var j = 0; j < marker.markers.length; j++) {
              var subMarker = marker.markers[j];
              if (indexOf2(linked, subMarker.doc) == -1) {
                subMarker.parent = null;
                marker.markers.splice(j--, 1);
              }
            }
          };
          for (var i2 = 0; i2 < markers.length; i2++)
            loop(i2);
        }
        var nextDocId = 0;
        var Doc = function(text, mode, firstLine, lineSep, direction) {
          if (!(this instanceof Doc)) {
            return new Doc(text, mode, firstLine, lineSep, direction);
          }
          if (firstLine == null) {
            firstLine = 0;
          }
          BranchChunk.call(this, [new LeafChunk([new Line3("", null)])]);
          this.first = firstLine;
          this.scrollTop = this.scrollLeft = 0;
          this.cantEdit = false;
          this.cleanGeneration = 1;
          this.modeFrontier = this.highlightFrontier = firstLine;
          var start2 = Pos(firstLine, 0);
          this.sel = simpleSelection(start2);
          this.history = new History(null);
          this.id = ++nextDocId;
          this.modeOption = mode;
          this.lineSep = lineSep;
          this.direction = direction == "rtl" ? "rtl" : "ltr";
          this.extend = false;
          if (typeof text == "string") {
            text = this.splitLines(text);
          }
          updateDoc(this, { from: start2, to: start2, text });
          setSelection(this, simpleSelection(start2), sel_dontScroll);
        };
        Doc.prototype = createObj(BranchChunk.prototype, {
          constructor: Doc,
          iter: function(from, to, op) {
            if (op) {
              this.iterN(from - this.first, to - from, op);
            } else {
              this.iterN(this.first, this.first + this.size, from);
            }
          },
          insert: function(at, lines) {
            var height = 0;
            for (var i2 = 0; i2 < lines.length; ++i2) {
              height += lines[i2].height;
            }
            this.insertInner(at - this.first, lines, height);
          },
          remove: function(at, n) {
            this.removeInner(at - this.first, n);
          },
          getValue: function(lineSep) {
            var lines = getLines(this, this.first, this.first + this.size);
            if (lineSep === false) {
              return lines;
            }
            return lines.join(lineSep || this.lineSeparator());
          },
          setValue: docMethodOp(function(code) {
            var top = Pos(this.first, 0), last = this.first + this.size - 1;
            makeChange(this, {
              from: top,
              to: Pos(last, getLine(this, last).text.length),
              text: this.splitLines(code),
              origin: "setValue",
              full: true
            }, true);
            if (this.cm) {
              scrollToCoords(this.cm, 0, 0);
            }
            setSelection(this, simpleSelection(top), sel_dontScroll);
          }),
          replaceRange: function(code, from, to, origin) {
            from = clipPos(this, from);
            to = to ? clipPos(this, to) : from;
            replaceRange(this, code, from, to, origin);
          },
          getRange: function(from, to, lineSep) {
            var lines = getBetween(this, clipPos(this, from), clipPos(this, to));
            if (lineSep === false) {
              return lines;
            }
            if (lineSep === "") {
              return lines.join("");
            }
            return lines.join(lineSep || this.lineSeparator());
          },
          getLine: function(line) {
            var l = this.getLineHandle(line);
            return l && l.text;
          },
          getLineHandle: function(line) {
            if (isLine(this, line)) {
              return getLine(this, line);
            }
          },
          getLineNumber: function(line) {
            return lineNo(line);
          },
          getLineHandleVisualStart: function(line) {
            if (typeof line == "number") {
              line = getLine(this, line);
            }
            return visualLine(line);
          },
          lineCount: function() {
            return this.size;
          },
          firstLine: function() {
            return this.first;
          },
          lastLine: function() {
            return this.first + this.size - 1;
          },
          clipPos: function(pos) {
            return clipPos(this, pos);
          },
          getCursor: function(start2) {
            var range2 = this.sel.primary(), pos;
            if (start2 == null || start2 == "head") {
              pos = range2.head;
            } else if (start2 == "anchor") {
              pos = range2.anchor;
            } else if (start2 == "end" || start2 == "to" || start2 === false) {
              pos = range2.to();
            } else {
              pos = range2.from();
            }
            return pos;
          },
          listSelections: function() {
            return this.sel.ranges;
          },
          somethingSelected: function() {
            return this.sel.somethingSelected();
          },
          setCursor: docMethodOp(function(line, ch, options) {
            setSimpleSelection(this, clipPos(this, typeof line == "number" ? Pos(line, ch || 0) : line), null, options);
          }),
          setSelection: docMethodOp(function(anchor, head, options) {
            setSimpleSelection(this, clipPos(this, anchor), clipPos(this, head || anchor), options);
          }),
          extendSelection: docMethodOp(function(head, other, options) {
            extendSelection(this, clipPos(this, head), other && clipPos(this, other), options);
          }),
          extendSelections: docMethodOp(function(heads, options) {
            extendSelections(this, clipPosArray(this, heads), options);
          }),
          extendSelectionsBy: docMethodOp(function(f, options) {
            var heads = map3(this.sel.ranges, f);
            extendSelections(this, clipPosArray(this, heads), options);
          }),
          setSelections: docMethodOp(function(ranges, primary, options) {
            if (!ranges.length) {
              return;
            }
            var out2 = [];
            for (var i2 = 0; i2 < ranges.length; i2++) {
              out2[i2] = new Range(clipPos(this, ranges[i2].anchor), clipPos(this, ranges[i2].head || ranges[i2].anchor));
            }
            if (primary == null) {
              primary = Math.min(ranges.length - 1, this.sel.primIndex);
            }
            setSelection(this, normalizeSelection(this.cm, out2, primary), options);
          }),
          addSelection: docMethodOp(function(anchor, head, options) {
            var ranges = this.sel.ranges.slice(0);
            ranges.push(new Range(clipPos(this, anchor), clipPos(this, head || anchor)));
            setSelection(this, normalizeSelection(this.cm, ranges, ranges.length - 1), options);
          }),
          getSelection: function(lineSep) {
            var ranges = this.sel.ranges, lines;
            for (var i2 = 0; i2 < ranges.length; i2++) {
              var sel = getBetween(this, ranges[i2].from(), ranges[i2].to());
              lines = lines ? lines.concat(sel) : sel;
            }
            if (lineSep === false) {
              return lines;
            } else {
              return lines.join(lineSep || this.lineSeparator());
            }
          },
          getSelections: function(lineSep) {
            var parts = [], ranges = this.sel.ranges;
            for (var i2 = 0; i2 < ranges.length; i2++) {
              var sel = getBetween(this, ranges[i2].from(), ranges[i2].to());
              if (lineSep !== false) {
                sel = sel.join(lineSep || this.lineSeparator());
              }
              parts[i2] = sel;
            }
            return parts;
          },
          replaceSelection: function(code, collapse, origin) {
            var dup = [];
            for (var i2 = 0; i2 < this.sel.ranges.length; i2++) {
              dup[i2] = code;
            }
            this.replaceSelections(dup, collapse, origin || "+input");
          },
          replaceSelections: docMethodOp(function(code, collapse, origin) {
            var changes = [], sel = this.sel;
            for (var i2 = 0; i2 < sel.ranges.length; i2++) {
              var range2 = sel.ranges[i2];
              changes[i2] = { from: range2.from(), to: range2.to(), text: this.splitLines(code[i2]), origin };
            }
            var newSel = collapse && collapse != "end" && computeReplacedSel(this, changes, collapse);
            for (var i$12 = changes.length - 1; i$12 >= 0; i$12--) {
              makeChange(this, changes[i$12]);
            }
            if (newSel) {
              setSelectionReplaceHistory(this, newSel);
            } else if (this.cm) {
              ensureCursorVisible(this.cm);
            }
          }),
          undo: docMethodOp(function() {
            makeChangeFromHistory(this, "undo");
          }),
          redo: docMethodOp(function() {
            makeChangeFromHistory(this, "redo");
          }),
          undoSelection: docMethodOp(function() {
            makeChangeFromHistory(this, "undo", true);
          }),
          redoSelection: docMethodOp(function() {
            makeChangeFromHistory(this, "redo", true);
          }),
          setExtending: function(val) {
            this.extend = val;
          },
          getExtending: function() {
            return this.extend;
          },
          historySize: function() {
            var hist = this.history, done = 0, undone = 0;
            for (var i2 = 0; i2 < hist.done.length; i2++) {
              if (!hist.done[i2].ranges) {
                ++done;
              }
            }
            for (var i$12 = 0; i$12 < hist.undone.length; i$12++) {
              if (!hist.undone[i$12].ranges) {
                ++undone;
              }
            }
            return { undo: done, redo: undone };
          },
          clearHistory: function() {
            var this$1 = this;
            this.history = new History(this.history);
            linkedDocs(this, function(doc2) {
              return doc2.history = this$1.history;
            }, true);
          },
          markClean: function() {
            this.cleanGeneration = this.changeGeneration(true);
          },
          changeGeneration: function(forceSplit) {
            if (forceSplit) {
              this.history.lastOp = this.history.lastSelOp = this.history.lastOrigin = null;
            }
            return this.history.generation;
          },
          isClean: function(gen) {
            return this.history.generation == (gen || this.cleanGeneration);
          },
          getHistory: function() {
            return {
              done: copyHistoryArray(this.history.done),
              undone: copyHistoryArray(this.history.undone)
            };
          },
          setHistory: function(histData) {
            var hist = this.history = new History(this.history);
            hist.done = copyHistoryArray(histData.done.slice(0), null, true);
            hist.undone = copyHistoryArray(histData.undone.slice(0), null, true);
          },
          setGutterMarker: docMethodOp(function(line, gutterID, value) {
            return changeLine(this, line, "gutter", function(line2) {
              var markers = line2.gutterMarkers || (line2.gutterMarkers = {});
              markers[gutterID] = value;
              if (!value && isEmpty(markers)) {
                line2.gutterMarkers = null;
              }
              return true;
            });
          }),
          clearGutter: docMethodOp(function(gutterID) {
            var this$1 = this;
            this.iter(function(line) {
              if (line.gutterMarkers && line.gutterMarkers[gutterID]) {
                changeLine(this$1, line, "gutter", function() {
                  line.gutterMarkers[gutterID] = null;
                  if (isEmpty(line.gutterMarkers)) {
                    line.gutterMarkers = null;
                  }
                  return true;
                });
              }
            });
          }),
          lineInfo: function(line) {
            var n;
            if (typeof line == "number") {
              if (!isLine(this, line)) {
                return null;
              }
              n = line;
              line = getLine(this, line);
              if (!line) {
                return null;
              }
            } else {
              n = lineNo(line);
              if (n == null) {
                return null;
              }
            }
            return {
              line: n,
              handle: line,
              text: line.text,
              gutterMarkers: line.gutterMarkers,
              textClass: line.textClass,
              bgClass: line.bgClass,
              wrapClass: line.wrapClass,
              widgets: line.widgets
            };
          },
          addLineClass: docMethodOp(function(handle, where, cls) {
            return changeLine(this, handle, where == "gutter" ? "gutter" : "class", function(line) {
              var prop2 = where == "text" ? "textClass" : where == "background" ? "bgClass" : where == "gutter" ? "gutterClass" : "wrapClass";
              if (!line[prop2]) {
                line[prop2] = cls;
              } else if (classTest(cls).test(line[prop2])) {
                return false;
              } else {
                line[prop2] += " " + cls;
              }
              return true;
            });
          }),
          removeLineClass: docMethodOp(function(handle, where, cls) {
            return changeLine(this, handle, where == "gutter" ? "gutter" : "class", function(line) {
              var prop2 = where == "text" ? "textClass" : where == "background" ? "bgClass" : where == "gutter" ? "gutterClass" : "wrapClass";
              var cur = line[prop2];
              if (!cur) {
                return false;
              } else if (cls == null) {
                line[prop2] = null;
              } else {
                var found = cur.match(classTest(cls));
                if (!found) {
                  return false;
                }
                var end2 = found.index + found[0].length;
                line[prop2] = cur.slice(0, found.index) + (!found.index || end2 == cur.length ? "" : " ") + cur.slice(end2) || null;
              }
              return true;
            });
          }),
          addLineWidget: docMethodOp(function(handle, node, options) {
            return addLineWidget(this, handle, node, options);
          }),
          removeLineWidget: function(widget) {
            widget.clear();
          },
          markText: function(from, to, options) {
            return markText(this, clipPos(this, from), clipPos(this, to), options, options && options.type || "range");
          },
          setBookmark: function(pos, options) {
            var realOpts = {
              replacedWith: options && (options.nodeType == null ? options.widget : options),
              insertLeft: options && options.insertLeft,
              clearWhenEmpty: false,
              shared: options && options.shared,
              handleMouseEvents: options && options.handleMouseEvents
            };
            pos = clipPos(this, pos);
            return markText(this, pos, pos, realOpts, "bookmark");
          },
          findMarksAt: function(pos) {
            pos = clipPos(this, pos);
            var markers = [], spans = getLine(this, pos.line).markedSpans;
            if (spans) {
              for (var i2 = 0; i2 < spans.length; ++i2) {
                var span = spans[i2];
                if ((span.from == null || span.from <= pos.ch) && (span.to == null || span.to >= pos.ch)) {
                  markers.push(span.marker.parent || span.marker);
                }
              }
            }
            return markers;
          },
          findMarks: function(from, to, filter2) {
            from = clipPos(this, from);
            to = clipPos(this, to);
            var found = [], lineNo2 = from.line;
            this.iter(from.line, to.line + 1, function(line) {
              var spans = line.markedSpans;
              if (spans) {
                for (var i2 = 0; i2 < spans.length; i2++) {
                  var span = spans[i2];
                  if (!(span.to != null && lineNo2 == from.line && from.ch >= span.to || span.from == null && lineNo2 != from.line || span.from != null && lineNo2 == to.line && span.from >= to.ch) && (!filter2 || filter2(span.marker))) {
                    found.push(span.marker.parent || span.marker);
                  }
                }
              }
              ++lineNo2;
            });
            return found;
          },
          getAllMarks: function() {
            var markers = [];
            this.iter(function(line) {
              var sps = line.markedSpans;
              if (sps) {
                for (var i2 = 0; i2 < sps.length; ++i2) {
                  if (sps[i2].from != null) {
                    markers.push(sps[i2].marker);
                  }
                }
              }
            });
            return markers;
          },
          posFromIndex: function(off2) {
            var ch, lineNo2 = this.first, sepSize = this.lineSeparator().length;
            this.iter(function(line) {
              var sz = line.text.length + sepSize;
              if (sz > off2) {
                ch = off2;
                return true;
              }
              off2 -= sz;
              ++lineNo2;
            });
            return clipPos(this, Pos(lineNo2, ch));
          },
          indexFromPos: function(coords) {
            coords = clipPos(this, coords);
            var index = coords.ch;
            if (coords.line < this.first || coords.ch < 0) {
              return 0;
            }
            var sepSize = this.lineSeparator().length;
            this.iter(this.first, coords.line, function(line) {
              index += line.text.length + sepSize;
            });
            return index;
          },
          copy: function(copyHistory) {
            var doc2 = new Doc(getLines(this, this.first, this.first + this.size), this.modeOption, this.first, this.lineSep, this.direction);
            doc2.scrollTop = this.scrollTop;
            doc2.scrollLeft = this.scrollLeft;
            doc2.sel = this.sel;
            doc2.extend = false;
            if (copyHistory) {
              doc2.history.undoDepth = this.history.undoDepth;
              doc2.setHistory(this.getHistory());
            }
            return doc2;
          },
          linkedDoc: function(options) {
            if (!options) {
              options = {};
            }
            var from = this.first, to = this.first + this.size;
            if (options.from != null && options.from > from) {
              from = options.from;
            }
            if (options.to != null && options.to < to) {
              to = options.to;
            }
            var copy3 = new Doc(getLines(this, from, to), options.mode || this.modeOption, from, this.lineSep, this.direction);
            if (options.sharedHist) {
              copy3.history = this.history;
            }
            (this.linked || (this.linked = [])).push({ doc: copy3, sharedHist: options.sharedHist });
            copy3.linked = [{ doc: this, isParent: true, sharedHist: options.sharedHist }];
            copySharedMarkers(copy3, findSharedMarkers(this));
            return copy3;
          },
          unlinkDoc: function(other) {
            if (other instanceof CodeMirror2) {
              other = other.doc;
            }
            if (this.linked) {
              for (var i2 = 0; i2 < this.linked.length; ++i2) {
                var link = this.linked[i2];
                if (link.doc != other) {
                  continue;
                }
                this.linked.splice(i2, 1);
                other.unlinkDoc(this);
                detachSharedMarkers(findSharedMarkers(this));
                break;
              }
            }
            if (other.history == this.history) {
              var splitIds = [other.id];
              linkedDocs(other, function(doc2) {
                return splitIds.push(doc2.id);
              }, true);
              other.history = new History(null);
              other.history.done = copyHistoryArray(this.history.done, splitIds);
              other.history.undone = copyHistoryArray(this.history.undone, splitIds);
            }
          },
          iterLinkedDocs: function(f) {
            linkedDocs(this, f);
          },
          getMode: function() {
            return this.mode;
          },
          getEditor: function() {
            return this.cm;
          },
          splitLines: function(str) {
            if (this.lineSep) {
              return str.split(this.lineSep);
            }
            return splitLinesAuto(str);
          },
          lineSeparator: function() {
            return this.lineSep || "\n";
          },
          setDirection: docMethodOp(function(dir3) {
            if (dir3 != "rtl") {
              dir3 = "ltr";
            }
            if (dir3 == this.direction) {
              return;
            }
            this.direction = dir3;
            this.iter(function(line) {
              return line.order = null;
            });
            if (this.cm) {
              directionChanged(this.cm);
            }
          })
        });
        Doc.prototype.eachLine = Doc.prototype.iter;
        var lastDrop = 0;
        function onDrop(e2) {
          var cm = this;
          clearDragCursor(cm);
          if (signalDOMEvent(cm, e2) || eventInWidget(cm.display, e2)) {
            return;
          }
          e_preventDefault(e2);
          if (ie) {
            lastDrop = +new Date();
          }
          var pos = posFromMouse(cm, e2, true), files = e2.dataTransfer.files;
          if (!pos || cm.isReadOnly()) {
            return;
          }
          if (files && files.length && window.FileReader && window.File) {
            var n = files.length, text = Array(n), read = 0;
            var markAsReadAndPasteIfAllFilesAreRead = function() {
              if (++read == n) {
                operation(cm, function() {
                  pos = clipPos(cm.doc, pos);
                  var change = {
                    from: pos,
                    to: pos,
                    text: cm.doc.splitLines(text.filter(function(t) {
                      return t != null;
                    }).join(cm.doc.lineSeparator())),
                    origin: "paste"
                  };
                  makeChange(cm.doc, change);
                  setSelectionReplaceHistory(cm.doc, simpleSelection(clipPos(cm.doc, pos), clipPos(cm.doc, changeEnd(change))));
                })();
              }
            };
            var readTextFromFile = function(file, i3) {
              if (cm.options.allowDropFileTypes && indexOf2(cm.options.allowDropFileTypes, file.type) == -1) {
                markAsReadAndPasteIfAllFilesAreRead();
                return;
              }
              var reader = new FileReader();
              reader.onerror = function() {
                return markAsReadAndPasteIfAllFilesAreRead();
              };
              reader.onload = function() {
                var content = reader.result;
                if (/[\x00-\x08\x0e-\x1f]{2}/.test(content)) {
                  markAsReadAndPasteIfAllFilesAreRead();
                  return;
                }
                text[i3] = content;
                markAsReadAndPasteIfAllFilesAreRead();
              };
              reader.readAsText(file);
            };
            for (var i2 = 0; i2 < files.length; i2++) {
              readTextFromFile(files[i2], i2);
            }
          } else {
            if (cm.state.draggingText && cm.doc.sel.contains(pos) > -1) {
              cm.state.draggingText(e2);
              setTimeout(function() {
                return cm.display.input.focus();
              }, 20);
              return;
            }
            try {
              var text$1 = e2.dataTransfer.getData("Text");
              if (text$1) {
                var selected;
                if (cm.state.draggingText && !cm.state.draggingText.copy) {
                  selected = cm.listSelections();
                }
                setSelectionNoUndo(cm.doc, simpleSelection(pos, pos));
                if (selected) {
                  for (var i$12 = 0; i$12 < selected.length; ++i$12) {
                    replaceRange(cm.doc, "", selected[i$12].anchor, selected[i$12].head, "drag");
                  }
                }
                cm.replaceSelection(text$1, "around", "paste");
                cm.display.input.focus();
              }
            } catch (e$1) {
            }
          }
        }
        function onDragStart(cm, e2) {
          if (ie && (!cm.state.draggingText || +new Date() - lastDrop < 100)) {
            e_stop(e2);
            return;
          }
          if (signalDOMEvent(cm, e2) || eventInWidget(cm.display, e2)) {
            return;
          }
          e2.dataTransfer.setData("Text", cm.getSelection());
          e2.dataTransfer.effectAllowed = "copyMove";
          if (e2.dataTransfer.setDragImage && !safari) {
            var img = elt("img", null, null, "position: fixed; left: 0; top: 0;");
            img.src = "data:image/gif;base64,R0lGODlhAQABAAAAACH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==";
            if (presto) {
              img.width = img.height = 1;
              cm.display.wrapper.appendChild(img);
              img._top = img.offsetTop;
            }
            e2.dataTransfer.setDragImage(img, 0, 0);
            if (presto) {
              img.parentNode.removeChild(img);
            }
          }
        }
        function onDragOver(cm, e2) {
          var pos = posFromMouse(cm, e2);
          if (!pos) {
            return;
          }
          var frag = document.createDocumentFragment();
          drawSelectionCursor(cm, pos, frag);
          if (!cm.display.dragCursor) {
            cm.display.dragCursor = elt("div", null, "CodeMirror-cursors CodeMirror-dragcursors");
            cm.display.lineSpace.insertBefore(cm.display.dragCursor, cm.display.cursorDiv);
          }
          removeChildrenAndAdd(cm.display.dragCursor, frag);
        }
        function clearDragCursor(cm) {
          if (cm.display.dragCursor) {
            cm.display.lineSpace.removeChild(cm.display.dragCursor);
            cm.display.dragCursor = null;
          }
        }
        function forEachCodeMirror(f) {
          if (!document.getElementsByClassName) {
            return;
          }
          var byClass = document.getElementsByClassName("CodeMirror"), editors = [];
          for (var i2 = 0; i2 < byClass.length; i2++) {
            var cm = byClass[i2].CodeMirror;
            if (cm) {
              editors.push(cm);
            }
          }
          if (editors.length) {
            editors[0].operation(function() {
              for (var i3 = 0; i3 < editors.length; i3++) {
                f(editors[i3]);
              }
            });
          }
        }
        var globalsRegistered = false;
        function ensureGlobalHandlers() {
          if (globalsRegistered) {
            return;
          }
          registerGlobalHandlers();
          globalsRegistered = true;
        }
        function registerGlobalHandlers() {
          var resizeTimer;
          on(window, "resize", function() {
            if (resizeTimer == null) {
              resizeTimer = setTimeout(function() {
                resizeTimer = null;
                forEachCodeMirror(onResize);
              }, 100);
            }
          });
          on(window, "blur", function() {
            return forEachCodeMirror(onBlur);
          });
        }
        function onResize(cm) {
          var d = cm.display;
          d.cachedCharWidth = d.cachedTextHeight = d.cachedPaddingH = null;
          d.scrollbarsClipped = false;
          cm.setSize();
        }
        var keyNames = {
          3: "Pause",
          8: "Backspace",
          9: "Tab",
          13: "Enter",
          16: "Shift",
          17: "Ctrl",
          18: "Alt",
          19: "Pause",
          20: "CapsLock",
          27: "Esc",
          32: "Space",
          33: "PageUp",
          34: "PageDown",
          35: "End",
          36: "Home",
          37: "Left",
          38: "Up",
          39: "Right",
          40: "Down",
          44: "PrintScrn",
          45: "Insert",
          46: "Delete",
          59: ";",
          61: "=",
          91: "Mod",
          92: "Mod",
          93: "Mod",
          106: "*",
          107: "=",
          109: "-",
          110: ".",
          111: "/",
          145: "ScrollLock",
          173: "-",
          186: ";",
          187: "=",
          188: ",",
          189: "-",
          190: ".",
          191: "/",
          192: "`",
          219: "[",
          220: "\\",
          221: "]",
          222: "'",
          224: "Mod",
          63232: "Up",
          63233: "Down",
          63234: "Left",
          63235: "Right",
          63272: "Delete",
          63273: "Home",
          63275: "End",
          63276: "PageUp",
          63277: "PageDown",
          63302: "Insert"
        };
        for (var i = 0; i < 10; i++) {
          keyNames[i + 48] = keyNames[i + 96] = String(i);
        }
        for (var i$1 = 65; i$1 <= 90; i$1++) {
          keyNames[i$1] = String.fromCharCode(i$1);
        }
        for (var i$2 = 1; i$2 <= 12; i$2++) {
          keyNames[i$2 + 111] = keyNames[i$2 + 63235] = "F" + i$2;
        }
        var keyMap = {};
        keyMap.basic = {
          "Left": "goCharLeft",
          "Right": "goCharRight",
          "Up": "goLineUp",
          "Down": "goLineDown",
          "End": "goLineEnd",
          "Home": "goLineStartSmart",
          "PageUp": "goPageUp",
          "PageDown": "goPageDown",
          "Delete": "delCharAfter",
          "Backspace": "delCharBefore",
          "Shift-Backspace": "delCharBefore",
          "Tab": "defaultTab",
          "Shift-Tab": "indentAuto",
          "Enter": "newlineAndIndent",
          "Insert": "toggleOverwrite",
          "Esc": "singleSelection"
        };
        keyMap.pcDefault = {
          "Ctrl-A": "selectAll",
          "Ctrl-D": "deleteLine",
          "Ctrl-Z": "undo",
          "Shift-Ctrl-Z": "redo",
          "Ctrl-Y": "redo",
          "Ctrl-Home": "goDocStart",
          "Ctrl-End": "goDocEnd",
          "Ctrl-Up": "goLineUp",
          "Ctrl-Down": "goLineDown",
          "Ctrl-Left": "goGroupLeft",
          "Ctrl-Right": "goGroupRight",
          "Alt-Left": "goLineStart",
          "Alt-Right": "goLineEnd",
          "Ctrl-Backspace": "delGroupBefore",
          "Ctrl-Delete": "delGroupAfter",
          "Ctrl-S": "save",
          "Ctrl-F": "find",
          "Ctrl-G": "findNext",
          "Shift-Ctrl-G": "findPrev",
          "Shift-Ctrl-F": "replace",
          "Shift-Ctrl-R": "replaceAll",
          "Ctrl-[": "indentLess",
          "Ctrl-]": "indentMore",
          "Ctrl-U": "undoSelection",
          "Shift-Ctrl-U": "redoSelection",
          "Alt-U": "redoSelection",
          "fallthrough": "basic"
        };
        keyMap.emacsy = {
          "Ctrl-F": "goCharRight",
          "Ctrl-B": "goCharLeft",
          "Ctrl-P": "goLineUp",
          "Ctrl-N": "goLineDown",
          "Ctrl-A": "goLineStart",
          "Ctrl-E": "goLineEnd",
          "Ctrl-V": "goPageDown",
          "Shift-Ctrl-V": "goPageUp",
          "Ctrl-D": "delCharAfter",
          "Ctrl-H": "delCharBefore",
          "Alt-Backspace": "delWordBefore",
          "Ctrl-K": "killLine",
          "Ctrl-T": "transposeChars",
          "Ctrl-O": "openLine"
        };
        keyMap.macDefault = {
          "Cmd-A": "selectAll",
          "Cmd-D": "deleteLine",
          "Cmd-Z": "undo",
          "Shift-Cmd-Z": "redo",
          "Cmd-Y": "redo",
          "Cmd-Home": "goDocStart",
          "Cmd-Up": "goDocStart",
          "Cmd-End": "goDocEnd",
          "Cmd-Down": "goDocEnd",
          "Alt-Left": "goGroupLeft",
          "Alt-Right": "goGroupRight",
          "Cmd-Left": "goLineLeft",
          "Cmd-Right": "goLineRight",
          "Alt-Backspace": "delGroupBefore",
          "Ctrl-Alt-Backspace": "delGroupAfter",
          "Alt-Delete": "delGroupAfter",
          "Cmd-S": "save",
          "Cmd-F": "find",
          "Cmd-G": "findNext",
          "Shift-Cmd-G": "findPrev",
          "Cmd-Alt-F": "replace",
          "Shift-Cmd-Alt-F": "replaceAll",
          "Cmd-[": "indentLess",
          "Cmd-]": "indentMore",
          "Cmd-Backspace": "delWrappedLineLeft",
          "Cmd-Delete": "delWrappedLineRight",
          "Cmd-U": "undoSelection",
          "Shift-Cmd-U": "redoSelection",
          "Ctrl-Up": "goDocStart",
          "Ctrl-Down": "goDocEnd",
          "fallthrough": ["basic", "emacsy"]
        };
        keyMap["default"] = mac ? keyMap.macDefault : keyMap.pcDefault;
        function normalizeKeyName(name) {
          var parts = name.split(/-(?!$)/);
          name = parts[parts.length - 1];
          var alt, ctrl, shift, cmd;
          for (var i2 = 0; i2 < parts.length - 1; i2++) {
            var mod = parts[i2];
            if (/^(cmd|meta|m)$/i.test(mod)) {
              cmd = true;
            } else if (/^a(lt)?$/i.test(mod)) {
              alt = true;
            } else if (/^(c|ctrl|control)$/i.test(mod)) {
              ctrl = true;
            } else if (/^s(hift)?$/i.test(mod)) {
              shift = true;
            } else {
              throw new Error("Unrecognized modifier name: " + mod);
            }
          }
          if (alt) {
            name = "Alt-" + name;
          }
          if (ctrl) {
            name = "Ctrl-" + name;
          }
          if (cmd) {
            name = "Cmd-" + name;
          }
          if (shift) {
            name = "Shift-" + name;
          }
          return name;
        }
        function normalizeKeyMap(keymap) {
          var copy3 = {};
          for (var keyname in keymap) {
            if (keymap.hasOwnProperty(keyname)) {
              var value = keymap[keyname];
              if (/^(name|fallthrough|(de|at)tach)$/.test(keyname)) {
                continue;
              }
              if (value == "...") {
                delete keymap[keyname];
                continue;
              }
              var keys2 = map3(keyname.split(" "), normalizeKeyName);
              for (var i2 = 0; i2 < keys2.length; i2++) {
                var val = void 0, name = void 0;
                if (i2 == keys2.length - 1) {
                  name = keys2.join(" ");
                  val = value;
                } else {
                  name = keys2.slice(0, i2 + 1).join(" ");
                  val = "...";
                }
                var prev = copy3[name];
                if (!prev) {
                  copy3[name] = val;
                } else if (prev != val) {
                  throw new Error("Inconsistent bindings for " + name);
                }
              }
              delete keymap[keyname];
            }
          }
          for (var prop2 in copy3) {
            keymap[prop2] = copy3[prop2];
          }
          return keymap;
        }
        function lookupKey(key, map4, handle, context) {
          map4 = getKeyMap(map4);
          var found = map4.call ? map4.call(key, context) : map4[key];
          if (found === false) {
            return "nothing";
          }
          if (found === "...") {
            return "multi";
          }
          if (found != null && handle(found)) {
            return "handled";
          }
          if (map4.fallthrough) {
            if (Object.prototype.toString.call(map4.fallthrough) != "[object Array]") {
              return lookupKey(key, map4.fallthrough, handle, context);
            }
            for (var i2 = 0; i2 < map4.fallthrough.length; i2++) {
              var result = lookupKey(key, map4.fallthrough[i2], handle, context);
              if (result) {
                return result;
              }
            }
          }
        }
        function isModifierKey(value) {
          var name = typeof value == "string" ? value : keyNames[value.keyCode];
          return name == "Ctrl" || name == "Alt" || name == "Shift" || name == "Mod";
        }
        function addModifierNames(name, event, noShift) {
          var base2 = name;
          if (event.altKey && base2 != "Alt") {
            name = "Alt-" + name;
          }
          if ((flipCtrlCmd ? event.metaKey : event.ctrlKey) && base2 != "Ctrl") {
            name = "Ctrl-" + name;
          }
          if ((flipCtrlCmd ? event.ctrlKey : event.metaKey) && base2 != "Mod") {
            name = "Cmd-" + name;
          }
          if (!noShift && event.shiftKey && base2 != "Shift") {
            name = "Shift-" + name;
          }
          return name;
        }
        function keyName(event, noShift) {
          if (presto && event.keyCode == 34 && event["char"]) {
            return false;
          }
          var name = keyNames[event.keyCode];
          if (name == null || event.altGraphKey) {
            return false;
          }
          if (event.keyCode == 3 && event.code) {
            name = event.code;
          }
          return addModifierNames(name, event, noShift);
        }
        function getKeyMap(val) {
          return typeof val == "string" ? keyMap[val] : val;
        }
        function deleteNearSelection(cm, compute) {
          var ranges = cm.doc.sel.ranges, kill = [];
          for (var i2 = 0; i2 < ranges.length; i2++) {
            var toKill = compute(ranges[i2]);
            while (kill.length && cmp(toKill.from, lst(kill).to) <= 0) {
              var replaced = kill.pop();
              if (cmp(replaced.from, toKill.from) < 0) {
                toKill.from = replaced.from;
                break;
              }
            }
            kill.push(toKill);
          }
          runInOp(cm, function() {
            for (var i3 = kill.length - 1; i3 >= 0; i3--) {
              replaceRange(cm.doc, "", kill[i3].from, kill[i3].to, "+delete");
            }
            ensureCursorVisible(cm);
          });
        }
        function moveCharLogically(line, ch, dir3) {
          var target = skipExtendingChars(line.text, ch + dir3, dir3);
          return target < 0 || target > line.text.length ? null : target;
        }
        function moveLogically(line, start2, dir3) {
          var ch = moveCharLogically(line, start2.ch, dir3);
          return ch == null ? null : new Pos(start2.line, ch, dir3 < 0 ? "after" : "before");
        }
        function endOfLine(visually, cm, lineObj, lineNo2, dir3) {
          if (visually) {
            if (cm.doc.direction == "rtl") {
              dir3 = -dir3;
            }
            var order = getOrder(lineObj, cm.doc.direction);
            if (order) {
              var part = dir3 < 0 ? lst(order) : order[0];
              var moveInStorageOrder = dir3 < 0 == (part.level == 1);
              var sticky = moveInStorageOrder ? "after" : "before";
              var ch;
              if (part.level > 0 || cm.doc.direction == "rtl") {
                var prep = prepareMeasureForLine(cm, lineObj);
                ch = dir3 < 0 ? lineObj.text.length - 1 : 0;
                var targetTop = measureCharPrepared(cm, prep, ch).top;
                ch = findFirst(function(ch2) {
                  return measureCharPrepared(cm, prep, ch2).top == targetTop;
                }, dir3 < 0 == (part.level == 1) ? part.from : part.to - 1, ch);
                if (sticky == "before") {
                  ch = moveCharLogically(lineObj, ch, 1);
                }
              } else {
                ch = dir3 < 0 ? part.to : part.from;
              }
              return new Pos(lineNo2, ch, sticky);
            }
          }
          return new Pos(lineNo2, dir3 < 0 ? lineObj.text.length : 0, dir3 < 0 ? "before" : "after");
        }
        function moveVisually(cm, line, start2, dir3) {
          var bidi = getOrder(line, cm.doc.direction);
          if (!bidi) {
            return moveLogically(line, start2, dir3);
          }
          if (start2.ch >= line.text.length) {
            start2.ch = line.text.length;
            start2.sticky = "before";
          } else if (start2.ch <= 0) {
            start2.ch = 0;
            start2.sticky = "after";
          }
          var partPos = getBidiPartAt(bidi, start2.ch, start2.sticky), part = bidi[partPos];
          if (cm.doc.direction == "ltr" && part.level % 2 == 0 && (dir3 > 0 ? part.to > start2.ch : part.from < start2.ch)) {
            return moveLogically(line, start2, dir3);
          }
          var mv = function(pos, dir4) {
            return moveCharLogically(line, pos instanceof Pos ? pos.ch : pos, dir4);
          };
          var prep;
          var getWrappedLineExtent = function(ch2) {
            if (!cm.options.lineWrapping) {
              return { begin: 0, end: line.text.length };
            }
            prep = prep || prepareMeasureForLine(cm, line);
            return wrappedLineExtentChar(cm, line, prep, ch2);
          };
          var wrappedLineExtent2 = getWrappedLineExtent(start2.sticky == "before" ? mv(start2, -1) : start2.ch);
          if (cm.doc.direction == "rtl" || part.level == 1) {
            var moveInStorageOrder = part.level == 1 == dir3 < 0;
            var ch = mv(start2, moveInStorageOrder ? 1 : -1);
            if (ch != null && (!moveInStorageOrder ? ch >= part.from && ch >= wrappedLineExtent2.begin : ch <= part.to && ch <= wrappedLineExtent2.end)) {
              var sticky = moveInStorageOrder ? "before" : "after";
              return new Pos(start2.line, ch, sticky);
            }
          }
          var searchInVisualLine = function(partPos2, dir4, wrappedLineExtent3) {
            var getRes = function(ch3, moveInStorageOrder3) {
              return moveInStorageOrder3 ? new Pos(start2.line, mv(ch3, 1), "before") : new Pos(start2.line, ch3, "after");
            };
            for (; partPos2 >= 0 && partPos2 < bidi.length; partPos2 += dir4) {
              var part2 = bidi[partPos2];
              var moveInStorageOrder2 = dir4 > 0 == (part2.level != 1);
              var ch2 = moveInStorageOrder2 ? wrappedLineExtent3.begin : mv(wrappedLineExtent3.end, -1);
              if (part2.from <= ch2 && ch2 < part2.to) {
                return getRes(ch2, moveInStorageOrder2);
              }
              ch2 = moveInStorageOrder2 ? part2.from : mv(part2.to, -1);
              if (wrappedLineExtent3.begin <= ch2 && ch2 < wrappedLineExtent3.end) {
                return getRes(ch2, moveInStorageOrder2);
              }
            }
          };
          var res = searchInVisualLine(partPos + dir3, dir3, wrappedLineExtent2);
          if (res) {
            return res;
          }
          var nextCh = dir3 > 0 ? wrappedLineExtent2.end : mv(wrappedLineExtent2.begin, -1);
          if (nextCh != null && !(dir3 > 0 && nextCh == line.text.length)) {
            res = searchInVisualLine(dir3 > 0 ? 0 : bidi.length - 1, dir3, getWrappedLineExtent(nextCh));
            if (res) {
              return res;
            }
          }
          return null;
        }
        var commands = {
          selectAll,
          singleSelection: function(cm) {
            return cm.setSelection(cm.getCursor("anchor"), cm.getCursor("head"), sel_dontScroll);
          },
          killLine: function(cm) {
            return deleteNearSelection(cm, function(range2) {
              if (range2.empty()) {
                var len2 = getLine(cm.doc, range2.head.line).text.length;
                if (range2.head.ch == len2 && range2.head.line < cm.lastLine()) {
                  return { from: range2.head, to: Pos(range2.head.line + 1, 0) };
                } else {
                  return { from: range2.head, to: Pos(range2.head.line, len2) };
                }
              } else {
                return { from: range2.from(), to: range2.to() };
              }
            });
          },
          deleteLine: function(cm) {
            return deleteNearSelection(cm, function(range2) {
              return {
                from: Pos(range2.from().line, 0),
                to: clipPos(cm.doc, Pos(range2.to().line + 1, 0))
              };
            });
          },
          delLineLeft: function(cm) {
            return deleteNearSelection(cm, function(range2) {
              return {
                from: Pos(range2.from().line, 0),
                to: range2.from()
              };
            });
          },
          delWrappedLineLeft: function(cm) {
            return deleteNearSelection(cm, function(range2) {
              var top = cm.charCoords(range2.head, "div").top + 5;
              var leftPos = cm.coordsChar({ left: 0, top }, "div");
              return { from: leftPos, to: range2.from() };
            });
          },
          delWrappedLineRight: function(cm) {
            return deleteNearSelection(cm, function(range2) {
              var top = cm.charCoords(range2.head, "div").top + 5;
              var rightPos = cm.coordsChar({ left: cm.display.lineDiv.offsetWidth + 100, top }, "div");
              return { from: range2.from(), to: rightPos };
            });
          },
          undo: function(cm) {
            return cm.undo();
          },
          redo: function(cm) {
            return cm.redo();
          },
          undoSelection: function(cm) {
            return cm.undoSelection();
          },
          redoSelection: function(cm) {
            return cm.redoSelection();
          },
          goDocStart: function(cm) {
            return cm.extendSelection(Pos(cm.firstLine(), 0));
          },
          goDocEnd: function(cm) {
            return cm.extendSelection(Pos(cm.lastLine()));
          },
          goLineStart: function(cm) {
            return cm.extendSelectionsBy(function(range2) {
              return lineStart(cm, range2.head.line);
            }, { origin: "+move", bias: 1 });
          },
          goLineStartSmart: function(cm) {
            return cm.extendSelectionsBy(function(range2) {
              return lineStartSmart(cm, range2.head);
            }, { origin: "+move", bias: 1 });
          },
          goLineEnd: function(cm) {
            return cm.extendSelectionsBy(function(range2) {
              return lineEnd(cm, range2.head.line);
            }, { origin: "+move", bias: -1 });
          },
          goLineRight: function(cm) {
            return cm.extendSelectionsBy(function(range2) {
              var top = cm.cursorCoords(range2.head, "div").top + 5;
              return cm.coordsChar({ left: cm.display.lineDiv.offsetWidth + 100, top }, "div");
            }, sel_move);
          },
          goLineLeft: function(cm) {
            return cm.extendSelectionsBy(function(range2) {
              var top = cm.cursorCoords(range2.head, "div").top + 5;
              return cm.coordsChar({ left: 0, top }, "div");
            }, sel_move);
          },
          goLineLeftSmart: function(cm) {
            return cm.extendSelectionsBy(function(range2) {
              var top = cm.cursorCoords(range2.head, "div").top + 5;
              var pos = cm.coordsChar({ left: 0, top }, "div");
              if (pos.ch < cm.getLine(pos.line).search(/\S/)) {
                return lineStartSmart(cm, range2.head);
              }
              return pos;
            }, sel_move);
          },
          goLineUp: function(cm) {
            return cm.moveV(-1, "line");
          },
          goLineDown: function(cm) {
            return cm.moveV(1, "line");
          },
          goPageUp: function(cm) {
            return cm.moveV(-1, "page");
          },
          goPageDown: function(cm) {
            return cm.moveV(1, "page");
          },
          goCharLeft: function(cm) {
            return cm.moveH(-1, "char");
          },
          goCharRight: function(cm) {
            return cm.moveH(1, "char");
          },
          goColumnLeft: function(cm) {
            return cm.moveH(-1, "column");
          },
          goColumnRight: function(cm) {
            return cm.moveH(1, "column");
          },
          goWordLeft: function(cm) {
            return cm.moveH(-1, "word");
          },
          goGroupRight: function(cm) {
            return cm.moveH(1, "group");
          },
          goGroupLeft: function(cm) {
            return cm.moveH(-1, "group");
          },
          goWordRight: function(cm) {
            return cm.moveH(1, "word");
          },
          delCharBefore: function(cm) {
            return cm.deleteH(-1, "codepoint");
          },
          delCharAfter: function(cm) {
            return cm.deleteH(1, "char");
          },
          delWordBefore: function(cm) {
            return cm.deleteH(-1, "word");
          },
          delWordAfter: function(cm) {
            return cm.deleteH(1, "word");
          },
          delGroupBefore: function(cm) {
            return cm.deleteH(-1, "group");
          },
          delGroupAfter: function(cm) {
            return cm.deleteH(1, "group");
          },
          indentAuto: function(cm) {
            return cm.indentSelection("smart");
          },
          indentMore: function(cm) {
            return cm.indentSelection("add");
          },
          indentLess: function(cm) {
            return cm.indentSelection("subtract");
          },
          insertTab: function(cm) {
            return cm.replaceSelection("	");
          },
          insertSoftTab: function(cm) {
            var spaces = [], ranges = cm.listSelections(), tabSize = cm.options.tabSize;
            for (var i2 = 0; i2 < ranges.length; i2++) {
              var pos = ranges[i2].from();
              var col = countColumn(cm.getLine(pos.line), pos.ch, tabSize);
              spaces.push(spaceStr(tabSize - col % tabSize));
            }
            cm.replaceSelections(spaces);
          },
          defaultTab: function(cm) {
            if (cm.somethingSelected()) {
              cm.indentSelection("add");
            } else {
              cm.execCommand("insertTab");
            }
          },
          transposeChars: function(cm) {
            return runInOp(cm, function() {
              var ranges = cm.listSelections(), newSel = [];
              for (var i2 = 0; i2 < ranges.length; i2++) {
                if (!ranges[i2].empty()) {
                  continue;
                }
                var cur = ranges[i2].head, line = getLine(cm.doc, cur.line).text;
                if (line) {
                  if (cur.ch == line.length) {
                    cur = new Pos(cur.line, cur.ch - 1);
                  }
                  if (cur.ch > 0) {
                    cur = new Pos(cur.line, cur.ch + 1);
                    cm.replaceRange(line.charAt(cur.ch - 1) + line.charAt(cur.ch - 2), Pos(cur.line, cur.ch - 2), cur, "+transpose");
                  } else if (cur.line > cm.doc.first) {
                    var prev = getLine(cm.doc, cur.line - 1).text;
                    if (prev) {
                      cur = new Pos(cur.line, 1);
                      cm.replaceRange(line.charAt(0) + cm.doc.lineSeparator() + prev.charAt(prev.length - 1), Pos(cur.line - 1, prev.length - 1), cur, "+transpose");
                    }
                  }
                }
                newSel.push(new Range(cur, cur));
              }
              cm.setSelections(newSel);
            });
          },
          newlineAndIndent: function(cm) {
            return runInOp(cm, function() {
              var sels = cm.listSelections();
              for (var i2 = sels.length - 1; i2 >= 0; i2--) {
                cm.replaceRange(cm.doc.lineSeparator(), sels[i2].anchor, sels[i2].head, "+input");
              }
              sels = cm.listSelections();
              for (var i$12 = 0; i$12 < sels.length; i$12++) {
                cm.indentLine(sels[i$12].from().line, null, true);
              }
              ensureCursorVisible(cm);
            });
          },
          openLine: function(cm) {
            return cm.replaceSelection("\n", "start");
          },
          toggleOverwrite: function(cm) {
            return cm.toggleOverwrite();
          }
        };
        function lineStart(cm, lineN) {
          var line = getLine(cm.doc, lineN);
          var visual = visualLine(line);
          if (visual != line) {
            lineN = lineNo(visual);
          }
          return endOfLine(true, cm, visual, lineN, 1);
        }
        function lineEnd(cm, lineN) {
          var line = getLine(cm.doc, lineN);
          var visual = visualLineEnd(line);
          if (visual != line) {
            lineN = lineNo(visual);
          }
          return endOfLine(true, cm, line, lineN, -1);
        }
        function lineStartSmart(cm, pos) {
          var start2 = lineStart(cm, pos.line);
          var line = getLine(cm.doc, start2.line);
          var order = getOrder(line, cm.doc.direction);
          if (!order || order[0].level == 0) {
            var firstNonWS = Math.max(start2.ch, line.text.search(/\S/));
            var inWS = pos.line == start2.line && pos.ch <= firstNonWS && pos.ch;
            return Pos(start2.line, inWS ? 0 : firstNonWS, start2.sticky);
          }
          return start2;
        }
        function doHandleBinding(cm, bound, dropShift) {
          if (typeof bound == "string") {
            bound = commands[bound];
            if (!bound) {
              return false;
            }
          }
          cm.display.input.ensurePolled();
          var prevShift = cm.display.shift, done = false;
          try {
            if (cm.isReadOnly()) {
              cm.state.suppressEdits = true;
            }
            if (dropShift) {
              cm.display.shift = false;
            }
            done = bound(cm) != Pass;
          } finally {
            cm.display.shift = prevShift;
            cm.state.suppressEdits = false;
          }
          return done;
        }
        function lookupKeyForEditor(cm, name, handle) {
          for (var i2 = 0; i2 < cm.state.keyMaps.length; i2++) {
            var result = lookupKey(name, cm.state.keyMaps[i2], handle, cm);
            if (result) {
              return result;
            }
          }
          return cm.options.extraKeys && lookupKey(name, cm.options.extraKeys, handle, cm) || lookupKey(name, cm.options.keyMap, handle, cm);
        }
        var stopSeq = new Delayed();
        function dispatchKey(cm, name, e2, handle) {
          var seq = cm.state.keySeq;
          if (seq) {
            if (isModifierKey(name)) {
              return "handled";
            }
            if (/\'$/.test(name)) {
              cm.state.keySeq = null;
            } else {
              stopSeq.set(50, function() {
                if (cm.state.keySeq == seq) {
                  cm.state.keySeq = null;
                  cm.display.input.reset();
                }
              });
            }
            if (dispatchKeyInner(cm, seq + " " + name, e2, handle)) {
              return true;
            }
          }
          return dispatchKeyInner(cm, name, e2, handle);
        }
        function dispatchKeyInner(cm, name, e2, handle) {
          var result = lookupKeyForEditor(cm, name, handle);
          if (result == "multi") {
            cm.state.keySeq = name;
          }
          if (result == "handled") {
            signalLater(cm, "keyHandled", cm, name, e2);
          }
          if (result == "handled" || result == "multi") {
            e_preventDefault(e2);
            restartBlink(cm);
          }
          return !!result;
        }
        function handleKeyBinding(cm, e2) {
          var name = keyName(e2, true);
          if (!name) {
            return false;
          }
          if (e2.shiftKey && !cm.state.keySeq) {
            return dispatchKey(cm, "Shift-" + name, e2, function(b) {
              return doHandleBinding(cm, b, true);
            }) || dispatchKey(cm, name, e2, function(b) {
              if (typeof b == "string" ? /^go[A-Z]/.test(b) : b.motion) {
                return doHandleBinding(cm, b);
              }
            });
          } else {
            return dispatchKey(cm, name, e2, function(b) {
              return doHandleBinding(cm, b);
            });
          }
        }
        function handleCharBinding(cm, e2, ch) {
          return dispatchKey(cm, "'" + ch + "'", e2, function(b) {
            return doHandleBinding(cm, b, true);
          });
        }
        var lastStoppedKey = null;
        function onKeyDown(e2) {
          var cm = this;
          if (e2.target && e2.target != cm.display.input.getField()) {
            return;
          }
          cm.curOp.focus = activeElt(doc(cm));
          if (signalDOMEvent(cm, e2)) {
            return;
          }
          if (ie && ie_version < 11 && e2.keyCode == 27) {
            e2.returnValue = false;
          }
          var code = e2.keyCode;
          cm.display.shift = code == 16 || e2.shiftKey;
          var handled = handleKeyBinding(cm, e2);
          if (presto) {
            lastStoppedKey = handled ? code : null;
            if (!handled && code == 88 && !hasCopyEvent && (mac ? e2.metaKey : e2.ctrlKey)) {
              cm.replaceSelection("", null, "cut");
            }
          }
          if (gecko && !mac && !handled && code == 46 && e2.shiftKey && !e2.ctrlKey && document.execCommand) {
            document.execCommand("cut");
          }
          if (code == 18 && !/\bCodeMirror-crosshair\b/.test(cm.display.lineDiv.className)) {
            showCrossHair(cm);
          }
        }
        function showCrossHair(cm) {
          var lineDiv = cm.display.lineDiv;
          addClass(lineDiv, "CodeMirror-crosshair");
          function up(e2) {
            if (e2.keyCode == 18 || !e2.altKey) {
              rmClass(lineDiv, "CodeMirror-crosshair");
              off(document, "keyup", up);
              off(document, "mouseover", up);
            }
          }
          on(document, "keyup", up);
          on(document, "mouseover", up);
        }
        function onKeyUp(e2) {
          if (e2.keyCode == 16) {
            this.doc.sel.shift = false;
          }
          signalDOMEvent(this, e2);
        }
        function onKeyPress(e2) {
          var cm = this;
          if (e2.target && e2.target != cm.display.input.getField()) {
            return;
          }
          if (eventInWidget(cm.display, e2) || signalDOMEvent(cm, e2) || e2.ctrlKey && !e2.altKey || mac && e2.metaKey) {
            return;
          }
          var keyCode = e2.keyCode, charCode = e2.charCode;
          if (presto && keyCode == lastStoppedKey) {
            lastStoppedKey = null;
            e_preventDefault(e2);
            return;
          }
          if (presto && (!e2.which || e2.which < 10) && handleKeyBinding(cm, e2)) {
            return;
          }
          var ch = String.fromCharCode(charCode == null ? keyCode : charCode);
          if (ch == "\b") {
            return;
          }
          if (handleCharBinding(cm, e2, ch)) {
            return;
          }
          cm.display.input.onKeyPress(e2);
        }
        var DOUBLECLICK_DELAY = 400;
        var PastClick = function(time, pos, button) {
          this.time = time;
          this.pos = pos;
          this.button = button;
        };
        PastClick.prototype.compare = function(time, pos, button) {
          return this.time + DOUBLECLICK_DELAY > time && cmp(pos, this.pos) == 0 && button == this.button;
        };
        var lastClick, lastDoubleClick;
        function clickRepeat(pos, button) {
          var now = +new Date();
          if (lastDoubleClick && lastDoubleClick.compare(now, pos, button)) {
            lastClick = lastDoubleClick = null;
            return "triple";
          } else if (lastClick && lastClick.compare(now, pos, button)) {
            lastDoubleClick = new PastClick(now, pos, button);
            lastClick = null;
            return "double";
          } else {
            lastClick = new PastClick(now, pos, button);
            lastDoubleClick = null;
            return "single";
          }
        }
        function onMouseDown(e2) {
          var cm = this, display = cm.display;
          if (signalDOMEvent(cm, e2) || display.activeTouch && display.input.supportsTouch()) {
            return;
          }
          display.input.ensurePolled();
          display.shift = e2.shiftKey;
          if (eventInWidget(display, e2)) {
            if (!webkit) {
              display.scroller.draggable = false;
              setTimeout(function() {
                return display.scroller.draggable = true;
              }, 100);
            }
            return;
          }
          if (clickInGutter(cm, e2)) {
            return;
          }
          var pos = posFromMouse(cm, e2), button = e_button(e2), repeat = pos ? clickRepeat(pos, button) : "single";
          win(cm).focus();
          if (button == 1 && cm.state.selectingText) {
            cm.state.selectingText(e2);
          }
          if (pos && handleMappedButton(cm, button, pos, repeat, e2)) {
            return;
          }
          if (button == 1) {
            if (pos) {
              leftButtonDown(cm, pos, repeat, e2);
            } else if (e_target(e2) == display.scroller) {
              e_preventDefault(e2);
            }
          } else if (button == 2) {
            if (pos) {
              extendSelection(cm.doc, pos);
            }
            setTimeout(function() {
              return display.input.focus();
            }, 20);
          } else if (button == 3) {
            if (captureRightClick) {
              cm.display.input.onContextMenu(e2);
            } else {
              delayBlurEvent(cm);
            }
          }
        }
        function handleMappedButton(cm, button, pos, repeat, event) {
          var name = "Click";
          if (repeat == "double") {
            name = "Double" + name;
          } else if (repeat == "triple") {
            name = "Triple" + name;
          }
          name = (button == 1 ? "Left" : button == 2 ? "Middle" : "Right") + name;
          return dispatchKey(cm, addModifierNames(name, event), event, function(bound) {
            if (typeof bound == "string") {
              bound = commands[bound];
            }
            if (!bound) {
              return false;
            }
            var done = false;
            try {
              if (cm.isReadOnly()) {
                cm.state.suppressEdits = true;
              }
              done = bound(cm, pos) != Pass;
            } finally {
              cm.state.suppressEdits = false;
            }
            return done;
          });
        }
        function configureMouse(cm, repeat, event) {
          var option = cm.getOption("configureMouse");
          var value = option ? option(cm, repeat, event) : {};
          if (value.unit == null) {
            var rect = chromeOS ? event.shiftKey && event.metaKey : event.altKey;
            value.unit = rect ? "rectangle" : repeat == "single" ? "char" : repeat == "double" ? "word" : "line";
          }
          if (value.extend == null || cm.doc.extend) {
            value.extend = cm.doc.extend || event.shiftKey;
          }
          if (value.addNew == null) {
            value.addNew = mac ? event.metaKey : event.ctrlKey;
          }
          if (value.moveOnDrag == null) {
            value.moveOnDrag = !(mac ? event.altKey : event.ctrlKey);
          }
          return value;
        }
        function leftButtonDown(cm, pos, repeat, event) {
          if (ie) {
            setTimeout(bind3(ensureFocus, cm), 0);
          } else {
            cm.curOp.focus = activeElt(doc(cm));
          }
          var behavior = configureMouse(cm, repeat, event);
          var sel = cm.doc.sel, contained;
          if (cm.options.dragDrop && dragAndDrop && !cm.isReadOnly() && repeat == "single" && (contained = sel.contains(pos)) > -1 && (cmp((contained = sel.ranges[contained]).from(), pos) < 0 || pos.xRel > 0) && (cmp(contained.to(), pos) > 0 || pos.xRel < 0)) {
            leftButtonStartDrag(cm, event, pos, behavior);
          } else {
            leftButtonSelect(cm, event, pos, behavior);
          }
        }
        function leftButtonStartDrag(cm, event, pos, behavior) {
          var display = cm.display, moved = false;
          var dragEnd = operation(cm, function(e2) {
            if (webkit) {
              display.scroller.draggable = false;
            }
            cm.state.draggingText = false;
            if (cm.state.delayingBlurEvent) {
              if (cm.hasFocus()) {
                cm.state.delayingBlurEvent = false;
              } else {
                delayBlurEvent(cm);
              }
            }
            off(display.wrapper.ownerDocument, "mouseup", dragEnd);
            off(display.wrapper.ownerDocument, "mousemove", mouseMove);
            off(display.scroller, "dragstart", dragStart);
            off(display.scroller, "drop", dragEnd);
            if (!moved) {
              e_preventDefault(e2);
              if (!behavior.addNew) {
                extendSelection(cm.doc, pos, null, null, behavior.extend);
              }
              if (webkit && !safari || ie && ie_version == 9) {
                setTimeout(function() {
                  display.wrapper.ownerDocument.body.focus({ preventScroll: true });
                  display.input.focus();
                }, 20);
              } else {
                display.input.focus();
              }
            }
          });
          var mouseMove = function(e2) {
            moved = moved || Math.abs(event.clientX - e2.clientX) + Math.abs(event.clientY - e2.clientY) >= 10;
          };
          var dragStart = function() {
            return moved = true;
          };
          if (webkit) {
            display.scroller.draggable = true;
          }
          cm.state.draggingText = dragEnd;
          dragEnd.copy = !behavior.moveOnDrag;
          on(display.wrapper.ownerDocument, "mouseup", dragEnd);
          on(display.wrapper.ownerDocument, "mousemove", mouseMove);
          on(display.scroller, "dragstart", dragStart);
          on(display.scroller, "drop", dragEnd);
          cm.state.delayingBlurEvent = true;
          setTimeout(function() {
            return display.input.focus();
          }, 20);
          if (display.scroller.dragDrop) {
            display.scroller.dragDrop();
          }
        }
        function rangeForUnit(cm, pos, unit) {
          if (unit == "char") {
            return new Range(pos, pos);
          }
          if (unit == "word") {
            return cm.findWordAt(pos);
          }
          if (unit == "line") {
            return new Range(Pos(pos.line, 0), clipPos(cm.doc, Pos(pos.line + 1, 0)));
          }
          var result = unit(cm, pos);
          return new Range(result.from, result.to);
        }
        function leftButtonSelect(cm, event, start2, behavior) {
          if (ie) {
            delayBlurEvent(cm);
          }
          var display = cm.display, doc$1 = cm.doc;
          e_preventDefault(event);
          var ourRange, ourIndex, startSel = doc$1.sel, ranges = startSel.ranges;
          if (behavior.addNew && !behavior.extend) {
            ourIndex = doc$1.sel.contains(start2);
            if (ourIndex > -1) {
              ourRange = ranges[ourIndex];
            } else {
              ourRange = new Range(start2, start2);
            }
          } else {
            ourRange = doc$1.sel.primary();
            ourIndex = doc$1.sel.primIndex;
          }
          if (behavior.unit == "rectangle") {
            if (!behavior.addNew) {
              ourRange = new Range(start2, start2);
            }
            start2 = posFromMouse(cm, event, true, true);
            ourIndex = -1;
          } else {
            var range2 = rangeForUnit(cm, start2, behavior.unit);
            if (behavior.extend) {
              ourRange = extendRange(ourRange, range2.anchor, range2.head, behavior.extend);
            } else {
              ourRange = range2;
            }
          }
          if (!behavior.addNew) {
            ourIndex = 0;
            setSelection(doc$1, new Selection([ourRange], 0), sel_mouse);
            startSel = doc$1.sel;
          } else if (ourIndex == -1) {
            ourIndex = ranges.length;
            setSelection(doc$1, normalizeSelection(cm, ranges.concat([ourRange]), ourIndex), { scroll: false, origin: "*mouse" });
          } else if (ranges.length > 1 && ranges[ourIndex].empty() && behavior.unit == "char" && !behavior.extend) {
            setSelection(doc$1, normalizeSelection(cm, ranges.slice(0, ourIndex).concat(ranges.slice(ourIndex + 1)), 0), { scroll: false, origin: "*mouse" });
            startSel = doc$1.sel;
          } else {
            replaceOneSelection(doc$1, ourIndex, ourRange, sel_mouse);
          }
          var lastPos = start2;
          function extendTo(pos) {
            if (cmp(lastPos, pos) == 0) {
              return;
            }
            lastPos = pos;
            if (behavior.unit == "rectangle") {
              var ranges2 = [], tabSize = cm.options.tabSize;
              var startCol = countColumn(getLine(doc$1, start2.line).text, start2.ch, tabSize);
              var posCol = countColumn(getLine(doc$1, pos.line).text, pos.ch, tabSize);
              var left = Math.min(startCol, posCol), right = Math.max(startCol, posCol);
              for (var line = Math.min(start2.line, pos.line), end2 = Math.min(cm.lastLine(), Math.max(start2.line, pos.line)); line <= end2; line++) {
                var text = getLine(doc$1, line).text, leftPos = findColumn(text, left, tabSize);
                if (left == right) {
                  ranges2.push(new Range(Pos(line, leftPos), Pos(line, leftPos)));
                } else if (text.length > leftPos) {
                  ranges2.push(new Range(Pos(line, leftPos), Pos(line, findColumn(text, right, tabSize))));
                }
              }
              if (!ranges2.length) {
                ranges2.push(new Range(start2, start2));
              }
              setSelection(doc$1, normalizeSelection(cm, startSel.ranges.slice(0, ourIndex).concat(ranges2), ourIndex), { origin: "*mouse", scroll: false });
              cm.scrollIntoView(pos);
            } else {
              var oldRange = ourRange;
              var range3 = rangeForUnit(cm, pos, behavior.unit);
              var anchor = oldRange.anchor, head;
              if (cmp(range3.anchor, anchor) > 0) {
                head = range3.head;
                anchor = minPos(oldRange.from(), range3.anchor);
              } else {
                head = range3.anchor;
                anchor = maxPos(oldRange.to(), range3.head);
              }
              var ranges$1 = startSel.ranges.slice(0);
              ranges$1[ourIndex] = bidiSimplify(cm, new Range(clipPos(doc$1, anchor), head));
              setSelection(doc$1, normalizeSelection(cm, ranges$1, ourIndex), sel_mouse);
            }
          }
          var editorSize = display.wrapper.getBoundingClientRect();
          var counter = 0;
          function extend2(e2) {
            var curCount = ++counter;
            var cur = posFromMouse(cm, e2, true, behavior.unit == "rectangle");
            if (!cur) {
              return;
            }
            if (cmp(cur, lastPos) != 0) {
              cm.curOp.focus = activeElt(doc(cm));
              extendTo(cur);
              var visible = visibleLines(display, doc$1);
              if (cur.line >= visible.to || cur.line < visible.from) {
                setTimeout(operation(cm, function() {
                  if (counter == curCount) {
                    extend2(e2);
                  }
                }), 150);
              }
            } else {
              var outside = e2.clientY < editorSize.top ? -20 : e2.clientY > editorSize.bottom ? 20 : 0;
              if (outside) {
                setTimeout(operation(cm, function() {
                  if (counter != curCount) {
                    return;
                  }
                  display.scroller.scrollTop += outside;
                  extend2(e2);
                }), 50);
              }
            }
          }
          function done(e2) {
            cm.state.selectingText = false;
            counter = Infinity;
            if (e2) {
              e_preventDefault(e2);
              display.input.focus();
            }
            off(display.wrapper.ownerDocument, "mousemove", move);
            off(display.wrapper.ownerDocument, "mouseup", up);
            doc$1.history.lastSelOrigin = null;
          }
          var move = operation(cm, function(e2) {
            if (e2.buttons === 0 || !e_button(e2)) {
              done(e2);
            } else {
              extend2(e2);
            }
          });
          var up = operation(cm, done);
          cm.state.selectingText = up;
          on(display.wrapper.ownerDocument, "mousemove", move);
          on(display.wrapper.ownerDocument, "mouseup", up);
        }
        function bidiSimplify(cm, range2) {
          var anchor = range2.anchor;
          var head = range2.head;
          var anchorLine = getLine(cm.doc, anchor.line);
          if (cmp(anchor, head) == 0 && anchor.sticky == head.sticky) {
            return range2;
          }
          var order = getOrder(anchorLine);
          if (!order) {
            return range2;
          }
          var index = getBidiPartAt(order, anchor.ch, anchor.sticky), part = order[index];
          if (part.from != anchor.ch && part.to != anchor.ch) {
            return range2;
          }
          var boundary = index + (part.from == anchor.ch == (part.level != 1) ? 0 : 1);
          if (boundary == 0 || boundary == order.length) {
            return range2;
          }
          var leftSide;
          if (head.line != anchor.line) {
            leftSide = (head.line - anchor.line) * (cm.doc.direction == "ltr" ? 1 : -1) > 0;
          } else {
            var headIndex = getBidiPartAt(order, head.ch, head.sticky);
            var dir3 = headIndex - index || (head.ch - anchor.ch) * (part.level == 1 ? -1 : 1);
            if (headIndex == boundary - 1 || headIndex == boundary) {
              leftSide = dir3 < 0;
            } else {
              leftSide = dir3 > 0;
            }
          }
          var usePart = order[boundary + (leftSide ? -1 : 0)];
          var from = leftSide == (usePart.level == 1);
          var ch = from ? usePart.from : usePart.to, sticky = from ? "after" : "before";
          return anchor.ch == ch && anchor.sticky == sticky ? range2 : new Range(new Pos(anchor.line, ch, sticky), head);
        }
        function gutterEvent(cm, e2, type, prevent) {
          var mX, mY;
          if (e2.touches) {
            mX = e2.touches[0].clientX;
            mY = e2.touches[0].clientY;
          } else {
            try {
              mX = e2.clientX;
              mY = e2.clientY;
            } catch (e$1) {
              return false;
            }
          }
          if (mX >= Math.floor(cm.display.gutters.getBoundingClientRect().right)) {
            return false;
          }
          if (prevent) {
            e_preventDefault(e2);
          }
          var display = cm.display;
          var lineBox = display.lineDiv.getBoundingClientRect();
          if (mY > lineBox.bottom || !hasHandler(cm, type)) {
            return e_defaultPrevented(e2);
          }
          mY -= lineBox.top - display.viewOffset;
          for (var i2 = 0; i2 < cm.display.gutterSpecs.length; ++i2) {
            var g = display.gutters.childNodes[i2];
            if (g && g.getBoundingClientRect().right >= mX) {
              var line = lineAtHeight(cm.doc, mY);
              var gutter = cm.display.gutterSpecs[i2];
              signal(cm, type, cm, line, gutter.className, e2);
              return e_defaultPrevented(e2);
            }
          }
        }
        function clickInGutter(cm, e2) {
          return gutterEvent(cm, e2, "gutterClick", true);
        }
        function onContextMenu(cm, e2) {
          if (eventInWidget(cm.display, e2) || contextMenuInGutter(cm, e2)) {
            return;
          }
          if (signalDOMEvent(cm, e2, "contextmenu")) {
            return;
          }
          if (!captureRightClick) {
            cm.display.input.onContextMenu(e2);
          }
        }
        function contextMenuInGutter(cm, e2) {
          if (!hasHandler(cm, "gutterContextMenu")) {
            return false;
          }
          return gutterEvent(cm, e2, "gutterContextMenu", false);
        }
        function themeChanged(cm) {
          cm.display.wrapper.className = cm.display.wrapper.className.replace(/\s*cm-s-\S+/g, "") + cm.options.theme.replace(/(^|\s)\s*/g, " cm-s-");
          clearCaches(cm);
        }
        var Init = { toString: function() {
          return "CodeMirror.Init";
        } };
        var defaults2 = {};
        var optionHandlers = {};
        function defineOptions(CodeMirror3) {
          var optionHandlers2 = CodeMirror3.optionHandlers;
          function option(name, deflt, handle, notOnInit) {
            CodeMirror3.defaults[name] = deflt;
            if (handle) {
              optionHandlers2[name] = notOnInit ? function(cm, val, old) {
                if (old != Init) {
                  handle(cm, val, old);
                }
              } : handle;
            }
          }
          CodeMirror3.defineOption = option;
          CodeMirror3.Init = Init;
          option("value", "", function(cm, val) {
            return cm.setValue(val);
          }, true);
          option("mode", null, function(cm, val) {
            cm.doc.modeOption = val;
            loadMode(cm);
          }, true);
          option("indentUnit", 2, loadMode, true);
          option("indentWithTabs", false);
          option("smartIndent", true);
          option("tabSize", 4, function(cm) {
            resetModeState(cm);
            clearCaches(cm);
            regChange(cm);
          }, true);
          option("lineSeparator", null, function(cm, val) {
            cm.doc.lineSep = val;
            if (!val) {
              return;
            }
            var newBreaks = [], lineNo2 = cm.doc.first;
            cm.doc.iter(function(line) {
              for (var pos = 0; ; ) {
                var found = line.text.indexOf(val, pos);
                if (found == -1) {
                  break;
                }
                pos = found + val.length;
                newBreaks.push(Pos(lineNo2, found));
              }
              lineNo2++;
            });
            for (var i2 = newBreaks.length - 1; i2 >= 0; i2--) {
              replaceRange(cm.doc, val, newBreaks[i2], Pos(newBreaks[i2].line, newBreaks[i2].ch + val.length));
            }
          });
          option("specialChars", /[\u0000-\u001f\u007f-\u009f\u00ad\u061c\u200b\u200e\u200f\u2028\u2029\u202d\u202e\u2066\u2067\u2069\ufeff\ufff9-\ufffc]/g, function(cm, val, old) {
            cm.state.specialChars = new RegExp(val.source + (val.test("	") ? "" : "|	"), "g");
            if (old != Init) {
              cm.refresh();
            }
          });
          option("specialCharPlaceholder", defaultSpecialCharPlaceholder, function(cm) {
            return cm.refresh();
          }, true);
          option("electricChars", true);
          option("inputStyle", mobile ? "contenteditable" : "textarea", function() {
            throw new Error("inputStyle can not (yet) be changed in a running editor");
          }, true);
          option("spellcheck", false, function(cm, val) {
            return cm.getInputField().spellcheck = val;
          }, true);
          option("autocorrect", false, function(cm, val) {
            return cm.getInputField().autocorrect = val;
          }, true);
          option("autocapitalize", false, function(cm, val) {
            return cm.getInputField().autocapitalize = val;
          }, true);
          option("rtlMoveVisually", !windows);
          option("wholeLineUpdateBefore", true);
          option("theme", "default", function(cm) {
            themeChanged(cm);
            updateGutters(cm);
          }, true);
          option("keyMap", "default", function(cm, val, old) {
            var next = getKeyMap(val);
            var prev = old != Init && getKeyMap(old);
            if (prev && prev.detach) {
              prev.detach(cm, next);
            }
            if (next.attach) {
              next.attach(cm, prev || null);
            }
          });
          option("extraKeys", null);
          option("configureMouse", null);
          option("lineWrapping", false, wrappingChanged, true);
          option("gutters", [], function(cm, val) {
            cm.display.gutterSpecs = getGutters(val, cm.options.lineNumbers);
            updateGutters(cm);
          }, true);
          option("fixedGutter", true, function(cm, val) {
            cm.display.gutters.style.left = val ? compensateForHScroll(cm.display) + "px" : "0";
            cm.refresh();
          }, true);
          option("coverGutterNextToScrollbar", false, function(cm) {
            return updateScrollbars(cm);
          }, true);
          option("scrollbarStyle", "native", function(cm) {
            initScrollbars(cm);
            updateScrollbars(cm);
            cm.display.scrollbars.setScrollTop(cm.doc.scrollTop);
            cm.display.scrollbars.setScrollLeft(cm.doc.scrollLeft);
          }, true);
          option("lineNumbers", false, function(cm, val) {
            cm.display.gutterSpecs = getGutters(cm.options.gutters, val);
            updateGutters(cm);
          }, true);
          option("firstLineNumber", 1, updateGutters, true);
          option("lineNumberFormatter", function(integer) {
            return integer;
          }, updateGutters, true);
          option("showCursorWhenSelecting", false, updateSelection, true);
          option("resetSelectionOnContextMenu", true);
          option("lineWiseCopyCut", true);
          option("pasteLinesPerSelection", true);
          option("selectionsMayTouch", false);
          option("readOnly", false, function(cm, val) {
            if (val == "nocursor") {
              onBlur(cm);
              cm.display.input.blur();
            }
            cm.display.input.readOnlyChanged(val);
          });
          option("screenReaderLabel", null, function(cm, val) {
            val = val === "" ? null : val;
            cm.display.input.screenReaderLabelChanged(val);
          });
          option("disableInput", false, function(cm, val) {
            if (!val) {
              cm.display.input.reset();
            }
          }, true);
          option("dragDrop", true, dragDropChanged);
          option("allowDropFileTypes", null);
          option("cursorBlinkRate", 530);
          option("cursorScrollMargin", 0);
          option("cursorHeight", 1, updateSelection, true);
          option("singleCursorHeightPerLine", true, updateSelection, true);
          option("workTime", 100);
          option("workDelay", 100);
          option("flattenSpans", true, resetModeState, true);
          option("addModeClass", false, resetModeState, true);
          option("pollInterval", 100);
          option("undoDepth", 200, function(cm, val) {
            return cm.doc.history.undoDepth = val;
          });
          option("historyEventDelay", 1250);
          option("viewportMargin", 10, function(cm) {
            return cm.refresh();
          }, true);
          option("maxHighlightLength", 1e4, resetModeState, true);
          option("moveInputWithCursor", true, function(cm, val) {
            if (!val) {
              cm.display.input.resetPosition();
            }
          });
          option("tabindex", null, function(cm, val) {
            return cm.display.input.getField().tabIndex = val || "";
          });
          option("autofocus", null);
          option("direction", "ltr", function(cm, val) {
            return cm.doc.setDirection(val);
          }, true);
          option("phrases", null);
        }
        function dragDropChanged(cm, value, old) {
          var wasOn = old && old != Init;
          if (!value != !wasOn) {
            var funcs = cm.display.dragFunctions;
            var toggle = value ? on : off;
            toggle(cm.display.scroller, "dragstart", funcs.start);
            toggle(cm.display.scroller, "dragenter", funcs.enter);
            toggle(cm.display.scroller, "dragover", funcs.over);
            toggle(cm.display.scroller, "dragleave", funcs.leave);
            toggle(cm.display.scroller, "drop", funcs.drop);
          }
        }
        function wrappingChanged(cm) {
          if (cm.options.lineWrapping) {
            addClass(cm.display.wrapper, "CodeMirror-wrap");
            cm.display.sizer.style.minWidth = "";
            cm.display.sizerWidth = null;
          } else {
            rmClass(cm.display.wrapper, "CodeMirror-wrap");
            findMaxLine(cm);
          }
          estimateLineHeights(cm);
          regChange(cm);
          clearCaches(cm);
          setTimeout(function() {
            return updateScrollbars(cm);
          }, 100);
        }
        function CodeMirror2(place, options) {
          var this$1 = this;
          if (!(this instanceof CodeMirror2)) {
            return new CodeMirror2(place, options);
          }
          this.options = options = options ? copyObj(options) : {};
          copyObj(defaults2, options, false);
          var doc2 = options.value;
          if (typeof doc2 == "string") {
            doc2 = new Doc(doc2, options.mode, null, options.lineSeparator, options.direction);
          } else if (options.mode) {
            doc2.modeOption = options.mode;
          }
          this.doc = doc2;
          var input = new CodeMirror2.inputStyles[options.inputStyle](this);
          var display = this.display = new Display(place, doc2, input, options);
          display.wrapper.CodeMirror = this;
          themeChanged(this);
          if (options.lineWrapping) {
            this.display.wrapper.className += " CodeMirror-wrap";
          }
          initScrollbars(this);
          this.state = {
            keyMaps: [],
            overlays: [],
            modeGen: 0,
            overwrite: false,
            delayingBlurEvent: false,
            focused: false,
            suppressEdits: false,
            pasteIncoming: -1,
            cutIncoming: -1,
            selectingText: false,
            draggingText: false,
            highlight: new Delayed(),
            keySeq: null,
            specialChars: null
          };
          if (options.autofocus && !mobile) {
            display.input.focus();
          }
          if (ie && ie_version < 11) {
            setTimeout(function() {
              return this$1.display.input.reset(true);
            }, 20);
          }
          registerEventHandlers(this);
          ensureGlobalHandlers();
          startOperation(this);
          this.curOp.forceUpdate = true;
          attachDoc(this, doc2);
          if (options.autofocus && !mobile || this.hasFocus()) {
            setTimeout(function() {
              if (this$1.hasFocus() && !this$1.state.focused) {
                onFocus(this$1);
              }
            }, 20);
          } else {
            onBlur(this);
          }
          for (var opt in optionHandlers) {
            if (optionHandlers.hasOwnProperty(opt)) {
              optionHandlers[opt](this, options[opt], Init);
            }
          }
          maybeUpdateLineNumberWidth(this);
          if (options.finishInit) {
            options.finishInit(this);
          }
          for (var i2 = 0; i2 < initHooks.length; ++i2) {
            initHooks[i2](this);
          }
          endOperation(this);
          if (webkit && options.lineWrapping && getComputedStyle(display.lineDiv).textRendering == "optimizelegibility") {
            display.lineDiv.style.textRendering = "auto";
          }
        }
        CodeMirror2.defaults = defaults2;
        CodeMirror2.optionHandlers = optionHandlers;
        function registerEventHandlers(cm) {
          var d = cm.display;
          on(d.scroller, "mousedown", operation(cm, onMouseDown));
          if (ie && ie_version < 11) {
            on(d.scroller, "dblclick", operation(cm, function(e2) {
              if (signalDOMEvent(cm, e2)) {
                return;
              }
              var pos = posFromMouse(cm, e2);
              if (!pos || clickInGutter(cm, e2) || eventInWidget(cm.display, e2)) {
                return;
              }
              e_preventDefault(e2);
              var word = cm.findWordAt(pos);
              extendSelection(cm.doc, word.anchor, word.head);
            }));
          } else {
            on(d.scroller, "dblclick", function(e2) {
              return signalDOMEvent(cm, e2) || e_preventDefault(e2);
            });
          }
          on(d.scroller, "contextmenu", function(e2) {
            return onContextMenu(cm, e2);
          });
          on(d.input.getField(), "contextmenu", function(e2) {
            if (!d.scroller.contains(e2.target)) {
              onContextMenu(cm, e2);
            }
          });
          var touchFinished, prevTouch = { end: 0 };
          function finishTouch() {
            if (d.activeTouch) {
              touchFinished = setTimeout(function() {
                return d.activeTouch = null;
              }, 1e3);
              prevTouch = d.activeTouch;
              prevTouch.end = +new Date();
            }
          }
          function isMouseLikeTouchEvent(e2) {
            if (e2.touches.length != 1) {
              return false;
            }
            var touch = e2.touches[0];
            return touch.radiusX <= 1 && touch.radiusY <= 1;
          }
          function farAway(touch, other) {
            if (other.left == null) {
              return true;
            }
            var dx = other.left - touch.left, dy = other.top - touch.top;
            return dx * dx + dy * dy > 20 * 20;
          }
          on(d.scroller, "touchstart", function(e2) {
            if (!signalDOMEvent(cm, e2) && !isMouseLikeTouchEvent(e2) && !clickInGutter(cm, e2)) {
              d.input.ensurePolled();
              clearTimeout(touchFinished);
              var now = +new Date();
              d.activeTouch = {
                start: now,
                moved: false,
                prev: now - prevTouch.end <= 300 ? prevTouch : null
              };
              if (e2.touches.length == 1) {
                d.activeTouch.left = e2.touches[0].pageX;
                d.activeTouch.top = e2.touches[0].pageY;
              }
            }
          });
          on(d.scroller, "touchmove", function() {
            if (d.activeTouch) {
              d.activeTouch.moved = true;
            }
          });
          on(d.scroller, "touchend", function(e2) {
            var touch = d.activeTouch;
            if (touch && !eventInWidget(d, e2) && touch.left != null && !touch.moved && new Date() - touch.start < 300) {
              var pos = cm.coordsChar(d.activeTouch, "page"), range2;
              if (!touch.prev || farAway(touch, touch.prev)) {
                range2 = new Range(pos, pos);
              } else if (!touch.prev.prev || farAway(touch, touch.prev.prev)) {
                range2 = cm.findWordAt(pos);
              } else {
                range2 = new Range(Pos(pos.line, 0), clipPos(cm.doc, Pos(pos.line + 1, 0)));
              }
              cm.setSelection(range2.anchor, range2.head);
              cm.focus();
              e_preventDefault(e2);
            }
            finishTouch();
          });
          on(d.scroller, "touchcancel", finishTouch);
          on(d.scroller, "scroll", function() {
            if (d.scroller.clientHeight) {
              updateScrollTop(cm, d.scroller.scrollTop);
              setScrollLeft(cm, d.scroller.scrollLeft, true);
              signal(cm, "scroll", cm);
            }
          });
          on(d.scroller, "mousewheel", function(e2) {
            return onScrollWheel(cm, e2);
          });
          on(d.scroller, "DOMMouseScroll", function(e2) {
            return onScrollWheel(cm, e2);
          });
          on(d.wrapper, "scroll", function() {
            return d.wrapper.scrollTop = d.wrapper.scrollLeft = 0;
          });
          d.dragFunctions = {
            enter: function(e2) {
              if (!signalDOMEvent(cm, e2)) {
                e_stop(e2);
              }
            },
            over: function(e2) {
              if (!signalDOMEvent(cm, e2)) {
                onDragOver(cm, e2);
                e_stop(e2);
              }
            },
            start: function(e2) {
              return onDragStart(cm, e2);
            },
            drop: operation(cm, onDrop),
            leave: function(e2) {
              if (!signalDOMEvent(cm, e2)) {
                clearDragCursor(cm);
              }
            }
          };
          var inp = d.input.getField();
          on(inp, "keyup", function(e2) {
            return onKeyUp.call(cm, e2);
          });
          on(inp, "keydown", operation(cm, onKeyDown));
          on(inp, "keypress", operation(cm, onKeyPress));
          on(inp, "focus", function(e2) {
            return onFocus(cm, e2);
          });
          on(inp, "blur", function(e2) {
            return onBlur(cm, e2);
          });
        }
        var initHooks = [];
        CodeMirror2.defineInitHook = function(f) {
          return initHooks.push(f);
        };
        function indentLine(cm, n, how, aggressive) {
          var doc2 = cm.doc, state;
          if (how == null) {
            how = "add";
          }
          if (how == "smart") {
            if (!doc2.mode.indent) {
              how = "prev";
            } else {
              state = getContextBefore(cm, n).state;
            }
          }
          var tabSize = cm.options.tabSize;
          var line = getLine(doc2, n), curSpace = countColumn(line.text, null, tabSize);
          if (line.stateAfter) {
            line.stateAfter = null;
          }
          var curSpaceString = line.text.match(/^\s*/)[0], indentation;
          if (!aggressive && !/\S/.test(line.text)) {
            indentation = 0;
            how = "not";
          } else if (how == "smart") {
            indentation = doc2.mode.indent(state, line.text.slice(curSpaceString.length), line.text);
            if (indentation == Pass || indentation > 150) {
              if (!aggressive) {
                return;
              }
              how = "prev";
            }
          }
          if (how == "prev") {
            if (n > doc2.first) {
              indentation = countColumn(getLine(doc2, n - 1).text, null, tabSize);
            } else {
              indentation = 0;
            }
          } else if (how == "add") {
            indentation = curSpace + cm.options.indentUnit;
          } else if (how == "subtract") {
            indentation = curSpace - cm.options.indentUnit;
          } else if (typeof how == "number") {
            indentation = curSpace + how;
          }
          indentation = Math.max(0, indentation);
          var indentString = "", pos = 0;
          if (cm.options.indentWithTabs) {
            for (var i2 = Math.floor(indentation / tabSize); i2; --i2) {
              pos += tabSize;
              indentString += "	";
            }
          }
          if (pos < indentation) {
            indentString += spaceStr(indentation - pos);
          }
          if (indentString != curSpaceString) {
            replaceRange(doc2, indentString, Pos(n, 0), Pos(n, curSpaceString.length), "+input");
            line.stateAfter = null;
            return true;
          } else {
            for (var i$12 = 0; i$12 < doc2.sel.ranges.length; i$12++) {
              var range2 = doc2.sel.ranges[i$12];
              if (range2.head.line == n && range2.head.ch < curSpaceString.length) {
                var pos$1 = Pos(n, curSpaceString.length);
                replaceOneSelection(doc2, i$12, new Range(pos$1, pos$1));
                break;
              }
            }
          }
        }
        var lastCopied = null;
        function setLastCopied(newLastCopied) {
          lastCopied = newLastCopied;
        }
        function applyTextInput(cm, inserted, deleted, sel, origin) {
          var doc2 = cm.doc;
          cm.display.shift = false;
          if (!sel) {
            sel = doc2.sel;
          }
          var recent = +new Date() - 200;
          var paste = origin == "paste" || cm.state.pasteIncoming > recent;
          var textLines = splitLinesAuto(inserted), multiPaste = null;
          if (paste && sel.ranges.length > 1) {
            if (lastCopied && lastCopied.text.join("\n") == inserted) {
              if (sel.ranges.length % lastCopied.text.length == 0) {
                multiPaste = [];
                for (var i2 = 0; i2 < lastCopied.text.length; i2++) {
                  multiPaste.push(doc2.splitLines(lastCopied.text[i2]));
                }
              }
            } else if (textLines.length == sel.ranges.length && cm.options.pasteLinesPerSelection) {
              multiPaste = map3(textLines, function(l) {
                return [l];
              });
            }
          }
          var updateInput = cm.curOp.updateInput;
          for (var i$12 = sel.ranges.length - 1; i$12 >= 0; i$12--) {
            var range2 = sel.ranges[i$12];
            var from = range2.from(), to = range2.to();
            if (range2.empty()) {
              if (deleted && deleted > 0) {
                from = Pos(from.line, from.ch - deleted);
              } else if (cm.state.overwrite && !paste) {
                to = Pos(to.line, Math.min(getLine(doc2, to.line).text.length, to.ch + lst(textLines).length));
              } else if (paste && lastCopied && lastCopied.lineWise && lastCopied.text.join("\n") == textLines.join("\n")) {
                from = to = Pos(from.line, 0);
              }
            }
            var changeEvent = {
              from,
              to,
              text: multiPaste ? multiPaste[i$12 % multiPaste.length] : textLines,
              origin: origin || (paste ? "paste" : cm.state.cutIncoming > recent ? "cut" : "+input")
            };
            makeChange(cm.doc, changeEvent);
            signalLater(cm, "inputRead", cm, changeEvent);
          }
          if (inserted && !paste) {
            triggerElectric(cm, inserted);
          }
          ensureCursorVisible(cm);
          if (cm.curOp.updateInput < 2) {
            cm.curOp.updateInput = updateInput;
          }
          cm.curOp.typing = true;
          cm.state.pasteIncoming = cm.state.cutIncoming = -1;
        }
        function handlePaste(e2, cm) {
          var pasted = e2.clipboardData && e2.clipboardData.getData("Text");
          if (pasted) {
            e2.preventDefault();
            if (!cm.isReadOnly() && !cm.options.disableInput && cm.hasFocus()) {
              runInOp(cm, function() {
                return applyTextInput(cm, pasted, 0, null, "paste");
              });
            }
            return true;
          }
        }
        function triggerElectric(cm, inserted) {
          if (!cm.options.electricChars || !cm.options.smartIndent) {
            return;
          }
          var sel = cm.doc.sel;
          for (var i2 = sel.ranges.length - 1; i2 >= 0; i2--) {
            var range2 = sel.ranges[i2];
            if (range2.head.ch > 100 || i2 && sel.ranges[i2 - 1].head.line == range2.head.line) {
              continue;
            }
            var mode = cm.getModeAt(range2.head);
            var indented = false;
            if (mode.electricChars) {
              for (var j = 0; j < mode.electricChars.length; j++) {
                if (inserted.indexOf(mode.electricChars.charAt(j)) > -1) {
                  indented = indentLine(cm, range2.head.line, "smart");
                  break;
                }
              }
            } else if (mode.electricInput) {
              if (mode.electricInput.test(getLine(cm.doc, range2.head.line).text.slice(0, range2.head.ch))) {
                indented = indentLine(cm, range2.head.line, "smart");
              }
            }
            if (indented) {
              signalLater(cm, "electricInput", cm, range2.head.line);
            }
          }
        }
        function copyableRanges(cm) {
          var text = [], ranges = [];
          for (var i2 = 0; i2 < cm.doc.sel.ranges.length; i2++) {
            var line = cm.doc.sel.ranges[i2].head.line;
            var lineRange = { anchor: Pos(line, 0), head: Pos(line + 1, 0) };
            ranges.push(lineRange);
            text.push(cm.getRange(lineRange.anchor, lineRange.head));
          }
          return { text, ranges };
        }
        function disableBrowserMagic(field, spellcheck, autocorrect, autocapitalize) {
          field.setAttribute("autocorrect", autocorrect ? "" : "off");
          field.setAttribute("autocapitalize", autocapitalize ? "" : "off");
          field.setAttribute("spellcheck", !!spellcheck);
        }
        function hiddenTextarea() {
          var te = elt("textarea", null, null, "position: absolute; bottom: -1em; padding: 0; width: 1px; height: 1em; min-height: 1em; outline: none");
          var div2 = elt("div", [te], null, "overflow: hidden; position: relative; width: 3px; height: 0px;");
          if (webkit) {
            te.style.width = "1000px";
          } else {
            te.setAttribute("wrap", "off");
          }
          if (ios) {
            te.style.border = "1px solid black";
          }
          disableBrowserMagic(te);
          return div2;
        }
        function addEditorMethods(CodeMirror3) {
          var optionHandlers2 = CodeMirror3.optionHandlers;
          var helpers = CodeMirror3.helpers = {};
          CodeMirror3.prototype = {
            constructor: CodeMirror3,
            focus: function() {
              win(this).focus();
              this.display.input.focus();
            },
            setOption: function(option, value) {
              var options = this.options, old = options[option];
              if (options[option] == value && option != "mode") {
                return;
              }
              options[option] = value;
              if (optionHandlers2.hasOwnProperty(option)) {
                operation(this, optionHandlers2[option])(this, value, old);
              }
              signal(this, "optionChange", this, option);
            },
            getOption: function(option) {
              return this.options[option];
            },
            getDoc: function() {
              return this.doc;
            },
            addKeyMap: function(map4, bottom) {
              this.state.keyMaps[bottom ? "push" : "unshift"](getKeyMap(map4));
            },
            removeKeyMap: function(map4) {
              var maps = this.state.keyMaps;
              for (var i2 = 0; i2 < maps.length; ++i2) {
                if (maps[i2] == map4 || maps[i2].name == map4) {
                  maps.splice(i2, 1);
                  return true;
                }
              }
            },
            addOverlay: methodOp(function(spec, options) {
              var mode = spec.token ? spec : CodeMirror3.getMode(this.options, spec);
              if (mode.startState) {
                throw new Error("Overlays may not be stateful.");
              }
              insertSorted(this.state.overlays, {
                mode,
                modeSpec: spec,
                opaque: options && options.opaque,
                priority: options && options.priority || 0
              }, function(overlay) {
                return overlay.priority;
              });
              this.state.modeGen++;
              regChange(this);
            }),
            removeOverlay: methodOp(function(spec) {
              var overlays = this.state.overlays;
              for (var i2 = 0; i2 < overlays.length; ++i2) {
                var cur = overlays[i2].modeSpec;
                if (cur == spec || typeof spec == "string" && cur.name == spec) {
                  overlays.splice(i2, 1);
                  this.state.modeGen++;
                  regChange(this);
                  return;
                }
              }
            }),
            indentLine: methodOp(function(n, dir3, aggressive) {
              if (typeof dir3 != "string" && typeof dir3 != "number") {
                if (dir3 == null) {
                  dir3 = this.options.smartIndent ? "smart" : "prev";
                } else {
                  dir3 = dir3 ? "add" : "subtract";
                }
              }
              if (isLine(this.doc, n)) {
                indentLine(this, n, dir3, aggressive);
              }
            }),
            indentSelection: methodOp(function(how) {
              var ranges = this.doc.sel.ranges, end2 = -1;
              for (var i2 = 0; i2 < ranges.length; i2++) {
                var range2 = ranges[i2];
                if (!range2.empty()) {
                  var from = range2.from(), to = range2.to();
                  var start2 = Math.max(end2, from.line);
                  end2 = Math.min(this.lastLine(), to.line - (to.ch ? 0 : 1)) + 1;
                  for (var j = start2; j < end2; ++j) {
                    indentLine(this, j, how);
                  }
                  var newRanges = this.doc.sel.ranges;
                  if (from.ch == 0 && ranges.length == newRanges.length && newRanges[i2].from().ch > 0) {
                    replaceOneSelection(this.doc, i2, new Range(from, newRanges[i2].to()), sel_dontScroll);
                  }
                } else if (range2.head.line > end2) {
                  indentLine(this, range2.head.line, how, true);
                  end2 = range2.head.line;
                  if (i2 == this.doc.sel.primIndex) {
                    ensureCursorVisible(this);
                  }
                }
              }
            }),
            getTokenAt: function(pos, precise) {
              return takeToken(this, pos, precise);
            },
            getLineTokens: function(line, precise) {
              return takeToken(this, Pos(line), precise, true);
            },
            getTokenTypeAt: function(pos) {
              pos = clipPos(this.doc, pos);
              var styles = getLineStyles(this, getLine(this.doc, pos.line));
              var before = 0, after = (styles.length - 1) / 2, ch = pos.ch;
              var type;
              if (ch == 0) {
                type = styles[2];
              } else {
                for (; ; ) {
                  var mid = before + after >> 1;
                  if ((mid ? styles[mid * 2 - 1] : 0) >= ch) {
                    after = mid;
                  } else if (styles[mid * 2 + 1] < ch) {
                    before = mid + 1;
                  } else {
                    type = styles[mid * 2 + 2];
                    break;
                  }
                }
              }
              var cut = type ? type.indexOf("overlay ") : -1;
              return cut < 0 ? type : cut == 0 ? null : type.slice(0, cut - 1);
            },
            getModeAt: function(pos) {
              var mode = this.doc.mode;
              if (!mode.innerMode) {
                return mode;
              }
              return CodeMirror3.innerMode(mode, this.getTokenAt(pos).state).mode;
            },
            getHelper: function(pos, type) {
              return this.getHelpers(pos, type)[0];
            },
            getHelpers: function(pos, type) {
              var found = [];
              if (!helpers.hasOwnProperty(type)) {
                return found;
              }
              var help = helpers[type], mode = this.getModeAt(pos);
              if (typeof mode[type] == "string") {
                if (help[mode[type]]) {
                  found.push(help[mode[type]]);
                }
              } else if (mode[type]) {
                for (var i2 = 0; i2 < mode[type].length; i2++) {
                  var val = help[mode[type][i2]];
                  if (val) {
                    found.push(val);
                  }
                }
              } else if (mode.helperType && help[mode.helperType]) {
                found.push(help[mode.helperType]);
              } else if (help[mode.name]) {
                found.push(help[mode.name]);
              }
              for (var i$12 = 0; i$12 < help._global.length; i$12++) {
                var cur = help._global[i$12];
                if (cur.pred(mode, this) && indexOf2(found, cur.val) == -1) {
                  found.push(cur.val);
                }
              }
              return found;
            },
            getStateAfter: function(line, precise) {
              var doc2 = this.doc;
              line = clipLine(doc2, line == null ? doc2.first + doc2.size - 1 : line);
              return getContextBefore(this, line + 1, precise).state;
            },
            cursorCoords: function(start2, mode) {
              var pos, range2 = this.doc.sel.primary();
              if (start2 == null) {
                pos = range2.head;
              } else if (typeof start2 == "object") {
                pos = clipPos(this.doc, start2);
              } else {
                pos = start2 ? range2.from() : range2.to();
              }
              return cursorCoords(this, pos, mode || "page");
            },
            charCoords: function(pos, mode) {
              return charCoords(this, clipPos(this.doc, pos), mode || "page");
            },
            coordsChar: function(coords, mode) {
              coords = fromCoordSystem(this, coords, mode || "page");
              return coordsChar(this, coords.left, coords.top);
            },
            lineAtHeight: function(height, mode) {
              height = fromCoordSystem(this, { top: height, left: 0 }, mode || "page").top;
              return lineAtHeight(this.doc, height + this.display.viewOffset);
            },
            heightAtLine: function(line, mode, includeWidgets) {
              var end2 = false, lineObj;
              if (typeof line == "number") {
                var last = this.doc.first + this.doc.size - 1;
                if (line < this.doc.first) {
                  line = this.doc.first;
                } else if (line > last) {
                  line = last;
                  end2 = true;
                }
                lineObj = getLine(this.doc, line);
              } else {
                lineObj = line;
              }
              return intoCoordSystem(this, lineObj, { top: 0, left: 0 }, mode || "page", includeWidgets || end2).top + (end2 ? this.doc.height - heightAtLine(lineObj) : 0);
            },
            defaultTextHeight: function() {
              return textHeight(this.display);
            },
            defaultCharWidth: function() {
              return charWidth(this.display);
            },
            getViewport: function() {
              return { from: this.display.viewFrom, to: this.display.viewTo };
            },
            addWidget: function(pos, node, scroll, vert, horiz) {
              var display = this.display;
              pos = cursorCoords(this, clipPos(this.doc, pos));
              var top = pos.bottom, left = pos.left;
              node.style.position = "absolute";
              node.setAttribute("cm-ignore-events", "true");
              this.display.input.setUneditable(node);
              display.sizer.appendChild(node);
              if (vert == "over") {
                top = pos.top;
              } else if (vert == "above" || vert == "near") {
                var vspace = Math.max(display.wrapper.clientHeight, this.doc.height), hspace = Math.max(display.sizer.clientWidth, display.lineSpace.clientWidth);
                if ((vert == "above" || pos.bottom + node.offsetHeight > vspace) && pos.top > node.offsetHeight) {
                  top = pos.top - node.offsetHeight;
                } else if (pos.bottom + node.offsetHeight <= vspace) {
                  top = pos.bottom;
                }
                if (left + node.offsetWidth > hspace) {
                  left = hspace - node.offsetWidth;
                }
              }
              node.style.top = top + "px";
              node.style.left = node.style.right = "";
              if (horiz == "right") {
                left = display.sizer.clientWidth - node.offsetWidth;
                node.style.right = "0px";
              } else {
                if (horiz == "left") {
                  left = 0;
                } else if (horiz == "middle") {
                  left = (display.sizer.clientWidth - node.offsetWidth) / 2;
                }
                node.style.left = left + "px";
              }
              if (scroll) {
                scrollIntoView(this, { left, top, right: left + node.offsetWidth, bottom: top + node.offsetHeight });
              }
            },
            triggerOnKeyDown: methodOp(onKeyDown),
            triggerOnKeyPress: methodOp(onKeyPress),
            triggerOnKeyUp: onKeyUp,
            triggerOnMouseDown: methodOp(onMouseDown),
            execCommand: function(cmd) {
              if (commands.hasOwnProperty(cmd)) {
                return commands[cmd].call(null, this);
              }
            },
            triggerElectric: methodOp(function(text) {
              triggerElectric(this, text);
            }),
            findPosH: function(from, amount, unit, visually) {
              var dir3 = 1;
              if (amount < 0) {
                dir3 = -1;
                amount = -amount;
              }
              var cur = clipPos(this.doc, from);
              for (var i2 = 0; i2 < amount; ++i2) {
                cur = findPosH(this.doc, cur, dir3, unit, visually);
                if (cur.hitSide) {
                  break;
                }
              }
              return cur;
            },
            moveH: methodOp(function(dir3, unit) {
              var this$1 = this;
              this.extendSelectionsBy(function(range2) {
                if (this$1.display.shift || this$1.doc.extend || range2.empty()) {
                  return findPosH(this$1.doc, range2.head, dir3, unit, this$1.options.rtlMoveVisually);
                } else {
                  return dir3 < 0 ? range2.from() : range2.to();
                }
              }, sel_move);
            }),
            deleteH: methodOp(function(dir3, unit) {
              var sel = this.doc.sel, doc2 = this.doc;
              if (sel.somethingSelected()) {
                doc2.replaceSelection("", null, "+delete");
              } else {
                deleteNearSelection(this, function(range2) {
                  var other = findPosH(doc2, range2.head, dir3, unit, false);
                  return dir3 < 0 ? { from: other, to: range2.head } : { from: range2.head, to: other };
                });
              }
            }),
            findPosV: function(from, amount, unit, goalColumn) {
              var dir3 = 1, x = goalColumn;
              if (amount < 0) {
                dir3 = -1;
                amount = -amount;
              }
              var cur = clipPos(this.doc, from);
              for (var i2 = 0; i2 < amount; ++i2) {
                var coords = cursorCoords(this, cur, "div");
                if (x == null) {
                  x = coords.left;
                } else {
                  coords.left = x;
                }
                cur = findPosV(this, coords, dir3, unit);
                if (cur.hitSide) {
                  break;
                }
              }
              return cur;
            },
            moveV: methodOp(function(dir3, unit) {
              var this$1 = this;
              var doc2 = this.doc, goals = [];
              var collapse = !this.display.shift && !doc2.extend && doc2.sel.somethingSelected();
              doc2.extendSelectionsBy(function(range2) {
                if (collapse) {
                  return dir3 < 0 ? range2.from() : range2.to();
                }
                var headPos = cursorCoords(this$1, range2.head, "div");
                if (range2.goalColumn != null) {
                  headPos.left = range2.goalColumn;
                }
                goals.push(headPos.left);
                var pos = findPosV(this$1, headPos, dir3, unit);
                if (unit == "page" && range2 == doc2.sel.primary()) {
                  addToScrollTop(this$1, charCoords(this$1, pos, "div").top - headPos.top);
                }
                return pos;
              }, sel_move);
              if (goals.length) {
                for (var i2 = 0; i2 < doc2.sel.ranges.length; i2++) {
                  doc2.sel.ranges[i2].goalColumn = goals[i2];
                }
              }
            }),
            findWordAt: function(pos) {
              var doc2 = this.doc, line = getLine(doc2, pos.line).text;
              var start2 = pos.ch, end2 = pos.ch;
              if (line) {
                var helper = this.getHelper(pos, "wordChars");
                if ((pos.sticky == "before" || end2 == line.length) && start2) {
                  --start2;
                } else {
                  ++end2;
                }
                var startChar = line.charAt(start2);
                var check = isWordChar(startChar, helper) ? function(ch) {
                  return isWordChar(ch, helper);
                } : /\s/.test(startChar) ? function(ch) {
                  return /\s/.test(ch);
                } : function(ch) {
                  return !/\s/.test(ch) && !isWordChar(ch);
                };
                while (start2 > 0 && check(line.charAt(start2 - 1))) {
                  --start2;
                }
                while (end2 < line.length && check(line.charAt(end2))) {
                  ++end2;
                }
              }
              return new Range(Pos(pos.line, start2), Pos(pos.line, end2));
            },
            toggleOverwrite: function(value) {
              if (value != null && value == this.state.overwrite) {
                return;
              }
              if (this.state.overwrite = !this.state.overwrite) {
                addClass(this.display.cursorDiv, "CodeMirror-overwrite");
              } else {
                rmClass(this.display.cursorDiv, "CodeMirror-overwrite");
              }
              signal(this, "overwriteToggle", this, this.state.overwrite);
            },
            hasFocus: function() {
              return this.display.input.getField() == activeElt(doc(this));
            },
            isReadOnly: function() {
              return !!(this.options.readOnly || this.doc.cantEdit);
            },
            scrollTo: methodOp(function(x, y) {
              scrollToCoords(this, x, y);
            }),
            getScrollInfo: function() {
              var scroller = this.display.scroller;
              return {
                left: scroller.scrollLeft,
                top: scroller.scrollTop,
                height: scroller.scrollHeight - scrollGap(this) - this.display.barHeight,
                width: scroller.scrollWidth - scrollGap(this) - this.display.barWidth,
                clientHeight: displayHeight(this),
                clientWidth: displayWidth(this)
              };
            },
            scrollIntoView: methodOp(function(range2, margin) {
              if (range2 == null) {
                range2 = { from: this.doc.sel.primary().head, to: null };
                if (margin == null) {
                  margin = this.options.cursorScrollMargin;
                }
              } else if (typeof range2 == "number") {
                range2 = { from: Pos(range2, 0), to: null };
              } else if (range2.from == null) {
                range2 = { from: range2, to: null };
              }
              if (!range2.to) {
                range2.to = range2.from;
              }
              range2.margin = margin || 0;
              if (range2.from.line != null) {
                scrollToRange(this, range2);
              } else {
                scrollToCoordsRange(this, range2.from, range2.to, range2.margin);
              }
            }),
            setSize: methodOp(function(width, height) {
              var this$1 = this;
              var interpret = function(val) {
                return typeof val == "number" || /^\d+$/.test(String(val)) ? val + "px" : val;
              };
              if (width != null) {
                this.display.wrapper.style.width = interpret(width);
              }
              if (height != null) {
                this.display.wrapper.style.height = interpret(height);
              }
              if (this.options.lineWrapping) {
                clearLineMeasurementCache(this);
              }
              var lineNo2 = this.display.viewFrom;
              this.doc.iter(lineNo2, this.display.viewTo, function(line) {
                if (line.widgets) {
                  for (var i2 = 0; i2 < line.widgets.length; i2++) {
                    if (line.widgets[i2].noHScroll) {
                      regLineChange(this$1, lineNo2, "widget");
                      break;
                    }
                  }
                }
                ++lineNo2;
              });
              this.curOp.forceUpdate = true;
              signal(this, "refresh", this);
            }),
            operation: function(f) {
              return runInOp(this, f);
            },
            startOperation: function() {
              return startOperation(this);
            },
            endOperation: function() {
              return endOperation(this);
            },
            refresh: methodOp(function() {
              var oldHeight = this.display.cachedTextHeight;
              regChange(this);
              this.curOp.forceUpdate = true;
              clearCaches(this);
              scrollToCoords(this, this.doc.scrollLeft, this.doc.scrollTop);
              updateGutterSpace(this.display);
              if (oldHeight == null || Math.abs(oldHeight - textHeight(this.display)) > 0.5 || this.options.lineWrapping) {
                estimateLineHeights(this);
              }
              signal(this, "refresh", this);
            }),
            swapDoc: methodOp(function(doc2) {
              var old = this.doc;
              old.cm = null;
              if (this.state.selectingText) {
                this.state.selectingText();
              }
              attachDoc(this, doc2);
              clearCaches(this);
              this.display.input.reset();
              scrollToCoords(this, doc2.scrollLeft, doc2.scrollTop);
              this.curOp.forceScroll = true;
              signalLater(this, "swapDoc", this, old);
              return old;
            }),
            phrase: function(phraseText) {
              var phrases = this.options.phrases;
              return phrases && Object.prototype.hasOwnProperty.call(phrases, phraseText) ? phrases[phraseText] : phraseText;
            },
            getInputField: function() {
              return this.display.input.getField();
            },
            getWrapperElement: function() {
              return this.display.wrapper;
            },
            getScrollerElement: function() {
              return this.display.scroller;
            },
            getGutterElement: function() {
              return this.display.gutters;
            }
          };
          eventMixin(CodeMirror3);
          CodeMirror3.registerHelper = function(type, name, value) {
            if (!helpers.hasOwnProperty(type)) {
              helpers[type] = CodeMirror3[type] = { _global: [] };
            }
            helpers[type][name] = value;
          };
          CodeMirror3.registerGlobalHelper = function(type, name, predicate, value) {
            CodeMirror3.registerHelper(type, name, value);
            helpers[type]._global.push({ pred: predicate, val: value });
          };
        }
        function findPosH(doc2, pos, dir3, unit, visually) {
          var oldPos = pos;
          var origDir = dir3;
          var lineObj = getLine(doc2, pos.line);
          var lineDir = visually && doc2.direction == "rtl" ? -dir3 : dir3;
          function findNextLine() {
            var l = pos.line + lineDir;
            if (l < doc2.first || l >= doc2.first + doc2.size) {
              return false;
            }
            pos = new Pos(l, pos.ch, pos.sticky);
            return lineObj = getLine(doc2, l);
          }
          function moveOnce(boundToLine) {
            var next;
            if (unit == "codepoint") {
              var ch = lineObj.text.charCodeAt(pos.ch + (dir3 > 0 ? 0 : -1));
              if (isNaN(ch)) {
                next = null;
              } else {
                var astral = dir3 > 0 ? ch >= 55296 && ch < 56320 : ch >= 56320 && ch < 57343;
                next = new Pos(pos.line, Math.max(0, Math.min(lineObj.text.length, pos.ch + dir3 * (astral ? 2 : 1))), -dir3);
              }
            } else if (visually) {
              next = moveVisually(doc2.cm, lineObj, pos, dir3);
            } else {
              next = moveLogically(lineObj, pos, dir3);
            }
            if (next == null) {
              if (!boundToLine && findNextLine()) {
                pos = endOfLine(visually, doc2.cm, lineObj, pos.line, lineDir);
              } else {
                return false;
              }
            } else {
              pos = next;
            }
            return true;
          }
          if (unit == "char" || unit == "codepoint") {
            moveOnce();
          } else if (unit == "column") {
            moveOnce(true);
          } else if (unit == "word" || unit == "group") {
            var sawType = null, group = unit == "group";
            var helper = doc2.cm && doc2.cm.getHelper(pos, "wordChars");
            for (var first = true; ; first = false) {
              if (dir3 < 0 && !moveOnce(!first)) {
                break;
              }
              var cur = lineObj.text.charAt(pos.ch) || "\n";
              var type = isWordChar(cur, helper) ? "w" : group && cur == "\n" ? "n" : !group || /\s/.test(cur) ? null : "p";
              if (group && !first && !type) {
                type = "s";
              }
              if (sawType && sawType != type) {
                if (dir3 < 0) {
                  dir3 = 1;
                  moveOnce();
                  pos.sticky = "after";
                }
                break;
              }
              if (type) {
                sawType = type;
              }
              if (dir3 > 0 && !moveOnce(!first)) {
                break;
              }
            }
          }
          var result = skipAtomic(doc2, pos, oldPos, origDir, true);
          if (equalCursorPos(oldPos, result)) {
            result.hitSide = true;
          }
          return result;
        }
        function findPosV(cm, pos, dir3, unit) {
          var doc2 = cm.doc, x = pos.left, y;
          if (unit == "page") {
            var pageSize = Math.min(cm.display.wrapper.clientHeight, win(cm).innerHeight || doc2(cm).documentElement.clientHeight);
            var moveAmount = Math.max(pageSize - 0.5 * textHeight(cm.display), 3);
            y = (dir3 > 0 ? pos.bottom : pos.top) + dir3 * moveAmount;
          } else if (unit == "line") {
            y = dir3 > 0 ? pos.bottom + 3 : pos.top - 3;
          }
          var target;
          for (; ; ) {
            target = coordsChar(cm, x, y);
            if (!target.outside) {
              break;
            }
            if (dir3 < 0 ? y <= 0 : y >= doc2.height) {
              target.hitSide = true;
              break;
            }
            y += dir3 * 5;
          }
          return target;
        }
        var ContentEditableInput = function(cm) {
          this.cm = cm;
          this.lastAnchorNode = this.lastAnchorOffset = this.lastFocusNode = this.lastFocusOffset = null;
          this.polling = new Delayed();
          this.composing = null;
          this.gracePeriod = false;
          this.readDOMTimeout = null;
        };
        ContentEditableInput.prototype.init = function(display) {
          var this$1 = this;
          var input = this, cm = input.cm;
          var div2 = input.div = display.lineDiv;
          div2.contentEditable = true;
          disableBrowserMagic(div2, cm.options.spellcheck, cm.options.autocorrect, cm.options.autocapitalize);
          function belongsToInput(e2) {
            for (var t = e2.target; t; t = t.parentNode) {
              if (t == div2) {
                return true;
              }
              if (/\bCodeMirror-(?:line)?widget\b/.test(t.className)) {
                break;
              }
            }
            return false;
          }
          on(div2, "paste", function(e2) {
            if (!belongsToInput(e2) || signalDOMEvent(cm, e2) || handlePaste(e2, cm)) {
              return;
            }
            if (ie_version <= 11) {
              setTimeout(operation(cm, function() {
                return this$1.updateFromDOM();
              }), 20);
            }
          });
          on(div2, "compositionstart", function(e2) {
            this$1.composing = { data: e2.data, done: false };
          });
          on(div2, "compositionupdate", function(e2) {
            if (!this$1.composing) {
              this$1.composing = { data: e2.data, done: false };
            }
          });
          on(div2, "compositionend", function(e2) {
            if (this$1.composing) {
              if (e2.data != this$1.composing.data) {
                this$1.readFromDOMSoon();
              }
              this$1.composing.done = true;
            }
          });
          on(div2, "touchstart", function() {
            return input.forceCompositionEnd();
          });
          on(div2, "input", function() {
            if (!this$1.composing) {
              this$1.readFromDOMSoon();
            }
          });
          function onCopyCut(e2) {
            if (!belongsToInput(e2) || signalDOMEvent(cm, e2)) {
              return;
            }
            if (cm.somethingSelected()) {
              setLastCopied({ lineWise: false, text: cm.getSelections() });
              if (e2.type == "cut") {
                cm.replaceSelection("", null, "cut");
              }
            } else if (!cm.options.lineWiseCopyCut) {
              return;
            } else {
              var ranges = copyableRanges(cm);
              setLastCopied({ lineWise: true, text: ranges.text });
              if (e2.type == "cut") {
                cm.operation(function() {
                  cm.setSelections(ranges.ranges, 0, sel_dontScroll);
                  cm.replaceSelection("", null, "cut");
                });
              }
            }
            if (e2.clipboardData) {
              e2.clipboardData.clearData();
              var content = lastCopied.text.join("\n");
              e2.clipboardData.setData("Text", content);
              if (e2.clipboardData.getData("Text") == content) {
                e2.preventDefault();
                return;
              }
            }
            var kludge = hiddenTextarea(), te = kludge.firstChild;
            cm.display.lineSpace.insertBefore(kludge, cm.display.lineSpace.firstChild);
            te.value = lastCopied.text.join("\n");
            var hadFocus = activeElt(div2.ownerDocument);
            selectInput(te);
            setTimeout(function() {
              cm.display.lineSpace.removeChild(kludge);
              hadFocus.focus();
              if (hadFocus == div2) {
                input.showPrimarySelection();
              }
            }, 50);
          }
          on(div2, "copy", onCopyCut);
          on(div2, "cut", onCopyCut);
        };
        ContentEditableInput.prototype.screenReaderLabelChanged = function(label) {
          if (label) {
            this.div.setAttribute("aria-label", label);
          } else {
            this.div.removeAttribute("aria-label");
          }
        };
        ContentEditableInput.prototype.prepareSelection = function() {
          var result = prepareSelection(this.cm, false);
          result.focus = activeElt(this.div.ownerDocument) == this.div;
          return result;
        };
        ContentEditableInput.prototype.showSelection = function(info, takeFocus) {
          if (!info || !this.cm.display.view.length) {
            return;
          }
          if (info.focus || takeFocus) {
            this.showPrimarySelection();
          }
          this.showMultipleSelections(info);
        };
        ContentEditableInput.prototype.getSelection = function() {
          return this.cm.display.wrapper.ownerDocument.getSelection();
        };
        ContentEditableInput.prototype.showPrimarySelection = function() {
          var sel = this.getSelection(), cm = this.cm, prim = cm.doc.sel.primary();
          var from = prim.from(), to = prim.to();
          if (cm.display.viewTo == cm.display.viewFrom || from.line >= cm.display.viewTo || to.line < cm.display.viewFrom) {
            sel.removeAllRanges();
            return;
          }
          var curAnchor = domToPos(cm, sel.anchorNode, sel.anchorOffset);
          var curFocus = domToPos(cm, sel.focusNode, sel.focusOffset);
          if (curAnchor && !curAnchor.bad && curFocus && !curFocus.bad && cmp(minPos(curAnchor, curFocus), from) == 0 && cmp(maxPos(curAnchor, curFocus), to) == 0) {
            return;
          }
          var view = cm.display.view;
          var start2 = from.line >= cm.display.viewFrom && posToDOM(cm, from) || { node: view[0].measure.map[2], offset: 0 };
          var end2 = to.line < cm.display.viewTo && posToDOM(cm, to);
          if (!end2) {
            var measure = view[view.length - 1].measure;
            var map4 = measure.maps ? measure.maps[measure.maps.length - 1] : measure.map;
            end2 = { node: map4[map4.length - 1], offset: map4[map4.length - 2] - map4[map4.length - 3] };
          }
          if (!start2 || !end2) {
            sel.removeAllRanges();
            return;
          }
          var old = sel.rangeCount && sel.getRangeAt(0), rng;
          try {
            rng = range(start2.node, start2.offset, end2.offset, end2.node);
          } catch (e2) {
          }
          if (rng) {
            if (!gecko && cm.state.focused) {
              sel.collapse(start2.node, start2.offset);
              if (!rng.collapsed) {
                sel.removeAllRanges();
                sel.addRange(rng);
              }
            } else {
              sel.removeAllRanges();
              sel.addRange(rng);
            }
            if (old && sel.anchorNode == null) {
              sel.addRange(old);
            } else if (gecko) {
              this.startGracePeriod();
            }
          }
          this.rememberSelection();
        };
        ContentEditableInput.prototype.startGracePeriod = function() {
          var this$1 = this;
          clearTimeout(this.gracePeriod);
          this.gracePeriod = setTimeout(function() {
            this$1.gracePeriod = false;
            if (this$1.selectionChanged()) {
              this$1.cm.operation(function() {
                return this$1.cm.curOp.selectionChanged = true;
              });
            }
          }, 20);
        };
        ContentEditableInput.prototype.showMultipleSelections = function(info) {
          removeChildrenAndAdd(this.cm.display.cursorDiv, info.cursors);
          removeChildrenAndAdd(this.cm.display.selectionDiv, info.selection);
        };
        ContentEditableInput.prototype.rememberSelection = function() {
          var sel = this.getSelection();
          this.lastAnchorNode = sel.anchorNode;
          this.lastAnchorOffset = sel.anchorOffset;
          this.lastFocusNode = sel.focusNode;
          this.lastFocusOffset = sel.focusOffset;
        };
        ContentEditableInput.prototype.selectionInEditor = function() {
          var sel = this.getSelection();
          if (!sel.rangeCount) {
            return false;
          }
          var node = sel.getRangeAt(0).commonAncestorContainer;
          return contains(this.div, node);
        };
        ContentEditableInput.prototype.focus = function() {
          if (this.cm.options.readOnly != "nocursor") {
            if (!this.selectionInEditor() || activeElt(this.div.ownerDocument) != this.div) {
              this.showSelection(this.prepareSelection(), true);
            }
            this.div.focus();
          }
        };
        ContentEditableInput.prototype.blur = function() {
          this.div.blur();
        };
        ContentEditableInput.prototype.getField = function() {
          return this.div;
        };
        ContentEditableInput.prototype.supportsTouch = function() {
          return true;
        };
        ContentEditableInput.prototype.receivedFocus = function() {
          var this$1 = this;
          var input = this;
          if (this.selectionInEditor()) {
            setTimeout(function() {
              return this$1.pollSelection();
            }, 20);
          } else {
            runInOp(this.cm, function() {
              return input.cm.curOp.selectionChanged = true;
            });
          }
          function poll() {
            if (input.cm.state.focused) {
              input.pollSelection();
              input.polling.set(input.cm.options.pollInterval, poll);
            }
          }
          this.polling.set(this.cm.options.pollInterval, poll);
        };
        ContentEditableInput.prototype.selectionChanged = function() {
          var sel = this.getSelection();
          return sel.anchorNode != this.lastAnchorNode || sel.anchorOffset != this.lastAnchorOffset || sel.focusNode != this.lastFocusNode || sel.focusOffset != this.lastFocusOffset;
        };
        ContentEditableInput.prototype.pollSelection = function() {
          if (this.readDOMTimeout != null || this.gracePeriod || !this.selectionChanged()) {
            return;
          }
          var sel = this.getSelection(), cm = this.cm;
          if (android && chrome && this.cm.display.gutterSpecs.length && isInGutter(sel.anchorNode)) {
            this.cm.triggerOnKeyDown({ type: "keydown", keyCode: 8, preventDefault: Math.abs });
            this.blur();
            this.focus();
            return;
          }
          if (this.composing) {
            return;
          }
          this.rememberSelection();
          var anchor = domToPos(cm, sel.anchorNode, sel.anchorOffset);
          var head = domToPos(cm, sel.focusNode, sel.focusOffset);
          if (anchor && head) {
            runInOp(cm, function() {
              setSelection(cm.doc, simpleSelection(anchor, head), sel_dontScroll);
              if (anchor.bad || head.bad) {
                cm.curOp.selectionChanged = true;
              }
            });
          }
        };
        ContentEditableInput.prototype.pollContent = function() {
          if (this.readDOMTimeout != null) {
            clearTimeout(this.readDOMTimeout);
            this.readDOMTimeout = null;
          }
          var cm = this.cm, display = cm.display, sel = cm.doc.sel.primary();
          var from = sel.from(), to = sel.to();
          if (from.ch == 0 && from.line > cm.firstLine()) {
            from = Pos(from.line - 1, getLine(cm.doc, from.line - 1).length);
          }
          if (to.ch == getLine(cm.doc, to.line).text.length && to.line < cm.lastLine()) {
            to = Pos(to.line + 1, 0);
          }
          if (from.line < display.viewFrom || to.line > display.viewTo - 1) {
            return false;
          }
          var fromIndex, fromLine2, fromNode;
          if (from.line == display.viewFrom || (fromIndex = findViewIndex(cm, from.line)) == 0) {
            fromLine2 = lineNo(display.view[0].line);
            fromNode = display.view[0].node;
          } else {
            fromLine2 = lineNo(display.view[fromIndex].line);
            fromNode = display.view[fromIndex - 1].node.nextSibling;
          }
          var toIndex = findViewIndex(cm, to.line);
          var toLine, toNode;
          if (toIndex == display.view.length - 1) {
            toLine = display.viewTo - 1;
            toNode = display.lineDiv.lastChild;
          } else {
            toLine = lineNo(display.view[toIndex + 1].line) - 1;
            toNode = display.view[toIndex + 1].node.previousSibling;
          }
          if (!fromNode) {
            return false;
          }
          var newText = cm.doc.splitLines(domTextBetween(cm, fromNode, toNode, fromLine2, toLine));
          var oldText = getBetween(cm.doc, Pos(fromLine2, 0), Pos(toLine, getLine(cm.doc, toLine).text.length));
          while (newText.length > 1 && oldText.length > 1) {
            if (lst(newText) == lst(oldText)) {
              newText.pop();
              oldText.pop();
              toLine--;
            } else if (newText[0] == oldText[0]) {
              newText.shift();
              oldText.shift();
              fromLine2++;
            } else {
              break;
            }
          }
          var cutFront = 0, cutEnd = 0;
          var newTop = newText[0], oldTop = oldText[0], maxCutFront = Math.min(newTop.length, oldTop.length);
          while (cutFront < maxCutFront && newTop.charCodeAt(cutFront) == oldTop.charCodeAt(cutFront)) {
            ++cutFront;
          }
          var newBot = lst(newText), oldBot = lst(oldText);
          var maxCutEnd = Math.min(newBot.length - (newText.length == 1 ? cutFront : 0), oldBot.length - (oldText.length == 1 ? cutFront : 0));
          while (cutEnd < maxCutEnd && newBot.charCodeAt(newBot.length - cutEnd - 1) == oldBot.charCodeAt(oldBot.length - cutEnd - 1)) {
            ++cutEnd;
          }
          if (newText.length == 1 && oldText.length == 1 && fromLine2 == from.line) {
            while (cutFront && cutFront > from.ch && newBot.charCodeAt(newBot.length - cutEnd - 1) == oldBot.charCodeAt(oldBot.length - cutEnd - 1)) {
              cutFront--;
              cutEnd++;
            }
          }
          newText[newText.length - 1] = newBot.slice(0, newBot.length - cutEnd).replace(/^\u200b+/, "");
          newText[0] = newText[0].slice(cutFront).replace(/\u200b+$/, "");
          var chFrom = Pos(fromLine2, cutFront);
          var chTo = Pos(toLine, oldText.length ? lst(oldText).length - cutEnd : 0);
          if (newText.length > 1 || newText[0] || cmp(chFrom, chTo)) {
            replaceRange(cm.doc, newText, chFrom, chTo, "+input");
            return true;
          }
        };
        ContentEditableInput.prototype.ensurePolled = function() {
          this.forceCompositionEnd();
        };
        ContentEditableInput.prototype.reset = function() {
          this.forceCompositionEnd();
        };
        ContentEditableInput.prototype.forceCompositionEnd = function() {
          if (!this.composing) {
            return;
          }
          clearTimeout(this.readDOMTimeout);
          this.composing = null;
          this.updateFromDOM();
          this.div.blur();
          this.div.focus();
        };
        ContentEditableInput.prototype.readFromDOMSoon = function() {
          var this$1 = this;
          if (this.readDOMTimeout != null) {
            return;
          }
          this.readDOMTimeout = setTimeout(function() {
            this$1.readDOMTimeout = null;
            if (this$1.composing) {
              if (this$1.composing.done) {
                this$1.composing = null;
              } else {
                return;
              }
            }
            this$1.updateFromDOM();
          }, 80);
        };
        ContentEditableInput.prototype.updateFromDOM = function() {
          var this$1 = this;
          if (this.cm.isReadOnly() || !this.pollContent()) {
            runInOp(this.cm, function() {
              return regChange(this$1.cm);
            });
          }
        };
        ContentEditableInput.prototype.setUneditable = function(node) {
          node.contentEditable = "false";
        };
        ContentEditableInput.prototype.onKeyPress = function(e2) {
          if (e2.charCode == 0 || this.composing) {
            return;
          }
          e2.preventDefault();
          if (!this.cm.isReadOnly()) {
            operation(this.cm, applyTextInput)(this.cm, String.fromCharCode(e2.charCode == null ? e2.keyCode : e2.charCode), 0);
          }
        };
        ContentEditableInput.prototype.readOnlyChanged = function(val) {
          this.div.contentEditable = String(val != "nocursor");
        };
        ContentEditableInput.prototype.onContextMenu = function() {
        };
        ContentEditableInput.prototype.resetPosition = function() {
        };
        ContentEditableInput.prototype.needsContentAttribute = true;
        function posToDOM(cm, pos) {
          var view = findViewForLine(cm, pos.line);
          if (!view || view.hidden) {
            return null;
          }
          var line = getLine(cm.doc, pos.line);
          var info = mapFromLineView(view, line, pos.line);
          var order = getOrder(line, cm.doc.direction), side = "left";
          if (order) {
            var partPos = getBidiPartAt(order, pos.ch);
            side = partPos % 2 ? "right" : "left";
          }
          var result = nodeAndOffsetInLineMap(info.map, pos.ch, side);
          result.offset = result.collapse == "right" ? result.end : result.start;
          return result;
        }
        function isInGutter(node) {
          for (var scan = node; scan; scan = scan.parentNode) {
            if (/CodeMirror-gutter-wrapper/.test(scan.className)) {
              return true;
            }
          }
          return false;
        }
        function badPos(pos, bad) {
          if (bad) {
            pos.bad = true;
          }
          return pos;
        }
        function domTextBetween(cm, from, to, fromLine2, toLine) {
          var text = "", closing = false, lineSep = cm.doc.lineSeparator(), extraLinebreak = false;
          function recognizeMarker(id) {
            return function(marker) {
              return marker.id == id;
            };
          }
          function close() {
            if (closing) {
              text += lineSep;
              if (extraLinebreak) {
                text += lineSep;
              }
              closing = extraLinebreak = false;
            }
          }
          function addText(str) {
            if (str) {
              close();
              text += str;
            }
          }
          function walk(node) {
            if (node.nodeType == 1) {
              var cmText = node.getAttribute("cm-text");
              if (cmText) {
                addText(cmText);
                return;
              }
              var markerID = node.getAttribute("cm-marker"), range2;
              if (markerID) {
                var found = cm.findMarks(Pos(fromLine2, 0), Pos(toLine + 1, 0), recognizeMarker(+markerID));
                if (found.length && (range2 = found[0].find(0))) {
                  addText(getBetween(cm.doc, range2.from, range2.to).join(lineSep));
                }
                return;
              }
              if (node.getAttribute("contenteditable") == "false") {
                return;
              }
              var isBlock = /^(pre|div|p|li|table|br)$/i.test(node.nodeName);
              if (!/^br$/i.test(node.nodeName) && node.textContent.length == 0) {
                return;
              }
              if (isBlock) {
                close();
              }
              for (var i2 = 0; i2 < node.childNodes.length; i2++) {
                walk(node.childNodes[i2]);
              }
              if (/^(pre|p)$/i.test(node.nodeName)) {
                extraLinebreak = true;
              }
              if (isBlock) {
                closing = true;
              }
            } else if (node.nodeType == 3) {
              addText(node.nodeValue.replace(/\u200b/g, "").replace(/\u00a0/g, " "));
            }
          }
          for (; ; ) {
            walk(from);
            if (from == to) {
              break;
            }
            from = from.nextSibling;
            extraLinebreak = false;
          }
          return text;
        }
        function domToPos(cm, node, offset) {
          var lineNode;
          if (node == cm.display.lineDiv) {
            lineNode = cm.display.lineDiv.childNodes[offset];
            if (!lineNode) {
              return badPos(cm.clipPos(Pos(cm.display.viewTo - 1)), true);
            }
            node = null;
            offset = 0;
          } else {
            for (lineNode = node; ; lineNode = lineNode.parentNode) {
              if (!lineNode || lineNode == cm.display.lineDiv) {
                return null;
              }
              if (lineNode.parentNode && lineNode.parentNode == cm.display.lineDiv) {
                break;
              }
            }
          }
          for (var i2 = 0; i2 < cm.display.view.length; i2++) {
            var lineView = cm.display.view[i2];
            if (lineView.node == lineNode) {
              return locateNodeInLineView(lineView, node, offset);
            }
          }
        }
        function locateNodeInLineView(lineView, node, offset) {
          var wrapper = lineView.text.firstChild, bad = false;
          if (!node || !contains(wrapper, node)) {
            return badPos(Pos(lineNo(lineView.line), 0), true);
          }
          if (node == wrapper) {
            bad = true;
            node = wrapper.childNodes[offset];
            offset = 0;
            if (!node) {
              var line = lineView.rest ? lst(lineView.rest) : lineView.line;
              return badPos(Pos(lineNo(line), line.text.length), bad);
            }
          }
          var textNode = node.nodeType == 3 ? node : null, topNode = node;
          if (!textNode && node.childNodes.length == 1 && node.firstChild.nodeType == 3) {
            textNode = node.firstChild;
            if (offset) {
              offset = textNode.nodeValue.length;
            }
          }
          while (topNode.parentNode != wrapper) {
            topNode = topNode.parentNode;
          }
          var measure = lineView.measure, maps = measure.maps;
          function find2(textNode2, topNode2, offset2) {
            for (var i2 = -1; i2 < (maps ? maps.length : 0); i2++) {
              var map4 = i2 < 0 ? measure.map : maps[i2];
              for (var j = 0; j < map4.length; j += 3) {
                var curNode = map4[j + 2];
                if (curNode == textNode2 || curNode == topNode2) {
                  var line2 = lineNo(i2 < 0 ? lineView.line : lineView.rest[i2]);
                  var ch = map4[j] + offset2;
                  if (offset2 < 0 || curNode != textNode2) {
                    ch = map4[j + (offset2 ? 1 : 0)];
                  }
                  return Pos(line2, ch);
                }
              }
            }
          }
          var found = find2(textNode, topNode, offset);
          if (found) {
            return badPos(found, bad);
          }
          for (var after = topNode.nextSibling, dist3 = textNode ? textNode.nodeValue.length - offset : 0; after; after = after.nextSibling) {
            found = find2(after, after.firstChild, 0);
            if (found) {
              return badPos(Pos(found.line, found.ch - dist3), bad);
            } else {
              dist3 += after.textContent.length;
            }
          }
          for (var before = topNode.previousSibling, dist$1 = offset; before; before = before.previousSibling) {
            found = find2(before, before.firstChild, -1);
            if (found) {
              return badPos(Pos(found.line, found.ch + dist$1), bad);
            } else {
              dist$1 += before.textContent.length;
            }
          }
        }
        var TextareaInput = function(cm) {
          this.cm = cm;
          this.prevInput = "";
          this.pollingFast = false;
          this.polling = new Delayed();
          this.hasSelection = false;
          this.composing = null;
          this.resetting = false;
        };
        TextareaInput.prototype.init = function(display) {
          var this$1 = this;
          var input = this, cm = this.cm;
          this.createField(display);
          var te = this.textarea;
          display.wrapper.insertBefore(this.wrapper, display.wrapper.firstChild);
          if (ios) {
            te.style.width = "0px";
          }
          on(te, "input", function() {
            if (ie && ie_version >= 9 && this$1.hasSelection) {
              this$1.hasSelection = null;
            }
            input.poll();
          });
          on(te, "paste", function(e2) {
            if (signalDOMEvent(cm, e2) || handlePaste(e2, cm)) {
              return;
            }
            cm.state.pasteIncoming = +new Date();
            input.fastPoll();
          });
          function prepareCopyCut(e2) {
            if (signalDOMEvent(cm, e2)) {
              return;
            }
            if (cm.somethingSelected()) {
              setLastCopied({ lineWise: false, text: cm.getSelections() });
            } else if (!cm.options.lineWiseCopyCut) {
              return;
            } else {
              var ranges = copyableRanges(cm);
              setLastCopied({ lineWise: true, text: ranges.text });
              if (e2.type == "cut") {
                cm.setSelections(ranges.ranges, null, sel_dontScroll);
              } else {
                input.prevInput = "";
                te.value = ranges.text.join("\n");
                selectInput(te);
              }
            }
            if (e2.type == "cut") {
              cm.state.cutIncoming = +new Date();
            }
          }
          on(te, "cut", prepareCopyCut);
          on(te, "copy", prepareCopyCut);
          on(display.scroller, "paste", function(e2) {
            if (eventInWidget(display, e2) || signalDOMEvent(cm, e2)) {
              return;
            }
            if (!te.dispatchEvent) {
              cm.state.pasteIncoming = +new Date();
              input.focus();
              return;
            }
            var event = new Event("paste");
            event.clipboardData = e2.clipboardData;
            te.dispatchEvent(event);
          });
          on(display.lineSpace, "selectstart", function(e2) {
            if (!eventInWidget(display, e2)) {
              e_preventDefault(e2);
            }
          });
          on(te, "compositionstart", function() {
            var start2 = cm.getCursor("from");
            if (input.composing) {
              input.composing.range.clear();
            }
            input.composing = {
              start: start2,
              range: cm.markText(start2, cm.getCursor("to"), { className: "CodeMirror-composing" })
            };
          });
          on(te, "compositionend", function() {
            if (input.composing) {
              input.poll();
              input.composing.range.clear();
              input.composing = null;
            }
          });
        };
        TextareaInput.prototype.createField = function(_display) {
          this.wrapper = hiddenTextarea();
          this.textarea = this.wrapper.firstChild;
        };
        TextareaInput.prototype.screenReaderLabelChanged = function(label) {
          if (label) {
            this.textarea.setAttribute("aria-label", label);
          } else {
            this.textarea.removeAttribute("aria-label");
          }
        };
        TextareaInput.prototype.prepareSelection = function() {
          var cm = this.cm, display = cm.display, doc2 = cm.doc;
          var result = prepareSelection(cm);
          if (cm.options.moveInputWithCursor) {
            var headPos = cursorCoords(cm, doc2.sel.primary().head, "div");
            var wrapOff = display.wrapper.getBoundingClientRect(), lineOff = display.lineDiv.getBoundingClientRect();
            result.teTop = Math.max(0, Math.min(display.wrapper.clientHeight - 10, headPos.top + lineOff.top - wrapOff.top));
            result.teLeft = Math.max(0, Math.min(display.wrapper.clientWidth - 10, headPos.left + lineOff.left - wrapOff.left));
          }
          return result;
        };
        TextareaInput.prototype.showSelection = function(drawn) {
          var cm = this.cm, display = cm.display;
          removeChildrenAndAdd(display.cursorDiv, drawn.cursors);
          removeChildrenAndAdd(display.selectionDiv, drawn.selection);
          if (drawn.teTop != null) {
            this.wrapper.style.top = drawn.teTop + "px";
            this.wrapper.style.left = drawn.teLeft + "px";
          }
        };
        TextareaInput.prototype.reset = function(typing) {
          if (this.contextMenuPending || this.composing && typing) {
            return;
          }
          var cm = this.cm;
          this.resetting = true;
          if (cm.somethingSelected()) {
            this.prevInput = "";
            var content = cm.getSelection();
            this.textarea.value = content;
            if (cm.state.focused) {
              selectInput(this.textarea);
            }
            if (ie && ie_version >= 9) {
              this.hasSelection = content;
            }
          } else if (!typing) {
            this.prevInput = this.textarea.value = "";
            if (ie && ie_version >= 9) {
              this.hasSelection = null;
            }
          }
          this.resetting = false;
        };
        TextareaInput.prototype.getField = function() {
          return this.textarea;
        };
        TextareaInput.prototype.supportsTouch = function() {
          return false;
        };
        TextareaInput.prototype.focus = function() {
          if (this.cm.options.readOnly != "nocursor" && (!mobile || activeElt(this.textarea.ownerDocument) != this.textarea)) {
            try {
              this.textarea.focus();
            } catch (e2) {
            }
          }
        };
        TextareaInput.prototype.blur = function() {
          this.textarea.blur();
        };
        TextareaInput.prototype.resetPosition = function() {
          this.wrapper.style.top = this.wrapper.style.left = 0;
        };
        TextareaInput.prototype.receivedFocus = function() {
          this.slowPoll();
        };
        TextareaInput.prototype.slowPoll = function() {
          var this$1 = this;
          if (this.pollingFast) {
            return;
          }
          this.polling.set(this.cm.options.pollInterval, function() {
            this$1.poll();
            if (this$1.cm.state.focused) {
              this$1.slowPoll();
            }
          });
        };
        TextareaInput.prototype.fastPoll = function() {
          var missed = false, input = this;
          input.pollingFast = true;
          function p() {
            var changed = input.poll();
            if (!changed && !missed) {
              missed = true;
              input.polling.set(60, p);
            } else {
              input.pollingFast = false;
              input.slowPoll();
            }
          }
          input.polling.set(20, p);
        };
        TextareaInput.prototype.poll = function() {
          var this$1 = this;
          var cm = this.cm, input = this.textarea, prevInput = this.prevInput;
          if (this.contextMenuPending || this.resetting || !cm.state.focused || hasSelection(input) && !prevInput && !this.composing || cm.isReadOnly() || cm.options.disableInput || cm.state.keySeq) {
            return false;
          }
          var text = input.value;
          if (text == prevInput && !cm.somethingSelected()) {
            return false;
          }
          if (ie && ie_version >= 9 && this.hasSelection === text || mac && /[\uf700-\uf7ff]/.test(text)) {
            cm.display.input.reset();
            return false;
          }
          if (cm.doc.sel == cm.display.selForContextMenu) {
            var first = text.charCodeAt(0);
            if (first == 8203 && !prevInput) {
              prevInput = "​";
            }
            if (first == 8666) {
              this.reset();
              return this.cm.execCommand("undo");
            }
          }
          var same = 0, l = Math.min(prevInput.length, text.length);
          while (same < l && prevInput.charCodeAt(same) == text.charCodeAt(same)) {
            ++same;
          }
          runInOp(cm, function() {
            applyTextInput(cm, text.slice(same), prevInput.length - same, null, this$1.composing ? "*compose" : null);
            if (text.length > 1e3 || text.indexOf("\n") > -1) {
              input.value = this$1.prevInput = "";
            } else {
              this$1.prevInput = text;
            }
            if (this$1.composing) {
              this$1.composing.range.clear();
              this$1.composing.range = cm.markText(this$1.composing.start, cm.getCursor("to"), { className: "CodeMirror-composing" });
            }
          });
          return true;
        };
        TextareaInput.prototype.ensurePolled = function() {
          if (this.pollingFast && this.poll()) {
            this.pollingFast = false;
          }
        };
        TextareaInput.prototype.onKeyPress = function() {
          if (ie && ie_version >= 9) {
            this.hasSelection = null;
          }
          this.fastPoll();
        };
        TextareaInput.prototype.onContextMenu = function(e2) {
          var input = this, cm = input.cm, display = cm.display, te = input.textarea;
          if (input.contextMenuPending) {
            input.contextMenuPending();
          }
          var pos = posFromMouse(cm, e2), scrollPos = display.scroller.scrollTop;
          if (!pos || presto) {
            return;
          }
          var reset = cm.options.resetSelectionOnContextMenu;
          if (reset && cm.doc.sel.contains(pos) == -1) {
            operation(cm, setSelection)(cm.doc, simpleSelection(pos), sel_dontScroll);
          }
          var oldCSS = te.style.cssText, oldWrapperCSS = input.wrapper.style.cssText;
          var wrapperBox = input.wrapper.offsetParent.getBoundingClientRect();
          input.wrapper.style.cssText = "position: static";
          te.style.cssText = "position: absolute; width: 30px; height: 30px;\n      top: " + (e2.clientY - wrapperBox.top - 5) + "px; left: " + (e2.clientX - wrapperBox.left - 5) + "px;\n      z-index: 1000; background: " + (ie ? "rgba(255, 255, 255, .05)" : "transparent") + ";\n      outline: none; border-width: 0; outline: none; overflow: hidden; opacity: .05; filter: alpha(opacity=5);";
          var oldScrollY;
          if (webkit) {
            oldScrollY = te.ownerDocument.defaultView.scrollY;
          }
          display.input.focus();
          if (webkit) {
            te.ownerDocument.defaultView.scrollTo(null, oldScrollY);
          }
          display.input.reset();
          if (!cm.somethingSelected()) {
            te.value = input.prevInput = " ";
          }
          input.contextMenuPending = rehide;
          display.selForContextMenu = cm.doc.sel;
          clearTimeout(display.detectingSelectAll);
          function prepareSelectAllHack() {
            if (te.selectionStart != null) {
              var selected = cm.somethingSelected();
              var extval = "​" + (selected ? te.value : "");
              te.value = "⇚";
              te.value = extval;
              input.prevInput = selected ? "" : "​";
              te.selectionStart = 1;
              te.selectionEnd = extval.length;
              display.selForContextMenu = cm.doc.sel;
            }
          }
          function rehide() {
            if (input.contextMenuPending != rehide) {
              return;
            }
            input.contextMenuPending = false;
            input.wrapper.style.cssText = oldWrapperCSS;
            te.style.cssText = oldCSS;
            if (ie && ie_version < 9) {
              display.scrollbars.setScrollTop(display.scroller.scrollTop = scrollPos);
            }
            if (te.selectionStart != null) {
              if (!ie || ie && ie_version < 9) {
                prepareSelectAllHack();
              }
              var i2 = 0, poll = function() {
                if (display.selForContextMenu == cm.doc.sel && te.selectionStart == 0 && te.selectionEnd > 0 && input.prevInput == "​") {
                  operation(cm, selectAll)(cm);
                } else if (i2++ < 10) {
                  display.detectingSelectAll = setTimeout(poll, 500);
                } else {
                  display.selForContextMenu = null;
                  display.input.reset();
                }
              };
              display.detectingSelectAll = setTimeout(poll, 200);
            }
          }
          if (ie && ie_version >= 9) {
            prepareSelectAllHack();
          }
          if (captureRightClick) {
            e_stop(e2);
            var mouseup = function() {
              off(window, "mouseup", mouseup);
              setTimeout(rehide, 20);
            };
            on(window, "mouseup", mouseup);
          } else {
            setTimeout(rehide, 50);
          }
        };
        TextareaInput.prototype.readOnlyChanged = function(val) {
          if (!val) {
            this.reset();
          }
          this.textarea.disabled = val == "nocursor";
          this.textarea.readOnly = !!val;
        };
        TextareaInput.prototype.setUneditable = function() {
        };
        TextareaInput.prototype.needsContentAttribute = false;
        function fromTextArea(textarea, options) {
          options = options ? copyObj(options) : {};
          options.value = textarea.value;
          if (!options.tabindex && textarea.tabIndex) {
            options.tabindex = textarea.tabIndex;
          }
          if (!options.placeholder && textarea.placeholder) {
            options.placeholder = textarea.placeholder;
          }
          if (options.autofocus == null) {
            var hasFocus = activeElt(textarea.ownerDocument);
            options.autofocus = hasFocus == textarea || textarea.getAttribute("autofocus") != null && hasFocus == document.body;
          }
          function save() {
            textarea.value = cm.getValue();
          }
          var realSubmit;
          if (textarea.form) {
            on(textarea.form, "submit", save);
            if (!options.leaveSubmitMethodAlone) {
              var form = textarea.form;
              realSubmit = form.submit;
              try {
                var wrappedSubmit = form.submit = function() {
                  save();
                  form.submit = realSubmit;
                  form.submit();
                  form.submit = wrappedSubmit;
                };
              } catch (e2) {
              }
            }
          }
          options.finishInit = function(cm2) {
            cm2.save = save;
            cm2.getTextArea = function() {
              return textarea;
            };
            cm2.toTextArea = function() {
              cm2.toTextArea = isNaN;
              save();
              textarea.parentNode.removeChild(cm2.getWrapperElement());
              textarea.style.display = "";
              if (textarea.form) {
                off(textarea.form, "submit", save);
                if (!options.leaveSubmitMethodAlone && typeof textarea.form.submit == "function") {
                  textarea.form.submit = realSubmit;
                }
              }
            };
          };
          textarea.style.display = "none";
          var cm = CodeMirror2(function(node) {
            return textarea.parentNode.insertBefore(node, textarea.nextSibling);
          }, options);
          return cm;
        }
        function addLegacyProps(CodeMirror3) {
          CodeMirror3.off = off;
          CodeMirror3.on = on;
          CodeMirror3.wheelEventPixels = wheelEventPixels;
          CodeMirror3.Doc = Doc;
          CodeMirror3.splitLines = splitLinesAuto;
          CodeMirror3.countColumn = countColumn;
          CodeMirror3.findColumn = findColumn;
          CodeMirror3.isWordChar = isWordCharBasic;
          CodeMirror3.Pass = Pass;
          CodeMirror3.signal = signal;
          CodeMirror3.Line = Line3;
          CodeMirror3.changeEnd = changeEnd;
          CodeMirror3.scrollbarModel = scrollbarModel;
          CodeMirror3.Pos = Pos;
          CodeMirror3.cmpPos = cmp;
          CodeMirror3.modes = modes;
          CodeMirror3.mimeModes = mimeModes;
          CodeMirror3.resolveMode = resolveMode;
          CodeMirror3.getMode = getMode;
          CodeMirror3.modeExtensions = modeExtensions;
          CodeMirror3.extendMode = extendMode;
          CodeMirror3.copyState = copyState;
          CodeMirror3.startState = startState;
          CodeMirror3.innerMode = innerMode;
          CodeMirror3.commands = commands;
          CodeMirror3.keyMap = keyMap;
          CodeMirror3.keyName = keyName;
          CodeMirror3.isModifierKey = isModifierKey;
          CodeMirror3.lookupKey = lookupKey;
          CodeMirror3.normalizeKeyMap = normalizeKeyMap;
          CodeMirror3.StringStream = StringStream;
          CodeMirror3.SharedTextMarker = SharedTextMarker;
          CodeMirror3.TextMarker = TextMarker;
          CodeMirror3.LineWidget = LineWidget;
          CodeMirror3.e_preventDefault = e_preventDefault;
          CodeMirror3.e_stopPropagation = e_stopPropagation;
          CodeMirror3.e_stop = e_stop;
          CodeMirror3.addClass = addClass;
          CodeMirror3.contains = contains;
          CodeMirror3.rmClass = rmClass;
          CodeMirror3.keyNames = keyNames;
        }
        defineOptions(CodeMirror2);
        addEditorMethods(CodeMirror2);
        var dontDelegate = "iter insert remove copy getEditor constructor".split(" ");
        for (var prop in Doc.prototype) {
          if (Doc.prototype.hasOwnProperty(prop) && indexOf2(dontDelegate, prop) < 0) {
            CodeMirror2.prototype[prop] = function(method) {
              return function() {
                return method.apply(this.doc, arguments);
              };
            }(Doc.prototype[prop]);
          }
        }
        eventMixin(Doc);
        CodeMirror2.inputStyles = { "textarea": TextareaInput, "contenteditable": ContentEditableInput };
        CodeMirror2.defineMode = function(name) {
          if (!CodeMirror2.defaults.mode && name != "null") {
            CodeMirror2.defaults.mode = name;
          }
          defineMode.apply(this, arguments);
        };
        CodeMirror2.defineMIME = defineMIME;
        CodeMirror2.defineMode("null", function() {
          return { token: function(stream) {
            return stream.skipToEnd();
          } };
        });
        CodeMirror2.defineMIME("text/plain", "null");
        CodeMirror2.defineExtension = function(name, func) {
          CodeMirror2.prototype[name] = func;
        };
        CodeMirror2.defineDocExtension = function(name, func) {
          Doc.prototype[name] = func;
        };
        CodeMirror2.fromTextArea = fromTextArea;
        addLegacyProps(CodeMirror2);
        CodeMirror2.version = "5.65.8";
        return CodeMirror2;
      });
    }
  });

  // node_modules/vue-codemirror/dist/vue-codemirror.js
  var require_vue_codemirror = __commonJS({
    "node_modules/vue-codemirror/dist/vue-codemirror.js"(exports, module) {
      !function(e2, t) {
        "object" == typeof exports && "object" == typeof module ? module.exports = t(require_codemirror()) : "function" == typeof define && define.amd ? define(["codemirror"], t) : "object" == typeof exports ? exports.VueCodemirror = t(require_codemirror()) : e2.VueCodemirror = t(e2.codemirror);
      }(exports, function(e2) {
        return function(e3) {
          function t(r) {
            if (n[r])
              return n[r].exports;
            var o = n[r] = { i: r, l: false, exports: {} };
            return e3[r].call(o.exports, o, o.exports, t), o.l = true, o.exports;
          }
          var n = {};
          return t.m = e3, t.c = n, t.i = function(e4) {
            return e4;
          }, t.d = function(e4, n2, r) {
            t.o(e4, n2) || Object.defineProperty(e4, n2, { configurable: false, enumerable: true, get: r });
          }, t.n = function(e4) {
            var n2 = e4 && e4.__esModule ? function() {
              return e4.default;
            } : function() {
              return e4;
            };
            return t.d(n2, "a", n2), n2;
          }, t.o = function(e4, t2) {
            return Object.prototype.hasOwnProperty.call(e4, t2);
          }, t.p = "/", t(t.s = 3);
        }([function(t, n) {
          t.exports = e2;
        }, function(e3, t, n) {
          "use strict";
          Object.defineProperty(t, "__esModule", { value: true });
          var r = n(0), o = function(e4) {
            return e4 && e4.__esModule ? e4 : { default: e4 };
          }(r), i = window.CodeMirror || o.default;
          "function" != typeof Object.assign && Object.defineProperty(Object, "assign", { value: function(e4, t2) {
            if (null == e4)
              throw new TypeError("Cannot convert undefined or null to object");
            for (var n2 = Object(e4), r2 = 1; r2 < arguments.length; r2++) {
              var o2 = arguments[r2];
              if (null != o2)
                for (var i2 in o2)
                  Object.prototype.hasOwnProperty.call(o2, i2) && (n2[i2] = o2[i2]);
            }
            return n2;
          }, writable: true, configurable: true }), t.default = { name: "codemirror", data: function() {
            return { content: "", codemirror: null, cminstance: null };
          }, props: { code: String, value: String, marker: Function, unseenLines: Array, name: { type: String, default: "codemirror" }, placeholder: { type: String, default: "" }, merge: { type: Boolean, default: false }, options: { type: Object, default: function() {
            return {};
          } }, events: { type: Array, default: function() {
            return [];
          } }, globalOptions: { type: Object, default: function() {
            return {};
          } }, globalEvents: { type: Array, default: function() {
            return [];
          } } }, watch: { options: { deep: true, handler: function(e4) {
            for (var t2 in e4)
              this.cminstance.setOption(t2, e4[t2]);
          } }, merge: function() {
            this.$nextTick(this.switchMerge);
          }, code: function(e4) {
            this.handerCodeChange(e4);
          }, value: function(e4) {
            this.handerCodeChange(e4);
          } }, methods: { initialize: function() {
            var e4 = this, t2 = Object.assign({}, this.globalOptions, this.options);
            this.merge ? (this.codemirror = i.MergeView(this.$refs.mergeview, t2), this.cminstance = this.codemirror.edit) : (this.codemirror = i.fromTextArea(this.$refs.textarea, t2), this.cminstance = this.codemirror, this.cminstance.setValue(this.code || this.value || this.content)), this.cminstance.on("change", function(t3) {
              e4.content = t3.getValue(), e4.$emit && e4.$emit("input", e4.content);
            });
            var n2 = {};
            ["scroll", "changes", "beforeChange", "cursorActivity", "keyHandled", "inputRead", "electricInput", "beforeSelectionChange", "viewportChange", "swapDoc", "gutterClick", "gutterContextMenu", "focus", "blur", "refresh", "optionChange", "scrollCursorIntoView", "update"].concat(this.events).concat(this.globalEvents).filter(function(e5) {
              return !n2[e5] && (n2[e5] = true);
            }).forEach(function(t3) {
              e4.cminstance.on(t3, function() {
                for (var n3 = arguments.length, r2 = Array(n3), o2 = 0; o2 < n3; o2++)
                  r2[o2] = arguments[o2];
                e4.$emit.apply(e4, [t3].concat(r2));
                var i2 = t3.replace(/([A-Z])/g, "-$1").toLowerCase();
                i2 !== t3 && e4.$emit.apply(e4, [i2].concat(r2));
              });
            });
            this.$emit("ready", this.codemirror), this.unseenLineMarkers(), this.refresh();
          }, refresh: function() {
            var e4 = this;
            this.$nextTick(function() {
              e4.cminstance.refresh();
            });
          }, destroy: function() {
            var e4 = this.cminstance.doc.cm.getWrapperElement();
            e4 && e4.remove && e4.remove();
          }, handerCodeChange: function(e4) {
            if (e4 !== this.cminstance.getValue()) {
              var t2 = this.cminstance.getScrollInfo();
              this.cminstance.setValue(e4), this.content = e4, this.cminstance.scrollTo(t2.left, t2.top);
            }
            this.unseenLineMarkers();
          }, unseenLineMarkers: function() {
            var e4 = this;
            void 0 !== this.unseenLines && void 0 !== this.marker && this.unseenLines.forEach(function(t2) {
              var n2 = e4.cminstance.lineInfo(t2);
              e4.cminstance.setGutterMarker(t2, "breakpoints", n2.gutterMarkers ? null : e4.marker());
            });
          }, switchMerge: function() {
            var e4 = this.cminstance.doc.history, t2 = this.cminstance.doc.cleanGeneration;
            this.options.value = this.cminstance.getValue(), this.destroy(), this.initialize(), this.cminstance.doc.history = e4, this.cminstance.doc.cleanGeneration = t2;
          } }, mounted: function() {
            this.initialize();
          }, beforeDestroy: function() {
            this.destroy();
          } };
        }, function(e3, t, n) {
          "use strict";
          Object.defineProperty(t, "__esModule", { value: true });
          var r = n(1), o = n.n(r);
          for (var i in r)
            ["default", "default"].indexOf(i) < 0 && function(e4) {
              n.d(t, e4, function() {
                return r[e4];
              });
            }(i);
          var s = n(5), c = n(4), a = c(o.a, s.a, false, null, null, null);
          t.default = a.exports;
        }, function(e3, t, n) {
          "use strict";
          function r(e4) {
            return e4 && e4.__esModule ? e4 : { default: e4 };
          }
          Object.defineProperty(t, "__esModule", { value: true }), t.install = t.codemirror = t.CodeMirror = void 0;
          var o = n(0), i = r(o), s = n(2), c = r(s), a = window.CodeMirror || i.default, u = function(e4, t2) {
            t2 && (t2.options && (c.default.props.globalOptions.default = function() {
              return t2.options;
            }), t2.events && (c.default.props.globalEvents.default = function() {
              return t2.events;
            })), e4.component(c.default.name, c.default);
          }, l = { CodeMirror: a, codemirror: c.default, install: u };
          t.default = l, t.CodeMirror = a, t.codemirror = c.default, t.install = u;
        }, function(e3, t) {
          e3.exports = function(e4, t2, n, r, o, i) {
            var s, c = e4 = e4 || {}, a = typeof e4.default;
            "object" !== a && "function" !== a || (s = e4, c = e4.default);
            var u = "function" == typeof c ? c.options : c;
            t2 && (u.render = t2.render, u.staticRenderFns = t2.staticRenderFns, u._compiled = true), n && (u.functional = true), o && (u._scopeId = o);
            var l;
            if (i ? (l = function(e5) {
              e5 = e5 || this.$vnode && this.$vnode.ssrContext || this.parent && this.parent.$vnode && this.parent.$vnode.ssrContext, e5 || "undefined" == typeof __VUE_SSR_CONTEXT__ || (e5 = __VUE_SSR_CONTEXT__), r && r.call(this, e5), e5 && e5._registeredComponents && e5._registeredComponents.add(i);
            }, u._ssrRegister = l) : r && (l = r), l) {
              var f = u.functional, d = f ? u.render : u.beforeCreate;
              f ? (u._injectStyles = l, u.render = function(e5, t3) {
                return l.call(t3), d(e5, t3);
              }) : u.beforeCreate = d ? [].concat(d, l) : [l];
            }
            return { esModule: s, exports: c, options: u };
          };
        }, function(e3, t, n) {
          "use strict";
          var r = function() {
            var e4 = this, t2 = e4.$createElement, n2 = e4._self._c || t2;
            return n2("div", { staticClass: "vue-codemirror", class: { merge: e4.merge } }, [e4.merge ? n2("div", { ref: "mergeview" }) : n2("textarea", { ref: "textarea", attrs: { name: e4.name, placeholder: e4.placeholder } })]);
          }, o = [], i = { render: r, staticRenderFns: o };
          t.a = i;
        }]);
      });
    }
  });

  // src/views/demo/example2.m.vue
  var example2_m_exports = {};
  __export(example2_m_exports, {
    default: () => example2_m
  });

  // node_modules/echarts/index.js
  var echarts_exports2 = {};
  __export(echarts_exports2, {
    Axis: () => Axis_default,
    ChartView: () => Chart_default,
    ComponentModel: () => Component_default,
    ComponentView: () => Component_default2,
    List: () => SeriesData_default,
    Model: () => Model_default,
    PRIORITY: () => PRIORITY,
    SeriesModel: () => Series_default,
    color: () => color_exports,
    connect: () => connect,
    dataTool: () => dataTool,
    dependencies: () => dependencies,
    disConnect: () => disConnect,
    disconnect: () => disconnect,
    dispose: () => dispose2,
    env: () => env_default,
    extendChartView: () => extendChartView,
    extendComponentModel: () => extendComponentModel,
    extendComponentView: () => extendComponentView,
    extendSeriesModel: () => extendSeriesModel,
    format: () => format_exports2,
    getCoordinateSystemDimensions: () => getCoordinateSystemDimensions,
    getInstanceByDom: () => getInstanceByDom,
    getInstanceById: () => getInstanceById,
    getMap: () => getMap,
    graphic: () => graphic_exports2,
    helper: () => helper_exports2,
    init: () => init2,
    innerDrawElementOnCanvas: () => brushSingle,
    matrix: () => matrix_exports,
    number: () => number_exports2,
    parseGeoJSON: () => parseGeoJSON,
    parseGeoJson: () => parseGeoJSON,
    registerAction: () => registerAction,
    registerCoordinateSystem: () => registerCoordinateSystem,
    registerLayout: () => registerLayout,
    registerLoading: () => registerLoading,
    registerLocale: () => registerLocale,
    registerMap: () => registerMap,
    registerPostInit: () => registerPostInit,
    registerPostUpdate: () => registerPostUpdate,
    registerPreprocessor: () => registerPreprocessor,
    registerProcessor: () => registerProcessor,
    registerTheme: () => registerTheme,
    registerTransform: () => registerTransform,
    registerUpdateLifecycle: () => registerUpdateLifecycle,
    registerVisual: () => registerVisual,
    setCanvasCreator: () => setCanvasCreator,
    setPlatformAPI: () => setPlatformAPI,
    throttle: () => throttle,
    time: () => time_exports,
    use: () => use,
    util: () => util_exports2,
    vector: () => vector_exports,
    version: () => version2,
    zrUtil: () => util_exports,
    zrender: () => zrender_exports
  });

  // node_modules/echarts/node_modules/tslib/modules/index.js
  var import_tslib = __toESM(require_tslib(), 1);
  var {
    __extends,
    __assign,
    __rest,
    __decorate,
    __param,
    __metadata,
    __awaiter,
    __generator,
    __exportStar,
    __createBinding,
    __values,
    __read,
    __spread,
    __spreadArrays,
    __spreadArray,
    __await,
    __asyncGenerator,
    __asyncDelegator,
    __asyncValues,
    __makeTemplateObject,
    __importStar,
    __importDefault,
    __classPrivateFieldGet,
    __classPrivateFieldSet
  } = import_tslib.default;

  // node_modules/zrender/lib/zrender.js
  var zrender_exports = {};
  __export(zrender_exports, {
    dispose: () => dispose,
    disposeAll: () => disposeAll,
    getInstance: () => getInstance,
    init: () => init,
    registerPainter: () => registerPainter,
    version: () => version
  });

  // node_modules/zrender/lib/core/env.js
  var Browser = function() {
    function Browser2() {
      this.firefox = false;
      this.ie = false;
      this.edge = false;
      this.newEdge = false;
      this.weChat = false;
    }
    return Browser2;
  }();
  var Env = function() {
    function Env2() {
      this.browser = new Browser();
      this.node = false;
      this.wxa = false;
      this.worker = false;
      this.svgSupported = false;
      this.touchEventsSupported = false;
      this.pointerEventsSupported = false;
      this.domSupported = false;
      this.transformSupported = false;
      this.transform3dSupported = false;
      this.hasGlobalWindow = typeof window !== "undefined";
    }
    return Env2;
  }();
  var env = new Env();
  if (typeof wx === "object" && typeof wx.getSystemInfoSync === "function") {
    env.wxa = true;
    env.touchEventsSupported = true;
  } else if (typeof document === "undefined" && typeof self !== "undefined") {
    env.worker = true;
  } else if (typeof navigator === "undefined") {
    env.node = true;
    env.svgSupported = true;
  } else {
    detect(navigator.userAgent, env);
  }
  function detect(ua, env2) {
    var browser = env2.browser;
    var firefox = ua.match(/Firefox\/([\d.]+)/);
    var ie = ua.match(/MSIE\s([\d.]+)/) || ua.match(/Trident\/.+?rv:(([\d.]+))/);
    var edge = ua.match(/Edge?\/([\d.]+)/);
    var weChat = /micromessenger/i.test(ua);
    if (firefox) {
      browser.firefox = true;
      browser.version = firefox[1];
    }
    if (ie) {
      browser.ie = true;
      browser.version = ie[1];
    }
    if (edge) {
      browser.edge = true;
      browser.version = edge[1];
      browser.newEdge = +edge[1].split(".")[0] > 18;
    }
    if (weChat) {
      browser.weChat = true;
    }
    env2.svgSupported = typeof SVGRect !== "undefined";
    env2.touchEventsSupported = "ontouchstart" in window && !browser.ie && !browser.edge;
    env2.pointerEventsSupported = "onpointerdown" in window && (browser.edge || browser.ie && +browser.version >= 11);
    env2.domSupported = typeof document !== "undefined";
    var style = document.documentElement.style;
    env2.transform3dSupported = (browser.ie && "transition" in style || browser.edge || "WebKitCSSMatrix" in window && "m11" in new WebKitCSSMatrix() || "MozPerspective" in style) && !("OTransition" in style);
    env2.transformSupported = env2.transform3dSupported || browser.ie && +browser.version >= 9;
  }
  var env_default = env;

  // node_modules/zrender/lib/core/util.js
  var util_exports = {};
  __export(util_exports, {
    HashMap: () => HashMap,
    RADIAN_TO_DEGREE: () => RADIAN_TO_DEGREE,
    assert: () => assert,
    bind: () => bind,
    clone: () => clone,
    concatArray: () => concatArray,
    createCanvas: () => createCanvas,
    createHashMap: () => createHashMap,
    createObject: () => createObject,
    curry: () => curry,
    defaults: () => defaults,
    disableUserSelect: () => disableUserSelect,
    each: () => each,
    eqNaN: () => eqNaN,
    extend: () => extend,
    filter: () => filter,
    find: () => find,
    guid: () => guid,
    hasOwn: () => hasOwn,
    indexOf: () => indexOf,
    inherits: () => inherits,
    isArray: () => isArray,
    isArrayLike: () => isArrayLike,
    isBuiltInObject: () => isBuiltInObject,
    isDom: () => isDom,
    isFunction: () => isFunction,
    isGradientObject: () => isGradientObject,
    isImagePatternObject: () => isImagePatternObject,
    isNumber: () => isNumber,
    isObject: () => isObject,
    isPrimitive: () => isPrimitive,
    isRegExp: () => isRegExp,
    isString: () => isString,
    isStringSafe: () => isStringSafe,
    isTypedArray: () => isTypedArray,
    keys: () => keys,
    logError: () => logError,
    map: () => map,
    merge: () => merge,
    mergeAll: () => mergeAll,
    mixin: () => mixin,
    noop: () => noop,
    normalizeCssArray: () => normalizeCssArray,
    reduce: () => reduce,
    retrieve: () => retrieve,
    retrieve2: () => retrieve2,
    retrieve3: () => retrieve3,
    setAsPrimitive: () => setAsPrimitive,
    slice: () => slice,
    trim: () => trim
  });

  // node_modules/zrender/lib/core/platform.js
  var DEFAULT_FONT_SIZE = 12;
  var DEFAULT_FONT_FAMILY = "sans-serif";
  var DEFAULT_FONT = DEFAULT_FONT_SIZE + "px " + DEFAULT_FONT_FAMILY;
  var OFFSET = 20;
  var SCALE = 100;
  var defaultWidthMapStr = "007LLmW'55;N0500LLLLLLLLLL00NNNLzWW\\\\WQb\\0FWLg\\bWb\\WQ\\WrWWQ000CL5LLFLL0LL**F*gLLLL5F0LF\\FFF5.5N";
  function getTextWidthMap(mapStr) {
    var map3 = {};
    if (typeof JSON === "undefined") {
      return map3;
    }
    for (var i = 0; i < mapStr.length; i++) {
      var char = String.fromCharCode(i + 32);
      var size = (mapStr.charCodeAt(i) - OFFSET) / SCALE;
      map3[char] = size;
    }
    return map3;
  }
  var DEFAULT_TEXT_WIDTH_MAP = getTextWidthMap(defaultWidthMapStr);
  var platformApi = {
    createCanvas: function() {
      return typeof document !== "undefined" && document.createElement("canvas");
    },
    measureText: function() {
      var _ctx;
      var _cachedFont;
      return function(text, font) {
        if (!_ctx) {
          var canvas = platformApi.createCanvas();
          _ctx = canvas && canvas.getContext("2d");
        }
        if (_ctx) {
          if (_cachedFont !== font) {
            _cachedFont = _ctx.font = font || DEFAULT_FONT;
          }
          return _ctx.measureText(text);
        } else {
          text = text || "";
          font = font || DEFAULT_FONT;
          var res = /^([0-9]*?)px$/.exec(font);
          var fontSize = +(res && res[1]) || DEFAULT_FONT_SIZE;
          var width = 0;
          if (font.indexOf("mono") >= 0) {
            width = fontSize * text.length;
          } else {
            for (var i = 0; i < text.length; i++) {
              var preCalcWidth = DEFAULT_TEXT_WIDTH_MAP[text[i]];
              width += preCalcWidth == null ? fontSize : preCalcWidth * fontSize;
            }
          }
          return { width };
        }
      };
    }(),
    loadImage: function(src, onload, onerror) {
      var image = new Image();
      image.onload = onload;
      image.onerror = onerror;
      image.src = src;
      return image;
    }
  };
  function setPlatformAPI(newPlatformApis) {
    for (var key in platformApi) {
      if (newPlatformApis[key]) {
        platformApi[key] = newPlatformApis[key];
      }
    }
  }

  // node_modules/zrender/lib/core/util.js
  var BUILTIN_OBJECT = reduce([
    "Function",
    "RegExp",
    "Date",
    "Error",
    "CanvasGradient",
    "CanvasPattern",
    "Image",
    "Canvas"
  ], function(obj, val) {
    obj["[object " + val + "]"] = true;
    return obj;
  }, {});
  var TYPED_ARRAY = reduce([
    "Int8",
    "Uint8",
    "Uint8Clamped",
    "Int16",
    "Uint16",
    "Int32",
    "Uint32",
    "Float32",
    "Float64"
  ], function(obj, val) {
    obj["[object " + val + "Array]"] = true;
    return obj;
  }, {});
  var objToString = Object.prototype.toString;
  var arrayProto = Array.prototype;
  var nativeForEach = arrayProto.forEach;
  var nativeFilter = arrayProto.filter;
  var nativeSlice = arrayProto.slice;
  var nativeMap = arrayProto.map;
  var ctorFunction = function() {
  }.constructor;
  var protoFunction = ctorFunction ? ctorFunction.prototype : null;
  var protoKey = "__proto__";
  var idStart = 2311;
  function guid() {
    return idStart++;
  }
  function logError() {
    var args = [];
    for (var _i = 0; _i < arguments.length; _i++) {
      args[_i] = arguments[_i];
    }
    if (typeof console !== "undefined") {
      console.error.apply(console, args);
    }
  }
  function clone(source) {
    if (source == null || typeof source !== "object") {
      return source;
    }
    var result = source;
    var typeStr = objToString.call(source);
    if (typeStr === "[object Array]") {
      if (!isPrimitive(source)) {
        result = [];
        for (var i = 0, len2 = source.length; i < len2; i++) {
          result[i] = clone(source[i]);
        }
      }
    } else if (TYPED_ARRAY[typeStr]) {
      if (!isPrimitive(source)) {
        var Ctor = source.constructor;
        if (Ctor.from) {
          result = Ctor.from(source);
        } else {
          result = new Ctor(source.length);
          for (var i = 0, len2 = source.length; i < len2; i++) {
            result[i] = source[i];
          }
        }
      }
    } else if (!BUILTIN_OBJECT[typeStr] && !isPrimitive(source) && !isDom(source)) {
      result = {};
      for (var key in source) {
        if (source.hasOwnProperty(key) && key !== protoKey) {
          result[key] = clone(source[key]);
        }
      }
    }
    return result;
  }
  function merge(target, source, overwrite) {
    if (!isObject(source) || !isObject(target)) {
      return overwrite ? clone(source) : target;
    }
    for (var key in source) {
      if (source.hasOwnProperty(key) && key !== protoKey) {
        var targetProp = target[key];
        var sourceProp = source[key];
        if (isObject(sourceProp) && isObject(targetProp) && !isArray(sourceProp) && !isArray(targetProp) && !isDom(sourceProp) && !isDom(targetProp) && !isBuiltInObject(sourceProp) && !isBuiltInObject(targetProp) && !isPrimitive(sourceProp) && !isPrimitive(targetProp)) {
          merge(targetProp, sourceProp, overwrite);
        } else if (overwrite || !(key in target)) {
          target[key] = clone(source[key]);
        }
      }
    }
    return target;
  }
  function mergeAll(targetAndSources, overwrite) {
    var result = targetAndSources[0];
    for (var i = 1, len2 = targetAndSources.length; i < len2; i++) {
      result = merge(result, targetAndSources[i], overwrite);
    }
    return result;
  }
  function extend(target, source) {
    if (Object.assign) {
      Object.assign(target, source);
    } else {
      for (var key in source) {
        if (source.hasOwnProperty(key) && key !== protoKey) {
          target[key] = source[key];
        }
      }
    }
    return target;
  }
  function defaults(target, source, overlay) {
    var keysArr = keys(source);
    for (var i = 0; i < keysArr.length; i++) {
      var key = keysArr[i];
      if (overlay ? source[key] != null : target[key] == null) {
        target[key] = source[key];
      }
    }
    return target;
  }
  var createCanvas = platformApi.createCanvas;
  function indexOf(array, value) {
    if (array) {
      if (array.indexOf) {
        return array.indexOf(value);
      }
      for (var i = 0, len2 = array.length; i < len2; i++) {
        if (array[i] === value) {
          return i;
        }
      }
    }
    return -1;
  }
  function inherits(clazz, baseClazz) {
    var clazzPrototype = clazz.prototype;
    function F() {
    }
    F.prototype = baseClazz.prototype;
    clazz.prototype = new F();
    for (var prop in clazzPrototype) {
      if (clazzPrototype.hasOwnProperty(prop)) {
        clazz.prototype[prop] = clazzPrototype[prop];
      }
    }
    clazz.prototype.constructor = clazz;
    clazz.superClass = baseClazz;
  }
  function mixin(target, source, override) {
    target = "prototype" in target ? target.prototype : target;
    source = "prototype" in source ? source.prototype : source;
    if (Object.getOwnPropertyNames) {
      var keyList = Object.getOwnPropertyNames(source);
      for (var i = 0; i < keyList.length; i++) {
        var key = keyList[i];
        if (key !== "constructor") {
          if (override ? source[key] != null : target[key] == null) {
            target[key] = source[key];
          }
        }
      }
    } else {
      defaults(target, source, override);
    }
  }
  function isArrayLike(data) {
    if (!data) {
      return false;
    }
    if (typeof data === "string") {
      return false;
    }
    return typeof data.length === "number";
  }
  function each(arr, cb, context) {
    if (!(arr && cb)) {
      return;
    }
    if (arr.forEach && arr.forEach === nativeForEach) {
      arr.forEach(cb, context);
    } else if (arr.length === +arr.length) {
      for (var i = 0, len2 = arr.length; i < len2; i++) {
        cb.call(context, arr[i], i, arr);
      }
    } else {
      for (var key in arr) {
        if (arr.hasOwnProperty(key)) {
          cb.call(context, arr[key], key, arr);
        }
      }
    }
  }
  function map(arr, cb, context) {
    if (!arr) {
      return [];
    }
    if (!cb) {
      return slice(arr);
    }
    if (arr.map && arr.map === nativeMap) {
      return arr.map(cb, context);
    } else {
      var result = [];
      for (var i = 0, len2 = arr.length; i < len2; i++) {
        result.push(cb.call(context, arr[i], i, arr));
      }
      return result;
    }
  }
  function reduce(arr, cb, memo, context) {
    if (!(arr && cb)) {
      return;
    }
    for (var i = 0, len2 = arr.length; i < len2; i++) {
      memo = cb.call(context, memo, arr[i], i, arr);
    }
    return memo;
  }
  function filter(arr, cb, context) {
    if (!arr) {
      return [];
    }
    if (!cb) {
      return slice(arr);
    }
    if (arr.filter && arr.filter === nativeFilter) {
      return arr.filter(cb, context);
    } else {
      var result = [];
      for (var i = 0, len2 = arr.length; i < len2; i++) {
        if (cb.call(context, arr[i], i, arr)) {
          result.push(arr[i]);
        }
      }
      return result;
    }
  }
  function find(arr, cb, context) {
    if (!(arr && cb)) {
      return;
    }
    for (var i = 0, len2 = arr.length; i < len2; i++) {
      if (cb.call(context, arr[i], i, arr)) {
        return arr[i];
      }
    }
  }
  function keys(obj) {
    if (!obj) {
      return [];
    }
    if (Object.keys) {
      return Object.keys(obj);
    }
    var keyList = [];
    for (var key in obj) {
      if (obj.hasOwnProperty(key)) {
        keyList.push(key);
      }
    }
    return keyList;
  }
  function bindPolyfill(func, context) {
    var args = [];
    for (var _i = 2; _i < arguments.length; _i++) {
      args[_i - 2] = arguments[_i];
    }
    return function() {
      return func.apply(context, args.concat(nativeSlice.call(arguments)));
    };
  }
  var bind = protoFunction && isFunction(protoFunction.bind) ? protoFunction.call.bind(protoFunction.bind) : bindPolyfill;
  function curry(func) {
    var args = [];
    for (var _i = 1; _i < arguments.length; _i++) {
      args[_i - 1] = arguments[_i];
    }
    return function() {
      return func.apply(this, args.concat(nativeSlice.call(arguments)));
    };
  }
  function isArray(value) {
    if (Array.isArray) {
      return Array.isArray(value);
    }
    return objToString.call(value) === "[object Array]";
  }
  function isFunction(value) {
    return typeof value === "function";
  }
  function isString(value) {
    return typeof value === "string";
  }
  function isStringSafe(value) {
    return objToString.call(value) === "[object String]";
  }
  function isNumber(value) {
    return typeof value === "number";
  }
  function isObject(value) {
    var type = typeof value;
    return type === "function" || !!value && type === "object";
  }
  function isBuiltInObject(value) {
    return !!BUILTIN_OBJECT[objToString.call(value)];
  }
  function isTypedArray(value) {
    return !!TYPED_ARRAY[objToString.call(value)];
  }
  function isDom(value) {
    return typeof value === "object" && typeof value.nodeType === "number" && typeof value.ownerDocument === "object";
  }
  function isGradientObject(value) {
    return value.colorStops != null;
  }
  function isImagePatternObject(value) {
    return value.image != null;
  }
  function isRegExp(value) {
    return objToString.call(value) === "[object RegExp]";
  }
  function eqNaN(value) {
    return value !== value;
  }
  function retrieve() {
    var args = [];
    for (var _i = 0; _i < arguments.length; _i++) {
      args[_i] = arguments[_i];
    }
    for (var i = 0, len2 = args.length; i < len2; i++) {
      if (args[i] != null) {
        return args[i];
      }
    }
  }
  function retrieve2(value0, value1) {
    return value0 != null ? value0 : value1;
  }
  function retrieve3(value0, value1, value2) {
    return value0 != null ? value0 : value1 != null ? value1 : value2;
  }
  function slice(arr) {
    var args = [];
    for (var _i = 1; _i < arguments.length; _i++) {
      args[_i - 1] = arguments[_i];
    }
    return nativeSlice.apply(arr, args);
  }
  function normalizeCssArray(val) {
    if (typeof val === "number") {
      return [val, val, val, val];
    }
    var len2 = val.length;
    if (len2 === 2) {
      return [val[0], val[1], val[0], val[1]];
    } else if (len2 === 3) {
      return [val[0], val[1], val[2], val[1]];
    }
    return val;
  }
  function assert(condition, message) {
    if (!condition) {
      throw new Error(message);
    }
  }
  function trim(str) {
    if (str == null) {
      return null;
    } else if (typeof str.trim === "function") {
      return str.trim();
    } else {
      return str.replace(/^[\s\uFEFF\xA0]+|[\s\uFEFF\xA0]+$/g, "");
    }
  }
  var primitiveKey = "__ec_primitive__";
  function setAsPrimitive(obj) {
    obj[primitiveKey] = true;
  }
  function isPrimitive(obj) {
    return obj[primitiveKey];
  }
  var HashMap = function() {
    function HashMap2(obj) {
      this.data = {};
      var isArr = isArray(obj);
      this.data = {};
      var thisMap = this;
      obj instanceof HashMap2 ? obj.each(visit) : obj && each(obj, visit);
      function visit(value, key) {
        isArr ? thisMap.set(value, key) : thisMap.set(key, value);
      }
    }
    HashMap2.prototype.get = function(key) {
      return this.data.hasOwnProperty(key) ? this.data[key] : null;
    };
    HashMap2.prototype.set = function(key, value) {
      return this.data[key] = value;
    };
    HashMap2.prototype.each = function(cb, context) {
      for (var key in this.data) {
        if (this.data.hasOwnProperty(key)) {
          cb.call(context, this.data[key], key);
        }
      }
    };
    HashMap2.prototype.keys = function() {
      return keys(this.data);
    };
    HashMap2.prototype.removeKey = function(key) {
      delete this.data[key];
    };
    return HashMap2;
  }();
  function createHashMap(obj) {
    return new HashMap(obj);
  }
  function concatArray(a, b) {
    var newArray = new a.constructor(a.length + b.length);
    for (var i = 0; i < a.length; i++) {
      newArray[i] = a[i];
    }
    var offset = a.length;
    for (var i = 0; i < b.length; i++) {
      newArray[i + offset] = b[i];
    }
    return newArray;
  }
  function createObject(proto2, properties) {
    var obj;
    if (Object.create) {
      obj = Object.create(proto2);
    } else {
      var StyleCtor = function() {
      };
      StyleCtor.prototype = proto2;
      obj = new StyleCtor();
    }
    if (properties) {
      extend(obj, properties);
    }
    return obj;
  }
  function disableUserSelect(dom) {
    var domStyle = dom.style;
    domStyle.webkitUserSelect = "none";
    domStyle.userSelect = "none";
    domStyle.webkitTapHighlightColor = "rgba(0,0,0,0)";
    domStyle["-webkit-touch-callout"] = "none";
  }
  function hasOwn(own, prop) {
    return own.hasOwnProperty(prop);
  }
  function noop() {
  }
  var RADIAN_TO_DEGREE = 180 / Math.PI;

  // node_modules/zrender/node_modules/tslib/modules/index.js
  var import_tslib2 = __toESM(require_tslib2(), 1);
  var {
    __extends: __extends2,
    __assign: __assign2,
    __rest: __rest2,
    __decorate: __decorate2,
    __param: __param2,
    __metadata: __metadata2,
    __awaiter: __awaiter2,
    __generator: __generator2,
    __exportStar: __exportStar2,
    __createBinding: __createBinding2,
    __values: __values2,
    __read: __read2,
    __spread: __spread2,
    __spreadArrays: __spreadArrays2,
    __spreadArray: __spreadArray2,
    __await: __await2,
    __asyncGenerator: __asyncGenerator2,
    __asyncDelegator: __asyncDelegator2,
    __asyncValues: __asyncValues2,
    __makeTemplateObject: __makeTemplateObject2,
    __importStar: __importStar2,
    __importDefault: __importDefault2,
    __classPrivateFieldGet: __classPrivateFieldGet2,
    __classPrivateFieldSet: __classPrivateFieldSet2
  } = import_tslib2.default;

  // node_modules/zrender/lib/core/vector.js
  var vector_exports = {};
  __export(vector_exports, {
    add: () => add,
    applyTransform: () => applyTransform,
    clone: () => clone2,
    copy: () => copy,
    create: () => create,
    dist: () => dist,
    distSquare: () => distSquare,
    distance: () => distance,
    distanceSquare: () => distanceSquare,
    div: () => div,
    dot: () => dot,
    len: () => len,
    lenSquare: () => lenSquare,
    length: () => length,
    lengthSquare: () => lengthSquare,
    lerp: () => lerp,
    max: () => max,
    min: () => min,
    mul: () => mul,
    negate: () => negate,
    normalize: () => normalize,
    scale: () => scale,
    scaleAndAdd: () => scaleAndAdd,
    set: () => set,
    sub: () => sub
  });
  function create(x, y) {
    if (x == null) {
      x = 0;
    }
    if (y == null) {
      y = 0;
    }
    return [x, y];
  }
  function copy(out2, v) {
    out2[0] = v[0];
    out2[1] = v[1];
    return out2;
  }
  function clone2(v) {
    return [v[0], v[1]];
  }
  function set(out2, a, b) {
    out2[0] = a;
    out2[1] = b;
    return out2;
  }
  function add(out2, v12, v22) {
    out2[0] = v12[0] + v22[0];
    out2[1] = v12[1] + v22[1];
    return out2;
  }
  function scaleAndAdd(out2, v12, v22, a) {
    out2[0] = v12[0] + v22[0] * a;
    out2[1] = v12[1] + v22[1] * a;
    return out2;
  }
  function sub(out2, v12, v22) {
    out2[0] = v12[0] - v22[0];
    out2[1] = v12[1] - v22[1];
    return out2;
  }
  function len(v) {
    return Math.sqrt(lenSquare(v));
  }
  var length = len;
  function lenSquare(v) {
    return v[0] * v[0] + v[1] * v[1];
  }
  var lengthSquare = lenSquare;
  function mul(out2, v12, v22) {
    out2[0] = v12[0] * v22[0];
    out2[1] = v12[1] * v22[1];
    return out2;
  }
  function div(out2, v12, v22) {
    out2[0] = v12[0] / v22[0];
    out2[1] = v12[1] / v22[1];
    return out2;
  }
  function dot(v12, v22) {
    return v12[0] * v22[0] + v12[1] * v22[1];
  }
  function scale(out2, v, s) {
    out2[0] = v[0] * s;
    out2[1] = v[1] * s;
    return out2;
  }
  function normalize(out2, v) {
    var d = len(v);
    if (d === 0) {
      out2[0] = 0;
      out2[1] = 0;
    } else {
      out2[0] = v[0] / d;
      out2[1] = v[1] / d;
    }
    return out2;
  }
  function distance(v12, v22) {
    return Math.sqrt((v12[0] - v22[0]) * (v12[0] - v22[0]) + (v12[1] - v22[1]) * (v12[1] - v22[1]));
  }
  var dist = distance;
  function distanceSquare(v12, v22) {
    return (v12[0] - v22[0]) * (v12[0] - v22[0]) + (v12[1] - v22[1]) * (v12[1] - v22[1]);
  }
  var distSquare = distanceSquare;
  function negate(out2, v) {
    out2[0] = -v[0];
    out2[1] = -v[1];
    return out2;
  }
  function lerp(out2, v12, v22, t) {
    out2[0] = v12[0] + t * (v22[0] - v12[0]);
    out2[1] = v12[1] + t * (v22[1] - v12[1]);
    return out2;
  }
  function applyTransform(out2, v, m2) {
    var x = v[0];
    var y = v[1];
    out2[0] = m2[0] * x + m2[2] * y + m2[4];
    out2[1] = m2[1] * x + m2[3] * y + m2[5];
    return out2;
  }
  function min(out2, v12, v22) {
    out2[0] = Math.min(v12[0], v22[0]);
    out2[1] = Math.min(v12[1], v22[1]);
    return out2;
  }
  function max(out2, v12, v22) {
    out2[0] = Math.max(v12[0], v22[0]);
    out2[1] = Math.max(v12[1], v22[1]);
    return out2;
  }

  // node_modules/zrender/lib/mixin/Draggable.js
  var Param = function() {
    function Param2(target, e2) {
      this.target = target;
      this.topTarget = e2 && e2.topTarget;
    }
    return Param2;
  }();
  var Draggable = function() {
    function Draggable2(handler) {
      this.handler = handler;
      handler.on("mousedown", this._dragStart, this);
      handler.on("mousemove", this._drag, this);
      handler.on("mouseup", this._dragEnd, this);
    }
    Draggable2.prototype._dragStart = function(e2) {
      var draggingTarget = e2.target;
      while (draggingTarget && !draggingTarget.draggable) {
        draggingTarget = draggingTarget.parent || draggingTarget.__hostTarget;
      }
      if (draggingTarget) {
        this._draggingTarget = draggingTarget;
        draggingTarget.dragging = true;
        this._x = e2.offsetX;
        this._y = e2.offsetY;
        this.handler.dispatchToElement(new Param(draggingTarget, e2), "dragstart", e2.event);
      }
    };
    Draggable2.prototype._drag = function(e2) {
      var draggingTarget = this._draggingTarget;
      if (draggingTarget) {
        var x = e2.offsetX;
        var y = e2.offsetY;
        var dx = x - this._x;
        var dy = y - this._y;
        this._x = x;
        this._y = y;
        draggingTarget.drift(dx, dy, e2);
        this.handler.dispatchToElement(new Param(draggingTarget, e2), "drag", e2.event);
        var dropTarget = this.handler.findHover(x, y, draggingTarget).target;
        var lastDropTarget = this._dropTarget;
        this._dropTarget = dropTarget;
        if (draggingTarget !== dropTarget) {
          if (lastDropTarget && dropTarget !== lastDropTarget) {
            this.handler.dispatchToElement(new Param(lastDropTarget, e2), "dragleave", e2.event);
          }
          if (dropTarget && dropTarget !== lastDropTarget) {
            this.handler.dispatchToElement(new Param(dropTarget, e2), "dragenter", e2.event);
          }
        }
      }
    };
    Draggable2.prototype._dragEnd = function(e2) {
      var draggingTarget = this._draggingTarget;
      if (draggingTarget) {
        draggingTarget.dragging = false;
      }
      this.handler.dispatchToElement(new Param(draggingTarget, e2), "dragend", e2.event);
      if (this._dropTarget) {
        this.handler.dispatchToElement(new Param(this._dropTarget, e2), "drop", e2.event);
      }
      this._draggingTarget = null;
      this._dropTarget = null;
    };
    return Draggable2;
  }();
  var Draggable_default = Draggable;

  // node_modules/zrender/lib/core/Eventful.js
  var Eventful = function() {
    function Eventful2(eventProcessors) {
      if (eventProcessors) {
        this._$eventProcessor = eventProcessors;
      }
    }
    Eventful2.prototype.on = function(event, query, handler, context) {
      if (!this._$handlers) {
        this._$handlers = {};
      }
      var _h = this._$handlers;
      if (typeof query === "function") {
        context = handler;
        handler = query;
        query = null;
      }
      if (!handler || !event) {
        return this;
      }
      var eventProcessor = this._$eventProcessor;
      if (query != null && eventProcessor && eventProcessor.normalizeQuery) {
        query = eventProcessor.normalizeQuery(query);
      }
      if (!_h[event]) {
        _h[event] = [];
      }
      for (var i = 0; i < _h[event].length; i++) {
        if (_h[event][i].h === handler) {
          return this;
        }
      }
      var wrap = {
        h: handler,
        query,
        ctx: context || this,
        callAtLast: handler.zrEventfulCallAtLast
      };
      var lastIndex = _h[event].length - 1;
      var lastWrap = _h[event][lastIndex];
      lastWrap && lastWrap.callAtLast ? _h[event].splice(lastIndex, 0, wrap) : _h[event].push(wrap);
      return this;
    };
    Eventful2.prototype.isSilent = function(eventName) {
      var _h = this._$handlers;
      return !_h || !_h[eventName] || !_h[eventName].length;
    };
    Eventful2.prototype.off = function(eventType, handler) {
      var _h = this._$handlers;
      if (!_h) {
        return this;
      }
      if (!eventType) {
        this._$handlers = {};
        return this;
      }
      if (handler) {
        if (_h[eventType]) {
          var newList = [];
          for (var i = 0, l = _h[eventType].length; i < l; i++) {
            if (_h[eventType][i].h !== handler) {
              newList.push(_h[eventType][i]);
            }
          }
          _h[eventType] = newList;
        }
        if (_h[eventType] && _h[eventType].length === 0) {
          delete _h[eventType];
        }
      } else {
        delete _h[eventType];
      }
      return this;
    };
    Eventful2.prototype.trigger = function(eventType) {
      var args = [];
      for (var _i = 1; _i < arguments.length; _i++) {
        args[_i - 1] = arguments[_i];
      }
      if (!this._$handlers) {
        return this;
      }
      var _h = this._$handlers[eventType];
      var eventProcessor = this._$eventProcessor;
      if (_h) {
        var argLen = args.length;
        var len2 = _h.length;
        for (var i = 0; i < len2; i++) {
          var hItem = _h[i];
          if (eventProcessor && eventProcessor.filter && hItem.query != null && !eventProcessor.filter(eventType, hItem.query)) {
            continue;
          }
          switch (argLen) {
            case 0:
              hItem.h.call(hItem.ctx);
              break;
            case 1:
              hItem.h.call(hItem.ctx, args[0]);
              break;
            case 2:
              hItem.h.call(hItem.ctx, args[0], args[1]);
              break;
            default:
              hItem.h.apply(hItem.ctx, args);
              break;
          }
        }
      }
      eventProcessor && eventProcessor.afterTrigger && eventProcessor.afterTrigger(eventType);
      return this;
    };
    Eventful2.prototype.triggerWithContext = function(type) {
      var args = [];
      for (var _i = 1; _i < arguments.length; _i++) {
        args[_i - 1] = arguments[_i];
      }
      if (!this._$handlers) {
        return this;
      }
      var _h = this._$handlers[type];
      var eventProcessor = this._$eventProcessor;
      if (_h) {
        var argLen = args.length;
        var ctx = args[argLen - 1];
        var len2 = _h.length;
        for (var i = 0; i < len2; i++) {
          var hItem = _h[i];
          if (eventProcessor && eventProcessor.filter && hItem.query != null && !eventProcessor.filter(type, hItem.query)) {
            continue;
          }
          switch (argLen) {
            case 0:
              hItem.h.call(ctx);
              break;
            case 1:
              hItem.h.call(ctx, args[0]);
              break;
            case 2:
              hItem.h.call(ctx, args[0], args[1]);
              break;
            default:
              hItem.h.apply(ctx, args.slice(1, argLen - 1));
              break;
          }
        }
      }
      eventProcessor && eventProcessor.afterTrigger && eventProcessor.afterTrigger(type);
      return this;
    };
    return Eventful2;
  }();
  var Eventful_default = Eventful;

  // node_modules/zrender/lib/core/fourPointsTransform.js
  var LN2 = Math.log(2);
  function determinant(rows, rank, rowStart, rowMask, colMask, detCache) {
    var cacheKey = rowMask + "-" + colMask;
    var fullRank = rows.length;
    if (detCache.hasOwnProperty(cacheKey)) {
      return detCache[cacheKey];
    }
    if (rank === 1) {
      var colStart = Math.round(Math.log((1 << fullRank) - 1 & ~colMask) / LN2);
      return rows[rowStart][colStart];
    }
    var subRowMask = rowMask | 1 << rowStart;
    var subRowStart = rowStart + 1;
    while (rowMask & 1 << subRowStart) {
      subRowStart++;
    }
    var sum2 = 0;
    for (var j = 0, colLocalIdx = 0; j < fullRank; j++) {
      var colTag = 1 << j;
      if (!(colTag & colMask)) {
        sum2 += (colLocalIdx % 2 ? -1 : 1) * rows[rowStart][j] * determinant(rows, rank - 1, subRowStart, subRowMask, colMask | colTag, detCache);
        colLocalIdx++;
      }
    }
    detCache[cacheKey] = sum2;
    return sum2;
  }
  function buildTransformer(src, dest) {
    var mA = [
      [src[0], src[1], 1, 0, 0, 0, -dest[0] * src[0], -dest[0] * src[1]],
      [0, 0, 0, src[0], src[1], 1, -dest[1] * src[0], -dest[1] * src[1]],
      [src[2], src[3], 1, 0, 0, 0, -dest[2] * src[2], -dest[2] * src[3]],
      [0, 0, 0, src[2], src[3], 1, -dest[3] * src[2], -dest[3] * src[3]],
      [src[4], src[5], 1, 0, 0, 0, -dest[4] * src[4], -dest[4] * src[5]],
      [0, 0, 0, src[4], src[5], 1, -dest[5] * src[4], -dest[5] * src[5]],
      [src[6], src[7], 1, 0, 0, 0, -dest[6] * src[6], -dest[6] * src[7]],
      [0, 0, 0, src[6], src[7], 1, -dest[7] * src[6], -dest[7] * src[7]]
    ];
    var detCache = {};
    var det = determinant(mA, 8, 0, 0, 0, detCache);
    if (det === 0) {
      return;
    }
    var vh = [];
    for (var i = 0; i < 8; i++) {
      for (var j = 0; j < 8; j++) {
        vh[j] == null && (vh[j] = 0);
        vh[j] += ((i + j) % 2 ? -1 : 1) * determinant(mA, 7, i === 0 ? 1 : 0, 1 << i, 1 << j, detCache) / det * dest[i];
      }
    }
    return function(out2, srcPointX, srcPointY) {
      var pk = srcPointX * vh[6] + srcPointY * vh[7] + 1;
      out2[0] = (srcPointX * vh[0] + srcPointY * vh[1] + vh[2]) / pk;
      out2[1] = (srcPointX * vh[3] + srcPointY * vh[4] + vh[5]) / pk;
    };
  }

  // node_modules/zrender/lib/core/dom.js
  var EVENT_SAVED_PROP = "___zrEVENTSAVED";
  var _calcOut = [];
  function transformLocalCoord(out2, elFrom, elTarget, inX, inY) {
    return transformCoordWithViewport(_calcOut, elFrom, inX, inY, true) && transformCoordWithViewport(out2, elTarget, _calcOut[0], _calcOut[1]);
  }
  function transformCoordWithViewport(out2, el, inX, inY, inverse) {
    if (el.getBoundingClientRect && env_default.domSupported && !isCanvasEl(el)) {
      var saved = el[EVENT_SAVED_PROP] || (el[EVENT_SAVED_PROP] = {});
      var markers = prepareCoordMarkers(el, saved);
      var transformer = preparePointerTransformer(markers, saved, inverse);
      if (transformer) {
        transformer(out2, inX, inY);
        return true;
      }
    }
    return false;
  }
  function prepareCoordMarkers(el, saved) {
    var markers = saved.markers;
    if (markers) {
      return markers;
    }
    markers = saved.markers = [];
    var propLR = ["left", "right"];
    var propTB = ["top", "bottom"];
    for (var i = 0; i < 4; i++) {
      var marker = document.createElement("div");
      var stl = marker.style;
      var idxLR = i % 2;
      var idxTB = (i >> 1) % 2;
      stl.cssText = [
        "position: absolute",
        "visibility: hidden",
        "padding: 0",
        "margin: 0",
        "border-width: 0",
        "user-select: none",
        "width:0",
        "height:0",
        propLR[idxLR] + ":0",
        propTB[idxTB] + ":0",
        propLR[1 - idxLR] + ":auto",
        propTB[1 - idxTB] + ":auto",
        ""
      ].join("!important;");
      el.appendChild(marker);
      markers.push(marker);
    }
    return markers;
  }
  function preparePointerTransformer(markers, saved, inverse) {
    var transformerName = inverse ? "invTrans" : "trans";
    var transformer = saved[transformerName];
    var oldSrcCoords = saved.srcCoords;
    var srcCoords = [];
    var destCoords = [];
    var oldCoordTheSame = true;
    for (var i = 0; i < 4; i++) {
      var rect = markers[i].getBoundingClientRect();
      var ii = 2 * i;
      var x = rect.left;
      var y = rect.top;
      srcCoords.push(x, y);
      oldCoordTheSame = oldCoordTheSame && oldSrcCoords && x === oldSrcCoords[ii] && y === oldSrcCoords[ii + 1];
      destCoords.push(markers[i].offsetLeft, markers[i].offsetTop);
    }
    return oldCoordTheSame && transformer ? transformer : (saved.srcCoords = srcCoords, saved[transformerName] = inverse ? buildTransformer(destCoords, srcCoords) : buildTransformer(srcCoords, destCoords));
  }
  function isCanvasEl(el) {
    return el.nodeName.toUpperCase() === "CANVAS";
  }

  // node_modules/zrender/lib/core/event.js
  var MOUSE_EVENT_REG = /^(?:mouse|pointer|contextmenu|drag|drop)|click/;
  var _calcOut2 = [];
  var firefoxNotSupportOffsetXY = env_default.browser.firefox && +env_default.browser.version.split(".")[0] < 39;
  function clientToLocal(el, e2, out2, calculate) {
    out2 = out2 || {};
    if (calculate) {
      calculateZrXY(el, e2, out2);
    } else if (firefoxNotSupportOffsetXY && e2.layerX != null && e2.layerX !== e2.offsetX) {
      out2.zrX = e2.layerX;
      out2.zrY = e2.layerY;
    } else if (e2.offsetX != null) {
      out2.zrX = e2.offsetX;
      out2.zrY = e2.offsetY;
    } else {
      calculateZrXY(el, e2, out2);
    }
    return out2;
  }
  function calculateZrXY(el, e2, out2) {
    if (env_default.domSupported && el.getBoundingClientRect) {
      var ex = e2.clientX;
      var ey = e2.clientY;
      if (isCanvasEl(el)) {
        var box2 = el.getBoundingClientRect();
        out2.zrX = ex - box2.left;
        out2.zrY = ey - box2.top;
        return;
      } else {
        if (transformCoordWithViewport(_calcOut2, el, ex, ey)) {
          out2.zrX = _calcOut2[0];
          out2.zrY = _calcOut2[1];
          return;
        }
      }
    }
    out2.zrX = out2.zrY = 0;
  }
  function getNativeEvent(e2) {
    return e2 || window.event;
  }
  function normalizeEvent(el, e2, calculate) {
    e2 = getNativeEvent(e2);
    if (e2.zrX != null) {
      return e2;
    }
    var eventType = e2.type;
    var isTouch = eventType && eventType.indexOf("touch") >= 0;
    if (!isTouch) {
      clientToLocal(el, e2, e2, calculate);
      var wheelDelta = getWheelDeltaMayPolyfill(e2);
      e2.zrDelta = wheelDelta ? wheelDelta / 120 : -(e2.detail || 0) / 3;
    } else {
      var touch = eventType !== "touchend" ? e2.targetTouches[0] : e2.changedTouches[0];
      touch && clientToLocal(el, touch, e2, calculate);
    }
    var button = e2.button;
    if (e2.which == null && button !== void 0 && MOUSE_EVENT_REG.test(e2.type)) {
      e2.which = button & 1 ? 1 : button & 2 ? 3 : button & 4 ? 2 : 0;
    }
    return e2;
  }
  function getWheelDeltaMayPolyfill(e2) {
    var rawWheelDelta = e2.wheelDelta;
    if (rawWheelDelta) {
      return rawWheelDelta;
    }
    var deltaX = e2.deltaX;
    var deltaY = e2.deltaY;
    if (deltaX == null || deltaY == null) {
      return rawWheelDelta;
    }
    var delta = deltaY !== 0 ? Math.abs(deltaY) : Math.abs(deltaX);
    var sign = deltaY > 0 ? -1 : deltaY < 0 ? 1 : deltaX > 0 ? -1 : 1;
    return 3 * delta * sign;
  }
  function addEventListener(el, name, handler, opt) {
    el.addEventListener(name, handler, opt);
  }
  function removeEventListener(el, name, handler, opt) {
    el.removeEventListener(name, handler, opt);
  }
  var stop = function(e2) {
    e2.preventDefault();
    e2.stopPropagation();
    e2.cancelBubble = true;
  };
  function isMiddleOrRightButtonOnMouseUpDown(e2) {
    return e2.which === 2 || e2.which === 3;
  }

  // node_modules/zrender/lib/core/GestureMgr.js
  var GestureMgr = function() {
    function GestureMgr2() {
      this._track = [];
    }
    GestureMgr2.prototype.recognize = function(event, target, root) {
      this._doTrack(event, target, root);
      return this._recognize(event);
    };
    GestureMgr2.prototype.clear = function() {
      this._track.length = 0;
      return this;
    };
    GestureMgr2.prototype._doTrack = function(event, target, root) {
      var touches = event.touches;
      if (!touches) {
        return;
      }
      var trackItem = {
        points: [],
        touches: [],
        target,
        event
      };
      for (var i = 0, len2 = touches.length; i < len2; i++) {
        var touch = touches[i];
        var pos = clientToLocal(root, touch, {});
        trackItem.points.push([pos.zrX, pos.zrY]);
        trackItem.touches.push(touch);
      }
      this._track.push(trackItem);
    };
    GestureMgr2.prototype._recognize = function(event) {
      for (var eventName in recognizers) {
        if (recognizers.hasOwnProperty(eventName)) {
          var gestureInfo = recognizers[eventName](this._track, event);
          if (gestureInfo) {
            return gestureInfo;
          }
        }
      }
    };
    return GestureMgr2;
  }();
  function dist2(pointPair) {
    var dx = pointPair[1][0] - pointPair[0][0];
    var dy = pointPair[1][1] - pointPair[0][1];
    return Math.sqrt(dx * dx + dy * dy);
  }
  function center(pointPair) {
    return [
      (pointPair[0][0] + pointPair[1][0]) / 2,
      (pointPair[0][1] + pointPair[1][1]) / 2
    ];
  }
  var recognizers = {
    pinch: function(tracks, event) {
      var trackLen = tracks.length;
      if (!trackLen) {
        return;
      }
      var pinchEnd = (tracks[trackLen - 1] || {}).points;
      var pinchPre = (tracks[trackLen - 2] || {}).points || pinchEnd;
      if (pinchPre && pinchPre.length > 1 && pinchEnd && pinchEnd.length > 1) {
        var pinchScale = dist2(pinchEnd) / dist2(pinchPre);
        !isFinite(pinchScale) && (pinchScale = 1);
        event.pinchScale = pinchScale;
        var pinchCenter = center(pinchEnd);
        event.pinchX = pinchCenter[0];
        event.pinchY = pinchCenter[1];
        return {
          type: "pinch",
          target: tracks[0].target,
          event
        };
      }
    }
  };

  // node_modules/zrender/lib/Handler.js
  var SILENT = "silent";
  function makeEventPacket(eveType, targetInfo, event) {
    return {
      type: eveType,
      event,
      target: targetInfo.target,
      topTarget: targetInfo.topTarget,
      cancelBubble: false,
      offsetX: event.zrX,
      offsetY: event.zrY,
      gestureEvent: event.gestureEvent,
      pinchX: event.pinchX,
      pinchY: event.pinchY,
      pinchScale: event.pinchScale,
      wheelDelta: event.zrDelta,
      zrByTouch: event.zrByTouch,
      which: event.which,
      stop: stopEvent
    };
  }
  function stopEvent() {
    stop(this.event);
  }
  var EmptyProxy = function(_super) {
    __extends2(EmptyProxy2, _super);
    function EmptyProxy2() {
      var _this = _super !== null && _super.apply(this, arguments) || this;
      _this.handler = null;
      return _this;
    }
    EmptyProxy2.prototype.dispose = function() {
    };
    EmptyProxy2.prototype.setCursor = function() {
    };
    return EmptyProxy2;
  }(Eventful_default);
  var HoveredResult = function() {
    function HoveredResult2(x, y) {
      this.x = x;
      this.y = y;
    }
    return HoveredResult2;
  }();
  var handlerNames = [
    "click",
    "dblclick",
    "mousewheel",
    "mouseout",
    "mouseup",
    "mousedown",
    "mousemove",
    "contextmenu"
  ];
  var Handler = function(_super) {
    __extends2(Handler2, _super);
    function Handler2(storage2, painter, proxy, painterRoot) {
      var _this = _super.call(this) || this;
      _this._hovered = new HoveredResult(0, 0);
      _this.storage = storage2;
      _this.painter = painter;
      _this.painterRoot = painterRoot;
      proxy = proxy || new EmptyProxy();
      _this.proxy = null;
      _this.setHandlerProxy(proxy);
      _this._draggingMgr = new Draggable_default(_this);
      return _this;
    }
    Handler2.prototype.setHandlerProxy = function(proxy) {
      if (this.proxy) {
        this.proxy.dispose();
      }
      if (proxy) {
        each(handlerNames, function(name) {
          proxy.on && proxy.on(name, this[name], this);
        }, this);
        proxy.handler = this;
      }
      this.proxy = proxy;
    };
    Handler2.prototype.mousemove = function(event) {
      var x = event.zrX;
      var y = event.zrY;
      var isOutside = isOutsideBoundary(this, x, y);
      var lastHovered = this._hovered;
      var lastHoveredTarget = lastHovered.target;
      if (lastHoveredTarget && !lastHoveredTarget.__zr) {
        lastHovered = this.findHover(lastHovered.x, lastHovered.y);
        lastHoveredTarget = lastHovered.target;
      }
      var hovered = this._hovered = isOutside ? new HoveredResult(x, y) : this.findHover(x, y);
      var hoveredTarget = hovered.target;
      var proxy = this.proxy;
      proxy.setCursor && proxy.setCursor(hoveredTarget ? hoveredTarget.cursor : "default");
      if (lastHoveredTarget && hoveredTarget !== lastHoveredTarget) {
        this.dispatchToElement(lastHovered, "mouseout", event);
      }
      this.dispatchToElement(hovered, "mousemove", event);
      if (hoveredTarget && hoveredTarget !== lastHoveredTarget) {
        this.dispatchToElement(hovered, "mouseover", event);
      }
    };
    Handler2.prototype.mouseout = function(event) {
      var eventControl = event.zrEventControl;
      if (eventControl !== "only_globalout") {
        this.dispatchToElement(this._hovered, "mouseout", event);
      }
      if (eventControl !== "no_globalout") {
        this.trigger("globalout", { type: "globalout", event });
      }
    };
    Handler2.prototype.resize = function() {
      this._hovered = new HoveredResult(0, 0);
    };
    Handler2.prototype.dispatch = function(eventName, eventArgs) {
      var handler = this[eventName];
      handler && handler.call(this, eventArgs);
    };
    Handler2.prototype.dispose = function() {
      this.proxy.dispose();
      this.storage = null;
      this.proxy = null;
      this.painter = null;
    };
    Handler2.prototype.setCursorStyle = function(cursorStyle) {
      var proxy = this.proxy;
      proxy.setCursor && proxy.setCursor(cursorStyle);
    };
    Handler2.prototype.dispatchToElement = function(targetInfo, eventName, event) {
      targetInfo = targetInfo || {};
      var el = targetInfo.target;
      if (el && el.silent) {
        return;
      }
      var eventKey = "on" + eventName;
      var eventPacket = makeEventPacket(eventName, targetInfo, event);
      while (el) {
        el[eventKey] && (eventPacket.cancelBubble = !!el[eventKey].call(el, eventPacket));
        el.trigger(eventName, eventPacket);
        el = el.__hostTarget ? el.__hostTarget : el.parent;
        if (eventPacket.cancelBubble) {
          break;
        }
      }
      if (!eventPacket.cancelBubble) {
        this.trigger(eventName, eventPacket);
        if (this.painter && this.painter.eachOtherLayer) {
          this.painter.eachOtherLayer(function(layer) {
            if (typeof layer[eventKey] === "function") {
              layer[eventKey].call(layer, eventPacket);
            }
            if (layer.trigger) {
              layer.trigger(eventName, eventPacket);
            }
          });
        }
      }
    };
    Handler2.prototype.findHover = function(x, y, exclude) {
      var list = this.storage.getDisplayList();
      var out2 = new HoveredResult(x, y);
      for (var i = list.length - 1; i >= 0; i--) {
        var hoverCheckResult = void 0;
        if (list[i] !== exclude && !list[i].ignore && (hoverCheckResult = isHover(list[i], x, y))) {
          !out2.topTarget && (out2.topTarget = list[i]);
          if (hoverCheckResult !== SILENT) {
            out2.target = list[i];
            break;
          }
        }
      }
      return out2;
    };
    Handler2.prototype.processGesture = function(event, stage) {
      if (!this._gestureMgr) {
        this._gestureMgr = new GestureMgr();
      }
      var gestureMgr = this._gestureMgr;
      stage === "start" && gestureMgr.clear();
      var gestureInfo = gestureMgr.recognize(event, this.findHover(event.zrX, event.zrY, null).target, this.proxy.dom);
      stage === "end" && gestureMgr.clear();
      if (gestureInfo) {
        var type = gestureInfo.type;
        event.gestureEvent = type;
        var res = new HoveredResult();
        res.target = gestureInfo.target;
        this.dispatchToElement(res, type, gestureInfo.event);
      }
    };
    return Handler2;
  }(Eventful_default);
  each(["click", "mousedown", "mouseup", "mousewheel", "dblclick", "contextmenu"], function(name) {
    Handler.prototype[name] = function(event) {
      var x = event.zrX;
      var y = event.zrY;
      var isOutside = isOutsideBoundary(this, x, y);
      var hovered;
      var hoveredTarget;
      if (name !== "mouseup" || !isOutside) {
        hovered = this.findHover(x, y);
        hoveredTarget = hovered.target;
      }
      if (name === "mousedown") {
        this._downEl = hoveredTarget;
        this._downPoint = [event.zrX, event.zrY];
        this._upEl = hoveredTarget;
      } else if (name === "mouseup") {
        this._upEl = hoveredTarget;
      } else if (name === "click") {
        if (this._downEl !== this._upEl || !this._downPoint || dist(this._downPoint, [event.zrX, event.zrY]) > 4) {
          return;
        }
        this._downPoint = null;
      }
      this.dispatchToElement(hovered, name, event);
    };
  });
  function isHover(displayable, x, y) {
    if (displayable[displayable.rectHover ? "rectContain" : "contain"](x, y)) {
      var el = displayable;
      var isSilent = void 0;
      var ignoreClip = false;
      while (el) {
        if (el.ignoreClip) {
          ignoreClip = true;
        }
        if (!ignoreClip) {
          var clipPath = el.getClipPath();
          if (clipPath && !clipPath.contain(x, y)) {
            return false;
          }
          if (el.silent) {
            isSilent = true;
          }
        }
        var hostEl = el.__hostTarget;
        el = hostEl ? hostEl : el.parent;
      }
      return isSilent ? SILENT : true;
    }
    return false;
  }
  function isOutsideBoundary(handlerInstance, x, y) {
    var painter = handlerInstance.painter;
    return x < 0 || x > painter.getWidth() || y < 0 || y > painter.getHeight();
  }
  var Handler_default = Handler;

  // node_modules/zrender/lib/core/timsort.js
  var DEFAULT_MIN_MERGE = 32;
  var DEFAULT_MIN_GALLOPING = 7;
  var DEFAULT_TMP_STORAGE_LENGTH = 256;
  function minRunLength(n) {
    var r = 0;
    while (n >= DEFAULT_MIN_MERGE) {
      r |= n & 1;
      n >>= 1;
    }
    return n + r;
  }
  function makeAscendingRun(array, lo, hi, compare2) {
    var runHi = lo + 1;
    if (runHi === hi) {
      return 1;
    }
    if (compare2(array[runHi++], array[lo]) < 0) {
      while (runHi < hi && compare2(array[runHi], array[runHi - 1]) < 0) {
        runHi++;
      }
      reverseRun(array, lo, runHi);
    } else {
      while (runHi < hi && compare2(array[runHi], array[runHi - 1]) >= 0) {
        runHi++;
      }
    }
    return runHi - lo;
  }
  function reverseRun(array, lo, hi) {
    hi--;
    while (lo < hi) {
      var t = array[lo];
      array[lo++] = array[hi];
      array[hi--] = t;
    }
  }
  function binaryInsertionSort(array, lo, hi, start2, compare2) {
    if (start2 === lo) {
      start2++;
    }
    for (; start2 < hi; start2++) {
      var pivot = array[start2];
      var left = lo;
      var right = start2;
      var mid;
      while (left < right) {
        mid = left + right >>> 1;
        if (compare2(pivot, array[mid]) < 0) {
          right = mid;
        } else {
          left = mid + 1;
        }
      }
      var n = start2 - left;
      switch (n) {
        case 3:
          array[left + 3] = array[left + 2];
        case 2:
          array[left + 2] = array[left + 1];
        case 1:
          array[left + 1] = array[left];
          break;
        default:
          while (n > 0) {
            array[left + n] = array[left + n - 1];
            n--;
          }
      }
      array[left] = pivot;
    }
  }
  function gallopLeft(value, array, start2, length2, hint, compare2) {
    var lastOffset = 0;
    var maxOffset = 0;
    var offset = 1;
    if (compare2(value, array[start2 + hint]) > 0) {
      maxOffset = length2 - hint;
      while (offset < maxOffset && compare2(value, array[start2 + hint + offset]) > 0) {
        lastOffset = offset;
        offset = (offset << 1) + 1;
        if (offset <= 0) {
          offset = maxOffset;
        }
      }
      if (offset > maxOffset) {
        offset = maxOffset;
      }
      lastOffset += hint;
      offset += hint;
    } else {
      maxOffset = hint + 1;
      while (offset < maxOffset && compare2(value, array[start2 + hint - offset]) <= 0) {
        lastOffset = offset;
        offset = (offset << 1) + 1;
        if (offset <= 0) {
          offset = maxOffset;
        }
      }
      if (offset > maxOffset) {
        offset = maxOffset;
      }
      var tmp = lastOffset;
      lastOffset = hint - offset;
      offset = hint - tmp;
    }
    lastOffset++;
    while (lastOffset < offset) {
      var m2 = lastOffset + (offset - lastOffset >>> 1);
      if (compare2(value, array[start2 + m2]) > 0) {
        lastOffset = m2 + 1;
      } else {
        offset = m2;
      }
    }
    return offset;
  }
  function gallopRight(value, array, start2, length2, hint, compare2) {
    var lastOffset = 0;
    var maxOffset = 0;
    var offset = 1;
    if (compare2(value, array[start2 + hint]) < 0) {
      maxOffset = hint + 1;
      while (offset < maxOffset && compare2(value, array[start2 + hint - offset]) < 0) {
        lastOffset = offset;
        offset = (offset << 1) + 1;
        if (offset <= 0) {
          offset = maxOffset;
        }
      }
      if (offset > maxOffset) {
        offset = maxOffset;
      }
      var tmp = lastOffset;
      lastOffset = hint - offset;
      offset = hint - tmp;
    } else {
      maxOffset = length2 - hint;
      while (offset < maxOffset && compare2(value, array[start2 + hint + offset]) >= 0) {
        lastOffset = offset;
        offset = (offset << 1) + 1;
        if (offset <= 0) {
          offset = maxOffset;
        }
      }
      if (offset > maxOffset) {
        offset = maxOffset;
      }
      lastOffset += hint;
      offset += hint;
    }
    lastOffset++;
    while (lastOffset < offset) {
      var m2 = lastOffset + (offset - lastOffset >>> 1);
      if (compare2(value, array[start2 + m2]) < 0) {
        offset = m2;
      } else {
        lastOffset = m2 + 1;
      }
    }
    return offset;
  }
  function TimSort(array, compare2) {
    var minGallop = DEFAULT_MIN_GALLOPING;
    var length2 = 0;
    var tmpStorageLength = DEFAULT_TMP_STORAGE_LENGTH;
    var stackLength = 0;
    var runStart;
    var runLength;
    var stackSize = 0;
    length2 = array.length;
    if (length2 < 2 * DEFAULT_TMP_STORAGE_LENGTH) {
      tmpStorageLength = length2 >>> 1;
    }
    var tmp = [];
    stackLength = length2 < 120 ? 5 : length2 < 1542 ? 10 : length2 < 119151 ? 19 : 40;
    runStart = [];
    runLength = [];
    function pushRun(_runStart, _runLength) {
      runStart[stackSize] = _runStart;
      runLength[stackSize] = _runLength;
      stackSize += 1;
    }
    function mergeRuns() {
      while (stackSize > 1) {
        var n = stackSize - 2;
        if (n >= 1 && runLength[n - 1] <= runLength[n] + runLength[n + 1] || n >= 2 && runLength[n - 2] <= runLength[n] + runLength[n - 1]) {
          if (runLength[n - 1] < runLength[n + 1]) {
            n--;
          }
        } else if (runLength[n] > runLength[n + 1]) {
          break;
        }
        mergeAt(n);
      }
    }
    function forceMergeRuns() {
      while (stackSize > 1) {
        var n = stackSize - 2;
        if (n > 0 && runLength[n - 1] < runLength[n + 1]) {
          n--;
        }
        mergeAt(n);
      }
    }
    function mergeAt(i) {
      var start1 = runStart[i];
      var length1 = runLength[i];
      var start2 = runStart[i + 1];
      var length22 = runLength[i + 1];
      runLength[i] = length1 + length22;
      if (i === stackSize - 3) {
        runStart[i + 1] = runStart[i + 2];
        runLength[i + 1] = runLength[i + 2];
      }
      stackSize--;
      var k = gallopRight(array[start2], array, start1, length1, 0, compare2);
      start1 += k;
      length1 -= k;
      if (length1 === 0) {
        return;
      }
      length22 = gallopLeft(array[start1 + length1 - 1], array, start2, length22, length22 - 1, compare2);
      if (length22 === 0) {
        return;
      }
      if (length1 <= length22) {
        mergeLow(start1, length1, start2, length22);
      } else {
        mergeHigh(start1, length1, start2, length22);
      }
    }
    function mergeLow(start1, length1, start2, length22) {
      var i = 0;
      for (i = 0; i < length1; i++) {
        tmp[i] = array[start1 + i];
      }
      var cursor1 = 0;
      var cursor2 = start2;
      var dest = start1;
      array[dest++] = array[cursor2++];
      if (--length22 === 0) {
        for (i = 0; i < length1; i++) {
          array[dest + i] = tmp[cursor1 + i];
        }
        return;
      }
      if (length1 === 1) {
        for (i = 0; i < length22; i++) {
          array[dest + i] = array[cursor2 + i];
        }
        array[dest + length22] = tmp[cursor1];
        return;
      }
      var _minGallop = minGallop;
      var count1;
      var count2;
      var exit;
      while (1) {
        count1 = 0;
        count2 = 0;
        exit = false;
        do {
          if (compare2(array[cursor2], tmp[cursor1]) < 0) {
            array[dest++] = array[cursor2++];
            count2++;
            count1 = 0;
            if (--length22 === 0) {
              exit = true;
              break;
            }
          } else {
            array[dest++] = tmp[cursor1++];
            count1++;
            count2 = 0;
            if (--length1 === 1) {
              exit = true;
              break;
            }
          }
        } while ((count1 | count2) < _minGallop);
        if (exit) {
          break;
        }
        do {
          count1 = gallopRight(array[cursor2], tmp, cursor1, length1, 0, compare2);
          if (count1 !== 0) {
            for (i = 0; i < count1; i++) {
              array[dest + i] = tmp[cursor1 + i];
            }
            dest += count1;
            cursor1 += count1;
            length1 -= count1;
            if (length1 <= 1) {
              exit = true;
              break;
            }
          }
          array[dest++] = array[cursor2++];
          if (--length22 === 0) {
            exit = true;
            break;
          }
          count2 = gallopLeft(tmp[cursor1], array, cursor2, length22, 0, compare2);
          if (count2 !== 0) {
            for (i = 0; i < count2; i++) {
              array[dest + i] = array[cursor2 + i];
            }
            dest += count2;
            cursor2 += count2;
            length22 -= count2;
            if (length22 === 0) {
              exit = true;
              break;
            }
          }
          array[dest++] = tmp[cursor1++];
          if (--length1 === 1) {
            exit = true;
            break;
          }
          _minGallop--;
        } while (count1 >= DEFAULT_MIN_GALLOPING || count2 >= DEFAULT_MIN_GALLOPING);
        if (exit) {
          break;
        }
        if (_minGallop < 0) {
          _minGallop = 0;
        }
        _minGallop += 2;
      }
      minGallop = _minGallop;
      minGallop < 1 && (minGallop = 1);
      if (length1 === 1) {
        for (i = 0; i < length22; i++) {
          array[dest + i] = array[cursor2 + i];
        }
        array[dest + length22] = tmp[cursor1];
      } else if (length1 === 0) {
        throw new Error();
      } else {
        for (i = 0; i < length1; i++) {
          array[dest + i] = tmp[cursor1 + i];
        }
      }
    }
    function mergeHigh(start1, length1, start2, length22) {
      var i = 0;
      for (i = 0; i < length22; i++) {
        tmp[i] = array[start2 + i];
      }
      var cursor1 = start1 + length1 - 1;
      var cursor2 = length22 - 1;
      var dest = start2 + length22 - 1;
      var customCursor = 0;
      var customDest = 0;
      array[dest--] = array[cursor1--];
      if (--length1 === 0) {
        customCursor = dest - (length22 - 1);
        for (i = 0; i < length22; i++) {
          array[customCursor + i] = tmp[i];
        }
        return;
      }
      if (length22 === 1) {
        dest -= length1;
        cursor1 -= length1;
        customDest = dest + 1;
        customCursor = cursor1 + 1;
        for (i = length1 - 1; i >= 0; i--) {
          array[customDest + i] = array[customCursor + i];
        }
        array[dest] = tmp[cursor2];
        return;
      }
      var _minGallop = minGallop;
      while (true) {
        var count1 = 0;
        var count2 = 0;
        var exit = false;
        do {
          if (compare2(tmp[cursor2], array[cursor1]) < 0) {
            array[dest--] = array[cursor1--];
            count1++;
            count2 = 0;
            if (--length1 === 0) {
              exit = true;
              break;
            }
          } else {
            array[dest--] = tmp[cursor2--];
            count2++;
            count1 = 0;
            if (--length22 === 1) {
              exit = true;
              break;
            }
          }
        } while ((count1 | count2) < _minGallop);
        if (exit) {
          break;
        }
        do {
          count1 = length1 - gallopRight(tmp[cursor2], array, start1, length1, length1 - 1, compare2);
          if (count1 !== 0) {
            dest -= count1;
            cursor1 -= count1;
            length1 -= count1;
            customDest = dest + 1;
            customCursor = cursor1 + 1;
            for (i = count1 - 1; i >= 0; i--) {
              array[customDest + i] = array[customCursor + i];
            }
            if (length1 === 0) {
              exit = true;
              break;
            }
          }
          array[dest--] = tmp[cursor2--];
          if (--length22 === 1) {
            exit = true;
            break;
          }
          count2 = length22 - gallopLeft(array[cursor1], tmp, 0, length22, length22 - 1, compare2);
          if (count2 !== 0) {
            dest -= count2;
            cursor2 -= count2;
            length22 -= count2;
            customDest = dest + 1;
            customCursor = cursor2 + 1;
            for (i = 0; i < count2; i++) {
              array[customDest + i] = tmp[customCursor + i];
            }
            if (length22 <= 1) {
              exit = true;
              break;
            }
          }
          array[dest--] = array[cursor1--];
          if (--length1 === 0) {
            exit = true;
            break;
          }
          _minGallop--;
        } while (count1 >= DEFAULT_MIN_GALLOPING || count2 >= DEFAULT_MIN_GALLOPING);
        if (exit) {
          break;
        }
        if (_minGallop < 0) {
          _minGallop = 0;
        }
        _minGallop += 2;
      }
      minGallop = _minGallop;
      if (minGallop < 1) {
        minGallop = 1;
      }
      if (length22 === 1) {
        dest -= length1;
        cursor1 -= length1;
        customDest = dest + 1;
        customCursor = cursor1 + 1;
        for (i = length1 - 1; i >= 0; i--) {
          array[customDest + i] = array[customCursor + i];
        }
        array[dest] = tmp[cursor2];
      } else if (length22 === 0) {
        throw new Error();
      } else {
        customCursor = dest - (length22 - 1);
        for (i = 0; i < length22; i++) {
          array[customCursor + i] = tmp[i];
        }
      }
    }
    return {
      mergeRuns,
      forceMergeRuns,
      pushRun
    };
  }
  function sort(array, compare2, lo, hi) {
    if (!lo) {
      lo = 0;
    }
    if (!hi) {
      hi = array.length;
    }
    var remaining = hi - lo;
    if (remaining < 2) {
      return;
    }
    var runLength = 0;
    if (remaining < DEFAULT_MIN_MERGE) {
      runLength = makeAscendingRun(array, lo, hi, compare2);
      binaryInsertionSort(array, lo, hi, lo + runLength, compare2);
      return;
    }
    var ts = TimSort(array, compare2);
    var minRun = minRunLength(remaining);
    do {
      runLength = makeAscendingRun(array, lo, hi, compare2);
      if (runLength < minRun) {
        var force = remaining;
        if (force > minRun) {
          force = minRun;
        }
        binaryInsertionSort(array, lo, lo + force, lo + runLength, compare2);
        runLength = force;
      }
      ts.pushRun(lo, runLength);
      ts.mergeRuns();
      remaining -= runLength;
      lo += runLength;
    } while (remaining !== 0);
    ts.forceMergeRuns();
  }

  // node_modules/zrender/lib/graphic/constants.js
  var REDRAW_BIT = 1;
  var STYLE_CHANGED_BIT = 2;
  var SHAPE_CHANGED_BIT = 4;

  // node_modules/zrender/lib/Storage.js
  var invalidZErrorLogged = false;
  function logInvalidZError() {
    if (invalidZErrorLogged) {
      return;
    }
    invalidZErrorLogged = true;
    console.warn("z / z2 / zlevel of displayable is invalid, which may cause unexpected errors");
  }
  function shapeCompareFunc(a, b) {
    if (a.zlevel === b.zlevel) {
      if (a.z === b.z) {
        return a.z2 - b.z2;
      }
      return a.z - b.z;
    }
    return a.zlevel - b.zlevel;
  }
  var Storage = function() {
    function Storage2() {
      this._roots = [];
      this._displayList = [];
      this._displayListLen = 0;
      this.displayableSortFunc = shapeCompareFunc;
    }
    Storage2.prototype.traverse = function(cb, context) {
      for (var i = 0; i < this._roots.length; i++) {
        this._roots[i].traverse(cb, context);
      }
    };
    Storage2.prototype.getDisplayList = function(update, includeIgnore) {
      includeIgnore = includeIgnore || false;
      var displayList = this._displayList;
      if (update || !displayList.length) {
        this.updateDisplayList(includeIgnore);
      }
      return displayList;
    };
    Storage2.prototype.updateDisplayList = function(includeIgnore) {
      this._displayListLen = 0;
      var roots2 = this._roots;
      var displayList = this._displayList;
      for (var i = 0, len2 = roots2.length; i < len2; i++) {
        this._updateAndAddDisplayable(roots2[i], null, includeIgnore);
      }
      displayList.length = this._displayListLen;
      sort(displayList, shapeCompareFunc);
    };
    Storage2.prototype._updateAndAddDisplayable = function(el, clipPaths, includeIgnore) {
      if (el.ignore && !includeIgnore) {
        return;
      }
      el.beforeUpdate();
      el.update();
      el.afterUpdate();
      var userSetClipPath = el.getClipPath();
      if (el.ignoreClip) {
        clipPaths = null;
      } else if (userSetClipPath) {
        if (clipPaths) {
          clipPaths = clipPaths.slice();
        } else {
          clipPaths = [];
        }
        var currentClipPath = userSetClipPath;
        var parentClipPath = el;
        while (currentClipPath) {
          currentClipPath.parent = parentClipPath;
          currentClipPath.updateTransform();
          clipPaths.push(currentClipPath);
          parentClipPath = currentClipPath;
          currentClipPath = currentClipPath.getClipPath();
        }
      }
      if (el.childrenRef) {
        var children = el.childrenRef();
        for (var i = 0; i < children.length; i++) {
          var child = children[i];
          if (el.__dirty) {
            child.__dirty |= REDRAW_BIT;
          }
          this._updateAndAddDisplayable(child, clipPaths, includeIgnore);
        }
        el.__dirty = 0;
      } else {
        var disp = el;
        if (clipPaths && clipPaths.length) {
          disp.__clipPaths = clipPaths;
        } else if (disp.__clipPaths && disp.__clipPaths.length > 0) {
          disp.__clipPaths = [];
        }
        if (isNaN(disp.z)) {
          logInvalidZError();
          disp.z = 0;
        }
        if (isNaN(disp.z2)) {
          logInvalidZError();
          disp.z2 = 0;
        }
        if (isNaN(disp.zlevel)) {
          logInvalidZError();
          disp.zlevel = 0;
        }
        this._displayList[this._displayListLen++] = disp;
      }
      var decalEl = el.getDecalElement && el.getDecalElement();
      if (decalEl) {
        this._updateAndAddDisplayable(decalEl, clipPaths, includeIgnore);
      }
      var textGuide = el.getTextGuideLine();
      if (textGuide) {
        this._updateAndAddDisplayable(textGuide, clipPaths, includeIgnore);
      }
      var textEl = el.getTextContent();
      if (textEl) {
        this._updateAndAddDisplayable(textEl, clipPaths, includeIgnore);
      }
    };
    Storage2.prototype.addRoot = function(el) {
      if (el.__zr && el.__zr.storage === this) {
        return;
      }
      this._roots.push(el);
    };
    Storage2.prototype.delRoot = function(el) {
      if (el instanceof Array) {
        for (var i = 0, l = el.length; i < l; i++) {
          this.delRoot(el[i]);
        }
        return;
      }
      var idx = indexOf(this._roots, el);
      if (idx >= 0) {
        this._roots.splice(idx, 1);
      }
    };
    Storage2.prototype.delAllRoots = function() {
      this._roots = [];
      this._displayList = [];
      this._displayListLen = 0;
      return;
    };
    Storage2.prototype.getRoots = function() {
      return this._roots;
    };
    Storage2.prototype.dispose = function() {
      this._displayList = null;
      this._roots = null;
    };
    return Storage2;
  }();
  var Storage_default = Storage;

  // node_modules/zrender/lib/animation/requestAnimationFrame.js
  var requestAnimationFrame2;
  requestAnimationFrame2 = env_default.hasGlobalWindow && (window.requestAnimationFrame && window.requestAnimationFrame.bind(window) || window.msRequestAnimationFrame && window.msRequestAnimationFrame.bind(window) || window.mozRequestAnimationFrame || window.webkitRequestAnimationFrame) || function(func) {
    return setTimeout(func, 16);
  };
  var requestAnimationFrame_default = requestAnimationFrame2;

  // node_modules/zrender/lib/animation/easing.js
  var easingFuncs = {
    linear: function(k) {
      return k;
    },
    quadraticIn: function(k) {
      return k * k;
    },
    quadraticOut: function(k) {
      return k * (2 - k);
    },
    quadraticInOut: function(k) {
      if ((k *= 2) < 1) {
        return 0.5 * k * k;
      }
      return -0.5 * (--k * (k - 2) - 1);
    },
    cubicIn: function(k) {
      return k * k * k;
    },
    cubicOut: function(k) {
      return --k * k * k + 1;
    },
    cubicInOut: function(k) {
      if ((k *= 2) < 1) {
        return 0.5 * k * k * k;
      }
      return 0.5 * ((k -= 2) * k * k + 2);
    },
    quarticIn: function(k) {
      return k * k * k * k;
    },
    quarticOut: function(k) {
      return 1 - --k * k * k * k;
    },
    quarticInOut: function(k) {
      if ((k *= 2) < 1) {
        return 0.5 * k * k * k * k;
      }
      return -0.5 * ((k -= 2) * k * k * k - 2);
    },
    quinticIn: function(k) {
      return k * k * k * k * k;
    },
    quinticOut: function(k) {
      return --k * k * k * k * k + 1;
    },
    quinticInOut: function(k) {
      if ((k *= 2) < 1) {
        return 0.5 * k * k * k * k * k;
      }
      return 0.5 * ((k -= 2) * k * k * k * k + 2);
    },
    sinusoidalIn: function(k) {
      return 1 - Math.cos(k * Math.PI / 2);
    },
    sinusoidalOut: function(k) {
      return Math.sin(k * Math.PI / 2);
    },
    sinusoidalInOut: function(k) {
      return 0.5 * (1 - Math.cos(Math.PI * k));
    },
    exponentialIn: function(k) {
      return k === 0 ? 0 : Math.pow(1024, k - 1);
    },
    exponentialOut: function(k) {
      return k === 1 ? 1 : 1 - Math.pow(2, -10 * k);
    },
    exponentialInOut: function(k) {
      if (k === 0) {
        return 0;
      }
      if (k === 1) {
        return 1;
      }
      if ((k *= 2) < 1) {
        return 0.5 * Math.pow(1024, k - 1);
      }
      return 0.5 * (-Math.pow(2, -10 * (k - 1)) + 2);
    },
    circularIn: function(k) {
      return 1 - Math.sqrt(1 - k * k);
    },
    circularOut: function(k) {
      return Math.sqrt(1 - --k * k);
    },
    circularInOut: function(k) {
      if ((k *= 2) < 1) {
        return -0.5 * (Math.sqrt(1 - k * k) - 1);
      }
      return 0.5 * (Math.sqrt(1 - (k -= 2) * k) + 1);
    },
    elasticIn: function(k) {
      var s;
      var a = 0.1;
      var p = 0.4;
      if (k === 0) {
        return 0;
      }
      if (k === 1) {
        return 1;
      }
      if (!a || a < 1) {
        a = 1;
        s = p / 4;
      } else {
        s = p * Math.asin(1 / a) / (2 * Math.PI);
      }
      return -(a * Math.pow(2, 10 * (k -= 1)) * Math.sin((k - s) * (2 * Math.PI) / p));
    },
    elasticOut: function(k) {
      var s;
      var a = 0.1;
      var p = 0.4;
      if (k === 0) {
        return 0;
      }
      if (k === 1) {
        return 1;
      }
      if (!a || a < 1) {
        a = 1;
        s = p / 4;
      } else {
        s = p * Math.asin(1 / a) / (2 * Math.PI);
      }
      return a * Math.pow(2, -10 * k) * Math.sin((k - s) * (2 * Math.PI) / p) + 1;
    },
    elasticInOut: function(k) {
      var s;
      var a = 0.1;
      var p = 0.4;
      if (k === 0) {
        return 0;
      }
      if (k === 1) {
        return 1;
      }
      if (!a || a < 1) {
        a = 1;
        s = p / 4;
      } else {
        s = p * Math.asin(1 / a) / (2 * Math.PI);
      }
      if ((k *= 2) < 1) {
        return -0.5 * (a * Math.pow(2, 10 * (k -= 1)) * Math.sin((k - s) * (2 * Math.PI) / p));
      }
      return a * Math.pow(2, -10 * (k -= 1)) * Math.sin((k - s) * (2 * Math.PI) / p) * 0.5 + 1;
    },
    backIn: function(k) {
      var s = 1.70158;
      return k * k * ((s + 1) * k - s);
    },
    backOut: function(k) {
      var s = 1.70158;
      return --k * k * ((s + 1) * k + s) + 1;
    },
    backInOut: function(k) {
      var s = 1.70158 * 1.525;
      if ((k *= 2) < 1) {
        return 0.5 * (k * k * ((s + 1) * k - s));
      }
      return 0.5 * ((k -= 2) * k * ((s + 1) * k + s) + 2);
    },
    bounceIn: function(k) {
      return 1 - easingFuncs.bounceOut(1 - k);
    },
    bounceOut: function(k) {
      if (k < 1 / 2.75) {
        return 7.5625 * k * k;
      } else if (k < 2 / 2.75) {
        return 7.5625 * (k -= 1.5 / 2.75) * k + 0.75;
      } else if (k < 2.5 / 2.75) {
        return 7.5625 * (k -= 2.25 / 2.75) * k + 0.9375;
      } else {
        return 7.5625 * (k -= 2.625 / 2.75) * k + 0.984375;
      }
    },
    bounceInOut: function(k) {
      if (k < 0.5) {
        return easingFuncs.bounceIn(k * 2) * 0.5;
      }
      return easingFuncs.bounceOut(k * 2 - 1) * 0.5 + 0.5;
    }
  };
  var easing_default = easingFuncs;

  // node_modules/zrender/lib/core/curve.js
  var mathPow = Math.pow;
  var mathSqrt = Math.sqrt;
  var EPSILON = 1e-8;
  var EPSILON_NUMERIC = 1e-4;
  var THREE_SQRT = mathSqrt(3);
  var ONE_THIRD = 1 / 3;
  var _v0 = create();
  var _v1 = create();
  var _v2 = create();
  function isAroundZero(val) {
    return val > -EPSILON && val < EPSILON;
  }
  function isNotAroundZero(val) {
    return val > EPSILON || val < -EPSILON;
  }
  function cubicAt(p0, p1, p2, p3, t) {
    var onet = 1 - t;
    return onet * onet * (onet * p0 + 3 * t * p1) + t * t * (t * p3 + 3 * onet * p2);
  }
  function cubicDerivativeAt(p0, p1, p2, p3, t) {
    var onet = 1 - t;
    return 3 * (((p1 - p0) * onet + 2 * (p2 - p1) * t) * onet + (p3 - p2) * t * t);
  }
  function cubicRootAt(p0, p1, p2, p3, val, roots2) {
    var a = p3 + 3 * (p1 - p2) - p0;
    var b = 3 * (p2 - p1 * 2 + p0);
    var c = 3 * (p1 - p0);
    var d = p0 - val;
    var A = b * b - 3 * a * c;
    var B = b * c - 9 * a * d;
    var C = c * c - 3 * b * d;
    var n = 0;
    if (isAroundZero(A) && isAroundZero(B)) {
      if (isAroundZero(b)) {
        roots2[0] = 0;
      } else {
        var t1 = -c / b;
        if (t1 >= 0 && t1 <= 1) {
          roots2[n++] = t1;
        }
      }
    } else {
      var disc = B * B - 4 * A * C;
      if (isAroundZero(disc)) {
        var K = B / A;
        var t1 = -b / a + K;
        var t2 = -K / 2;
        if (t1 >= 0 && t1 <= 1) {
          roots2[n++] = t1;
        }
        if (t2 >= 0 && t2 <= 1) {
          roots2[n++] = t2;
        }
      } else if (disc > 0) {
        var discSqrt = mathSqrt(disc);
        var Y1 = A * b + 1.5 * a * (-B + discSqrt);
        var Y2 = A * b + 1.5 * a * (-B - discSqrt);
        if (Y1 < 0) {
          Y1 = -mathPow(-Y1, ONE_THIRD);
        } else {
          Y1 = mathPow(Y1, ONE_THIRD);
        }
        if (Y2 < 0) {
          Y2 = -mathPow(-Y2, ONE_THIRD);
        } else {
          Y2 = mathPow(Y2, ONE_THIRD);
        }
        var t1 = (-b - (Y1 + Y2)) / (3 * a);
        if (t1 >= 0 && t1 <= 1) {
          roots2[n++] = t1;
        }
      } else {
        var T = (2 * A * b - 3 * a * B) / (2 * mathSqrt(A * A * A));
        var theta = Math.acos(T) / 3;
        var ASqrt = mathSqrt(A);
        var tmp = Math.cos(theta);
        var t1 = (-b - 2 * ASqrt * tmp) / (3 * a);
        var t2 = (-b + ASqrt * (tmp + THREE_SQRT * Math.sin(theta))) / (3 * a);
        var t3 = (-b + ASqrt * (tmp - THREE_SQRT * Math.sin(theta))) / (3 * a);
        if (t1 >= 0 && t1 <= 1) {
          roots2[n++] = t1;
        }
        if (t2 >= 0 && t2 <= 1) {
          roots2[n++] = t2;
        }
        if (t3 >= 0 && t3 <= 1) {
          roots2[n++] = t3;
        }
      }
    }
    return n;
  }
  function cubicExtrema(p0, p1, p2, p3, extrema2) {
    var b = 6 * p2 - 12 * p1 + 6 * p0;
    var a = 9 * p1 + 3 * p3 - 3 * p0 - 9 * p2;
    var c = 3 * p1 - 3 * p0;
    var n = 0;
    if (isAroundZero(a)) {
      if (isNotAroundZero(b)) {
        var t1 = -c / b;
        if (t1 >= 0 && t1 <= 1) {
          extrema2[n++] = t1;
        }
      }
    } else {
      var disc = b * b - 4 * a * c;
      if (isAroundZero(disc)) {
        extrema2[0] = -b / (2 * a);
      } else if (disc > 0) {
        var discSqrt = mathSqrt(disc);
        var t1 = (-b + discSqrt) / (2 * a);
        var t2 = (-b - discSqrt) / (2 * a);
        if (t1 >= 0 && t1 <= 1) {
          extrema2[n++] = t1;
        }
        if (t2 >= 0 && t2 <= 1) {
          extrema2[n++] = t2;
        }
      }
    }
    return n;
  }
  function cubicSubdivide(p0, p1, p2, p3, t, out2) {
    var p01 = (p1 - p0) * t + p0;
    var p12 = (p2 - p1) * t + p1;
    var p23 = (p3 - p2) * t + p2;
    var p012 = (p12 - p01) * t + p01;
    var p123 = (p23 - p12) * t + p12;
    var p0123 = (p123 - p012) * t + p012;
    out2[0] = p0;
    out2[1] = p01;
    out2[2] = p012;
    out2[3] = p0123;
    out2[4] = p0123;
    out2[5] = p123;
    out2[6] = p23;
    out2[7] = p3;
  }
  function cubicProjectPoint(x0, y0, x1, y1, x2, y2, x3, y3, x, y, out2) {
    var t;
    var interval = 5e-3;
    var d = Infinity;
    var prev;
    var next;
    var d1;
    var d2;
    _v0[0] = x;
    _v0[1] = y;
    for (var _t = 0; _t < 1; _t += 0.05) {
      _v1[0] = cubicAt(x0, x1, x2, x3, _t);
      _v1[1] = cubicAt(y0, y1, y2, y3, _t);
      d1 = distSquare(_v0, _v1);
      if (d1 < d) {
        t = _t;
        d = d1;
      }
    }
    d = Infinity;
    for (var i = 0; i < 32; i++) {
      if (interval < EPSILON_NUMERIC) {
        break;
      }
      prev = t - interval;
      next = t + interval;
      _v1[0] = cubicAt(x0, x1, x2, x3, prev);
      _v1[1] = cubicAt(y0, y1, y2, y3, prev);
      d1 = distSquare(_v1, _v0);
      if (prev >= 0 && d1 < d) {
        t = prev;
        d = d1;
      } else {
        _v2[0] = cubicAt(x0, x1, x2, x3, next);
        _v2[1] = cubicAt(y0, y1, y2, y3, next);
        d2 = distSquare(_v2, _v0);
        if (next <= 1 && d2 < d) {
          t = next;
          d = d2;
        } else {
          interval *= 0.5;
        }
      }
    }
    if (out2) {
      out2[0] = cubicAt(x0, x1, x2, x3, t);
      out2[1] = cubicAt(y0, y1, y2, y3, t);
    }
    return mathSqrt(d);
  }
  function cubicLength(x0, y0, x1, y1, x2, y2, x3, y3, iteration) {
    var px = x0;
    var py = y0;
    var d = 0;
    var step = 1 / iteration;
    for (var i = 1; i <= iteration; i++) {
      var t = i * step;
      var x = cubicAt(x0, x1, x2, x3, t);
      var y = cubicAt(y0, y1, y2, y3, t);
      var dx = x - px;
      var dy = y - py;
      d += Math.sqrt(dx * dx + dy * dy);
      px = x;
      py = y;
    }
    return d;
  }
  function quadraticAt(p0, p1, p2, t) {
    var onet = 1 - t;
    return onet * (onet * p0 + 2 * t * p1) + t * t * p2;
  }
  function quadraticDerivativeAt(p0, p1, p2, t) {
    return 2 * ((1 - t) * (p1 - p0) + t * (p2 - p1));
  }
  function quadraticRootAt(p0, p1, p2, val, roots2) {
    var a = p0 - 2 * p1 + p2;
    var b = 2 * (p1 - p0);
    var c = p0 - val;
    var n = 0;
    if (isAroundZero(a)) {
      if (isNotAroundZero(b)) {
        var t1 = -c / b;
        if (t1 >= 0 && t1 <= 1) {
          roots2[n++] = t1;
        }
      }
    } else {
      var disc = b * b - 4 * a * c;
      if (isAroundZero(disc)) {
        var t1 = -b / (2 * a);
        if (t1 >= 0 && t1 <= 1) {
          roots2[n++] = t1;
        }
      } else if (disc > 0) {
        var discSqrt = mathSqrt(disc);
        var t1 = (-b + discSqrt) / (2 * a);
        var t2 = (-b - discSqrt) / (2 * a);
        if (t1 >= 0 && t1 <= 1) {
          roots2[n++] = t1;
        }
        if (t2 >= 0 && t2 <= 1) {
          roots2[n++] = t2;
        }
      }
    }
    return n;
  }
  function quadraticExtremum(p0, p1, p2) {
    var divider = p0 + p2 - 2 * p1;
    if (divider === 0) {
      return 0.5;
    } else {
      return (p0 - p1) / divider;
    }
  }
  function quadraticSubdivide(p0, p1, p2, t, out2) {
    var p01 = (p1 - p0) * t + p0;
    var p12 = (p2 - p1) * t + p1;
    var p012 = (p12 - p01) * t + p01;
    out2[0] = p0;
    out2[1] = p01;
    out2[2] = p012;
    out2[3] = p012;
    out2[4] = p12;
    out2[5] = p2;
  }
  function quadraticProjectPoint(x0, y0, x1, y1, x2, y2, x, y, out2) {
    var t;
    var interval = 5e-3;
    var d = Infinity;
    _v0[0] = x;
    _v0[1] = y;
    for (var _t = 0; _t < 1; _t += 0.05) {
      _v1[0] = quadraticAt(x0, x1, x2, _t);
      _v1[1] = quadraticAt(y0, y1, y2, _t);
      var d1 = distSquare(_v0, _v1);
      if (d1 < d) {
        t = _t;
        d = d1;
      }
    }
    d = Infinity;
    for (var i = 0; i < 32; i++) {
      if (interval < EPSILON_NUMERIC) {
        break;
      }
      var prev = t - interval;
      var next = t + interval;
      _v1[0] = quadraticAt(x0, x1, x2, prev);
      _v1[1] = quadraticAt(y0, y1, y2, prev);
      var d1 = distSquare(_v1, _v0);
      if (prev >= 0 && d1 < d) {
        t = prev;
        d = d1;
      } else {
        _v2[0] = quadraticAt(x0, x1, x2, next);
        _v2[1] = quadraticAt(y0, y1, y2, next);
        var d2 = distSquare(_v2, _v0);
        if (next <= 1 && d2 < d) {
          t = next;
          d = d2;
        } else {
          interval *= 0.5;
        }
      }
    }
    if (out2) {
      out2[0] = quadraticAt(x0, x1, x2, t);
      out2[1] = quadraticAt(y0, y1, y2, t);
    }
    return mathSqrt(d);
  }
  function quadraticLength(x0, y0, x1, y1, x2, y2, iteration) {
    var px = x0;
    var py = y0;
    var d = 0;
    var step = 1 / iteration;
    for (var i = 1; i <= iteration; i++) {
      var t = i * step;
      var x = quadraticAt(x0, x1, x2, t);
      var y = quadraticAt(y0, y1, y2, t);
      var dx = x - px;
      var dy = y - py;
      d += Math.sqrt(dx * dx + dy * dy);
      px = x;
      py = y;
    }
    return d;
  }

  // node_modules/zrender/lib/animation/cubicEasing.js
  var regexp = /cubic-bezier\(([0-9,\.e ]+)\)/;
  function createCubicEasingFunc(cubicEasingStr) {
    var cubic = cubicEasingStr && regexp.exec(cubicEasingStr);
    if (cubic) {
      var points4 = cubic[1].split(",");
      var a_1 = +trim(points4[0]);
      var b_1 = +trim(points4[1]);
      var c_1 = +trim(points4[2]);
      var d_1 = +trim(points4[3]);
      if (isNaN(a_1 + b_1 + c_1 + d_1)) {
        return;
      }
      var roots_1 = [];
      return function(p) {
        return p <= 0 ? 0 : p >= 1 ? 1 : cubicRootAt(0, a_1, c_1, 1, p, roots_1) && cubicAt(0, b_1, d_1, 1, roots_1[0]);
      };
    }
  }

  // node_modules/zrender/lib/animation/Clip.js
  var Clip = function() {
    function Clip2(opts) {
      this._inited = false;
      this._startTime = 0;
      this._pausedTime = 0;
      this._paused = false;
      this._life = opts.life || 1e3;
      this._delay = opts.delay || 0;
      this.loop = opts.loop || false;
      this.onframe = opts.onframe || noop;
      this.ondestroy = opts.ondestroy || noop;
      this.onrestart = opts.onrestart || noop;
      opts.easing && this.setEasing(opts.easing);
    }
    Clip2.prototype.step = function(globalTime, deltaTime) {
      if (!this._inited) {
        this._startTime = globalTime + this._delay;
        this._inited = true;
      }
      if (this._paused) {
        this._pausedTime += deltaTime;
        return;
      }
      var life = this._life;
      var elapsedTime = globalTime - this._startTime - this._pausedTime;
      var percent = elapsedTime / life;
      if (percent < 0) {
        percent = 0;
      }
      percent = Math.min(percent, 1);
      var easingFunc = this.easingFunc;
      var schedule = easingFunc ? easingFunc(percent) : percent;
      this.onframe(schedule);
      if (percent === 1) {
        if (this.loop) {
          var remainder = elapsedTime % life;
          this._startTime = globalTime - remainder;
          this._pausedTime = 0;
          this.onrestart();
        } else {
          return true;
        }
      }
      return false;
    };
    Clip2.prototype.pause = function() {
      this._paused = true;
    };
    Clip2.prototype.resume = function() {
      this._paused = false;
    };
    Clip2.prototype.setEasing = function(easing) {
      this.easing = easing;
      this.easingFunc = isFunction(easing) ? easing : easing_default[easing] || createCubicEasingFunc(easing);
    };
    return Clip2;
  }();
  var Clip_default = Clip;

  // node_modules/zrender/lib/tool/color.js
  var color_exports = {};
  __export(color_exports, {
    fastLerp: () => fastLerp,
    fastMapToColor: () => fastMapToColor,
    lerp: () => lerp2,
    lift: () => lift,
    lum: () => lum,
    mapToColor: () => mapToColor,
    modifyAlpha: () => modifyAlpha,
    modifyHSL: () => modifyHSL,
    parse: () => parse,
    random: () => random,
    stringify: () => stringify,
    toHex: () => toHex
  });

  // node_modules/zrender/lib/core/LRU.js
  var Entry = function() {
    function Entry2(val) {
      this.value = val;
    }
    return Entry2;
  }();
  var LinkedList = function() {
    function LinkedList2() {
      this._len = 0;
    }
    LinkedList2.prototype.insert = function(val) {
      var entry = new Entry(val);
      this.insertEntry(entry);
      return entry;
    };
    LinkedList2.prototype.insertEntry = function(entry) {
      if (!this.head) {
        this.head = this.tail = entry;
      } else {
        this.tail.next = entry;
        entry.prev = this.tail;
        entry.next = null;
        this.tail = entry;
      }
      this._len++;
    };
    LinkedList2.prototype.remove = function(entry) {
      var prev = entry.prev;
      var next = entry.next;
      if (prev) {
        prev.next = next;
      } else {
        this.head = next;
      }
      if (next) {
        next.prev = prev;
      } else {
        this.tail = prev;
      }
      entry.next = entry.prev = null;
      this._len--;
    };
    LinkedList2.prototype.len = function() {
      return this._len;
    };
    LinkedList2.prototype.clear = function() {
      this.head = this.tail = null;
      this._len = 0;
    };
    return LinkedList2;
  }();
  var LRU = function() {
    function LRU2(maxSize) {
      this._list = new LinkedList();
      this._maxSize = 10;
      this._map = {};
      this._maxSize = maxSize;
    }
    LRU2.prototype.put = function(key, value) {
      var list = this._list;
      var map3 = this._map;
      var removed = null;
      if (map3[key] == null) {
        var len2 = list.len();
        var entry = this._lastRemovedEntry;
        if (len2 >= this._maxSize && len2 > 0) {
          var leastUsedEntry = list.head;
          list.remove(leastUsedEntry);
          delete map3[leastUsedEntry.key];
          removed = leastUsedEntry.value;
          this._lastRemovedEntry = leastUsedEntry;
        }
        if (entry) {
          entry.value = value;
        } else {
          entry = new Entry(value);
        }
        entry.key = key;
        list.insertEntry(entry);
        map3[key] = entry;
      }
      return removed;
    };
    LRU2.prototype.get = function(key) {
      var entry = this._map[key];
      var list = this._list;
      if (entry != null) {
        if (entry !== list.tail) {
          list.remove(entry);
          list.insertEntry(entry);
        }
        return entry.value;
      }
    };
    LRU2.prototype.clear = function() {
      this._list.clear();
      this._map = {};
    };
    LRU2.prototype.len = function() {
      return this._list.len();
    };
    return LRU2;
  }();
  var LRU_default = LRU;

  // node_modules/zrender/lib/tool/color.js
  var kCSSColorTable = {
    "transparent": [0, 0, 0, 0],
    "aliceblue": [240, 248, 255, 1],
    "antiquewhite": [250, 235, 215, 1],
    "aqua": [0, 255, 255, 1],
    "aquamarine": [127, 255, 212, 1],
    "azure": [240, 255, 255, 1],
    "beige": [245, 245, 220, 1],
    "bisque": [255, 228, 196, 1],
    "black": [0, 0, 0, 1],
    "blanchedalmond": [255, 235, 205, 1],
    "blue": [0, 0, 255, 1],
    "blueviolet": [138, 43, 226, 1],
    "brown": [165, 42, 42, 1],
    "burlywood": [222, 184, 135, 1],
    "cadetblue": [95, 158, 160, 1],
    "chartreuse": [127, 255, 0, 1],
    "chocolate": [210, 105, 30, 1],
    "coral": [255, 127, 80, 1],
    "cornflowerblue": [100, 149, 237, 1],
    "cornsilk": [255, 248, 220, 1],
    "crimson": [220, 20, 60, 1],
    "cyan": [0, 255, 255, 1],
    "darkblue": [0, 0, 139, 1],
    "darkcyan": [0, 139, 139, 1],
    "darkgoldenrod": [184, 134, 11, 1],
    "darkgray": [169, 169, 169, 1],
    "darkgreen": [0, 100, 0, 1],
    "darkgrey": [169, 169, 169, 1],
    "darkkhaki": [189, 183, 107, 1],
    "darkmagenta": [139, 0, 139, 1],
    "darkolivegreen": [85, 107, 47, 1],
    "darkorange": [255, 140, 0, 1],
    "darkorchid": [153, 50, 204, 1],
    "darkred": [139, 0, 0, 1],
    "darksalmon": [233, 150, 122, 1],
    "darkseagreen": [143, 188, 143, 1],
    "darkslateblue": [72, 61, 139, 1],
    "darkslategray": [47, 79, 79, 1],
    "darkslategrey": [47, 79, 79, 1],
    "darkturquoise": [0, 206, 209, 1],
    "darkviolet": [148, 0, 211, 1],
    "deeppink": [255, 20, 147, 1],
    "deepskyblue": [0, 191, 255, 1],
    "dimgray": [105, 105, 105, 1],
    "dimgrey": [105, 105, 105, 1],
    "dodgerblue": [30, 144, 255, 1],
    "firebrick": [178, 34, 34, 1],
    "floralwhite": [255, 250, 240, 1],
    "forestgreen": [34, 139, 34, 1],
    "fuchsia": [255, 0, 255, 1],
    "gainsboro": [220, 220, 220, 1],
    "ghostwhite": [248, 248, 255, 1],
    "gold": [255, 215, 0, 1],
    "goldenrod": [218, 165, 32, 1],
    "gray": [128, 128, 128, 1],
    "green": [0, 128, 0, 1],
    "greenyellow": [173, 255, 47, 1],
    "grey": [128, 128, 128, 1],
    "honeydew": [240, 255, 240, 1],
    "hotpink": [255, 105, 180, 1],
    "indianred": [205, 92, 92, 1],
    "indigo": [75, 0, 130, 1],
    "ivory": [255, 255, 240, 1],
    "khaki": [240, 230, 140, 1],
    "lavender": [230, 230, 250, 1],
    "lavenderblush": [255, 240, 245, 1],
    "lawngreen": [124, 252, 0, 1],
    "lemonchiffon": [255, 250, 205, 1],
    "lightblue": [173, 216, 230, 1],
    "lightcoral": [240, 128, 128, 1],
    "lightcyan": [224, 255, 255, 1],
    "lightgoldenrodyellow": [250, 250, 210, 1],
    "lightgray": [211, 211, 211, 1],
    "lightgreen": [144, 238, 144, 1],
    "lightgrey": [211, 211, 211, 1],
    "lightpink": [255, 182, 193, 1],
    "lightsalmon": [255, 160, 122, 1],
    "lightseagreen": [32, 178, 170, 1],
    "lightskyblue": [135, 206, 250, 1],
    "lightslategray": [119, 136, 153, 1],
    "lightslategrey": [119, 136, 153, 1],
    "lightsteelblue": [176, 196, 222, 1],
    "lightyellow": [255, 255, 224, 1],
    "lime": [0, 255, 0, 1],
    "limegreen": [50, 205, 50, 1],
    "linen": [250, 240, 230, 1],
    "magenta": [255, 0, 255, 1],
    "maroon": [128, 0, 0, 1],
    "mediumaquamarine": [102, 205, 170, 1],
    "mediumblue": [0, 0, 205, 1],
    "mediumorchid": [186, 85, 211, 1],
    "mediumpurple": [147, 112, 219, 1],
    "mediumseagreen": [60, 179, 113, 1],
    "mediumslateblue": [123, 104, 238, 1],
    "mediumspringgreen": [0, 250, 154, 1],
    "mediumturquoise": [72, 209, 204, 1],
    "mediumvioletred": [199, 21, 133, 1],
    "midnightblue": [25, 25, 112, 1],
    "mintcream": [245, 255, 250, 1],
    "mistyrose": [255, 228, 225, 1],
    "moccasin": [255, 228, 181, 1],
    "navajowhite": [255, 222, 173, 1],
    "navy": [0, 0, 128, 1],
    "oldlace": [253, 245, 230, 1],
    "olive": [128, 128, 0, 1],
    "olivedrab": [107, 142, 35, 1],
    "orange": [255, 165, 0, 1],
    "orangered": [255, 69, 0, 1],
    "orchid": [218, 112, 214, 1],
    "palegoldenrod": [238, 232, 170, 1],
    "palegreen": [152, 251, 152, 1],
    "paleturquoise": [175, 238, 238, 1],
    "palevioletred": [219, 112, 147, 1],
    "papayawhip": [255, 239, 213, 1],
    "peachpuff": [255, 218, 185, 1],
    "peru": [205, 133, 63, 1],
    "pink": [255, 192, 203, 1],
    "plum": [221, 160, 221, 1],
    "powderblue": [176, 224, 230, 1],
    "purple": [128, 0, 128, 1],
    "red": [255, 0, 0, 1],
    "rosybrown": [188, 143, 143, 1],
    "royalblue": [65, 105, 225, 1],
    "saddlebrown": [139, 69, 19, 1],
    "salmon": [250, 128, 114, 1],
    "sandybrown": [244, 164, 96, 1],
    "seagreen": [46, 139, 87, 1],
    "seashell": [255, 245, 238, 1],
    "sienna": [160, 82, 45, 1],
    "silver": [192, 192, 192, 1],
    "skyblue": [135, 206, 235, 1],
    "slateblue": [106, 90, 205, 1],
    "slategray": [112, 128, 144, 1],
    "slategrey": [112, 128, 144, 1],
    "snow": [255, 250, 250, 1],
    "springgreen": [0, 255, 127, 1],
    "steelblue": [70, 130, 180, 1],
    "tan": [210, 180, 140, 1],
    "teal": [0, 128, 128, 1],
    "thistle": [216, 191, 216, 1],
    "tomato": [255, 99, 71, 1],
    "turquoise": [64, 224, 208, 1],
    "violet": [238, 130, 238, 1],
    "wheat": [245, 222, 179, 1],
    "white": [255, 255, 255, 1],
    "whitesmoke": [245, 245, 245, 1],
    "yellow": [255, 255, 0, 1],
    "yellowgreen": [154, 205, 50, 1]
  };
  function clampCssByte(i) {
    i = Math.round(i);
    return i < 0 ? 0 : i > 255 ? 255 : i;
  }
  function clampCssAngle(i) {
    i = Math.round(i);
    return i < 0 ? 0 : i > 360 ? 360 : i;
  }
  function clampCssFloat(f) {
    return f < 0 ? 0 : f > 1 ? 1 : f;
  }
  function parseCssInt(val) {
    var str = val;
    if (str.length && str.charAt(str.length - 1) === "%") {
      return clampCssByte(parseFloat(str) / 100 * 255);
    }
    return clampCssByte(parseInt(str, 10));
  }
  function parseCssFloat(val) {
    var str = val;
    if (str.length && str.charAt(str.length - 1) === "%") {
      return clampCssFloat(parseFloat(str) / 100);
    }
    return clampCssFloat(parseFloat(str));
  }
  function cssHueToRgb(m1, m2, h) {
    if (h < 0) {
      h += 1;
    } else if (h > 1) {
      h -= 1;
    }
    if (h * 6 < 1) {
      return m1 + (m2 - m1) * h * 6;
    }
    if (h * 2 < 1) {
      return m2;
    }
    if (h * 3 < 2) {
      return m1 + (m2 - m1) * (2 / 3 - h) * 6;
    }
    return m1;
  }
  function lerpNumber(a, b, p) {
    return a + (b - a) * p;
  }
  function setRgba(out2, r, g, b, a) {
    out2[0] = r;
    out2[1] = g;
    out2[2] = b;
    out2[3] = a;
    return out2;
  }
  function copyRgba(out2, a) {
    out2[0] = a[0];
    out2[1] = a[1];
    out2[2] = a[2];
    out2[3] = a[3];
    return out2;
  }
  var colorCache = new LRU_default(20);
  var lastRemovedArr = null;
  function putToCache(colorStr, rgbaArr) {
    if (lastRemovedArr) {
      copyRgba(lastRemovedArr, rgbaArr);
    }
    lastRemovedArr = colorCache.put(colorStr, lastRemovedArr || rgbaArr.slice());
  }
  function parse(colorStr, rgbaArr) {
    if (!colorStr) {
      return;
    }
    rgbaArr = rgbaArr || [];
    var cached = colorCache.get(colorStr);
    if (cached) {
      return copyRgba(rgbaArr, cached);
    }
    colorStr = colorStr + "";
    var str = colorStr.replace(/ /g, "").toLowerCase();
    if (str in kCSSColorTable) {
      copyRgba(rgbaArr, kCSSColorTable[str]);
      putToCache(colorStr, rgbaArr);
      return rgbaArr;
    }
    var strLen = str.length;
    if (str.charAt(0) === "#") {
      if (strLen === 4 || strLen === 5) {
        var iv = parseInt(str.slice(1, 4), 16);
        if (!(iv >= 0 && iv <= 4095)) {
          setRgba(rgbaArr, 0, 0, 0, 1);
          return;
        }
        setRgba(rgbaArr, (iv & 3840) >> 4 | (iv & 3840) >> 8, iv & 240 | (iv & 240) >> 4, iv & 15 | (iv & 15) << 4, strLen === 5 ? parseInt(str.slice(4), 16) / 15 : 1);
        putToCache(colorStr, rgbaArr);
        return rgbaArr;
      } else if (strLen === 7 || strLen === 9) {
        var iv = parseInt(str.slice(1, 7), 16);
        if (!(iv >= 0 && iv <= 16777215)) {
          setRgba(rgbaArr, 0, 0, 0, 1);
          return;
        }
        setRgba(rgbaArr, (iv & 16711680) >> 16, (iv & 65280) >> 8, iv & 255, strLen === 9 ? parseInt(str.slice(7), 16) / 255 : 1);
        putToCache(colorStr, rgbaArr);
        return rgbaArr;
      }
      return;
    }
    var op = str.indexOf("(");
    var ep = str.indexOf(")");
    if (op !== -1 && ep + 1 === strLen) {
      var fname = str.substr(0, op);
      var params = str.substr(op + 1, ep - (op + 1)).split(",");
      var alpha = 1;
      switch (fname) {
        case "rgba":
          if (params.length !== 4) {
            return params.length === 3 ? setRgba(rgbaArr, +params[0], +params[1], +params[2], 1) : setRgba(rgbaArr, 0, 0, 0, 1);
          }
          alpha = parseCssFloat(params.pop());
        case "rgb":
          if (params.length !== 3) {
            setRgba(rgbaArr, 0, 0, 0, 1);
            return;
          }
          setRgba(rgbaArr, parseCssInt(params[0]), parseCssInt(params[1]), parseCssInt(params[2]), alpha);
          putToCache(colorStr, rgbaArr);
          return rgbaArr;
        case "hsla":
          if (params.length !== 4) {
            setRgba(rgbaArr, 0, 0, 0, 1);
            return;
          }
          params[3] = parseCssFloat(params[3]);
          hsla2rgba(params, rgbaArr);
          putToCache(colorStr, rgbaArr);
          return rgbaArr;
        case "hsl":
          if (params.length !== 3) {
            setRgba(rgbaArr, 0, 0, 0, 1);
            return;
          }
          hsla2rgba(params, rgbaArr);
          putToCache(colorStr, rgbaArr);
          return rgbaArr;
        default:
          return;
      }
    }
    setRgba(rgbaArr, 0, 0, 0, 1);
    return;
  }
  function hsla2rgba(hsla, rgba) {
    var h = (parseFloat(hsla[0]) % 360 + 360) % 360 / 360;
    var s = parseCssFloat(hsla[1]);
    var l = parseCssFloat(hsla[2]);
    var m2 = l <= 0.5 ? l * (s + 1) : l + s - l * s;
    var m1 = l * 2 - m2;
    rgba = rgba || [];
    setRgba(rgba, clampCssByte(cssHueToRgb(m1, m2, h + 1 / 3) * 255), clampCssByte(cssHueToRgb(m1, m2, h) * 255), clampCssByte(cssHueToRgb(m1, m2, h - 1 / 3) * 255), 1);
    if (hsla.length === 4) {
      rgba[3] = hsla[3];
    }
    return rgba;
  }
  function rgba2hsla(rgba) {
    if (!rgba) {
      return;
    }
    var R = rgba[0] / 255;
    var G = rgba[1] / 255;
    var B = rgba[2] / 255;
    var vMin = Math.min(R, G, B);
    var vMax = Math.max(R, G, B);
    var delta = vMax - vMin;
    var L = (vMax + vMin) / 2;
    var H;
    var S;
    if (delta === 0) {
      H = 0;
      S = 0;
    } else {
      if (L < 0.5) {
        S = delta / (vMax + vMin);
      } else {
        S = delta / (2 - vMax - vMin);
      }
      var deltaR = ((vMax - R) / 6 + delta / 2) / delta;
      var deltaG = ((vMax - G) / 6 + delta / 2) / delta;
      var deltaB = ((vMax - B) / 6 + delta / 2) / delta;
      if (R === vMax) {
        H = deltaB - deltaG;
      } else if (G === vMax) {
        H = 1 / 3 + deltaR - deltaB;
      } else if (B === vMax) {
        H = 2 / 3 + deltaG - deltaR;
      }
      if (H < 0) {
        H += 1;
      }
      if (H > 1) {
        H -= 1;
      }
    }
    var hsla = [H * 360, S, L];
    if (rgba[3] != null) {
      hsla.push(rgba[3]);
    }
    return hsla;
  }
  function lift(color, level) {
    var colorArr = parse(color);
    if (colorArr) {
      for (var i = 0; i < 3; i++) {
        if (level < 0) {
          colorArr[i] = colorArr[i] * (1 - level) | 0;
        } else {
          colorArr[i] = (255 - colorArr[i]) * level + colorArr[i] | 0;
        }
        if (colorArr[i] > 255) {
          colorArr[i] = 255;
        } else if (colorArr[i] < 0) {
          colorArr[i] = 0;
        }
      }
      return stringify(colorArr, colorArr.length === 4 ? "rgba" : "rgb");
    }
  }
  function toHex(color) {
    var colorArr = parse(color);
    if (colorArr) {
      return ((1 << 24) + (colorArr[0] << 16) + (colorArr[1] << 8) + +colorArr[2]).toString(16).slice(1);
    }
  }
  function fastLerp(normalizedValue, colors, out2) {
    if (!(colors && colors.length) || !(normalizedValue >= 0 && normalizedValue <= 1)) {
      return;
    }
    out2 = out2 || [];
    var value = normalizedValue * (colors.length - 1);
    var leftIndex = Math.floor(value);
    var rightIndex = Math.ceil(value);
    var leftColor = colors[leftIndex];
    var rightColor = colors[rightIndex];
    var dv = value - leftIndex;
    out2[0] = clampCssByte(lerpNumber(leftColor[0], rightColor[0], dv));
    out2[1] = clampCssByte(lerpNumber(leftColor[1], rightColor[1], dv));
    out2[2] = clampCssByte(lerpNumber(leftColor[2], rightColor[2], dv));
    out2[3] = clampCssFloat(lerpNumber(leftColor[3], rightColor[3], dv));
    return out2;
  }
  var fastMapToColor = fastLerp;
  function lerp2(normalizedValue, colors, fullOutput) {
    if (!(colors && colors.length) || !(normalizedValue >= 0 && normalizedValue <= 1)) {
      return;
    }
    var value = normalizedValue * (colors.length - 1);
    var leftIndex = Math.floor(value);
    var rightIndex = Math.ceil(value);
    var leftColor = parse(colors[leftIndex]);
    var rightColor = parse(colors[rightIndex]);
    var dv = value - leftIndex;
    var color = stringify([
      clampCssByte(lerpNumber(leftColor[0], rightColor[0], dv)),
      clampCssByte(lerpNumber(leftColor[1], rightColor[1], dv)),
      clampCssByte(lerpNumber(leftColor[2], rightColor[2], dv)),
      clampCssFloat(lerpNumber(leftColor[3], rightColor[3], dv))
    ], "rgba");
    return fullOutput ? {
      color,
      leftIndex,
      rightIndex,
      value
    } : color;
  }
  var mapToColor = lerp2;
  function modifyHSL(color, h, s, l) {
    var colorArr = parse(color);
    if (color) {
      colorArr = rgba2hsla(colorArr);
      h != null && (colorArr[0] = clampCssAngle(h));
      s != null && (colorArr[1] = parseCssFloat(s));
      l != null && (colorArr[2] = parseCssFloat(l));
      return stringify(hsla2rgba(colorArr), "rgba");
    }
  }
  function modifyAlpha(color, alpha) {
    var colorArr = parse(color);
    if (colorArr && alpha != null) {
      colorArr[3] = clampCssFloat(alpha);
      return stringify(colorArr, "rgba");
    }
  }
  function stringify(arrColor, type) {
    if (!arrColor || !arrColor.length) {
      return;
    }
    var colorStr = arrColor[0] + "," + arrColor[1] + "," + arrColor[2];
    if (type === "rgba" || type === "hsva" || type === "hsla") {
      colorStr += "," + arrColor[3];
    }
    return type + "(" + colorStr + ")";
  }
  function lum(color, backgroundLum) {
    var arr = parse(color);
    return arr ? (0.299 * arr[0] + 0.587 * arr[1] + 0.114 * arr[2]) * arr[3] / 255 + (1 - arr[3]) * backgroundLum : 0;
  }
  function random() {
    return stringify([
      Math.round(Math.random() * 255),
      Math.round(Math.random() * 255),
      Math.round(Math.random() * 255)
    ], "rgb");
  }

  // node_modules/zrender/lib/svg/helper.js
  var mathRound = Math.round;
  function normalizeColor(color) {
    var opacity;
    if (!color || color === "transparent") {
      color = "none";
    } else if (typeof color === "string" && color.indexOf("rgba") > -1) {
      var arr = parse(color);
      if (arr) {
        color = "rgb(" + arr[0] + "," + arr[1] + "," + arr[2] + ")";
        opacity = arr[3];
      }
    }
    return {
      color,
      opacity: opacity == null ? 1 : opacity
    };
  }
  var EPSILON2 = 1e-4;
  function isAroundZero2(transform2) {
    return transform2 < EPSILON2 && transform2 > -EPSILON2;
  }
  function round3(transform2) {
    return mathRound(transform2 * 1e3) / 1e3;
  }
  function round4(transform2) {
    return mathRound(transform2 * 1e4) / 1e4;
  }
  function getMatrixStr(m2) {
    return "matrix(" + round3(m2[0]) + "," + round3(m2[1]) + "," + round3(m2[2]) + "," + round3(m2[3]) + "," + round4(m2[4]) + "," + round4(m2[5]) + ")";
  }
  var TEXT_ALIGN_TO_ANCHOR = {
    left: "start",
    right: "end",
    center: "middle",
    middle: "middle"
  };
  function adjustTextY(y, lineHeight, textBaseline) {
    if (textBaseline === "top") {
      y += lineHeight / 2;
    } else if (textBaseline === "bottom") {
      y -= lineHeight / 2;
    }
    return y;
  }
  function hasShadow(style) {
    return style && (style.shadowBlur || style.shadowOffsetX || style.shadowOffsetY);
  }
  function getShadowKey(displayable) {
    var style = displayable.style;
    var globalScale = displayable.getGlobalScale();
    return [
      style.shadowColor,
      (style.shadowBlur || 0).toFixed(2),
      (style.shadowOffsetX || 0).toFixed(2),
      (style.shadowOffsetY || 0).toFixed(2),
      globalScale[0],
      globalScale[1]
    ].join(",");
  }
  function isImagePattern(val) {
    return val && !!val.image;
  }
  function isSVGPattern(val) {
    return val && !!val.svgElement;
  }
  function isPattern(val) {
    return isImagePattern(val) || isSVGPattern(val);
  }
  function isLinearGradient(val) {
    return val.type === "linear";
  }
  function isRadialGradient(val) {
    return val.type === "radial";
  }
  function isGradient(val) {
    return val && (val.type === "linear" || val.type === "radial");
  }
  function getIdURL(id) {
    return "url(#" + id + ")";
  }
  function getPathPrecision(el) {
    var scale4 = el.getGlobalScale();
    var size = Math.max(scale4[0], scale4[1]);
    return Math.max(Math.ceil(Math.log(size) / Math.log(10)), 1);
  }
  function getSRTTransformString(transform2) {
    var x = transform2.x || 0;
    var y = transform2.y || 0;
    var rotation = (transform2.rotation || 0) * RADIAN_TO_DEGREE;
    var scaleX = retrieve2(transform2.scaleX, 1);
    var scaleY = retrieve2(transform2.scaleY, 1);
    var skewX = transform2.skewX || 0;
    var skewY = transform2.skewY || 0;
    var res = [];
    if (x || y) {
      res.push("translate(" + x + "px," + y + "px)");
    }
    if (rotation) {
      res.push("rotate(" + rotation + ")");
    }
    if (scaleX !== 1 || scaleY !== 1) {
      res.push("scale(" + scaleX + "," + scaleY + ")");
    }
    if (skewX || skewY) {
      res.push("skew(" + mathRound(skewX * RADIAN_TO_DEGREE) + "deg, " + mathRound(skewY * RADIAN_TO_DEGREE) + "deg)");
    }
    return res.join(" ");
  }
  var encodeBase64 = function() {
    if (env_default.hasGlobalWindow && isFunction(window.btoa)) {
      return function(str) {
        return window.btoa(unescape(str));
      };
    }
    if (typeof Buffer !== "undefined") {
      return function(str) {
        return Buffer.from(str).toString("base64");
      };
    }
    return function(str) {
      if (true) {
        logError("Base64 isn't natively supported in the current environment.");
      }
      return null;
    };
  }();

  // node_modules/zrender/lib/animation/Animator.js
  var arraySlice = Array.prototype.slice;
  function interpolateNumber(p0, p1, percent) {
    return (p1 - p0) * percent + p0;
  }
  function interpolate1DArray(out2, p0, p1, percent) {
    var len2 = p0.length;
    for (var i = 0; i < len2; i++) {
      out2[i] = interpolateNumber(p0[i], p1[i], percent);
    }
    return out2;
  }
  function interpolate2DArray(out2, p0, p1, percent) {
    var len2 = p0.length;
    var len22 = len2 && p0[0].length;
    for (var i = 0; i < len2; i++) {
      if (!out2[i]) {
        out2[i] = [];
      }
      for (var j = 0; j < len22; j++) {
        out2[i][j] = interpolateNumber(p0[i][j], p1[i][j], percent);
      }
    }
    return out2;
  }
  function add1DArray(out2, p0, p1, sign) {
    var len2 = p0.length;
    for (var i = 0; i < len2; i++) {
      out2[i] = p0[i] + p1[i] * sign;
    }
    return out2;
  }
  function add2DArray(out2, p0, p1, sign) {
    var len2 = p0.length;
    var len22 = len2 && p0[0].length;
    for (var i = 0; i < len2; i++) {
      if (!out2[i]) {
        out2[i] = [];
      }
      for (var j = 0; j < len22; j++) {
        out2[i][j] = p0[i][j] + p1[i][j] * sign;
      }
    }
    return out2;
  }
  function fillColorStops(val0, val1) {
    var len0 = val0.length;
    var len1 = val1.length;
    var shorterArr = len0 > len1 ? val1 : val0;
    var shorterLen = Math.min(len0, len1);
    var last = shorterArr[shorterLen - 1] || { color: [0, 0, 0, 0], offset: 0 };
    for (var i = shorterLen; i < Math.max(len0, len1); i++) {
      shorterArr.push({
        offset: last.offset,
        color: last.color.slice()
      });
    }
  }
  function fillArray(val0, val1, arrDim) {
    var arr0 = val0;
    var arr1 = val1;
    if (!arr0.push || !arr1.push) {
      return;
    }
    var arr0Len = arr0.length;
    var arr1Len = arr1.length;
    if (arr0Len !== arr1Len) {
      var isPreviousLarger = arr0Len > arr1Len;
      if (isPreviousLarger) {
        arr0.length = arr1Len;
      } else {
        for (var i = arr0Len; i < arr1Len; i++) {
          arr0.push(arrDim === 1 ? arr1[i] : arraySlice.call(arr1[i]));
        }
      }
    }
    var len2 = arr0[0] && arr0[0].length;
    for (var i = 0; i < arr0.length; i++) {
      if (arrDim === 1) {
        if (isNaN(arr0[i])) {
          arr0[i] = arr1[i];
        }
      } else {
        for (var j = 0; j < len2; j++) {
          if (isNaN(arr0[i][j])) {
            arr0[i][j] = arr1[i][j];
          }
        }
      }
    }
  }
  function cloneValue(value) {
    if (isArrayLike(value)) {
      var len2 = value.length;
      if (isArrayLike(value[0])) {
        var ret = [];
        for (var i = 0; i < len2; i++) {
          ret.push(arraySlice.call(value[i]));
        }
        return ret;
      }
      return arraySlice.call(value);
    }
    return value;
  }
  function rgba2String(rgba) {
    rgba[0] = Math.floor(rgba[0]) || 0;
    rgba[1] = Math.floor(rgba[1]) || 0;
    rgba[2] = Math.floor(rgba[2]) || 0;
    rgba[3] = rgba[3] == null ? 1 : rgba[3];
    return "rgba(" + rgba.join(",") + ")";
  }
  function guessArrayDim(value) {
    return isArrayLike(value && value[0]) ? 2 : 1;
  }
  var VALUE_TYPE_NUMBER = 0;
  var VALUE_TYPE_1D_ARRAY = 1;
  var VALUE_TYPE_2D_ARRAY = 2;
  var VALUE_TYPE_COLOR = 3;
  var VALUE_TYPE_LINEAR_GRADIENT = 4;
  var VALUE_TYPE_RADIAL_GRADIENT = 5;
  var VALUE_TYPE_UNKOWN = 6;
  function isGradientValueType(valType) {
    return valType === VALUE_TYPE_LINEAR_GRADIENT || valType === VALUE_TYPE_RADIAL_GRADIENT;
  }
  function isArrayValueType(valType) {
    return valType === VALUE_TYPE_1D_ARRAY || valType === VALUE_TYPE_2D_ARRAY;
  }
  var tmpRgba = [0, 0, 0, 0];
  var Track = function() {
    function Track2(propName) {
      this.keyframes = [];
      this.discrete = false;
      this._invalid = false;
      this._needsSort = false;
      this._lastFr = 0;
      this._lastFrP = 0;
      this.propName = propName;
    }
    Track2.prototype.isFinished = function() {
      return this._finished;
    };
    Track2.prototype.setFinished = function() {
      this._finished = true;
      if (this._additiveTrack) {
        this._additiveTrack.setFinished();
      }
    };
    Track2.prototype.needsAnimate = function() {
      return this.keyframes.length >= 1;
    };
    Track2.prototype.getAdditiveTrack = function() {
      return this._additiveTrack;
    };
    Track2.prototype.addKeyframe = function(time, rawValue, easing) {
      this._needsSort = true;
      var keyframes = this.keyframes;
      var len2 = keyframes.length;
      var discrete = false;
      var valType = VALUE_TYPE_UNKOWN;
      var value = rawValue;
      if (isArrayLike(rawValue)) {
        var arrayDim = guessArrayDim(rawValue);
        valType = arrayDim;
        if (arrayDim === 1 && !isNumber(rawValue[0]) || arrayDim === 2 && !isNumber(rawValue[0][0])) {
          discrete = true;
        }
      } else {
        if (isNumber(rawValue) && !eqNaN(rawValue)) {
          valType = VALUE_TYPE_NUMBER;
        } else if (isString(rawValue)) {
          if (!isNaN(+rawValue)) {
            valType = VALUE_TYPE_NUMBER;
          } else {
            var colorArray = parse(rawValue);
            if (colorArray) {
              value = colorArray;
              valType = VALUE_TYPE_COLOR;
            }
          }
        } else if (isGradientObject(rawValue)) {
          var parsedGradient = extend({}, value);
          parsedGradient.colorStops = map(rawValue.colorStops, function(colorStop) {
            return {
              offset: colorStop.offset,
              color: parse(colorStop.color)
            };
          });
          if (isLinearGradient(rawValue)) {
            valType = VALUE_TYPE_LINEAR_GRADIENT;
          } else if (isRadialGradient(rawValue)) {
            valType = VALUE_TYPE_RADIAL_GRADIENT;
          }
          value = parsedGradient;
        }
      }
      if (len2 === 0) {
        this.valType = valType;
      } else if (valType !== this.valType || valType === VALUE_TYPE_UNKOWN) {
        discrete = true;
      }
      this.discrete = this.discrete || discrete;
      var kf = {
        time,
        value,
        rawValue,
        percent: 0
      };
      if (easing) {
        kf.easing = easing;
        kf.easingFunc = isFunction(easing) ? easing : easing_default[easing] || createCubicEasingFunc(easing);
      }
      keyframes.push(kf);
      return kf;
    };
    Track2.prototype.prepare = function(maxTime, additiveTrack) {
      var kfs = this.keyframes;
      if (this._needsSort) {
        kfs.sort(function(a, b) {
          return a.time - b.time;
        });
      }
      var valType = this.valType;
      var kfsLen = kfs.length;
      var lastKf = kfs[kfsLen - 1];
      var isDiscrete = this.discrete;
      var isArr = isArrayValueType(valType);
      var isGradient2 = isGradientValueType(valType);
      for (var i = 0; i < kfsLen; i++) {
        var kf = kfs[i];
        var value = kf.value;
        var lastValue = lastKf.value;
        kf.percent = kf.time / maxTime;
        if (!isDiscrete) {
          if (isArr && i !== kfsLen - 1) {
            fillArray(value, lastValue, valType);
          } else if (isGradient2) {
            fillColorStops(value.colorStops, lastValue.colorStops);
          }
        }
      }
      if (!isDiscrete && valType !== VALUE_TYPE_RADIAL_GRADIENT && additiveTrack && this.needsAnimate() && additiveTrack.needsAnimate() && valType === additiveTrack.valType && !additiveTrack._finished) {
        this._additiveTrack = additiveTrack;
        var startValue = kfs[0].value;
        for (var i = 0; i < kfsLen; i++) {
          if (valType === VALUE_TYPE_NUMBER) {
            kfs[i].additiveValue = kfs[i].value - startValue;
          } else if (valType === VALUE_TYPE_COLOR) {
            kfs[i].additiveValue = add1DArray([], kfs[i].value, startValue, -1);
          } else if (isArrayValueType(valType)) {
            kfs[i].additiveValue = valType === VALUE_TYPE_1D_ARRAY ? add1DArray([], kfs[i].value, startValue, -1) : add2DArray([], kfs[i].value, startValue, -1);
          }
        }
      }
    };
    Track2.prototype.step = function(target, percent) {
      if (this._finished) {
        return;
      }
      if (this._additiveTrack && this._additiveTrack._finished) {
        this._additiveTrack = null;
      }
      var isAdditive = this._additiveTrack != null;
      var valueKey = isAdditive ? "additiveValue" : "value";
      var valType = this.valType;
      var keyframes = this.keyframes;
      var kfsNum = keyframes.length;
      var propName = this.propName;
      var isValueColor = valType === VALUE_TYPE_COLOR;
      var frameIdx;
      var lastFrame = this._lastFr;
      var mathMin12 = Math.min;
      var frame;
      var nextFrame;
      if (kfsNum === 1) {
        frame = nextFrame = keyframes[0];
      } else {
        if (percent < 0) {
          frameIdx = 0;
        } else if (percent < this._lastFrP) {
          var start2 = mathMin12(lastFrame + 1, kfsNum - 1);
          for (frameIdx = start2; frameIdx >= 0; frameIdx--) {
            if (keyframes[frameIdx].percent <= percent) {
              break;
            }
          }
          frameIdx = mathMin12(frameIdx, kfsNum - 2);
        } else {
          for (frameIdx = lastFrame; frameIdx < kfsNum; frameIdx++) {
            if (keyframes[frameIdx].percent > percent) {
              break;
            }
          }
          frameIdx = mathMin12(frameIdx - 1, kfsNum - 2);
        }
        nextFrame = keyframes[frameIdx + 1];
        frame = keyframes[frameIdx];
      }
      if (!(frame && nextFrame)) {
        return;
      }
      this._lastFr = frameIdx;
      this._lastFrP = percent;
      var interval = nextFrame.percent - frame.percent;
      var w = interval === 0 ? 1 : mathMin12((percent - frame.percent) / interval, 1);
      if (nextFrame.easingFunc) {
        w = nextFrame.easingFunc(w);
      }
      var targetArr = isAdditive ? this._additiveValue : isValueColor ? tmpRgba : target[propName];
      if ((isArrayValueType(valType) || isValueColor) && !targetArr) {
        targetArr = this._additiveValue = [];
      }
      if (this.discrete) {
        target[propName] = w < 1 ? frame.rawValue : nextFrame.rawValue;
      } else if (isArrayValueType(valType)) {
        valType === VALUE_TYPE_1D_ARRAY ? interpolate1DArray(targetArr, frame[valueKey], nextFrame[valueKey], w) : interpolate2DArray(targetArr, frame[valueKey], nextFrame[valueKey], w);
      } else if (isGradientValueType(valType)) {
        var val = frame[valueKey];
        var nextVal_1 = nextFrame[valueKey];
        var isLinearGradient_1 = valType === VALUE_TYPE_LINEAR_GRADIENT;
        target[propName] = {
          type: isLinearGradient_1 ? "linear" : "radial",
          x: interpolateNumber(val.x, nextVal_1.x, w),
          y: interpolateNumber(val.y, nextVal_1.y, w),
          colorStops: map(val.colorStops, function(colorStop, idx) {
            var nextColorStop = nextVal_1.colorStops[idx];
            return {
              offset: interpolateNumber(colorStop.offset, nextColorStop.offset, w),
              color: rgba2String(interpolate1DArray([], colorStop.color, nextColorStop.color, w))
            };
          }),
          global: nextVal_1.global
        };
        if (isLinearGradient_1) {
          target[propName].x2 = interpolateNumber(val.x2, nextVal_1.x2, w);
          target[propName].y2 = interpolateNumber(val.y2, nextVal_1.y2, w);
        } else {
          target[propName].r = interpolateNumber(val.r, nextVal_1.r, w);
        }
      } else if (isValueColor) {
        interpolate1DArray(targetArr, frame[valueKey], nextFrame[valueKey], w);
        if (!isAdditive) {
          target[propName] = rgba2String(targetArr);
        }
      } else {
        var value = interpolateNumber(frame[valueKey], nextFrame[valueKey], w);
        if (isAdditive) {
          this._additiveValue = value;
        } else {
          target[propName] = value;
        }
      }
      if (isAdditive) {
        this._addToTarget(target);
      }
    };
    Track2.prototype._addToTarget = function(target) {
      var valType = this.valType;
      var propName = this.propName;
      var additiveValue = this._additiveValue;
      if (valType === VALUE_TYPE_NUMBER) {
        target[propName] = target[propName] + additiveValue;
      } else if (valType === VALUE_TYPE_COLOR) {
        parse(target[propName], tmpRgba);
        add1DArray(tmpRgba, tmpRgba, additiveValue, 1);
        target[propName] = rgba2String(tmpRgba);
      } else if (valType === VALUE_TYPE_1D_ARRAY) {
        add1DArray(target[propName], target[propName], additiveValue, 1);
      } else if (valType === VALUE_TYPE_2D_ARRAY) {
        add2DArray(target[propName], target[propName], additiveValue, 1);
      }
    };
    return Track2;
  }();
  var Animator = function() {
    function Animator2(target, loop, allowDiscreteAnimation, additiveTo) {
      this._tracks = {};
      this._trackKeys = [];
      this._maxTime = 0;
      this._started = 0;
      this._clip = null;
      this._target = target;
      this._loop = loop;
      if (loop && additiveTo) {
        logError("Can' use additive animation on looped animation.");
        return;
      }
      this._additiveAnimators = additiveTo;
      this._allowDiscrete = allowDiscreteAnimation;
    }
    Animator2.prototype.getMaxTime = function() {
      return this._maxTime;
    };
    Animator2.prototype.getDelay = function() {
      return this._delay;
    };
    Animator2.prototype.getLoop = function() {
      return this._loop;
    };
    Animator2.prototype.getTarget = function() {
      return this._target;
    };
    Animator2.prototype.changeTarget = function(target) {
      this._target = target;
    };
    Animator2.prototype.when = function(time, props, easing) {
      return this.whenWithKeys(time, props, keys(props), easing);
    };
    Animator2.prototype.whenWithKeys = function(time, props, propNames, easing) {
      var tracks = this._tracks;
      for (var i = 0; i < propNames.length; i++) {
        var propName = propNames[i];
        var track = tracks[propName];
        if (!track) {
          track = tracks[propName] = new Track(propName);
          var initialValue = void 0;
          var additiveTrack = this._getAdditiveTrack(propName);
          if (additiveTrack) {
            var addtiveTrackKfs = additiveTrack.keyframes;
            var lastFinalKf = addtiveTrackKfs[addtiveTrackKfs.length - 1];
            initialValue = lastFinalKf && lastFinalKf.value;
            if (additiveTrack.valType === VALUE_TYPE_COLOR && initialValue) {
              initialValue = rgba2String(initialValue);
            }
          } else {
            initialValue = this._target[propName];
          }
          if (initialValue == null) {
            continue;
          }
          if (time > 0) {
            track.addKeyframe(0, cloneValue(initialValue), easing);
          }
          this._trackKeys.push(propName);
        }
        track.addKeyframe(time, cloneValue(props[propName]), easing);
      }
      this._maxTime = Math.max(this._maxTime, time);
      return this;
    };
    Animator2.prototype.pause = function() {
      this._clip.pause();
      this._paused = true;
    };
    Animator2.prototype.resume = function() {
      this._clip.resume();
      this._paused = false;
    };
    Animator2.prototype.isPaused = function() {
      return !!this._paused;
    };
    Animator2.prototype.duration = function(duration) {
      this._maxTime = duration;
      this._force = true;
      return this;
    };
    Animator2.prototype._doneCallback = function() {
      this._setTracksFinished();
      this._clip = null;
      var doneList = this._doneCbs;
      if (doneList) {
        var len2 = doneList.length;
        for (var i = 0; i < len2; i++) {
          doneList[i].call(this);
        }
      }
    };
    Animator2.prototype._abortedCallback = function() {
      this._setTracksFinished();
      var animation = this.animation;
      var abortedList = this._abortedCbs;
      if (animation) {
        animation.removeClip(this._clip);
      }
      this._clip = null;
      if (abortedList) {
        for (var i = 0; i < abortedList.length; i++) {
          abortedList[i].call(this);
        }
      }
    };
    Animator2.prototype._setTracksFinished = function() {
      var tracks = this._tracks;
      var tracksKeys = this._trackKeys;
      for (var i = 0; i < tracksKeys.length; i++) {
        tracks[tracksKeys[i]].setFinished();
      }
    };
    Animator2.prototype._getAdditiveTrack = function(trackName) {
      var additiveTrack;
      var additiveAnimators = this._additiveAnimators;
      if (additiveAnimators) {
        for (var i = 0; i < additiveAnimators.length; i++) {
          var track = additiveAnimators[i].getTrack(trackName);
          if (track) {
            additiveTrack = track;
          }
        }
      }
      return additiveTrack;
    };
    Animator2.prototype.start = function(easing) {
      if (this._started > 0) {
        return;
      }
      this._started = 1;
      var self2 = this;
      var tracks = [];
      var maxTime = this._maxTime || 0;
      for (var i = 0; i < this._trackKeys.length; i++) {
        var propName = this._trackKeys[i];
        var track = this._tracks[propName];
        var additiveTrack = this._getAdditiveTrack(propName);
        var kfs = track.keyframes;
        var kfsNum = kfs.length;
        track.prepare(maxTime, additiveTrack);
        if (track.needsAnimate()) {
          if (!this._allowDiscrete && track.discrete) {
            var lastKf = kfs[kfsNum - 1];
            if (lastKf) {
              self2._target[track.propName] = lastKf.rawValue;
            }
            track.setFinished();
          } else {
            tracks.push(track);
          }
        }
      }
      if (tracks.length || this._force) {
        var clip2 = new Clip_default({
          life: maxTime,
          loop: this._loop,
          delay: this._delay || 0,
          onframe: function(percent) {
            self2._started = 2;
            var additiveAnimators = self2._additiveAnimators;
            if (additiveAnimators) {
              var stillHasAdditiveAnimator = false;
              for (var i2 = 0; i2 < additiveAnimators.length; i2++) {
                if (additiveAnimators[i2]._clip) {
                  stillHasAdditiveAnimator = true;
                  break;
                }
              }
              if (!stillHasAdditiveAnimator) {
                self2._additiveAnimators = null;
              }
            }
            for (var i2 = 0; i2 < tracks.length; i2++) {
              tracks[i2].step(self2._target, percent);
            }
            var onframeList = self2._onframeCbs;
            if (onframeList) {
              for (var i2 = 0; i2 < onframeList.length; i2++) {
                onframeList[i2](self2._target, percent);
              }
            }
          },
          ondestroy: function() {
            self2._doneCallback();
          }
        });
        this._clip = clip2;
        if (this.animation) {
          this.animation.addClip(clip2);
        }
        if (easing) {
          clip2.setEasing(easing);
        }
      } else {
        this._doneCallback();
      }
      return this;
    };
    Animator2.prototype.stop = function(forwardToLast) {
      if (!this._clip) {
        return;
      }
      var clip2 = this._clip;
      if (forwardToLast) {
        clip2.onframe(1);
      }
      this._abortedCallback();
    };
    Animator2.prototype.delay = function(time) {
      this._delay = time;
      return this;
    };
    Animator2.prototype.during = function(cb) {
      if (cb) {
        if (!this._onframeCbs) {
          this._onframeCbs = [];
        }
        this._onframeCbs.push(cb);
      }
      return this;
    };
    Animator2.prototype.done = function(cb) {
      if (cb) {
        if (!this._doneCbs) {
          this._doneCbs = [];
        }
        this._doneCbs.push(cb);
      }
      return this;
    };
    Animator2.prototype.aborted = function(cb) {
      if (cb) {
        if (!this._abortedCbs) {
          this._abortedCbs = [];
        }
        this._abortedCbs.push(cb);
      }
      return this;
    };
    Animator2.prototype.getClip = function() {
      return this._clip;
    };
    Animator2.prototype.getTrack = function(propName) {
      return this._tracks[propName];
    };
    Animator2.prototype.getTracks = function() {
      var _this = this;
      return map(this._trackKeys, function(key) {
        return _this._tracks[key];
      });
    };
    Animator2.prototype.stopTracks = function(propNames, forwardToLast) {
      if (!propNames.length || !this._clip) {
        return true;
      }
      var tracks = this._tracks;
      var tracksKeys = this._trackKeys;
      for (var i = 0; i < propNames.length; i++) {
        var track = tracks[propNames[i]];
        if (track && !track.isFinished()) {
          if (forwardToLast) {
            track.step(this._target, 1);
          } else if (this._started === 1) {
            track.step(this._target, 0);
          }
          track.setFinished();
        }
      }
      var allAborted = true;
      for (var i = 0; i < tracksKeys.length; i++) {
        if (!tracks[tracksKeys[i]].isFinished()) {
          allAborted = false;
          break;
        }
      }
      if (allAborted) {
        this._abortedCallback();
      }
      return allAborted;
    };
    Animator2.prototype.saveTo = function(target, trackKeys, firstOrLast) {
      if (!target) {
        return;
      }
      trackKeys = trackKeys || this._trackKeys;
      for (var i = 0; i < trackKeys.length; i++) {
        var propName = trackKeys[i];
        var track = this._tracks[propName];
        if (!track || track.isFinished()) {
          continue;
        }
        var kfs = track.keyframes;
        var kf = kfs[firstOrLast ? 0 : kfs.length - 1];
        if (kf) {
          target[propName] = cloneValue(kf.rawValue);
        }
      }
    };
    Animator2.prototype.__changeFinalValue = function(finalProps, trackKeys) {
      trackKeys = trackKeys || keys(finalProps);
      for (var i = 0; i < trackKeys.length; i++) {
        var propName = trackKeys[i];
        var track = this._tracks[propName];
        if (!track) {
          continue;
        }
        var kfs = track.keyframes;
        if (kfs.length > 1) {
          var lastKf = kfs.pop();
          track.addKeyframe(lastKf.time, finalProps[propName]);
          track.prepare(this._maxTime, track.getAdditiveTrack());
        }
      }
    };
    return Animator2;
  }();
  var Animator_default = Animator;

  // node_modules/zrender/lib/animation/Animation.js
  function getTime() {
    return new Date().getTime();
  }
  var Animation = function(_super) {
    __extends2(Animation2, _super);
    function Animation2(opts) {
      var _this = _super.call(this) || this;
      _this._running = false;
      _this._time = 0;
      _this._pausedTime = 0;
      _this._pauseStart = 0;
      _this._paused = false;
      opts = opts || {};
      _this.stage = opts.stage || {};
      return _this;
    }
    Animation2.prototype.addClip = function(clip2) {
      if (clip2.animation) {
        this.removeClip(clip2);
      }
      if (!this._head) {
        this._head = this._tail = clip2;
      } else {
        this._tail.next = clip2;
        clip2.prev = this._tail;
        clip2.next = null;
        this._tail = clip2;
      }
      clip2.animation = this;
    };
    Animation2.prototype.addAnimator = function(animator) {
      animator.animation = this;
      var clip2 = animator.getClip();
      if (clip2) {
        this.addClip(clip2);
      }
    };
    Animation2.prototype.removeClip = function(clip2) {
      if (!clip2.animation) {
        return;
      }
      var prev = clip2.prev;
      var next = clip2.next;
      if (prev) {
        prev.next = next;
      } else {
        this._head = next;
      }
      if (next) {
        next.prev = prev;
      } else {
        this._tail = prev;
      }
      clip2.next = clip2.prev = clip2.animation = null;
    };
    Animation2.prototype.removeAnimator = function(animator) {
      var clip2 = animator.getClip();
      if (clip2) {
        this.removeClip(clip2);
      }
      animator.animation = null;
    };
    Animation2.prototype.update = function(notTriggerFrameAndStageUpdate) {
      var time = getTime() - this._pausedTime;
      var delta = time - this._time;
      var clip2 = this._head;
      while (clip2) {
        var nextClip = clip2.next;
        var finished = clip2.step(time, delta);
        if (finished) {
          clip2.ondestroy();
          this.removeClip(clip2);
          clip2 = nextClip;
        } else {
          clip2 = nextClip;
        }
      }
      this._time = time;
      if (!notTriggerFrameAndStageUpdate) {
        this.trigger("frame", delta);
        this.stage.update && this.stage.update();
      }
    };
    Animation2.prototype._startLoop = function() {
      var self2 = this;
      this._running = true;
      function step() {
        if (self2._running) {
          requestAnimationFrame_default(step);
          !self2._paused && self2.update();
        }
      }
      requestAnimationFrame_default(step);
    };
    Animation2.prototype.start = function() {
      if (this._running) {
        return;
      }
      this._time = getTime();
      this._pausedTime = 0;
      this._startLoop();
    };
    Animation2.prototype.stop = function() {
      this._running = false;
    };
    Animation2.prototype.pause = function() {
      if (!this._paused) {
        this._pauseStart = getTime();
        this._paused = true;
      }
    };
    Animation2.prototype.resume = function() {
      if (this._paused) {
        this._pausedTime += getTime() - this._pauseStart;
        this._paused = false;
      }
    };
    Animation2.prototype.clear = function() {
      var clip2 = this._head;
      while (clip2) {
        var nextClip = clip2.next;
        clip2.prev = clip2.next = clip2.animation = null;
        clip2 = nextClip;
      }
      this._head = this._tail = null;
    };
    Animation2.prototype.isFinished = function() {
      return this._head == null;
    };
    Animation2.prototype.animate = function(target, options) {
      options = options || {};
      this.start();
      var animator = new Animator_default(target, options.loop);
      this.addAnimator(animator);
      return animator;
    };
    return Animation2;
  }(Eventful_default);
  var Animation_default = Animation;

  // node_modules/zrender/lib/dom/HandlerProxy.js
  var TOUCH_CLICK_DELAY = 300;
  var globalEventSupported = env_default.domSupported;
  var localNativeListenerNames = function() {
    var mouseHandlerNames = [
      "click",
      "dblclick",
      "mousewheel",
      "wheel",
      "mouseout",
      "mouseup",
      "mousedown",
      "mousemove",
      "contextmenu"
    ];
    var touchHandlerNames = [
      "touchstart",
      "touchend",
      "touchmove"
    ];
    var pointerEventNameMap = {
      pointerdown: 1,
      pointerup: 1,
      pointermove: 1,
      pointerout: 1
    };
    var pointerHandlerNames = map(mouseHandlerNames, function(name) {
      var nm = name.replace("mouse", "pointer");
      return pointerEventNameMap.hasOwnProperty(nm) ? nm : name;
    });
    return {
      mouse: mouseHandlerNames,
      touch: touchHandlerNames,
      pointer: pointerHandlerNames
    };
  }();
  var globalNativeListenerNames = {
    mouse: ["mousemove", "mouseup"],
    pointer: ["pointermove", "pointerup"]
  };
  var wheelEventSupported = false;
  function isPointerFromTouch(event) {
    var pointerType = event.pointerType;
    return pointerType === "pen" || pointerType === "touch";
  }
  function setTouchTimer(scope) {
    scope.touching = true;
    if (scope.touchTimer != null) {
      clearTimeout(scope.touchTimer);
      scope.touchTimer = null;
    }
    scope.touchTimer = setTimeout(function() {
      scope.touching = false;
      scope.touchTimer = null;
    }, 700);
  }
  function markTouch(event) {
    event && (event.zrByTouch = true);
  }
  function normalizeGlobalEvent(instance, event) {
    return normalizeEvent(instance.dom, new FakeGlobalEvent(instance, event), true);
  }
  function isLocalEl(instance, el) {
    var elTmp = el;
    var isLocal = false;
    while (elTmp && elTmp.nodeType !== 9 && !(isLocal = elTmp.domBelongToZr || elTmp !== el && elTmp === instance.painterRoot)) {
      elTmp = elTmp.parentNode;
    }
    return isLocal;
  }
  var FakeGlobalEvent = function() {
    function FakeGlobalEvent2(instance, event) {
      this.stopPropagation = noop;
      this.stopImmediatePropagation = noop;
      this.preventDefault = noop;
      this.type = event.type;
      this.target = this.currentTarget = instance.dom;
      this.pointerType = event.pointerType;
      this.clientX = event.clientX;
      this.clientY = event.clientY;
    }
    return FakeGlobalEvent2;
  }();
  var localDOMHandlers = {
    mousedown: function(event) {
      event = normalizeEvent(this.dom, event);
      this.__mayPointerCapture = [event.zrX, event.zrY];
      this.trigger("mousedown", event);
    },
    mousemove: function(event) {
      event = normalizeEvent(this.dom, event);
      var downPoint = this.__mayPointerCapture;
      if (downPoint && (event.zrX !== downPoint[0] || event.zrY !== downPoint[1])) {
        this.__togglePointerCapture(true);
      }
      this.trigger("mousemove", event);
    },
    mouseup: function(event) {
      event = normalizeEvent(this.dom, event);
      this.__togglePointerCapture(false);
      this.trigger("mouseup", event);
    },
    mouseout: function(event) {
      event = normalizeEvent(this.dom, event);
      var element = event.toElement || event.relatedTarget;
      if (!isLocalEl(this, element)) {
        if (this.__pointerCapturing) {
          event.zrEventControl = "no_globalout";
        }
        this.trigger("mouseout", event);
      }
    },
    wheel: function(event) {
      wheelEventSupported = true;
      event = normalizeEvent(this.dom, event);
      this.trigger("mousewheel", event);
    },
    mousewheel: function(event) {
      if (wheelEventSupported) {
        return;
      }
      event = normalizeEvent(this.dom, event);
      this.trigger("mousewheel", event);
    },
    touchstart: function(event) {
      event = normalizeEvent(this.dom, event);
      markTouch(event);
      this.__lastTouchMoment = new Date();
      this.handler.processGesture(event, "start");
      localDOMHandlers.mousemove.call(this, event);
      localDOMHandlers.mousedown.call(this, event);
    },
    touchmove: function(event) {
      event = normalizeEvent(this.dom, event);
      markTouch(event);
      this.handler.processGesture(event, "change");
      localDOMHandlers.mousemove.call(this, event);
    },
    touchend: function(event) {
      event = normalizeEvent(this.dom, event);
      markTouch(event);
      this.handler.processGesture(event, "end");
      localDOMHandlers.mouseup.call(this, event);
      if (+new Date() - +this.__lastTouchMoment < TOUCH_CLICK_DELAY) {
        localDOMHandlers.click.call(this, event);
      }
    },
    pointerdown: function(event) {
      localDOMHandlers.mousedown.call(this, event);
    },
    pointermove: function(event) {
      if (!isPointerFromTouch(event)) {
        localDOMHandlers.mousemove.call(this, event);
      }
    },
    pointerup: function(event) {
      localDOMHandlers.mouseup.call(this, event);
    },
    pointerout: function(event) {
      if (!isPointerFromTouch(event)) {
        localDOMHandlers.mouseout.call(this, event);
      }
    }
  };
  each(["click", "dblclick", "contextmenu"], function(name) {
    localDOMHandlers[name] = function(event) {
      event = normalizeEvent(this.dom, event);
      this.trigger(name, event);
    };
  });
  var globalDOMHandlers = {
    pointermove: function(event) {
      if (!isPointerFromTouch(event)) {
        globalDOMHandlers.mousemove.call(this, event);
      }
    },
    pointerup: function(event) {
      globalDOMHandlers.mouseup.call(this, event);
    },
    mousemove: function(event) {
      this.trigger("mousemove", event);
    },
    mouseup: function(event) {
      var pointerCaptureReleasing = this.__pointerCapturing;
      this.__togglePointerCapture(false);
      this.trigger("mouseup", event);
      if (pointerCaptureReleasing) {
        event.zrEventControl = "only_globalout";
        this.trigger("mouseout", event);
      }
    }
  };
  function mountLocalDOMEventListeners(instance, scope) {
    var domHandlers = scope.domHandlers;
    if (env_default.pointerEventsSupported) {
      each(localNativeListenerNames.pointer, function(nativeEventName) {
        mountSingleDOMEventListener(scope, nativeEventName, function(event) {
          domHandlers[nativeEventName].call(instance, event);
        });
      });
    } else {
      if (env_default.touchEventsSupported) {
        each(localNativeListenerNames.touch, function(nativeEventName) {
          mountSingleDOMEventListener(scope, nativeEventName, function(event) {
            domHandlers[nativeEventName].call(instance, event);
            setTouchTimer(scope);
          });
        });
      }
      each(localNativeListenerNames.mouse, function(nativeEventName) {
        mountSingleDOMEventListener(scope, nativeEventName, function(event) {
          event = getNativeEvent(event);
          if (!scope.touching) {
            domHandlers[nativeEventName].call(instance, event);
          }
        });
      });
    }
  }
  function mountGlobalDOMEventListeners(instance, scope) {
    if (env_default.pointerEventsSupported) {
      each(globalNativeListenerNames.pointer, mount);
    } else if (!env_default.touchEventsSupported) {
      each(globalNativeListenerNames.mouse, mount);
    }
    function mount(nativeEventName) {
      function nativeEventListener(event) {
        event = getNativeEvent(event);
        if (!isLocalEl(instance, event.target)) {
          event = normalizeGlobalEvent(instance, event);
          scope.domHandlers[nativeEventName].call(instance, event);
        }
      }
      mountSingleDOMEventListener(scope, nativeEventName, nativeEventListener, { capture: true });
    }
  }
  function mountSingleDOMEventListener(scope, nativeEventName, listener, opt) {
    scope.mounted[nativeEventName] = listener;
    scope.listenerOpts[nativeEventName] = opt;
    addEventListener(scope.domTarget, nativeEventName, listener, opt);
  }
  function unmountDOMEventListeners(scope) {
    var mounted = scope.mounted;
    for (var nativeEventName in mounted) {
      if (mounted.hasOwnProperty(nativeEventName)) {
        removeEventListener(scope.domTarget, nativeEventName, mounted[nativeEventName], scope.listenerOpts[nativeEventName]);
      }
    }
    scope.mounted = {};
  }
  var DOMHandlerScope = function() {
    function DOMHandlerScope2(domTarget, domHandlers) {
      this.mounted = {};
      this.listenerOpts = {};
      this.touching = false;
      this.domTarget = domTarget;
      this.domHandlers = domHandlers;
    }
    return DOMHandlerScope2;
  }();
  var HandlerDomProxy = function(_super) {
    __extends2(HandlerDomProxy2, _super);
    function HandlerDomProxy2(dom, painterRoot) {
      var _this = _super.call(this) || this;
      _this.__pointerCapturing = false;
      _this.dom = dom;
      _this.painterRoot = painterRoot;
      _this._localHandlerScope = new DOMHandlerScope(dom, localDOMHandlers);
      if (globalEventSupported) {
        _this._globalHandlerScope = new DOMHandlerScope(document, globalDOMHandlers);
      }
      mountLocalDOMEventListeners(_this, _this._localHandlerScope);
      return _this;
    }
    HandlerDomProxy2.prototype.dispose = function() {
      unmountDOMEventListeners(this._localHandlerScope);
      if (globalEventSupported) {
        unmountDOMEventListeners(this._globalHandlerScope);
      }
    };
    HandlerDomProxy2.prototype.setCursor = function(cursorStyle) {
      this.dom.style && (this.dom.style.cursor = cursorStyle || "default");
    };
    HandlerDomProxy2.prototype.__togglePointerCapture = function(isPointerCapturing) {
      this.__mayPointerCapture = null;
      if (globalEventSupported && +this.__pointerCapturing ^ +isPointerCapturing) {
        this.__pointerCapturing = isPointerCapturing;
        var globalHandlerScope = this._globalHandlerScope;
        isPointerCapturing ? mountGlobalDOMEventListeners(this, globalHandlerScope) : unmountDOMEventListeners(globalHandlerScope);
      }
    };
    return HandlerDomProxy2;
  }(Eventful_default);
  var HandlerProxy_default = HandlerDomProxy;

  // node_modules/zrender/lib/config.js
  var dpr = 1;
  if (env_default.hasGlobalWindow) {
    dpr = Math.max(window.devicePixelRatio || window.screen && window.screen.deviceXDPI / window.screen.logicalXDPI || 1, 1);
  }
  var devicePixelRatio = dpr;
  var DARK_MODE_THRESHOLD = 0.4;
  var DARK_LABEL_COLOR = "#333";
  var LIGHT_LABEL_COLOR = "#ccc";
  var LIGHTER_LABEL_COLOR = "#eee";

  // node_modules/zrender/lib/core/matrix.js
  var matrix_exports = {};
  __export(matrix_exports, {
    clone: () => clone3,
    copy: () => copy2,
    create: () => create2,
    identity: () => identity,
    invert: () => invert,
    mul: () => mul2,
    rotate: () => rotate,
    scale: () => scale2,
    translate: () => translate
  });
  function create2() {
    return [1, 0, 0, 1, 0, 0];
  }
  function identity(out2) {
    out2[0] = 1;
    out2[1] = 0;
    out2[2] = 0;
    out2[3] = 1;
    out2[4] = 0;
    out2[5] = 0;
    return out2;
  }
  function copy2(out2, m2) {
    out2[0] = m2[0];
    out2[1] = m2[1];
    out2[2] = m2[2];
    out2[3] = m2[3];
    out2[4] = m2[4];
    out2[5] = m2[5];
    return out2;
  }
  function mul2(out2, m1, m2) {
    var out0 = m1[0] * m2[0] + m1[2] * m2[1];
    var out1 = m1[1] * m2[0] + m1[3] * m2[1];
    var out22 = m1[0] * m2[2] + m1[2] * m2[3];
    var out3 = m1[1] * m2[2] + m1[3] * m2[3];
    var out4 = m1[0] * m2[4] + m1[2] * m2[5] + m1[4];
    var out5 = m1[1] * m2[4] + m1[3] * m2[5] + m1[5];
    out2[0] = out0;
    out2[1] = out1;
    out2[2] = out22;
    out2[3] = out3;
    out2[4] = out4;
    out2[5] = out5;
    return out2;
  }
  function translate(out2, a, v) {
    out2[0] = a[0];
    out2[1] = a[1];
    out2[2] = a[2];
    out2[3] = a[3];
    out2[4] = a[4] + v[0];
    out2[5] = a[5] + v[1];
    return out2;
  }
  function rotate(out2, a, rad) {
    var aa = a[0];
    var ac = a[2];
    var atx = a[4];
    var ab = a[1];
    var ad = a[3];
    var aty = a[5];
    var st = Math.sin(rad);
    var ct = Math.cos(rad);
    out2[0] = aa * ct + ab * st;
    out2[1] = -aa * st + ab * ct;
    out2[2] = ac * ct + ad * st;
    out2[3] = -ac * st + ct * ad;
    out2[4] = ct * atx + st * aty;
    out2[5] = ct * aty - st * atx;
    return out2;
  }
  function scale2(out2, a, v) {
    var vx = v[0];
    var vy = v[1];
    out2[0] = a[0] * vx;
    out2[1] = a[1] * vy;
    out2[2] = a[2] * vx;
    out2[3] = a[3] * vy;
    out2[4] = a[4] * vx;
    out2[5] = a[5] * vy;
    return out2;
  }
  function invert(out2, a) {
    var aa = a[0];
    var ac = a[2];
    var atx = a[4];
    var ab = a[1];
    var ad = a[3];
    var aty = a[5];
    var det = aa * ad - ab * ac;
    if (!det) {
      return null;
    }
    det = 1 / det;
    out2[0] = ad * det;
    out2[1] = -ab * det;
    out2[2] = -ac * det;
    out2[3] = aa * det;
    out2[4] = (ac * aty - ad * atx) * det;
    out2[5] = (ab * atx - aa * aty) * det;
    return out2;
  }
  function clone3(a) {
    var b = create2();
    copy2(b, a);
    return b;
  }

  // node_modules/zrender/lib/core/Transformable.js
  var mIdentity = identity;
  var EPSILON3 = 5e-5;
  function isNotAroundZero2(val) {
    return val > EPSILON3 || val < -EPSILON3;
  }
  var scaleTmp = [];
  var tmpTransform = [];
  var originTransform = create2();
  var abs = Math.abs;
  var Transformable = function() {
    function Transformable2() {
    }
    Transformable2.prototype.getLocalTransform = function(m2) {
      return Transformable2.getLocalTransform(this, m2);
    };
    Transformable2.prototype.setPosition = function(arr) {
      this.x = arr[0];
      this.y = arr[1];
    };
    Transformable2.prototype.setScale = function(arr) {
      this.scaleX = arr[0];
      this.scaleY = arr[1];
    };
    Transformable2.prototype.setSkew = function(arr) {
      this.skewX = arr[0];
      this.skewY = arr[1];
    };
    Transformable2.prototype.setOrigin = function(arr) {
      this.originX = arr[0];
      this.originY = arr[1];
    };
    Transformable2.prototype.needLocalTransform = function() {
      return isNotAroundZero2(this.rotation) || isNotAroundZero2(this.x) || isNotAroundZero2(this.y) || isNotAroundZero2(this.scaleX - 1) || isNotAroundZero2(this.scaleY - 1) || isNotAroundZero2(this.skewX) || isNotAroundZero2(this.skewY);
    };
    Transformable2.prototype.updateTransform = function() {
      var parentTransform = this.parent && this.parent.transform;
      var needLocalTransform = this.needLocalTransform();
      var m2 = this.transform;
      if (!(needLocalTransform || parentTransform)) {
        m2 && mIdentity(m2);
        return;
      }
      m2 = m2 || create2();
      if (needLocalTransform) {
        this.getLocalTransform(m2);
      } else {
        mIdentity(m2);
      }
      if (parentTransform) {
        if (needLocalTransform) {
          mul2(m2, parentTransform, m2);
        } else {
          copy2(m2, parentTransform);
        }
      }
      this.transform = m2;
      this._resolveGlobalScaleRatio(m2);
    };
    Transformable2.prototype._resolveGlobalScaleRatio = function(m2) {
      var globalScaleRatio = this.globalScaleRatio;
      if (globalScaleRatio != null && globalScaleRatio !== 1) {
        this.getGlobalScale(scaleTmp);
        var relX = scaleTmp[0] < 0 ? -1 : 1;
        var relY = scaleTmp[1] < 0 ? -1 : 1;
        var sx = ((scaleTmp[0] - relX) * globalScaleRatio + relX) / scaleTmp[0] || 0;
        var sy = ((scaleTmp[1] - relY) * globalScaleRatio + relY) / scaleTmp[1] || 0;
        m2[0] *= sx;
        m2[1] *= sx;
        m2[2] *= sy;
        m2[3] *= sy;
      }
      this.invTransform = this.invTransform || create2();
      invert(this.invTransform, m2);
    };
    Transformable2.prototype.getComputedTransform = function() {
      var transformNode = this;
      var ancestors = [];
      while (transformNode) {
        ancestors.push(transformNode);
        transformNode = transformNode.parent;
      }
      while (transformNode = ancestors.pop()) {
        transformNode.updateTransform();
      }
      return this.transform;
    };
    Transformable2.prototype.setLocalTransform = function(m2) {
      if (!m2) {
        return;
      }
      var sx = m2[0] * m2[0] + m2[1] * m2[1];
      var sy = m2[2] * m2[2] + m2[3] * m2[3];
      var rotation = Math.atan2(m2[1], m2[0]);
      var shearX = Math.PI / 2 + rotation - Math.atan2(m2[3], m2[2]);
      sy = Math.sqrt(sy) * Math.cos(shearX);
      sx = Math.sqrt(sx);
      this.skewX = shearX;
      this.skewY = 0;
      this.rotation = -rotation;
      this.x = +m2[4];
      this.y = +m2[5];
      this.scaleX = sx;
      this.scaleY = sy;
      this.originX = 0;
      this.originY = 0;
    };
    Transformable2.prototype.decomposeTransform = function() {
      if (!this.transform) {
        return;
      }
      var parent = this.parent;
      var m2 = this.transform;
      if (parent && parent.transform) {
        mul2(tmpTransform, parent.invTransform, m2);
        m2 = tmpTransform;
      }
      var ox = this.originX;
      var oy = this.originY;
      if (ox || oy) {
        originTransform[4] = ox;
        originTransform[5] = oy;
        mul2(tmpTransform, m2, originTransform);
        tmpTransform[4] -= ox;
        tmpTransform[5] -= oy;
        m2 = tmpTransform;
      }
      this.setLocalTransform(m2);
    };
    Transformable2.prototype.getGlobalScale = function(out2) {
      var m2 = this.transform;
      out2 = out2 || [];
      if (!m2) {
        out2[0] = 1;
        out2[1] = 1;
        return out2;
      }
      out2[0] = Math.sqrt(m2[0] * m2[0] + m2[1] * m2[1]);
      out2[1] = Math.sqrt(m2[2] * m2[2] + m2[3] * m2[3]);
      if (m2[0] < 0) {
        out2[0] = -out2[0];
      }
      if (m2[3] < 0) {
        out2[1] = -out2[1];
      }
      return out2;
    };
    Transformable2.prototype.transformCoordToLocal = function(x, y) {
      var v22 = [x, y];
      var invTransform = this.invTransform;
      if (invTransform) {
        applyTransform(v22, v22, invTransform);
      }
      return v22;
    };
    Transformable2.prototype.transformCoordToGlobal = function(x, y) {
      var v22 = [x, y];
      var transform2 = this.transform;
      if (transform2) {
        applyTransform(v22, v22, transform2);
      }
      return v22;
    };
    Transformable2.prototype.getLineScale = function() {
      var m2 = this.transform;
      return m2 && abs(m2[0] - 1) > 1e-10 && abs(m2[3] - 1) > 1e-10 ? Math.sqrt(abs(m2[0] * m2[3] - m2[2] * m2[1])) : 1;
    };
    Transformable2.prototype.copyTransform = function(source) {
      copyTransform(this, source);
    };
    Transformable2.getLocalTransform = function(target, m2) {
      m2 = m2 || [];
      var ox = target.originX || 0;
      var oy = target.originY || 0;
      var sx = target.scaleX;
      var sy = target.scaleY;
      var ax = target.anchorX;
      var ay = target.anchorY;
      var rotation = target.rotation || 0;
      var x = target.x;
      var y = target.y;
      var skewX = target.skewX ? Math.tan(target.skewX) : 0;
      var skewY = target.skewY ? Math.tan(-target.skewY) : 0;
      if (ox || oy || ax || ay) {
        var dx = ox + ax;
        var dy = oy + ay;
        m2[4] = -dx * sx - skewX * dy * sy;
        m2[5] = -dy * sy - skewY * dx * sx;
      } else {
        m2[4] = m2[5] = 0;
      }
      m2[0] = sx;
      m2[3] = sy;
      m2[1] = skewY * sx;
      m2[2] = skewX * sy;
      rotation && rotate(m2, m2, rotation);
      m2[4] += ox + x;
      m2[5] += oy + y;
      return m2;
    };
    Transformable2.initDefaultProps = function() {
      var proto2 = Transformable2.prototype;
      proto2.scaleX = proto2.scaleY = proto2.globalScaleRatio = 1;
      proto2.x = proto2.y = proto2.originX = proto2.originY = proto2.skewX = proto2.skewY = proto2.rotation = proto2.anchorX = proto2.anchorY = 0;
    }();
    return Transformable2;
  }();
  var TRANSFORMABLE_PROPS = [
    "x",
    "y",
    "originX",
    "originY",
    "anchorX",
    "anchorY",
    "rotation",
    "scaleX",
    "scaleY",
    "skewX",
    "skewY"
  ];
  function copyTransform(target, source) {
    for (var i = 0; i < TRANSFORMABLE_PROPS.length; i++) {
      var propName = TRANSFORMABLE_PROPS[i];
      target[propName] = source[propName];
    }
  }
  var Transformable_default = Transformable;

  // node_modules/zrender/lib/core/Point.js
  var Point = function() {
    function Point2(x, y) {
      this.x = x || 0;
      this.y = y || 0;
    }
    Point2.prototype.copy = function(other) {
      this.x = other.x;
      this.y = other.y;
      return this;
    };
    Point2.prototype.clone = function() {
      return new Point2(this.x, this.y);
    };
    Point2.prototype.set = function(x, y) {
      this.x = x;
      this.y = y;
      return this;
    };
    Point2.prototype.equal = function(other) {
      return other.x === this.x && other.y === this.y;
    };
    Point2.prototype.add = function(other) {
      this.x += other.x;
      this.y += other.y;
      return this;
    };
    Point2.prototype.scale = function(scalar) {
      this.x *= scalar;
      this.y *= scalar;
    };
    Point2.prototype.scaleAndAdd = function(other, scalar) {
      this.x += other.x * scalar;
      this.y += other.y * scalar;
    };
    Point2.prototype.sub = function(other) {
      this.x -= other.x;
      this.y -= other.y;
      return this;
    };
    Point2.prototype.dot = function(other) {
      return this.x * other.x + this.y * other.y;
    };
    Point2.prototype.len = function() {
      return Math.sqrt(this.x * this.x + this.y * this.y);
    };
    Point2.prototype.lenSquare = function() {
      return this.x * this.x + this.y * this.y;
    };
    Point2.prototype.normalize = function() {
      var len2 = this.len();
      this.x /= len2;
      this.y /= len2;
      return this;
    };
    Point2.prototype.distance = function(other) {
      var dx = this.x - other.x;
      var dy = this.y - other.y;
      return Math.sqrt(dx * dx + dy * dy);
    };
    Point2.prototype.distanceSquare = function(other) {
      var dx = this.x - other.x;
      var dy = this.y - other.y;
      return dx * dx + dy * dy;
    };
    Point2.prototype.negate = function() {
      this.x = -this.x;
      this.y = -this.y;
      return this;
    };
    Point2.prototype.transform = function(m2) {
      if (!m2) {
        return;
      }
      var x = this.x;
      var y = this.y;
      this.x = m2[0] * x + m2[2] * y + m2[4];
      this.y = m2[1] * x + m2[3] * y + m2[5];
      return this;
    };
    Point2.prototype.toArray = function(out2) {
      out2[0] = this.x;
      out2[1] = this.y;
      return out2;
    };
    Point2.prototype.fromArray = function(input) {
      this.x = input[0];
      this.y = input[1];
    };
    Point2.set = function(p, x, y) {
      p.x = x;
      p.y = y;
    };
    Point2.copy = function(p, p2) {
      p.x = p2.x;
      p.y = p2.y;
    };
    Point2.len = function(p) {
      return Math.sqrt(p.x * p.x + p.y * p.y);
    };
    Point2.lenSquare = function(p) {
      return p.x * p.x + p.y * p.y;
    };
    Point2.dot = function(p0, p1) {
      return p0.x * p1.x + p0.y * p1.y;
    };
    Point2.add = function(out2, p0, p1) {
      out2.x = p0.x + p1.x;
      out2.y = p0.y + p1.y;
    };
    Point2.sub = function(out2, p0, p1) {
      out2.x = p0.x - p1.x;
      out2.y = p0.y - p1.y;
    };
    Point2.scale = function(out2, p0, scalar) {
      out2.x = p0.x * scalar;
      out2.y = p0.y * scalar;
    };
    Point2.scaleAndAdd = function(out2, p0, p1, scalar) {
      out2.x = p0.x + p1.x * scalar;
      out2.y = p0.y + p1.y * scalar;
    };
    Point2.lerp = function(out2, p0, p1, t) {
      var onet = 1 - t;
      out2.x = onet * p0.x + t * p1.x;
      out2.y = onet * p0.y + t * p1.y;
    };
    return Point2;
  }();
  var Point_default = Point;

  // node_modules/zrender/lib/core/BoundingRect.js
  var mathMin = Math.min;
  var mathMax = Math.max;
  var lt = new Point_default();
  var rb = new Point_default();
  var lb = new Point_default();
  var rt = new Point_default();
  var minTv = new Point_default();
  var maxTv = new Point_default();
  var BoundingRect = function() {
    function BoundingRect2(x, y, width, height) {
      if (width < 0) {
        x = x + width;
        width = -width;
      }
      if (height < 0) {
        y = y + height;
        height = -height;
      }
      this.x = x;
      this.y = y;
      this.width = width;
      this.height = height;
    }
    BoundingRect2.prototype.union = function(other) {
      var x = mathMin(other.x, this.x);
      var y = mathMin(other.y, this.y);
      if (isFinite(this.x) && isFinite(this.width)) {
        this.width = mathMax(other.x + other.width, this.x + this.width) - x;
      } else {
        this.width = other.width;
      }
      if (isFinite(this.y) && isFinite(this.height)) {
        this.height = mathMax(other.y + other.height, this.y + this.height) - y;
      } else {
        this.height = other.height;
      }
      this.x = x;
      this.y = y;
    };
    BoundingRect2.prototype.applyTransform = function(m2) {
      BoundingRect2.applyTransform(this, this, m2);
    };
    BoundingRect2.prototype.calculateTransform = function(b) {
      var a = this;
      var sx = b.width / a.width;
      var sy = b.height / a.height;
      var m2 = create2();
      translate(m2, m2, [-a.x, -a.y]);
      scale2(m2, m2, [sx, sy]);
      translate(m2, m2, [b.x, b.y]);
      return m2;
    };
    BoundingRect2.prototype.intersect = function(b, mtv) {
      if (!b) {
        return false;
      }
      if (!(b instanceof BoundingRect2)) {
        b = BoundingRect2.create(b);
      }
      var a = this;
      var ax0 = a.x;
      var ax1 = a.x + a.width;
      var ay0 = a.y;
      var ay1 = a.y + a.height;
      var bx0 = b.x;
      var bx1 = b.x + b.width;
      var by0 = b.y;
      var by1 = b.y + b.height;
      var overlap = !(ax1 < bx0 || bx1 < ax0 || ay1 < by0 || by1 < ay0);
      if (mtv) {
        var dMin = Infinity;
        var dMax = 0;
        var d0 = Math.abs(ax1 - bx0);
        var d1 = Math.abs(bx1 - ax0);
        var d2 = Math.abs(ay1 - by0);
        var d3 = Math.abs(by1 - ay0);
        var dx = Math.min(d0, d1);
        var dy = Math.min(d2, d3);
        if (ax1 < bx0 || bx1 < ax0) {
          if (dx > dMax) {
            dMax = dx;
            if (d0 < d1) {
              Point_default.set(maxTv, -d0, 0);
            } else {
              Point_default.set(maxTv, d1, 0);
            }
          }
        } else {
          if (dx < dMin) {
            dMin = dx;
            if (d0 < d1) {
              Point_default.set(minTv, d0, 0);
            } else {
              Point_default.set(minTv, -d1, 0);
            }
          }
        }
        if (ay1 < by0 || by1 < ay0) {
          if (dy > dMax) {
            dMax = dy;
            if (d2 < d3) {
              Point_default.set(maxTv, 0, -d2);
            } else {
              Point_default.set(maxTv, 0, d3);
            }
          }
        } else {
          if (dx < dMin) {
            dMin = dx;
            if (d2 < d3) {
              Point_default.set(minTv, 0, d2);
            } else {
              Point_default.set(minTv, 0, -d3);
            }
          }
        }
      }
      if (mtv) {
        Point_default.copy(mtv, overlap ? minTv : maxTv);
      }
      return overlap;
    };
    BoundingRect2.prototype.contain = function(x, y) {
      var rect = this;
      return x >= rect.x && x <= rect.x + rect.width && y >= rect.y && y <= rect.y + rect.height;
    };
    BoundingRect2.prototype.clone = function() {
      return new BoundingRect2(this.x, this.y, this.width, this.height);
    };
    BoundingRect2.prototype.copy = function(other) {
      BoundingRect2.copy(this, other);
    };
    BoundingRect2.prototype.plain = function() {
      return {
        x: this.x,
        y: this.y,
        width: this.width,
        height: this.height
      };
    };
    BoundingRect2.prototype.isFinite = function() {
      return isFinite(this.x) && isFinite(this.y) && isFinite(this.width) && isFinite(this.height);
    };
    BoundingRect2.prototype.isZero = function() {
      return this.width === 0 || this.height === 0;
    };
    BoundingRect2.create = function(rect) {
      return new BoundingRect2(rect.x, rect.y, rect.width, rect.height);
    };
    BoundingRect2.copy = function(target, source) {
      target.x = source.x;
      target.y = source.y;
      target.width = source.width;
      target.height = source.height;
    };
    BoundingRect2.applyTransform = function(target, source, m2) {
      if (!m2) {
        if (target !== source) {
          BoundingRect2.copy(target, source);
        }
        return;
      }
      if (m2[1] < 1e-5 && m2[1] > -1e-5 && m2[2] < 1e-5 && m2[2] > -1e-5) {
        var sx = m2[0];
        var sy = m2[3];
        var tx = m2[4];
        var ty = m2[5];
        target.x = source.x * sx + tx;
        target.y = source.y * sy + ty;
        target.width = source.width * sx;
        target.height = source.height * sy;
        if (target.width < 0) {
          target.x += target.width;
          target.width = -target.width;
        }
        if (target.height < 0) {
          target.y += target.height;
          target.height = -target.height;
        }
        return;
      }
      lt.x = lb.x = source.x;
      lt.y = rt.y = source.y;
      rb.x = rt.x = source.x + source.width;
      rb.y = lb.y = source.y + source.height;
      lt.transform(m2);
      rt.transform(m2);
      rb.transform(m2);
      lb.transform(m2);
      target.x = mathMin(lt.x, rb.x, lb.x, rt.x);
      target.y = mathMin(lt.y, rb.y, lb.y, rt.y);
      var maxX = mathMax(lt.x, rb.x, lb.x, rt.x);
      var maxY = mathMax(lt.y, rb.y, lb.y, rt.y);
      target.width = maxX - target.x;
      target.height = maxY - target.y;
    };
    return BoundingRect2;
  }();
  var BoundingRect_default = BoundingRect;

  // node_modules/zrender/lib/contain/text.js
  var textWidthCache = {};
  function getWidth(text, font) {
    font = font || DEFAULT_FONT;
    var cacheOfFont = textWidthCache[font];
    if (!cacheOfFont) {
      cacheOfFont = textWidthCache[font] = new LRU_default(500);
    }
    var width = cacheOfFont.get(text);
    if (width == null) {
      width = platformApi.measureText(text, font).width;
      cacheOfFont.put(text, width);
    }
    return width;
  }
  function innerGetBoundingRect(text, font, textAlign, textBaseline) {
    var width = getWidth(text, font);
    var height = getLineHeight(font);
    var x = adjustTextX(0, width, textAlign);
    var y = adjustTextY2(0, height, textBaseline);
    var rect = new BoundingRect_default(x, y, width, height);
    return rect;
  }
  function getBoundingRect(text, font, textAlign, textBaseline) {
    var textLines = ((text || "") + "").split("\n");
    var len2 = textLines.length;
    if (len2 === 1) {
      return innerGetBoundingRect(textLines[0], font, textAlign, textBaseline);
    } else {
      var uniondRect = new BoundingRect_default(0, 0, 0, 0);
      for (var i = 0; i < textLines.length; i++) {
        var rect = innerGetBoundingRect(textLines[i], font, textAlign, textBaseline);
        i === 0 ? uniondRect.copy(rect) : uniondRect.union(rect);
      }
      return uniondRect;
    }
  }
  function adjustTextX(x, width, textAlign) {
    if (textAlign === "right") {
      x -= width;
    } else if (textAlign === "center") {
      x -= width / 2;
    }
    return x;
  }
  function adjustTextY2(y, height, verticalAlign) {
    if (verticalAlign === "middle") {
      y -= height / 2;
    } else if (verticalAlign === "bottom") {
      y -= height;
    }
    return y;
  }
  function getLineHeight(font) {
    return getWidth("国", font);
  }
  function parsePercent(value, maxValue) {
    if (typeof value === "string") {
      if (value.lastIndexOf("%") >= 0) {
        return parseFloat(value) / 100 * maxValue;
      }
      return parseFloat(value);
    }
    return value;
  }
  function calculateTextPosition(out2, opts, rect) {
    var textPosition = opts.position || "inside";
    var distance2 = opts.distance != null ? opts.distance : 5;
    var height = rect.height;
    var width = rect.width;
    var halfHeight = height / 2;
    var x = rect.x;
    var y = rect.y;
    var textAlign = "left";
    var textVerticalAlign = "top";
    if (textPosition instanceof Array) {
      x += parsePercent(textPosition[0], rect.width);
      y += parsePercent(textPosition[1], rect.height);
      textAlign = null;
      textVerticalAlign = null;
    } else {
      switch (textPosition) {
        case "left":
          x -= distance2;
          y += halfHeight;
          textAlign = "right";
          textVerticalAlign = "middle";
          break;
        case "right":
          x += distance2 + width;
          y += halfHeight;
          textVerticalAlign = "middle";
          break;
        case "top":
          x += width / 2;
          y -= distance2;
          textAlign = "center";
          textVerticalAlign = "bottom";
          break;
        case "bottom":
          x += width / 2;
          y += height + distance2;
          textAlign = "center";
          break;
        case "inside":
          x += width / 2;
          y += halfHeight;
          textAlign = "center";
          textVerticalAlign = "middle";
          break;
        case "insideLeft":
          x += distance2;
          y += halfHeight;
          textVerticalAlign = "middle";
          break;
        case "insideRight":
          x += width - distance2;
          y += halfHeight;
          textAlign = "right";
          textVerticalAlign = "middle";
          break;
        case "insideTop":
          x += width / 2;
          y += distance2;
          textAlign = "center";
          break;
        case "insideBottom":
          x += width / 2;
          y += height - distance2;
          textAlign = "center";
          textVerticalAlign = "bottom";
          break;
        case "insideTopLeft":
          x += distance2;
          y += distance2;
          break;
        case "insideTopRight":
          x += width - distance2;
          y += distance2;
          textAlign = "right";
          break;
        case "insideBottomLeft":
          x += distance2;
          y += height - distance2;
          textVerticalAlign = "bottom";
          break;
        case "insideBottomRight":
          x += width - distance2;
          y += height - distance2;
          textAlign = "right";
          textVerticalAlign = "bottom";
          break;
      }
    }
    out2 = out2 || {};
    out2.x = x;
    out2.y = y;
    out2.align = textAlign;
    out2.verticalAlign = textVerticalAlign;
    return out2;
  }

  // node_modules/zrender/lib/Element.js
  var PRESERVED_NORMAL_STATE = "__zr_normal__";
  var PRIMARY_STATES_KEYS = TRANSFORMABLE_PROPS.concat(["ignore"]);
  var DEFAULT_ANIMATABLE_MAP = reduce(TRANSFORMABLE_PROPS, function(obj, key) {
    obj[key] = true;
    return obj;
  }, { ignore: false });
  var tmpTextPosCalcRes = {};
  var tmpBoundingRect = new BoundingRect_default(0, 0, 0, 0);
  var Element2 = function() {
    function Element3(props) {
      this.id = guid();
      this.animators = [];
      this.currentStates = [];
      this.states = {};
      this._init(props);
    }
    Element3.prototype._init = function(props) {
      this.attr(props);
    };
    Element3.prototype.drift = function(dx, dy, e2) {
      switch (this.draggable) {
        case "horizontal":
          dy = 0;
          break;
        case "vertical":
          dx = 0;
          break;
      }
      var m2 = this.transform;
      if (!m2) {
        m2 = this.transform = [1, 0, 0, 1, 0, 0];
      }
      m2[4] += dx;
      m2[5] += dy;
      this.decomposeTransform();
      this.markRedraw();
    };
    Element3.prototype.beforeUpdate = function() {
    };
    Element3.prototype.afterUpdate = function() {
    };
    Element3.prototype.update = function() {
      this.updateTransform();
      if (this.__dirty) {
        this.updateInnerText();
      }
    };
    Element3.prototype.updateInnerText = function(forceUpdate) {
      var textEl = this._textContent;
      if (textEl && (!textEl.ignore || forceUpdate)) {
        if (!this.textConfig) {
          this.textConfig = {};
        }
        var textConfig = this.textConfig;
        var isLocal = textConfig.local;
        var innerTransformable = textEl.innerTransformable;
        var textAlign = void 0;
        var textVerticalAlign = void 0;
        var textStyleChanged = false;
        innerTransformable.parent = isLocal ? this : null;
        var innerOrigin = false;
        innerTransformable.copyTransform(textEl);
        if (textConfig.position != null) {
          var layoutRect = tmpBoundingRect;
          if (textConfig.layoutRect) {
            layoutRect.copy(textConfig.layoutRect);
          } else {
            layoutRect.copy(this.getBoundingRect());
          }
          if (!isLocal) {
            layoutRect.applyTransform(this.transform);
          }
          if (this.calculateTextPosition) {
            this.calculateTextPosition(tmpTextPosCalcRes, textConfig, layoutRect);
          } else {
            calculateTextPosition(tmpTextPosCalcRes, textConfig, layoutRect);
          }
          innerTransformable.x = tmpTextPosCalcRes.x;
          innerTransformable.y = tmpTextPosCalcRes.y;
          textAlign = tmpTextPosCalcRes.align;
          textVerticalAlign = tmpTextPosCalcRes.verticalAlign;
          var textOrigin = textConfig.origin;
          if (textOrigin && textConfig.rotation != null) {
            var relOriginX = void 0;
            var relOriginY = void 0;
            if (textOrigin === "center") {
              relOriginX = layoutRect.width * 0.5;
              relOriginY = layoutRect.height * 0.5;
            } else {
              relOriginX = parsePercent(textOrigin[0], layoutRect.width);
              relOriginY = parsePercent(textOrigin[1], layoutRect.height);
            }
            innerOrigin = true;
            innerTransformable.originX = -innerTransformable.x + relOriginX + (isLocal ? 0 : layoutRect.x);
            innerTransformable.originY = -innerTransformable.y + relOriginY + (isLocal ? 0 : layoutRect.y);
          }
        }
        if (textConfig.rotation != null) {
          innerTransformable.rotation = textConfig.rotation;
        }
        var textOffset = textConfig.offset;
        if (textOffset) {
          innerTransformable.x += textOffset[0];
          innerTransformable.y += textOffset[1];
          if (!innerOrigin) {
            innerTransformable.originX = -textOffset[0];
            innerTransformable.originY = -textOffset[1];
          }
        }
        var isInside = textConfig.inside == null ? typeof textConfig.position === "string" && textConfig.position.indexOf("inside") >= 0 : textConfig.inside;
        var innerTextDefaultStyle = this._innerTextDefaultStyle || (this._innerTextDefaultStyle = {});
        var textFill = void 0;
        var textStroke = void 0;
        var autoStroke = void 0;
        if (isInside && this.canBeInsideText()) {
          textFill = textConfig.insideFill;
          textStroke = textConfig.insideStroke;
          if (textFill == null || textFill === "auto") {
            textFill = this.getInsideTextFill();
          }
          if (textStroke == null || textStroke === "auto") {
            textStroke = this.getInsideTextStroke(textFill);
            autoStroke = true;
          }
        } else {
          textFill = textConfig.outsideFill;
          textStroke = textConfig.outsideStroke;
          if (textFill == null || textFill === "auto") {
            textFill = this.getOutsideFill();
          }
          if (textStroke == null || textStroke === "auto") {
            textStroke = this.getOutsideStroke(textFill);
            autoStroke = true;
          }
        }
        textFill = textFill || "#000";
        if (textFill !== innerTextDefaultStyle.fill || textStroke !== innerTextDefaultStyle.stroke || autoStroke !== innerTextDefaultStyle.autoStroke || textAlign !== innerTextDefaultStyle.align || textVerticalAlign !== innerTextDefaultStyle.verticalAlign) {
          textStyleChanged = true;
          innerTextDefaultStyle.fill = textFill;
          innerTextDefaultStyle.stroke = textStroke;
          innerTextDefaultStyle.autoStroke = autoStroke;
          innerTextDefaultStyle.align = textAlign;
          innerTextDefaultStyle.verticalAlign = textVerticalAlign;
          textEl.setDefaultTextStyle(innerTextDefaultStyle);
        }
        textEl.__dirty |= REDRAW_BIT;
        if (textStyleChanged) {
          textEl.dirtyStyle(true);
        }
      }
    };
    Element3.prototype.canBeInsideText = function() {
      return true;
    };
    Element3.prototype.getInsideTextFill = function() {
      return "#fff";
    };
    Element3.prototype.getInsideTextStroke = function(textFill) {
      return "#000";
    };
    Element3.prototype.getOutsideFill = function() {
      return this.__zr && this.__zr.isDarkMode() ? LIGHT_LABEL_COLOR : DARK_LABEL_COLOR;
    };
    Element3.prototype.getOutsideStroke = function(textFill) {
      var backgroundColor2 = this.__zr && this.__zr.getBackgroundColor();
      var colorArr = typeof backgroundColor2 === "string" && parse(backgroundColor2);
      if (!colorArr) {
        colorArr = [255, 255, 255, 1];
      }
      var alpha = colorArr[3];
      var isDark = this.__zr.isDarkMode();
      for (var i = 0; i < 3; i++) {
        colorArr[i] = colorArr[i] * alpha + (isDark ? 0 : 255) * (1 - alpha);
      }
      colorArr[3] = 1;
      return stringify(colorArr, "rgba");
    };
    Element3.prototype.traverse = function(cb, context) {
    };
    Element3.prototype.attrKV = function(key, value) {
      if (key === "textConfig") {
        this.setTextConfig(value);
      } else if (key === "textContent") {
        this.setTextContent(value);
      } else if (key === "clipPath") {
        this.setClipPath(value);
      } else if (key === "extra") {
        this.extra = this.extra || {};
        extend(this.extra, value);
      } else {
        this[key] = value;
      }
    };
    Element3.prototype.hide = function() {
      this.ignore = true;
      this.markRedraw();
    };
    Element3.prototype.show = function() {
      this.ignore = false;
      this.markRedraw();
    };
    Element3.prototype.attr = function(keyOrObj, value) {
      if (typeof keyOrObj === "string") {
        this.attrKV(keyOrObj, value);
      } else if (isObject(keyOrObj)) {
        var obj = keyOrObj;
        var keysArr = keys(obj);
        for (var i = 0; i < keysArr.length; i++) {
          var key = keysArr[i];
          this.attrKV(key, keyOrObj[key]);
        }
      }
      this.markRedraw();
      return this;
    };
    Element3.prototype.saveCurrentToNormalState = function(toState) {
      this._innerSaveToNormal(toState);
      var normalState = this._normalState;
      for (var i = 0; i < this.animators.length; i++) {
        var animator = this.animators[i];
        var fromStateTransition = animator.__fromStateTransition;
        if (animator.getLoop() || fromStateTransition && fromStateTransition !== PRESERVED_NORMAL_STATE) {
          continue;
        }
        var targetName = animator.targetName;
        var target = targetName ? normalState[targetName] : normalState;
        animator.saveTo(target);
      }
    };
    Element3.prototype._innerSaveToNormal = function(toState) {
      var normalState = this._normalState;
      if (!normalState) {
        normalState = this._normalState = {};
      }
      if (toState.textConfig && !normalState.textConfig) {
        normalState.textConfig = this.textConfig;
      }
      this._savePrimaryToNormal(toState, normalState, PRIMARY_STATES_KEYS);
    };
    Element3.prototype._savePrimaryToNormal = function(toState, normalState, primaryKeys) {
      for (var i = 0; i < primaryKeys.length; i++) {
        var key = primaryKeys[i];
        if (toState[key] != null && !(key in normalState)) {
          normalState[key] = this[key];
        }
      }
    };
    Element3.prototype.hasState = function() {
      return this.currentStates.length > 0;
    };
    Element3.prototype.getState = function(name) {
      return this.states[name];
    };
    Element3.prototype.ensureState = function(name) {
      var states = this.states;
      if (!states[name]) {
        states[name] = {};
      }
      return states[name];
    };
    Element3.prototype.clearStates = function(noAnimation) {
      this.useState(PRESERVED_NORMAL_STATE, false, noAnimation);
    };
    Element3.prototype.useState = function(stateName, keepCurrentStates, noAnimation, forceUseHoverLayer) {
      var toNormalState = stateName === PRESERVED_NORMAL_STATE;
      var hasStates = this.hasState();
      if (!hasStates && toNormalState) {
        return;
      }
      var currentStates = this.currentStates;
      var animationCfg = this.stateTransition;
      if (indexOf(currentStates, stateName) >= 0 && (keepCurrentStates || currentStates.length === 1)) {
        return;
      }
      var state;
      if (this.stateProxy && !toNormalState) {
        state = this.stateProxy(stateName);
      }
      if (!state) {
        state = this.states && this.states[stateName];
      }
      if (!state && !toNormalState) {
        logError("State " + stateName + " not exists.");
        return;
      }
      if (!toNormalState) {
        this.saveCurrentToNormalState(state);
      }
      var useHoverLayer = !!(state && state.hoverLayer || forceUseHoverLayer);
      if (useHoverLayer) {
        this._toggleHoverLayerFlag(true);
      }
      this._applyStateObj(stateName, state, this._normalState, keepCurrentStates, !noAnimation && !this.__inHover && animationCfg && animationCfg.duration > 0, animationCfg);
      var textContent = this._textContent;
      var textGuide = this._textGuide;
      if (textContent) {
        textContent.useState(stateName, keepCurrentStates, noAnimation, useHoverLayer);
      }
      if (textGuide) {
        textGuide.useState(stateName, keepCurrentStates, noAnimation, useHoverLayer);
      }
      if (toNormalState) {
        this.currentStates = [];
        this._normalState = {};
      } else {
        if (!keepCurrentStates) {
          this.currentStates = [stateName];
        } else {
          this.currentStates.push(stateName);
        }
      }
      this._updateAnimationTargets();
      this.markRedraw();
      if (!useHoverLayer && this.__inHover) {
        this._toggleHoverLayerFlag(false);
        this.__dirty &= ~REDRAW_BIT;
      }
      return state;
    };
    Element3.prototype.useStates = function(states, noAnimation, forceUseHoverLayer) {
      if (!states.length) {
        this.clearStates();
      } else {
        var stateObjects = [];
        var currentStates = this.currentStates;
        var len2 = states.length;
        var notChange = len2 === currentStates.length;
        if (notChange) {
          for (var i = 0; i < len2; i++) {
            if (states[i] !== currentStates[i]) {
              notChange = false;
              break;
            }
          }
        }
        if (notChange) {
          return;
        }
        for (var i = 0; i < len2; i++) {
          var stateName = states[i];
          var stateObj = void 0;
          if (this.stateProxy) {
            stateObj = this.stateProxy(stateName, states);
          }
          if (!stateObj) {
            stateObj = this.states[stateName];
          }
          if (stateObj) {
            stateObjects.push(stateObj);
          }
        }
        var lastStateObj = stateObjects[len2 - 1];
        var useHoverLayer = !!(lastStateObj && lastStateObj.hoverLayer || forceUseHoverLayer);
        if (useHoverLayer) {
          this._toggleHoverLayerFlag(true);
        }
        var mergedState = this._mergeStates(stateObjects);
        var animationCfg = this.stateTransition;
        this.saveCurrentToNormalState(mergedState);
        this._applyStateObj(states.join(","), mergedState, this._normalState, false, !noAnimation && !this.__inHover && animationCfg && animationCfg.duration > 0, animationCfg);
        var textContent = this._textContent;
        var textGuide = this._textGuide;
        if (textContent) {
          textContent.useStates(states, noAnimation, useHoverLayer);
        }
        if (textGuide) {
          textGuide.useStates(states, noAnimation, useHoverLayer);
        }
        this._updateAnimationTargets();
        this.currentStates = states.slice();
        this.markRedraw();
        if (!useHoverLayer && this.__inHover) {
          this._toggleHoverLayerFlag(false);
          this.__dirty &= ~REDRAW_BIT;
        }
      }
    };
    Element3.prototype._updateAnimationTargets = function() {
      for (var i = 0; i < this.animators.length; i++) {
        var animator = this.animators[i];
        if (animator.targetName) {
          animator.changeTarget(this[animator.targetName]);
        }
      }
    };
    Element3.prototype.removeState = function(state) {
      var idx = indexOf(this.currentStates, state);
      if (idx >= 0) {
        var currentStates = this.currentStates.slice();
        currentStates.splice(idx, 1);
        this.useStates(currentStates);
      }
    };
    Element3.prototype.replaceState = function(oldState, newState, forceAdd) {
      var currentStates = this.currentStates.slice();
      var idx = indexOf(currentStates, oldState);
      var newStateExists = indexOf(currentStates, newState) >= 0;
      if (idx >= 0) {
        if (!newStateExists) {
          currentStates[idx] = newState;
        } else {
          currentStates.splice(idx, 1);
        }
      } else if (forceAdd && !newStateExists) {
        currentStates.push(newState);
      }
      this.useStates(currentStates);
    };
    Element3.prototype.toggleState = function(state, enable) {
      if (enable) {
        this.useState(state, true);
      } else {
        this.removeState(state);
      }
    };
    Element3.prototype._mergeStates = function(states) {
      var mergedState = {};
      var mergedTextConfig;
      for (var i = 0; i < states.length; i++) {
        var state = states[i];
        extend(mergedState, state);
        if (state.textConfig) {
          mergedTextConfig = mergedTextConfig || {};
          extend(mergedTextConfig, state.textConfig);
        }
      }
      if (mergedTextConfig) {
        mergedState.textConfig = mergedTextConfig;
      }
      return mergedState;
    };
    Element3.prototype._applyStateObj = function(stateName, state, normalState, keepCurrentStates, transition, animationCfg) {
      var needsRestoreToNormal = !(state && keepCurrentStates);
      if (state && state.textConfig) {
        this.textConfig = extend({}, keepCurrentStates ? this.textConfig : normalState.textConfig);
        extend(this.textConfig, state.textConfig);
      } else if (needsRestoreToNormal) {
        if (normalState.textConfig) {
          this.textConfig = normalState.textConfig;
        }
      }
      var transitionTarget = {};
      var hasTransition = false;
      for (var i = 0; i < PRIMARY_STATES_KEYS.length; i++) {
        var key = PRIMARY_STATES_KEYS[i];
        var propNeedsTransition = transition && DEFAULT_ANIMATABLE_MAP[key];
        if (state && state[key] != null) {
          if (propNeedsTransition) {
            hasTransition = true;
            transitionTarget[key] = state[key];
          } else {
            this[key] = state[key];
          }
        } else if (needsRestoreToNormal) {
          if (normalState[key] != null) {
            if (propNeedsTransition) {
              hasTransition = true;
              transitionTarget[key] = normalState[key];
            } else {
              this[key] = normalState[key];
            }
          }
        }
      }
      if (!transition) {
        for (var i = 0; i < this.animators.length; i++) {
          var animator = this.animators[i];
          var targetName = animator.targetName;
          if (!animator.getLoop()) {
            animator.__changeFinalValue(targetName ? (state || normalState)[targetName] : state || normalState);
          }
        }
      }
      if (hasTransition) {
        this._transitionState(stateName, transitionTarget, animationCfg);
      }
    };
    Element3.prototype._attachComponent = function(componentEl) {
      if (componentEl.__zr && !componentEl.__hostTarget) {
        if (true) {
          throw new Error("Text element has been added to zrender.");
        }
        return;
      }
      if (componentEl === this) {
        if (true) {
          throw new Error("Recursive component attachment.");
        }
        return;
      }
      var zr = this.__zr;
      if (zr) {
        componentEl.addSelfToZr(zr);
      }
      componentEl.__zr = zr;
      componentEl.__hostTarget = this;
    };
    Element3.prototype._detachComponent = function(componentEl) {
      if (componentEl.__zr) {
        componentEl.removeSelfFromZr(componentEl.__zr);
      }
      componentEl.__zr = null;
      componentEl.__hostTarget = null;
    };
    Element3.prototype.getClipPath = function() {
      return this._clipPath;
    };
    Element3.prototype.setClipPath = function(clipPath) {
      if (this._clipPath && this._clipPath !== clipPath) {
        this.removeClipPath();
      }
      this._attachComponent(clipPath);
      this._clipPath = clipPath;
      this.markRedraw();
    };
    Element3.prototype.removeClipPath = function() {
      var clipPath = this._clipPath;
      if (clipPath) {
        this._detachComponent(clipPath);
        this._clipPath = null;
        this.markRedraw();
      }
    };
    Element3.prototype.getTextContent = function() {
      return this._textContent;
    };
    Element3.prototype.setTextContent = function(textEl) {
      var previousTextContent = this._textContent;
      if (previousTextContent === textEl) {
        return;
      }
      if (previousTextContent && previousTextContent !== textEl) {
        this.removeTextContent();
      }
      if (true) {
        if (textEl.__zr && !textEl.__hostTarget) {
          throw new Error("Text element has been added to zrender.");
        }
      }
      textEl.innerTransformable = new Transformable_default();
      this._attachComponent(textEl);
      this._textContent = textEl;
      this.markRedraw();
    };
    Element3.prototype.setTextConfig = function(cfg) {
      if (!this.textConfig) {
        this.textConfig = {};
      }
      extend(this.textConfig, cfg);
      this.markRedraw();
    };
    Element3.prototype.removeTextConfig = function() {
      this.textConfig = null;
      this.markRedraw();
    };
    Element3.prototype.removeTextContent = function() {
      var textEl = this._textContent;
      if (textEl) {
        textEl.innerTransformable = null;
        this._detachComponent(textEl);
        this._textContent = null;
        this._innerTextDefaultStyle = null;
        this.markRedraw();
      }
    };
    Element3.prototype.getTextGuideLine = function() {
      return this._textGuide;
    };
    Element3.prototype.setTextGuideLine = function(guideLine) {
      if (this._textGuide && this._textGuide !== guideLine) {
        this.removeTextGuideLine();
      }
      this._attachComponent(guideLine);
      this._textGuide = guideLine;
      this.markRedraw();
    };
    Element3.prototype.removeTextGuideLine = function() {
      var textGuide = this._textGuide;
      if (textGuide) {
        this._detachComponent(textGuide);
        this._textGuide = null;
        this.markRedraw();
      }
    };
    Element3.prototype.markRedraw = function() {
      this.__dirty |= REDRAW_BIT;
      var zr = this.__zr;
      if (zr) {
        if (this.__inHover) {
          zr.refreshHover();
        } else {
          zr.refresh();
        }
      }
      if (this.__hostTarget) {
        this.__hostTarget.markRedraw();
      }
    };
    Element3.prototype.dirty = function() {
      this.markRedraw();
    };
    Element3.prototype._toggleHoverLayerFlag = function(inHover) {
      this.__inHover = inHover;
      var textContent = this._textContent;
      var textGuide = this._textGuide;
      if (textContent) {
        textContent.__inHover = inHover;
      }
      if (textGuide) {
        textGuide.__inHover = inHover;
      }
    };
    Element3.prototype.addSelfToZr = function(zr) {
      if (this.__zr === zr) {
        return;
      }
      this.__zr = zr;
      var animators = this.animators;
      if (animators) {
        for (var i = 0; i < animators.length; i++) {
          zr.animation.addAnimator(animators[i]);
        }
      }
      if (this._clipPath) {
        this._clipPath.addSelfToZr(zr);
      }
      if (this._textContent) {
        this._textContent.addSelfToZr(zr);
      }
      if (this._textGuide) {
        this._textGuide.addSelfToZr(zr);
      }
    };
    Element3.prototype.removeSelfFromZr = function(zr) {
      if (!this.__zr) {
        return;
      }
      this.__zr = null;
      var animators = this.animators;
      if (animators) {
        for (var i = 0; i < animators.length; i++) {
          zr.animation.removeAnimator(animators[i]);
        }
      }
      if (this._clipPath) {
        this._clipPath.removeSelfFromZr(zr);
      }
      if (this._textContent) {
        this._textContent.removeSelfFromZr(zr);
      }
      if (this._textGuide) {
        this._textGuide.removeSelfFromZr(zr);
      }
    };
    Element3.prototype.animate = function(key, loop, allowDiscreteAnimation) {
      var target = key ? this[key] : this;
      if (true) {
        if (!target) {
          logError('Property "' + key + '" is not existed in element ' + this.id);
          return;
        }
      }
      var animator = new Animator_default(target, loop, allowDiscreteAnimation);
      key && (animator.targetName = key);
      this.addAnimator(animator, key);
      return animator;
    };
    Element3.prototype.addAnimator = function(animator, key) {
      var zr = this.__zr;
      var el = this;
      animator.during(function() {
        el.updateDuringAnimation(key);
      }).done(function() {
        var animators = el.animators;
        var idx = indexOf(animators, animator);
        if (idx >= 0) {
          animators.splice(idx, 1);
        }
      });
      this.animators.push(animator);
      if (zr) {
        zr.animation.addAnimator(animator);
      }
      zr && zr.wakeUp();
    };
    Element3.prototype.updateDuringAnimation = function(key) {
      this.markRedraw();
    };
    Element3.prototype.stopAnimation = function(scope, forwardToLast) {
      var animators = this.animators;
      var len2 = animators.length;
      var leftAnimators = [];
      for (var i = 0; i < len2; i++) {
        var animator = animators[i];
        if (!scope || scope === animator.scope) {
          animator.stop(forwardToLast);
        } else {
          leftAnimators.push(animator);
        }
      }
      this.animators = leftAnimators;
      return this;
    };
    Element3.prototype.animateTo = function(target, cfg, animationProps) {
      animateTo(this, target, cfg, animationProps);
    };
    Element3.prototype.animateFrom = function(target, cfg, animationProps) {
      animateTo(this, target, cfg, animationProps, true);
    };
    Element3.prototype._transitionState = function(stateName, target, cfg, animationProps) {
      var animators = animateTo(this, target, cfg, animationProps);
      for (var i = 0; i < animators.length; i++) {
        animators[i].__fromStateTransition = stateName;
      }
    };
    Element3.prototype.getBoundingRect = function() {
      return null;
    };
    Element3.prototype.getPaintRect = function() {
      return null;
    };
    Element3.initDefaultProps = function() {
      var elProto = Element3.prototype;
      elProto.type = "element";
      elProto.name = "";
      elProto.ignore = elProto.silent = elProto.isGroup = elProto.draggable = elProto.dragging = elProto.ignoreClip = elProto.__inHover = false;
      elProto.__dirty = REDRAW_BIT;
      var logs = {};
      function logDeprecatedError(key, xKey, yKey) {
        if (!logs[key + xKey + yKey]) {
          console.warn("DEPRECATED: '" + key + "' has been deprecated. use '" + xKey + "', '" + yKey + "' instead");
          logs[key + xKey + yKey] = true;
        }
      }
      function createLegacyProperty(key, privateKey, xKey, yKey) {
        Object.defineProperty(elProto, key, {
          get: function() {
            if (true) {
              logDeprecatedError(key, xKey, yKey);
            }
            if (!this[privateKey]) {
              var pos = this[privateKey] = [];
              enhanceArray(this, pos);
            }
            return this[privateKey];
          },
          set: function(pos) {
            if (true) {
              logDeprecatedError(key, xKey, yKey);
            }
            this[xKey] = pos[0];
            this[yKey] = pos[1];
            this[privateKey] = pos;
            enhanceArray(this, pos);
          }
        });
        function enhanceArray(self2, pos) {
          Object.defineProperty(pos, 0, {
            get: function() {
              return self2[xKey];
            },
            set: function(val) {
              self2[xKey] = val;
            }
          });
          Object.defineProperty(pos, 1, {
            get: function() {
              return self2[yKey];
            },
            set: function(val) {
              self2[yKey] = val;
            }
          });
        }
      }
      if (Object.defineProperty) {
        createLegacyProperty("position", "_legacyPos", "x", "y");
        createLegacyProperty("scale", "_legacyScale", "scaleX", "scaleY");
        createLegacyProperty("origin", "_legacyOrigin", "originX", "originY");
      }
    }();
    return Element3;
  }();
  mixin(Element2, Eventful_default);
  mixin(Element2, Transformable_default);
  function animateTo(animatable, target, cfg, animationProps, reverse2) {
    cfg = cfg || {};
    var animators = [];
    animateToShallow(animatable, "", animatable, target, cfg, animationProps, animators, reverse2);
    var finishCount = animators.length;
    var doneHappened = false;
    var cfgDone = cfg.done;
    var cfgAborted = cfg.aborted;
    var doneCb = function() {
      doneHappened = true;
      finishCount--;
      if (finishCount <= 0) {
        doneHappened ? cfgDone && cfgDone() : cfgAborted && cfgAborted();
      }
    };
    var abortedCb = function() {
      finishCount--;
      if (finishCount <= 0) {
        doneHappened ? cfgDone && cfgDone() : cfgAborted && cfgAborted();
      }
    };
    if (!finishCount) {
      cfgDone && cfgDone();
    }
    if (animators.length > 0 && cfg.during) {
      animators[0].during(function(target2, percent) {
        cfg.during(percent);
      });
    }
    for (var i = 0; i < animators.length; i++) {
      var animator = animators[i];
      if (doneCb) {
        animator.done(doneCb);
      }
      if (abortedCb) {
        animator.aborted(abortedCb);
      }
      if (cfg.force) {
        animator.duration(cfg.duration);
      }
      animator.start(cfg.easing);
    }
    return animators;
  }
  function copyArrShallow(source, target, len2) {
    for (var i = 0; i < len2; i++) {
      source[i] = target[i];
    }
  }
  function is2DArray(value) {
    return isArrayLike(value[0]);
  }
  function copyValue(target, source, key) {
    if (isArrayLike(source[key])) {
      if (!isArrayLike(target[key])) {
        target[key] = [];
      }
      if (isTypedArray(source[key])) {
        var len2 = source[key].length;
        if (target[key].length !== len2) {
          target[key] = new source[key].constructor(len2);
          copyArrShallow(target[key], source[key], len2);
        }
      } else {
        var sourceArr = source[key];
        var targetArr = target[key];
        var len0 = sourceArr.length;
        if (is2DArray(sourceArr)) {
          var len1 = sourceArr[0].length;
          for (var i = 0; i < len0; i++) {
            if (!targetArr[i]) {
              targetArr[i] = Array.prototype.slice.call(sourceArr[i]);
            } else {
              copyArrShallow(targetArr[i], sourceArr[i], len1);
            }
          }
        } else {
          copyArrShallow(targetArr, sourceArr, len0);
        }
        targetArr.length = sourceArr.length;
      }
    } else {
      target[key] = source[key];
    }
  }
  function isValueSame(val1, val2) {
    return val1 === val2 || isArrayLike(val1) && isArrayLike(val2) && is1DArraySame(val1, val2);
  }
  function is1DArraySame(arr0, arr1) {
    var len2 = arr0.length;
    if (len2 !== arr1.length) {
      return false;
    }
    for (var i = 0; i < len2; i++) {
      if (arr0[i] !== arr1[i]) {
        return false;
      }
    }
    return true;
  }
  function animateToShallow(animatable, topKey, animateObj, target, cfg, animationProps, animators, reverse2) {
    var targetKeys = keys(target);
    var duration = cfg.duration;
    var delay = cfg.delay;
    var additive = cfg.additive;
    var setToFinal = cfg.setToFinal;
    var animateAll = !isObject(animationProps);
    var existsAnimators = animatable.animators;
    var animationKeys = [];
    for (var k = 0; k < targetKeys.length; k++) {
      var innerKey = targetKeys[k];
      var targetVal = target[innerKey];
      if (targetVal != null && animateObj[innerKey] != null && (animateAll || animationProps[innerKey])) {
        if (isObject(targetVal) && !isArrayLike(targetVal) && !isGradientObject(targetVal)) {
          if (topKey) {
            if (!reverse2) {
              animateObj[innerKey] = targetVal;
              animatable.updateDuringAnimation(topKey);
            }
            continue;
          }
          animateToShallow(animatable, innerKey, animateObj[innerKey], targetVal, cfg, animationProps && animationProps[innerKey], animators, reverse2);
        } else {
          animationKeys.push(innerKey);
        }
      } else if (!reverse2) {
        animateObj[innerKey] = targetVal;
        animatable.updateDuringAnimation(topKey);
        animationKeys.push(innerKey);
      }
    }
    var keyLen = animationKeys.length;
    if (!additive && keyLen) {
      for (var i = 0; i < existsAnimators.length; i++) {
        var animator = existsAnimators[i];
        if (animator.targetName === topKey) {
          var allAborted = animator.stopTracks(animationKeys);
          if (allAborted) {
            var idx = indexOf(existsAnimators, animator);
            existsAnimators.splice(idx, 1);
          }
        }
      }
    }
    if (!cfg.force) {
      animationKeys = filter(animationKeys, function(key) {
        return !isValueSame(target[key], animateObj[key]);
      });
      keyLen = animationKeys.length;
    }
    if (keyLen > 0 || cfg.force && !animators.length) {
      var revertedSource = void 0;
      var reversedTarget = void 0;
      var sourceClone = void 0;
      if (reverse2) {
        reversedTarget = {};
        if (setToFinal) {
          revertedSource = {};
        }
        for (var i = 0; i < keyLen; i++) {
          var innerKey = animationKeys[i];
          reversedTarget[innerKey] = animateObj[innerKey];
          if (setToFinal) {
            revertedSource[innerKey] = target[innerKey];
          } else {
            animateObj[innerKey] = target[innerKey];
          }
        }
      } else if (setToFinal) {
        sourceClone = {};
        for (var i = 0; i < keyLen; i++) {
          var innerKey = animationKeys[i];
          sourceClone[innerKey] = cloneValue(animateObj[innerKey]);
          copyValue(animateObj, target, innerKey);
        }
      }
      var animator = new Animator_default(animateObj, false, false, additive ? filter(existsAnimators, function(animator2) {
        return animator2.targetName === topKey;
      }) : null);
      animator.targetName = topKey;
      if (cfg.scope) {
        animator.scope = cfg.scope;
      }
      if (setToFinal && revertedSource) {
        animator.whenWithKeys(0, revertedSource, animationKeys);
      }
      if (sourceClone) {
        animator.whenWithKeys(0, sourceClone, animationKeys);
      }
      animator.whenWithKeys(duration == null ? 500 : duration, reverse2 ? reversedTarget : target, animationKeys).delay(delay || 0);
      animatable.addAnimator(animator, topKey);
      animators.push(animator);
    }
  }
  var Element_default = Element2;

  // node_modules/zrender/lib/graphic/Group.js
  var Group = function(_super) {
    __extends2(Group5, _super);
    function Group5(opts) {
      var _this = _super.call(this) || this;
      _this.isGroup = true;
      _this._children = [];
      _this.attr(opts);
      return _this;
    }
    Group5.prototype.childrenRef = function() {
      return this._children;
    };
    Group5.prototype.children = function() {
      return this._children.slice();
    };
    Group5.prototype.childAt = function(idx) {
      return this._children[idx];
    };
    Group5.prototype.childOfName = function(name) {
      var children = this._children;
      for (var i = 0; i < children.length; i++) {
        if (children[i].name === name) {
          return children[i];
        }
      }
    };
    Group5.prototype.childCount = function() {
      return this._children.length;
    };
    Group5.prototype.add = function(child) {
      if (child) {
        if (child !== this && child.parent !== this) {
          this._children.push(child);
          this._doAdd(child);
        }
        if (true) {
          if (child.__hostTarget) {
            throw "This elemenet has been used as an attachment";
          }
        }
      }
      return this;
    };
    Group5.prototype.addBefore = function(child, nextSibling2) {
      if (child && child !== this && child.parent !== this && nextSibling2 && nextSibling2.parent === this) {
        var children = this._children;
        var idx = children.indexOf(nextSibling2);
        if (idx >= 0) {
          children.splice(idx, 0, child);
          this._doAdd(child);
        }
      }
      return this;
    };
    Group5.prototype.replace = function(oldChild, newChild) {
      var idx = indexOf(this._children, oldChild);
      if (idx >= 0) {
        this.replaceAt(newChild, idx);
      }
      return this;
    };
    Group5.prototype.replaceAt = function(child, index) {
      var children = this._children;
      var old = children[index];
      if (child && child !== this && child.parent !== this && child !== old) {
        children[index] = child;
        old.parent = null;
        var zr = this.__zr;
        if (zr) {
          old.removeSelfFromZr(zr);
        }
        this._doAdd(child);
      }
      return this;
    };
    Group5.prototype._doAdd = function(child) {
      if (child.parent) {
        child.parent.remove(child);
      }
      child.parent = this;
      var zr = this.__zr;
      if (zr && zr !== child.__zr) {
        child.addSelfToZr(zr);
      }
      zr && zr.refresh();
    };
    Group5.prototype.remove = function(child) {
      var zr = this.__zr;
      var children = this._children;
      var idx = indexOf(children, child);
      if (idx < 0) {
        return this;
      }
      children.splice(idx, 1);
      child.parent = null;
      if (zr) {
        child.removeSelfFromZr(zr);
      }
      zr && zr.refresh();
      return this;
    };
    Group5.prototype.removeAll = function() {
      var children = this._children;
      var zr = this.__zr;
      for (var i = 0; i < children.length; i++) {
        var child = children[i];
        if (zr) {
          child.removeSelfFromZr(zr);
        }
        child.parent = null;
      }
      children.length = 0;
      return this;
    };
    Group5.prototype.eachChild = function(cb, context) {
      var children = this._children;
      for (var i = 0; i < children.length; i++) {
        var child = children[i];
        cb.call(context, child, i);
      }
      return this;
    };
    Group5.prototype.traverse = function(cb, context) {
      for (var i = 0; i < this._children.length; i++) {
        var child = this._children[i];
        var stopped = cb.call(context, child);
        if (child.isGroup && !stopped) {
          child.traverse(cb, context);
        }
      }
      return this;
    };
    Group5.prototype.addSelfToZr = function(zr) {
      _super.prototype.addSelfToZr.call(this, zr);
      for (var i = 0; i < this._children.length; i++) {
        var child = this._children[i];
        child.addSelfToZr(zr);
      }
    };
    Group5.prototype.removeSelfFromZr = function(zr) {
      _super.prototype.removeSelfFromZr.call(this, zr);
      for (var i = 0; i < this._children.length; i++) {
        var child = this._children[i];
        child.removeSelfFromZr(zr);
      }
    };
    Group5.prototype.getBoundingRect = function(includeChildren) {
      var tmpRect2 = new BoundingRect_default(0, 0, 0, 0);
      var children = includeChildren || this._children;
      var tmpMat = [];
      var rect = null;
      for (var i = 0; i < children.length; i++) {
        var child = children[i];
        if (child.ignore || child.invisible) {
          continue;
        }
        var childRect = child.getBoundingRect();
        var transform2 = child.getLocalTransform(tmpMat);
        if (transform2) {
          BoundingRect_default.applyTransform(tmpRect2, childRect, transform2);
          rect = rect || tmpRect2.clone();
          rect.union(tmpRect2);
        } else {
          rect = rect || childRect.clone();
          rect.union(childRect);
        }
      }
      return rect || tmpRect2;
    };
    return Group5;
  }(Element_default);
  Group.prototype.type = "group";
  var Group_default = Group;

  // node_modules/zrender/lib/zrender.js
  var painterCtors = {};
  var instances = {};
  function delInstance(id) {
    delete instances[id];
  }
  function isDarkMode(backgroundColor2) {
    if (!backgroundColor2) {
      return false;
    }
    if (typeof backgroundColor2 === "string") {
      return lum(backgroundColor2, 1) < DARK_MODE_THRESHOLD;
    } else if (backgroundColor2.colorStops) {
      var colorStops = backgroundColor2.colorStops;
      var totalLum = 0;
      var len2 = colorStops.length;
      for (var i = 0; i < len2; i++) {
        totalLum += lum(colorStops[i].color, 1);
      }
      totalLum /= len2;
      return totalLum < DARK_MODE_THRESHOLD;
    }
    return false;
  }
  var ZRender = function() {
    function ZRender2(id, dom, opts) {
      var _this = this;
      this._sleepAfterStill = 10;
      this._stillFrameAccum = 0;
      this._needsRefresh = true;
      this._needsRefreshHover = true;
      this._darkMode = false;
      opts = opts || {};
      this.dom = dom;
      this.id = id;
      var storage2 = new Storage_default();
      var rendererType = opts.renderer || "canvas";
      if (!painterCtors[rendererType]) {
        rendererType = keys(painterCtors)[0];
      }
      if (true) {
        if (!painterCtors[rendererType]) {
          throw new Error("Renderer '" + rendererType + "' is not imported. Please import it first.");
        }
      }
      opts.useDirtyRect = opts.useDirtyRect == null ? false : opts.useDirtyRect;
      var painter = new painterCtors[rendererType](dom, storage2, opts, id);
      var ssrMode = opts.ssr || painter.ssrOnly;
      this.storage = storage2;
      this.painter = painter;
      var handerProxy = !env_default.node && !env_default.worker && !ssrMode ? new HandlerProxy_default(painter.getViewportRoot(), painter.root) : null;
      this.handler = new Handler_default(storage2, painter, handerProxy, painter.root);
      this.animation = new Animation_default({
        stage: {
          update: ssrMode ? null : function() {
            return _this._flush(true);
          }
        }
      });
      if (!ssrMode) {
        this.animation.start();
      }
    }
    ZRender2.prototype.add = function(el) {
      if (!el) {
        return;
      }
      this.storage.addRoot(el);
      el.addSelfToZr(this);
      this.refresh();
    };
    ZRender2.prototype.remove = function(el) {
      if (!el) {
        return;
      }
      this.storage.delRoot(el);
      el.removeSelfFromZr(this);
      this.refresh();
    };
    ZRender2.prototype.configLayer = function(zLevel, config) {
      if (this.painter.configLayer) {
        this.painter.configLayer(zLevel, config);
      }
      this.refresh();
    };
    ZRender2.prototype.setBackgroundColor = function(backgroundColor2) {
      if (this.painter.setBackgroundColor) {
        this.painter.setBackgroundColor(backgroundColor2);
      }
      this.refresh();
      this._backgroundColor = backgroundColor2;
      this._darkMode = isDarkMode(backgroundColor2);
    };
    ZRender2.prototype.getBackgroundColor = function() {
      return this._backgroundColor;
    };
    ZRender2.prototype.setDarkMode = function(darkMode) {
      this._darkMode = darkMode;
    };
    ZRender2.prototype.isDarkMode = function() {
      return this._darkMode;
    };
    ZRender2.prototype.refreshImmediately = function(fromInside) {
      if (!fromInside) {
        this.animation.update(true);
      }
      this._needsRefresh = false;
      this.painter.refresh();
      this._needsRefresh = false;
    };
    ZRender2.prototype.refresh = function() {
      this._needsRefresh = true;
      this.animation.start();
    };
    ZRender2.prototype.flush = function() {
      this._flush(false);
    };
    ZRender2.prototype._flush = function(fromInside) {
      var triggerRendered;
      var start2 = getTime();
      if (this._needsRefresh) {
        triggerRendered = true;
        this.refreshImmediately(fromInside);
      }
      if (this._needsRefreshHover) {
        triggerRendered = true;
        this.refreshHoverImmediately();
      }
      var end2 = getTime();
      if (triggerRendered) {
        this._stillFrameAccum = 0;
        this.trigger("rendered", {
          elapsedTime: end2 - start2
        });
      } else if (this._sleepAfterStill > 0) {
        this._stillFrameAccum++;
        if (this._stillFrameAccum > this._sleepAfterStill) {
          this.animation.stop();
        }
      }
    };
    ZRender2.prototype.setSleepAfterStill = function(stillFramesCount) {
      this._sleepAfterStill = stillFramesCount;
    };
    ZRender2.prototype.wakeUp = function() {
      this.animation.start();
      this._stillFrameAccum = 0;
    };
    ZRender2.prototype.refreshHover = function() {
      this._needsRefreshHover = true;
    };
    ZRender2.prototype.refreshHoverImmediately = function() {
      this._needsRefreshHover = false;
      if (this.painter.refreshHover && this.painter.getType() === "canvas") {
        this.painter.refreshHover();
      }
    };
    ZRender2.prototype.resize = function(opts) {
      opts = opts || {};
      this.painter.resize(opts.width, opts.height);
      this.handler.resize();
    };
    ZRender2.prototype.clearAnimation = function() {
      this.animation.clear();
    };
    ZRender2.prototype.getWidth = function() {
      return this.painter.getWidth();
    };
    ZRender2.prototype.getHeight = function() {
      return this.painter.getHeight();
    };
    ZRender2.prototype.setCursorStyle = function(cursorStyle) {
      this.handler.setCursorStyle(cursorStyle);
    };
    ZRender2.prototype.findHover = function(x, y) {
      return this.handler.findHover(x, y);
    };
    ZRender2.prototype.on = function(eventName, eventHandler, context) {
      this.handler.on(eventName, eventHandler, context);
      return this;
    };
    ZRender2.prototype.off = function(eventName, eventHandler) {
      this.handler.off(eventName, eventHandler);
    };
    ZRender2.prototype.trigger = function(eventName, event) {
      this.handler.trigger(eventName, event);
    };
    ZRender2.prototype.clear = function() {
      var roots2 = this.storage.getRoots();
      for (var i = 0; i < roots2.length; i++) {
        if (roots2[i] instanceof Group_default) {
          roots2[i].removeSelfFromZr(this);
        }
      }
      this.storage.delAllRoots();
      this.painter.clear();
    };
    ZRender2.prototype.dispose = function() {
      this.animation.stop();
      this.clear();
      this.storage.dispose();
      this.painter.dispose();
      this.handler.dispose();
      this.animation = this.storage = this.painter = this.handler = null;
      delInstance(this.id);
    };
    return ZRender2;
  }();
  function init(dom, opts) {
    var zr = new ZRender(guid(), dom, opts);
    instances[zr.id] = zr;
    return zr;
  }
  function dispose(zr) {
    zr.dispose();
  }
  function disposeAll() {
    for (var key in instances) {
      if (instances.hasOwnProperty(key)) {
        instances[key].dispose();
      }
    }
    instances = {};
  }
  function getInstance(id) {
    return instances[id];
  }
  function registerPainter(name, Ctor) {
    painterCtors[name] = Ctor;
  }
  var version = "5.3.2";

  // node_modules/echarts/lib/util/number.js
  var RADIAN_EPSILON = 1e-4;
  var ROUND_SUPPORTED_PRECISION_MAX = 20;
  function _trim(str) {
    return str.replace(/^\s+|\s+$/g, "");
  }
  function linearMap(val, domain, range, clamp2) {
    var d0 = domain[0];
    var d1 = domain[1];
    var r0 = range[0];
    var r1 = range[1];
    var subDomain = d1 - d0;
    var subRange = r1 - r0;
    if (subDomain === 0) {
      return subRange === 0 ? r0 : (r0 + r1) / 2;
    }
    if (clamp2) {
      if (subDomain > 0) {
        if (val <= d0) {
          return r0;
        } else if (val >= d1) {
          return r1;
        }
      } else {
        if (val >= d0) {
          return r0;
        } else if (val <= d1) {
          return r1;
        }
      }
    } else {
      if (val === d0) {
        return r0;
      }
      if (val === d1) {
        return r1;
      }
    }
    return (val - d0) / subDomain * subRange + r0;
  }
  function parsePercent2(percent, all) {
    switch (percent) {
      case "center":
      case "middle":
        percent = "50%";
        break;
      case "left":
      case "top":
        percent = "0%";
        break;
      case "right":
      case "bottom":
        percent = "100%";
        break;
    }
    if (isString(percent)) {
      if (_trim(percent).match(/%$/)) {
        return parseFloat(percent) / 100 * all;
      }
      return parseFloat(percent);
    }
    return percent == null ? NaN : +percent;
  }
  function round(x, precision, returnStr) {
    if (precision == null) {
      precision = 10;
    }
    precision = Math.min(Math.max(0, precision), ROUND_SUPPORTED_PRECISION_MAX);
    x = (+x).toFixed(precision);
    return returnStr ? x : +x;
  }
  function asc(arr) {
    arr.sort(function(a, b) {
      return a - b;
    });
    return arr;
  }
  function getPrecision(val) {
    val = +val;
    if (isNaN(val)) {
      return 0;
    }
    if (val > 1e-14) {
      var e2 = 1;
      for (var i = 0; i < 15; i++, e2 *= 10) {
        if (Math.round(val * e2) / e2 === val) {
          return i;
        }
      }
    }
    return getPrecisionSafe(val);
  }
  function getPrecisionSafe(val) {
    var str = val.toString().toLowerCase();
    var eIndex = str.indexOf("e");
    var exp = eIndex > 0 ? +str.slice(eIndex + 1) : 0;
    var significandPartLen = eIndex > 0 ? eIndex : str.length;
    var dotIndex = str.indexOf(".");
    var decimalPartLen = dotIndex < 0 ? 0 : significandPartLen - 1 - dotIndex;
    return Math.max(0, decimalPartLen - exp);
  }
  function getPixelPrecision(dataExtent, pixelExtent) {
    var log2 = Math.log;
    var LN10 = Math.LN10;
    var dataQuantity = Math.floor(log2(dataExtent[1] - dataExtent[0]) / LN10);
    var sizeQuantity = Math.round(log2(Math.abs(pixelExtent[1] - pixelExtent[0])) / LN10);
    var precision = Math.min(Math.max(-dataQuantity + sizeQuantity, 0), 20);
    return !isFinite(precision) ? 20 : precision;
  }
  function getPercentWithPrecision(valueList, idx, precision) {
    if (!valueList[idx]) {
      return 0;
    }
    var sum2 = reduce(valueList, function(acc, val) {
      return acc + (isNaN(val) ? 0 : val);
    }, 0);
    if (sum2 === 0) {
      return 0;
    }
    var digits = Math.pow(10, precision);
    var votesPerQuota = map(valueList, function(val) {
      return (isNaN(val) ? 0 : val) / sum2 * digits * 100;
    });
    var targetSeats = digits * 100;
    var seats = map(votesPerQuota, function(votes) {
      return Math.floor(votes);
    });
    var currentSum = reduce(seats, function(acc, val) {
      return acc + val;
    }, 0);
    var remainder = map(votesPerQuota, function(votes, idx2) {
      return votes - seats[idx2];
    });
    while (currentSum < targetSeats) {
      var max3 = Number.NEGATIVE_INFINITY;
      var maxId = null;
      for (var i = 0, len2 = remainder.length; i < len2; ++i) {
        if (remainder[i] > max3) {
          max3 = remainder[i];
          maxId = i;
        }
      }
      ++seats[maxId];
      remainder[maxId] = 0;
      ++currentSum;
    }
    return seats[idx] / digits;
  }
  function addSafe(val0, val1) {
    var maxPrecision = Math.max(getPrecision(val0), getPrecision(val1));
    var sum2 = val0 + val1;
    return maxPrecision > ROUND_SUPPORTED_PRECISION_MAX ? sum2 : round(sum2, maxPrecision);
  }
  var MAX_SAFE_INTEGER = 9007199254740991;
  function remRadian(radian) {
    var pi2 = Math.PI * 2;
    return (radian % pi2 + pi2) % pi2;
  }
  function isRadianAroundZero(val) {
    return val > -RADIAN_EPSILON && val < RADIAN_EPSILON;
  }
  var TIME_REG = /^(?:(\d{4})(?:[-\/](\d{1,2})(?:[-\/](\d{1,2})(?:[T ](\d{1,2})(?::(\d{1,2})(?::(\d{1,2})(?:[.,](\d+))?)?)?(Z|[\+\-]\d\d:?\d\d)?)?)?)?)?$/;
  function parseDate(value) {
    if (value instanceof Date) {
      return value;
    } else if (isString(value)) {
      var match = TIME_REG.exec(value);
      if (!match) {
        return new Date(NaN);
      }
      if (!match[8]) {
        return new Date(+match[1], +(match[2] || 1) - 1, +match[3] || 1, +match[4] || 0, +(match[5] || 0), +match[6] || 0, match[7] ? +match[7].substring(0, 3) : 0);
      } else {
        var hour = +match[4] || 0;
        if (match[8].toUpperCase() !== "Z") {
          hour -= +match[8].slice(0, 3);
        }
        return new Date(Date.UTC(+match[1], +(match[2] || 1) - 1, +match[3] || 1, hour, +(match[5] || 0), +match[6] || 0, match[7] ? +match[7].substring(0, 3) : 0));
      }
    } else if (value == null) {
      return new Date(NaN);
    }
    return new Date(Math.round(value));
  }
  function quantity(val) {
    return Math.pow(10, quantityExponent(val));
  }
  function quantityExponent(val) {
    if (val === 0) {
      return 0;
    }
    var exp = Math.floor(Math.log(val) / Math.LN10);
    if (val / Math.pow(10, exp) >= 10) {
      exp++;
    }
    return exp;
  }
  function nice(val, round7) {
    var exponent = quantityExponent(val);
    var exp10 = Math.pow(10, exponent);
    var f = val / exp10;
    var nf;
    if (round7) {
      if (f < 1.5) {
        nf = 1;
      } else if (f < 2.5) {
        nf = 2;
      } else if (f < 4) {
        nf = 3;
      } else if (f < 7) {
        nf = 5;
      } else {
        nf = 10;
      }
    } else {
      if (f < 1) {
        nf = 1;
      } else if (f < 2) {
        nf = 2;
      } else if (f < 3) {
        nf = 3;
      } else if (f < 5) {
        nf = 5;
      } else {
        nf = 10;
      }
    }
    val = nf * exp10;
    return exponent >= -20 ? +val.toFixed(exponent < 0 ? -exponent : 0) : val;
  }
  function quantile(ascArr, p) {
    var H = (ascArr.length - 1) * p + 1;
    var h = Math.floor(H);
    var v = +ascArr[h - 1];
    var e2 = H - h;
    return e2 ? v + e2 * (ascArr[h] - v) : v;
  }
  function reformIntervals(list) {
    list.sort(function(a, b) {
      return littleThan2(a, b, 0) ? -1 : 1;
    });
    var curr = -Infinity;
    var currClose = 1;
    for (var i = 0; i < list.length; ) {
      var interval = list[i].interval;
      var close_1 = list[i].close;
      for (var lg = 0; lg < 2; lg++) {
        if (interval[lg] <= curr) {
          interval[lg] = curr;
          close_1[lg] = !lg ? 1 - currClose : 1;
        }
        curr = interval[lg];
        currClose = close_1[lg];
      }
      if (interval[0] === interval[1] && close_1[0] * close_1[1] !== 1) {
        list.splice(i, 1);
      } else {
        i++;
      }
    }
    return list;
    function littleThan2(a, b, lg2) {
      return a.interval[lg2] < b.interval[lg2] || a.interval[lg2] === b.interval[lg2] && (a.close[lg2] - b.close[lg2] === (!lg2 ? 1 : -1) || !lg2 && littleThan2(a, b, 1));
    }
  }
  function numericToNumber(val) {
    var valFloat = parseFloat(val);
    return valFloat == val && (valFloat !== 0 || !isString(val) || val.indexOf("x") <= 0) ? valFloat : NaN;
  }
  function isNumeric(val) {
    return !isNaN(numericToNumber(val));
  }
  function getRandomIdBase() {
    return Math.round(Math.random() * 9);
  }
  function getGreatestCommonDividor(a, b) {
    if (b === 0) {
      return a;
    }
    return getGreatestCommonDividor(b, a % b);
  }
  function getLeastCommonMultiple(a, b) {
    if (a == null) {
      return b;
    }
    if (b == null) {
      return a;
    }
    return a * b / getGreatestCommonDividor(a, b);
  }

  // node_modules/echarts/lib/util/log.js
  var ECHARTS_PREFIX = "[ECharts] ";
  var storedLogs = {};
  var hasConsole = typeof console !== "undefined" && console.warn && console.log;
  function outputLog(type, str, onlyOnce) {
    if (hasConsole) {
      if (onlyOnce) {
        if (storedLogs[str]) {
          return;
        }
        storedLogs[str] = true;
      }
      console[type](ECHARTS_PREFIX + str);
    }
  }
  function log(str, onlyOnce) {
    outputLog("log", str, onlyOnce);
  }
  function warn(str, onlyOnce) {
    outputLog("warn", str, onlyOnce);
  }
  function error(str, onlyOnce) {
    outputLog("error", str, onlyOnce);
  }
  function deprecateLog(str) {
    if (true) {
      outputLog("warn", "DEPRECATED: " + str, true);
    }
  }
  function deprecateReplaceLog(oldOpt, newOpt, scope) {
    if (true) {
      deprecateLog((scope ? "[" + scope + "]" : "") + (oldOpt + " is deprecated, use " + newOpt + " instead."));
    }
  }
  function makePrintable() {
    var hintInfo = [];
    for (var _i = 0; _i < arguments.length; _i++) {
      hintInfo[_i] = arguments[_i];
    }
    var msg = "";
    if (true) {
      var makePrintableStringIfPossible_1 = function(val) {
        return val === void 0 ? "undefined" : val === Infinity ? "Infinity" : val === -Infinity ? "-Infinity" : eqNaN(val) ? "NaN" : val instanceof Date ? "Date(" + val.toISOString() + ")" : isFunction(val) ? "function () { ... }" : isRegExp(val) ? val + "" : null;
      };
      msg = map(hintInfo, function(arg) {
        if (isString(arg)) {
          return arg;
        } else {
          var printableStr = makePrintableStringIfPossible_1(arg);
          if (printableStr != null) {
            return printableStr;
          } else if (typeof JSON !== "undefined" && JSON.stringify) {
            try {
              return JSON.stringify(arg, function(n, val) {
                var printableStr2 = makePrintableStringIfPossible_1(val);
                return printableStr2 == null ? val : printableStr2;
              });
            } catch (err) {
              return "?";
            }
          } else {
            return "?";
          }
        }
      }).join(" ");
    }
    return msg;
  }
  function throwError(msg) {
    throw new Error(msg);
  }

  // node_modules/echarts/lib/util/model.js
  function interpolateNumber2(p0, p1, percent) {
    return (p1 - p0) * percent + p0;
  }
  var DUMMY_COMPONENT_NAME_PREFIX = "series\0";
  var INTERNAL_COMPONENT_ID_PREFIX = "\0_ec_\0";
  function normalizeToArray(value) {
    return value instanceof Array ? value : value == null ? [] : [value];
  }
  function defaultEmphasis(opt, key, subOpts) {
    if (opt) {
      opt[key] = opt[key] || {};
      opt.emphasis = opt.emphasis || {};
      opt.emphasis[key] = opt.emphasis[key] || {};
      for (var i = 0, len2 = subOpts.length; i < len2; i++) {
        var subOptName = subOpts[i];
        if (!opt.emphasis[key].hasOwnProperty(subOptName) && opt[key].hasOwnProperty(subOptName)) {
          opt.emphasis[key][subOptName] = opt[key][subOptName];
        }
      }
    }
  }
  var TEXT_STYLE_OPTIONS = ["fontStyle", "fontWeight", "fontSize", "fontFamily", "rich", "tag", "color", "textBorderColor", "textBorderWidth", "width", "height", "lineHeight", "align", "verticalAlign", "baseline", "shadowColor", "shadowBlur", "shadowOffsetX", "shadowOffsetY", "textShadowColor", "textShadowBlur", "textShadowOffsetX", "textShadowOffsetY", "backgroundColor", "borderColor", "borderWidth", "borderRadius", "padding"];
  function getDataItemValue(dataItem) {
    return isObject(dataItem) && !isArray(dataItem) && !(dataItem instanceof Date) ? dataItem.value : dataItem;
  }
  function isDataItemOption(dataItem) {
    return isObject(dataItem) && !(dataItem instanceof Array);
  }
  function mappingToExists(existings, newCmptOptions, mode) {
    var isNormalMergeMode = mode === "normalMerge";
    var isReplaceMergeMode = mode === "replaceMerge";
    var isReplaceAllMode = mode === "replaceAll";
    existings = existings || [];
    newCmptOptions = (newCmptOptions || []).slice();
    var existingIdIdxMap = createHashMap();
    each(newCmptOptions, function(cmptOption, index) {
      if (!isObject(cmptOption)) {
        newCmptOptions[index] = null;
        return;
      }
      if (true) {
        if (cmptOption.id != null && !isValidIdOrName(cmptOption.id)) {
          warnInvalidateIdOrName(cmptOption.id);
        }
        if (cmptOption.name != null && !isValidIdOrName(cmptOption.name)) {
          warnInvalidateIdOrName(cmptOption.name);
        }
      }
    });
    var result = prepareResult(existings, existingIdIdxMap, mode);
    if (isNormalMergeMode || isReplaceMergeMode) {
      mappingById(result, existings, existingIdIdxMap, newCmptOptions);
    }
    if (isNormalMergeMode) {
      mappingByName(result, newCmptOptions);
    }
    if (isNormalMergeMode || isReplaceMergeMode) {
      mappingByIndex(result, newCmptOptions, isReplaceMergeMode);
    } else if (isReplaceAllMode) {
      mappingInReplaceAllMode(result, newCmptOptions);
    }
    makeIdAndName(result);
    return result;
  }
  function prepareResult(existings, existingIdIdxMap, mode) {
    var result = [];
    if (mode === "replaceAll") {
      return result;
    }
    for (var index = 0; index < existings.length; index++) {
      var existing = existings[index];
      if (existing && existing.id != null) {
        existingIdIdxMap.set(existing.id, index);
      }
      result.push({
        existing: mode === "replaceMerge" || isComponentIdInternal(existing) ? null : existing,
        newOption: null,
        keyInfo: null,
        brandNew: null
      });
    }
    return result;
  }
  function mappingById(result, existings, existingIdIdxMap, newCmptOptions) {
    each(newCmptOptions, function(cmptOption, index) {
      if (!cmptOption || cmptOption.id == null) {
        return;
      }
      var optionId = makeComparableKey(cmptOption.id);
      var existingIdx = existingIdIdxMap.get(optionId);
      if (existingIdx != null) {
        var resultItem = result[existingIdx];
        assert(!resultItem.newOption, 'Duplicated option on id "' + optionId + '".');
        resultItem.newOption = cmptOption;
        resultItem.existing = existings[existingIdx];
        newCmptOptions[index] = null;
      }
    });
  }
  function mappingByName(result, newCmptOptions) {
    each(newCmptOptions, function(cmptOption, index) {
      if (!cmptOption || cmptOption.name == null) {
        return;
      }
      for (var i = 0; i < result.length; i++) {
        var existing = result[i].existing;
        if (!result[i].newOption && existing && (existing.id == null || cmptOption.id == null) && !isComponentIdInternal(cmptOption) && !isComponentIdInternal(existing) && keyExistAndEqual("name", existing, cmptOption)) {
          result[i].newOption = cmptOption;
          newCmptOptions[index] = null;
          return;
        }
      }
    });
  }
  function mappingByIndex(result, newCmptOptions, brandNew) {
    each(newCmptOptions, function(cmptOption) {
      if (!cmptOption) {
        return;
      }
      var resultItem;
      var nextIdx = 0;
      while ((resultItem = result[nextIdx]) && (resultItem.newOption || isComponentIdInternal(resultItem.existing) || resultItem.existing && cmptOption.id != null && !keyExistAndEqual("id", cmptOption, resultItem.existing))) {
        nextIdx++;
      }
      if (resultItem) {
        resultItem.newOption = cmptOption;
        resultItem.brandNew = brandNew;
      } else {
        result.push({
          newOption: cmptOption,
          brandNew,
          existing: null,
          keyInfo: null
        });
      }
      nextIdx++;
    });
  }
  function mappingInReplaceAllMode(result, newCmptOptions) {
    each(newCmptOptions, function(cmptOption) {
      result.push({
        newOption: cmptOption,
        brandNew: true,
        existing: null,
        keyInfo: null
      });
    });
  }
  function makeIdAndName(mapResult) {
    var idMap = createHashMap();
    each(mapResult, function(item) {
      var existing = item.existing;
      existing && idMap.set(existing.id, item);
    });
    each(mapResult, function(item) {
      var opt = item.newOption;
      assert(!opt || opt.id == null || !idMap.get(opt.id) || idMap.get(opt.id) === item, "id duplicates: " + (opt && opt.id));
      opt && opt.id != null && idMap.set(opt.id, item);
      !item.keyInfo && (item.keyInfo = {});
    });
    each(mapResult, function(item, index) {
      var existing = item.existing;
      var opt = item.newOption;
      var keyInfo = item.keyInfo;
      if (!isObject(opt)) {
        return;
      }
      keyInfo.name = opt.name != null ? makeComparableKey(opt.name) : existing ? existing.name : DUMMY_COMPONENT_NAME_PREFIX + index;
      if (existing) {
        keyInfo.id = makeComparableKey(existing.id);
      } else if (opt.id != null) {
        keyInfo.id = makeComparableKey(opt.id);
      } else {
        var idNum = 0;
        do {
          keyInfo.id = "\0" + keyInfo.name + "\0" + idNum++;
        } while (idMap.get(keyInfo.id));
      }
      idMap.set(keyInfo.id, item);
    });
  }
  function keyExistAndEqual(attr, obj1, obj2) {
    var key1 = convertOptionIdName(obj1[attr], null);
    var key2 = convertOptionIdName(obj2[attr], null);
    return key1 != null && key2 != null && key1 === key2;
  }
  function makeComparableKey(val) {
    if (true) {
      if (val == null) {
        throw new Error();
      }
    }
    return convertOptionIdName(val, "");
  }
  function convertOptionIdName(idOrName, defaultValue) {
    if (idOrName == null) {
      return defaultValue;
    }
    return isString(idOrName) ? idOrName : isNumber(idOrName) || isStringSafe(idOrName) ? idOrName + "" : defaultValue;
  }
  function warnInvalidateIdOrName(idOrName) {
    if (true) {
      warn("`" + idOrName + "` is invalid id or name. Must be a string or number.");
    }
  }
  function isValidIdOrName(idOrName) {
    return isStringSafe(idOrName) || isNumeric(idOrName);
  }
  function isNameSpecified(componentModel) {
    var name = componentModel.name;
    return !!(name && name.indexOf(DUMMY_COMPONENT_NAME_PREFIX));
  }
  function isComponentIdInternal(cmptOption) {
    return cmptOption && cmptOption.id != null && makeComparableKey(cmptOption.id).indexOf(INTERNAL_COMPONENT_ID_PREFIX) === 0;
  }
  function makeInternalComponentId(idSuffix) {
    return INTERNAL_COMPONENT_ID_PREFIX + idSuffix;
  }
  function setComponentTypeToKeyInfo(mappingResult, mainType, componentModelCtor) {
    each(mappingResult, function(item) {
      var newOption = item.newOption;
      if (isObject(newOption)) {
        item.keyInfo.mainType = mainType;
        item.keyInfo.subType = determineSubType(mainType, newOption, item.existing, componentModelCtor);
      }
    });
  }
  function determineSubType(mainType, newCmptOption, existComponent, componentModelCtor) {
    var subType = newCmptOption.type ? newCmptOption.type : existComponent ? existComponent.subType : componentModelCtor.determineSubType(mainType, newCmptOption);
    return subType;
  }
  function compressBatches(batchA, batchB) {
    var mapA = {};
    var mapB = {};
    makeMap(batchA || [], mapA);
    makeMap(batchB || [], mapB, mapA);
    return [mapToArray(mapA), mapToArray(mapB)];
    function makeMap(sourceBatch, map3, otherMap) {
      for (var i = 0, len2 = sourceBatch.length; i < len2; i++) {
        var seriesId = convertOptionIdName(sourceBatch[i].seriesId, null);
        if (seriesId == null) {
          return;
        }
        var dataIndices = normalizeToArray(sourceBatch[i].dataIndex);
        var otherDataIndices = otherMap && otherMap[seriesId];
        for (var j = 0, lenj = dataIndices.length; j < lenj; j++) {
          var dataIndex = dataIndices[j];
          if (otherDataIndices && otherDataIndices[dataIndex]) {
            otherDataIndices[dataIndex] = null;
          } else {
            (map3[seriesId] || (map3[seriesId] = {}))[dataIndex] = 1;
          }
        }
      }
    }
    function mapToArray(map3, isData) {
      var result = [];
      for (var i in map3) {
        if (map3.hasOwnProperty(i) && map3[i] != null) {
          if (isData) {
            result.push(+i);
          } else {
            var dataIndices = mapToArray(map3[i], true);
            dataIndices.length && result.push({
              seriesId: i,
              dataIndex: dataIndices
            });
          }
        }
      }
      return result;
    }
  }
  function queryDataIndex(data, payload) {
    if (payload.dataIndexInside != null) {
      return payload.dataIndexInside;
    } else if (payload.dataIndex != null) {
      return isArray(payload.dataIndex) ? map(payload.dataIndex, function(value) {
        return data.indexOfRawIndex(value);
      }) : data.indexOfRawIndex(payload.dataIndex);
    } else if (payload.name != null) {
      return isArray(payload.name) ? map(payload.name, function(value) {
        return data.indexOfName(value);
      }) : data.indexOfName(payload.name);
    }
  }
  function makeInner() {
    var key = "__ec_inner_" + innerUniqueIndex++;
    return function(hostObj) {
      return hostObj[key] || (hostObj[key] = {});
    };
  }
  var innerUniqueIndex = getRandomIdBase();
  function parseFinder(ecModel, finderInput, opt) {
    var _a2 = preParseFinder(finderInput, opt), mainTypeSpecified = _a2.mainTypeSpecified, queryOptionMap = _a2.queryOptionMap, others = _a2.others;
    var result = others;
    var defaultMainType = opt ? opt.defaultMainType : null;
    if (!mainTypeSpecified && defaultMainType) {
      queryOptionMap.set(defaultMainType, {});
    }
    queryOptionMap.each(function(queryOption, mainType) {
      var queryResult = queryReferringComponents(ecModel, mainType, queryOption, {
        useDefault: defaultMainType === mainType,
        enableAll: opt && opt.enableAll != null ? opt.enableAll : true,
        enableNone: opt && opt.enableNone != null ? opt.enableNone : true
      });
      result[mainType + "Models"] = queryResult.models;
      result[mainType + "Model"] = queryResult.models[0];
    });
    return result;
  }
  function preParseFinder(finderInput, opt) {
    var finder;
    if (isString(finderInput)) {
      var obj = {};
      obj[finderInput + "Index"] = 0;
      finder = obj;
    } else {
      finder = finderInput;
    }
    var queryOptionMap = createHashMap();
    var others = {};
    var mainTypeSpecified = false;
    each(finder, function(value, key) {
      if (key === "dataIndex" || key === "dataIndexInside") {
        others[key] = value;
        return;
      }
      var parsedKey = key.match(/^(\w+)(Index|Id|Name)$/) || [];
      var mainType = parsedKey[1];
      var queryType = (parsedKey[2] || "").toLowerCase();
      if (!mainType || !queryType || opt && opt.includeMainTypes && indexOf(opt.includeMainTypes, mainType) < 0) {
        return;
      }
      mainTypeSpecified = mainTypeSpecified || !!mainType;
      var queryOption = queryOptionMap.get(mainType) || queryOptionMap.set(mainType, {});
      queryOption[queryType] = value;
    });
    return {
      mainTypeSpecified,
      queryOptionMap,
      others
    };
  }
  var SINGLE_REFERRING = {
    useDefault: true,
    enableAll: false,
    enableNone: false
  };
  var MULTIPLE_REFERRING = {
    useDefault: false,
    enableAll: true,
    enableNone: true
  };
  function queryReferringComponents(ecModel, mainType, userOption, opt) {
    opt = opt || SINGLE_REFERRING;
    var indexOption = userOption.index;
    var idOption = userOption.id;
    var nameOption = userOption.name;
    var result = {
      models: null,
      specified: indexOption != null || idOption != null || nameOption != null
    };
    if (!result.specified) {
      var firstCmpt = void 0;
      result.models = opt.useDefault && (firstCmpt = ecModel.getComponent(mainType)) ? [firstCmpt] : [];
      return result;
    }
    if (indexOption === "none" || indexOption === false) {
      assert(opt.enableNone, '`"none"` or `false` is not a valid value on index option.');
      result.models = [];
      return result;
    }
    if (indexOption === "all") {
      assert(opt.enableAll, '`"all"` is not a valid value on index option.');
      indexOption = idOption = nameOption = null;
    }
    result.models = ecModel.queryComponents({
      mainType,
      index: indexOption,
      id: idOption,
      name: nameOption
    });
    return result;
  }
  function setAttribute(dom, key, value) {
    dom.setAttribute ? dom.setAttribute(key, value) : dom[key] = value;
  }
  function getAttribute(dom, key) {
    return dom.getAttribute ? dom.getAttribute(key) : dom[key];
  }
  function getTooltipRenderMode(renderModeOption) {
    if (renderModeOption === "auto") {
      return env_default.domSupported ? "html" : "richText";
    } else {
      return renderModeOption || "html";
    }
  }
  function groupData(array, getKey2) {
    var buckets = createHashMap();
    var keys2 = [];
    each(array, function(item) {
      var key = getKey2(item);
      (buckets.get(key) || (keys2.push(key), buckets.set(key, []))).push(item);
    });
    return {
      keys: keys2,
      buckets
    };
  }
  function interpolateRawValues(data, precision, sourceValue, targetValue, percent) {
    var isAutoPrecision = precision == null || precision === "auto";
    if (targetValue == null) {
      return targetValue;
    }
    if (isNumber(targetValue)) {
      var value = interpolateNumber2(sourceValue || 0, targetValue, percent);
      return round(value, isAutoPrecision ? Math.max(getPrecision(sourceValue || 0), getPrecision(targetValue)) : precision);
    } else if (isString(targetValue)) {
      return percent < 1 ? sourceValue : targetValue;
    } else {
      var interpolated = [];
      var leftArr = sourceValue;
      var rightArr = targetValue;
      var length_1 = Math.max(leftArr ? leftArr.length : 0, rightArr.length);
      for (var i = 0; i < length_1; ++i) {
        var info = data.getDimensionInfo(i);
        if (info && info.type === "ordinal") {
          interpolated[i] = (percent < 1 && leftArr ? leftArr : rightArr)[i];
        } else {
          var leftVal = leftArr && leftArr[i] ? leftArr[i] : 0;
          var rightVal = rightArr[i];
          var value = interpolateNumber2(leftVal, rightVal, percent);
          interpolated[i] = round(value, isAutoPrecision ? Math.max(getPrecision(leftVal), getPrecision(rightVal)) : precision);
        }
      }
      return interpolated;
    }
  }

  // node_modules/echarts/lib/util/clazz.js
  var TYPE_DELIMITER = ".";
  var IS_CONTAINER = "___EC__COMPONENT__CONTAINER___";
  var IS_EXTENDED_CLASS = "___EC__EXTENDED_CLASS___";
  function parseClassType(componentType) {
    var ret = {
      main: "",
      sub: ""
    };
    if (componentType) {
      var typeArr = componentType.split(TYPE_DELIMITER);
      ret.main = typeArr[0] || "";
      ret.sub = typeArr[1] || "";
    }
    return ret;
  }
  function checkClassType(componentType) {
    assert(/^[a-zA-Z0-9_]+([.][a-zA-Z0-9_]+)?$/.test(componentType), 'componentType "' + componentType + '" illegal');
  }
  function isExtendedClass(clz) {
    return !!(clz && clz[IS_EXTENDED_CLASS]);
  }
  function enableClassExtend(rootClz, mandatoryMethods) {
    rootClz.$constructor = rootClz;
    rootClz.extend = function(proto2) {
      if (true) {
        each(mandatoryMethods, function(method) {
          if (!proto2[method]) {
            console.warn("Method `" + method + "` should be implemented" + (proto2.type ? " in " + proto2.type : "") + ".");
          }
        });
      }
      var superClass = this;
      var ExtendedClass;
      if (isESClass(superClass)) {
        ExtendedClass = function(_super) {
          __extends(class_1, _super);
          function class_1() {
            return _super.apply(this, arguments) || this;
          }
          return class_1;
        }(superClass);
      } else {
        ExtendedClass = function() {
          (proto2.$constructor || superClass).apply(this, arguments);
        };
        inherits(ExtendedClass, this);
      }
      extend(ExtendedClass.prototype, proto2);
      ExtendedClass[IS_EXTENDED_CLASS] = true;
      ExtendedClass.extend = this.extend;
      ExtendedClass.superCall = superCall;
      ExtendedClass.superApply = superApply;
      ExtendedClass.superClass = superClass;
      return ExtendedClass;
    };
  }
  function isESClass(fn) {
    return isFunction(fn) && /^class\s/.test(Function.prototype.toString.call(fn));
  }
  function mountExtend(SubClz, SupperClz) {
    SubClz.extend = SupperClz.extend;
  }
  var classBase = Math.round(Math.random() * 10);
  function enableClassCheck(target) {
    var classAttr = ["__\0is_clz", classBase++].join("_");
    target.prototype[classAttr] = true;
    if (true) {
      assert(!target.isInstance, 'The method "is" can not be defined.');
    }
    target.isInstance = function(obj) {
      return !!(obj && obj[classAttr]);
    };
  }
  function superCall(context, methodName) {
    var args = [];
    for (var _i = 2; _i < arguments.length; _i++) {
      args[_i - 2] = arguments[_i];
    }
    return this.superClass.prototype[methodName].apply(context, args);
  }
  function superApply(context, methodName, args) {
    return this.superClass.prototype[methodName].apply(context, args);
  }
  function enableClassManagement(target) {
    var storage2 = {};
    target.registerClass = function(clz) {
      var componentFullType = clz.type || clz.prototype.type;
      if (componentFullType) {
        checkClassType(componentFullType);
        clz.prototype.type = componentFullType;
        var componentTypeInfo = parseClassType(componentFullType);
        if (!componentTypeInfo.sub) {
          if (true) {
            if (storage2[componentTypeInfo.main]) {
              console.warn(componentTypeInfo.main + " exists.");
            }
          }
          storage2[componentTypeInfo.main] = clz;
        } else if (componentTypeInfo.sub !== IS_CONTAINER) {
          var container = makeContainer(componentTypeInfo);
          container[componentTypeInfo.sub] = clz;
        }
      }
      return clz;
    };
    target.getClass = function(mainType, subType, throwWhenNotFound) {
      var clz = storage2[mainType];
      if (clz && clz[IS_CONTAINER]) {
        clz = subType ? clz[subType] : null;
      }
      if (throwWhenNotFound && !clz) {
        throw new Error(!subType ? mainType + ".type should be specified." : "Component " + mainType + "." + (subType || "") + " is used but not imported.");
      }
      return clz;
    };
    target.getClassesByMainType = function(componentType) {
      var componentTypeInfo = parseClassType(componentType);
      var result = [];
      var obj = storage2[componentTypeInfo.main];
      if (obj && obj[IS_CONTAINER]) {
        each(obj, function(o, type) {
          type !== IS_CONTAINER && result.push(o);
        });
      } else {
        result.push(obj);
      }
      return result;
    };
    target.hasClass = function(componentType) {
      var componentTypeInfo = parseClassType(componentType);
      return !!storage2[componentTypeInfo.main];
    };
    target.getAllClassMainTypes = function() {
      var types = [];
      each(storage2, function(obj, type) {
        types.push(type);
      });
      return types;
    };
    target.hasSubTypes = function(componentType) {
      var componentTypeInfo = parseClassType(componentType);
      var obj = storage2[componentTypeInfo.main];
      return obj && obj[IS_CONTAINER];
    };
    function makeContainer(componentTypeInfo) {
      var container = storage2[componentTypeInfo.main];
      if (!container || !container[IS_CONTAINER]) {
        container = storage2[componentTypeInfo.main] = {};
        container[IS_CONTAINER] = true;
      }
      return container;
    }
  }

  // node_modules/echarts/lib/model/mixin/makeStyleMapper.js
  function makeStyleMapper(properties, ignoreParent) {
    for (var i = 0; i < properties.length; i++) {
      if (!properties[i][1]) {
        properties[i][1] = properties[i][0];
      }
    }
    ignoreParent = ignoreParent || false;
    return function(model, excludes, includes) {
      var style = {};
      for (var i2 = 0; i2 < properties.length; i2++) {
        var propName = properties[i2][1];
        if (excludes && indexOf(excludes, propName) >= 0 || includes && indexOf(includes, propName) < 0) {
          continue;
        }
        var val = model.getShallow(propName, ignoreParent);
        if (val != null) {
          style[properties[i2][0]] = val;
        }
      }
      return style;
    };
  }

  // node_modules/echarts/lib/model/mixin/areaStyle.js
  var AREA_STYLE_KEY_MAP = [
    ["fill", "color"],
    ["shadowBlur"],
    ["shadowOffsetX"],
    ["shadowOffsetY"],
    ["opacity"],
    ["shadowColor"]
  ];
  var getAreaStyle = makeStyleMapper(AREA_STYLE_KEY_MAP);
  var AreaStyleMixin = function() {
    function AreaStyleMixin2() {
    }
    AreaStyleMixin2.prototype.getAreaStyle = function(excludes, includes) {
      return getAreaStyle(this, excludes, includes);
    };
    return AreaStyleMixin2;
  }();

  // node_modules/zrender/lib/graphic/helper/image.js
  var globalImageCache = new LRU_default(50);
  function findExistImage(newImageOrSrc) {
    if (typeof newImageOrSrc === "string") {
      var cachedImgObj = globalImageCache.get(newImageOrSrc);
      return cachedImgObj && cachedImgObj.image;
    } else {
      return newImageOrSrc;
    }
  }
  function createOrUpdateImage(newImageOrSrc, image, hostEl, onload, cbPayload) {
    if (!newImageOrSrc) {
      return image;
    } else if (typeof newImageOrSrc === "string") {
      if (image && image.__zrImageSrc === newImageOrSrc || !hostEl) {
        return image;
      }
      var cachedImgObj = globalImageCache.get(newImageOrSrc);
      var pendingWrap = { hostEl, cb: onload, cbPayload };
      if (cachedImgObj) {
        image = cachedImgObj.image;
        !isImageReady(image) && cachedImgObj.pending.push(pendingWrap);
      } else {
        image = platformApi.loadImage(newImageOrSrc, imageOnLoad, imageOnLoad);
        image.__zrImageSrc = newImageOrSrc;
        globalImageCache.put(newImageOrSrc, image.__cachedImgObj = {
          image,
          pending: [pendingWrap]
        });
      }
      return image;
    } else {
      return newImageOrSrc;
    }
  }
  function imageOnLoad() {
    var cachedImgObj = this.__cachedImgObj;
    this.onload = this.onerror = this.__cachedImgObj = null;
    for (var i = 0; i < cachedImgObj.pending.length; i++) {
      var pendingWrap = cachedImgObj.pending[i];
      var cb = pendingWrap.cb;
      cb && cb(this, pendingWrap.cbPayload);
      pendingWrap.hostEl.dirty();
    }
    cachedImgObj.pending.length = 0;
  }
  function isImageReady(image) {
    return image && image.width && image.height;
  }

  // node_modules/zrender/lib/graphic/helper/parseText.js
  var STYLE_REG = /\{([a-zA-Z0-9_]+)\|([^}]*)\}/g;
  function truncateText(text, containerWidth, font, ellipsis, options) {
    if (!containerWidth) {
      return "";
    }
    var textLines = (text + "").split("\n");
    options = prepareTruncateOptions(containerWidth, font, ellipsis, options);
    for (var i = 0, len2 = textLines.length; i < len2; i++) {
      textLines[i] = truncateSingleLine(textLines[i], options);
    }
    return textLines.join("\n");
  }
  function prepareTruncateOptions(containerWidth, font, ellipsis, options) {
    options = options || {};
    var preparedOpts = extend({}, options);
    preparedOpts.font = font;
    ellipsis = retrieve2(ellipsis, "...");
    preparedOpts.maxIterations = retrieve2(options.maxIterations, 2);
    var minChar = preparedOpts.minChar = retrieve2(options.minChar, 0);
    preparedOpts.cnCharWidth = getWidth("国", font);
    var ascCharWidth = preparedOpts.ascCharWidth = getWidth("a", font);
    preparedOpts.placeholder = retrieve2(options.placeholder, "");
    var contentWidth = containerWidth = Math.max(0, containerWidth - 1);
    for (var i = 0; i < minChar && contentWidth >= ascCharWidth; i++) {
      contentWidth -= ascCharWidth;
    }
    var ellipsisWidth = getWidth(ellipsis, font);
    if (ellipsisWidth > contentWidth) {
      ellipsis = "";
      ellipsisWidth = 0;
    }
    contentWidth = containerWidth - ellipsisWidth;
    preparedOpts.ellipsis = ellipsis;
    preparedOpts.ellipsisWidth = ellipsisWidth;
    preparedOpts.contentWidth = contentWidth;
    preparedOpts.containerWidth = containerWidth;
    return preparedOpts;
  }
  function truncateSingleLine(textLine, options) {
    var containerWidth = options.containerWidth;
    var font = options.font;
    var contentWidth = options.contentWidth;
    if (!containerWidth) {
      return "";
    }
    var lineWidth = getWidth(textLine, font);
    if (lineWidth <= containerWidth) {
      return textLine;
    }
    for (var j = 0; ; j++) {
      if (lineWidth <= contentWidth || j >= options.maxIterations) {
        textLine += options.ellipsis;
        break;
      }
      var subLength = j === 0 ? estimateLength(textLine, contentWidth, options.ascCharWidth, options.cnCharWidth) : lineWidth > 0 ? Math.floor(textLine.length * contentWidth / lineWidth) : 0;
      textLine = textLine.substr(0, subLength);
      lineWidth = getWidth(textLine, font);
    }
    if (textLine === "") {
      textLine = options.placeholder;
    }
    return textLine;
  }
  function estimateLength(text, contentWidth, ascCharWidth, cnCharWidth) {
    var width = 0;
    var i = 0;
    for (var len2 = text.length; i < len2 && width < contentWidth; i++) {
      var charCode = text.charCodeAt(i);
      width += 0 <= charCode && charCode <= 127 ? ascCharWidth : cnCharWidth;
    }
    return i;
  }
  function parsePlainText(text, style) {
    text != null && (text += "");
    var overflow = style.overflow;
    var padding = style.padding;
    var font = style.font;
    var truncate = overflow === "truncate";
    var calculatedLineHeight = getLineHeight(font);
    var lineHeight = retrieve2(style.lineHeight, calculatedLineHeight);
    var bgColorDrawn = !!style.backgroundColor;
    var truncateLineOverflow = style.lineOverflow === "truncate";
    var width = style.width;
    var lines;
    if (width != null && (overflow === "break" || overflow === "breakAll")) {
      lines = text ? wrapText(text, style.font, width, overflow === "breakAll", 0).lines : [];
    } else {
      lines = text ? text.split("\n") : [];
    }
    var contentHeight = lines.length * lineHeight;
    var height = retrieve2(style.height, contentHeight);
    if (contentHeight > height && truncateLineOverflow) {
      var lineCount = Math.floor(height / lineHeight);
      lines = lines.slice(0, lineCount);
    }
    if (text && truncate && width != null) {
      var options = prepareTruncateOptions(width, font, style.ellipsis, {
        minChar: style.truncateMinChar,
        placeholder: style.placeholder
      });
      for (var i = 0; i < lines.length; i++) {
        lines[i] = truncateSingleLine(lines[i], options);
      }
    }
    var outerHeight = height;
    var contentWidth = 0;
    for (var i = 0; i < lines.length; i++) {
      contentWidth = Math.max(getWidth(lines[i], font), contentWidth);
    }
    if (width == null) {
      width = contentWidth;
    }
    var outerWidth = contentWidth;
    if (padding) {
      outerHeight += padding[0] + padding[2];
      outerWidth += padding[1] + padding[3];
      width += padding[1] + padding[3];
    }
    if (bgColorDrawn) {
      outerWidth = width;
    }
    return {
      lines,
      height,
      outerWidth,
      outerHeight,
      lineHeight,
      calculatedLineHeight,
      contentWidth,
      contentHeight,
      width
    };
  }
  var RichTextToken = function() {
    function RichTextToken2() {
    }
    return RichTextToken2;
  }();
  var RichTextLine = function() {
    function RichTextLine2(tokens) {
      this.tokens = [];
      if (tokens) {
        this.tokens = tokens;
      }
    }
    return RichTextLine2;
  }();
  var RichTextContentBlock = function() {
    function RichTextContentBlock2() {
      this.width = 0;
      this.height = 0;
      this.contentWidth = 0;
      this.contentHeight = 0;
      this.outerWidth = 0;
      this.outerHeight = 0;
      this.lines = [];
    }
    return RichTextContentBlock2;
  }();
  function parseRichText(text, style) {
    var contentBlock = new RichTextContentBlock();
    text != null && (text += "");
    if (!text) {
      return contentBlock;
    }
    var topWidth = style.width;
    var topHeight = style.height;
    var overflow = style.overflow;
    var wrapInfo = (overflow === "break" || overflow === "breakAll") && topWidth != null ? { width: topWidth, accumWidth: 0, breakAll: overflow === "breakAll" } : null;
    var lastIndex = STYLE_REG.lastIndex = 0;
    var result;
    while ((result = STYLE_REG.exec(text)) != null) {
      var matchedIndex = result.index;
      if (matchedIndex > lastIndex) {
        pushTokens(contentBlock, text.substring(lastIndex, matchedIndex), style, wrapInfo);
      }
      pushTokens(contentBlock, result[2], style, wrapInfo, result[1]);
      lastIndex = STYLE_REG.lastIndex;
    }
    if (lastIndex < text.length) {
      pushTokens(contentBlock, text.substring(lastIndex, text.length), style, wrapInfo);
    }
    var pendingList = [];
    var calculatedHeight = 0;
    var calculatedWidth = 0;
    var stlPadding = style.padding;
    var truncate = overflow === "truncate";
    var truncateLine = style.lineOverflow === "truncate";
    function finishLine(line2, lineWidth2, lineHeight2) {
      line2.width = lineWidth2;
      line2.lineHeight = lineHeight2;
      calculatedHeight += lineHeight2;
      calculatedWidth = Math.max(calculatedWidth, lineWidth2);
    }
    outer:
      for (var i = 0; i < contentBlock.lines.length; i++) {
        var line = contentBlock.lines[i];
        var lineHeight = 0;
        var lineWidth = 0;
        for (var j = 0; j < line.tokens.length; j++) {
          var token = line.tokens[j];
          var tokenStyle = token.styleName && style.rich[token.styleName] || {};
          var textPadding = token.textPadding = tokenStyle.padding;
          var paddingH = textPadding ? textPadding[1] + textPadding[3] : 0;
          var font = token.font = tokenStyle.font || style.font;
          token.contentHeight = getLineHeight(font);
          var tokenHeight = retrieve2(tokenStyle.height, token.contentHeight);
          token.innerHeight = tokenHeight;
          textPadding && (tokenHeight += textPadding[0] + textPadding[2]);
          token.height = tokenHeight;
          token.lineHeight = retrieve3(tokenStyle.lineHeight, style.lineHeight, tokenHeight);
          token.align = tokenStyle && tokenStyle.align || style.align;
          token.verticalAlign = tokenStyle && tokenStyle.verticalAlign || "middle";
          if (truncateLine && topHeight != null && calculatedHeight + token.lineHeight > topHeight) {
            if (j > 0) {
              line.tokens = line.tokens.slice(0, j);
              finishLine(line, lineWidth, lineHeight);
              contentBlock.lines = contentBlock.lines.slice(0, i + 1);
            } else {
              contentBlock.lines = contentBlock.lines.slice(0, i);
            }
            break outer;
          }
          var styleTokenWidth = tokenStyle.width;
          var tokenWidthNotSpecified = styleTokenWidth == null || styleTokenWidth === "auto";
          if (typeof styleTokenWidth === "string" && styleTokenWidth.charAt(styleTokenWidth.length - 1) === "%") {
            token.percentWidth = styleTokenWidth;
            pendingList.push(token);
            token.contentWidth = getWidth(token.text, font);
          } else {
            if (tokenWidthNotSpecified) {
              var textBackgroundColor = tokenStyle.backgroundColor;
              var bgImg = textBackgroundColor && textBackgroundColor.image;
              if (bgImg) {
                bgImg = findExistImage(bgImg);
                if (isImageReady(bgImg)) {
                  token.width = Math.max(token.width, bgImg.width * tokenHeight / bgImg.height);
                }
              }
            }
            var remainTruncWidth = truncate && topWidth != null ? topWidth - lineWidth : null;
            if (remainTruncWidth != null && remainTruncWidth < token.width) {
              if (!tokenWidthNotSpecified || remainTruncWidth < paddingH) {
                token.text = "";
                token.width = token.contentWidth = 0;
              } else {
                token.text = truncateText(token.text, remainTruncWidth - paddingH, font, style.ellipsis, { minChar: style.truncateMinChar });
                token.width = token.contentWidth = getWidth(token.text, font);
              }
            } else {
              token.contentWidth = getWidth(token.text, font);
            }
          }
          token.width += paddingH;
          lineWidth += token.width;
          tokenStyle && (lineHeight = Math.max(lineHeight, token.lineHeight));
        }
        finishLine(line, lineWidth, lineHeight);
      }
    contentBlock.outerWidth = contentBlock.width = retrieve2(topWidth, calculatedWidth);
    contentBlock.outerHeight = contentBlock.height = retrieve2(topHeight, calculatedHeight);
    contentBlock.contentHeight = calculatedHeight;
    contentBlock.contentWidth = calculatedWidth;
    if (stlPadding) {
      contentBlock.outerWidth += stlPadding[1] + stlPadding[3];
      contentBlock.outerHeight += stlPadding[0] + stlPadding[2];
    }
    for (var i = 0; i < pendingList.length; i++) {
      var token = pendingList[i];
      var percentWidth = token.percentWidth;
      token.width = parseInt(percentWidth, 10) / 100 * contentBlock.width;
    }
    return contentBlock;
  }
  function pushTokens(block, str, style, wrapInfo, styleName) {
    var isEmptyStr = str === "";
    var tokenStyle = styleName && style.rich[styleName] || {};
    var lines = block.lines;
    var font = tokenStyle.font || style.font;
    var newLine = false;
    var strLines;
    var linesWidths;
    if (wrapInfo) {
      var tokenPadding = tokenStyle.padding;
      var tokenPaddingH = tokenPadding ? tokenPadding[1] + tokenPadding[3] : 0;
      if (tokenStyle.width != null && tokenStyle.width !== "auto") {
        var outerWidth_1 = parsePercent(tokenStyle.width, wrapInfo.width) + tokenPaddingH;
        if (lines.length > 0) {
          if (outerWidth_1 + wrapInfo.accumWidth > wrapInfo.width) {
            strLines = str.split("\n");
            newLine = true;
          }
        }
        wrapInfo.accumWidth = outerWidth_1;
      } else {
        var res = wrapText(str, font, wrapInfo.width, wrapInfo.breakAll, wrapInfo.accumWidth);
        wrapInfo.accumWidth = res.accumWidth + tokenPaddingH;
        linesWidths = res.linesWidths;
        strLines = res.lines;
      }
    } else {
      strLines = str.split("\n");
    }
    for (var i = 0; i < strLines.length; i++) {
      var text = strLines[i];
      var token = new RichTextToken();
      token.styleName = styleName;
      token.text = text;
      token.isLineHolder = !text && !isEmptyStr;
      if (typeof tokenStyle.width === "number") {
        token.width = tokenStyle.width;
      } else {
        token.width = linesWidths ? linesWidths[i] : getWidth(text, font);
      }
      if (!i && !newLine) {
        var tokens = (lines[lines.length - 1] || (lines[0] = new RichTextLine())).tokens;
        var tokensLen = tokens.length;
        tokensLen === 1 && tokens[0].isLineHolder ? tokens[0] = token : (text || !tokensLen || isEmptyStr) && tokens.push(token);
      } else {
        lines.push(new RichTextLine([token]));
      }
    }
  }
  function isLatin(ch) {
    var code = ch.charCodeAt(0);
    return code >= 33 && code <= 383;
  }
  var breakCharMap = reduce(",&?/;] ".split(""), function(obj, ch) {
    obj[ch] = true;
    return obj;
  }, {});
  function isWordBreakChar(ch) {
    if (isLatin(ch)) {
      if (breakCharMap[ch]) {
        return true;
      }
      return false;
    }
    return true;
  }
  function wrapText(text, font, lineWidth, isBreakAll, lastAccumWidth) {
    var lines = [];
    var linesWidths = [];
    var line = "";
    var currentWord = "";
    var currentWordWidth = 0;
    var accumWidth = 0;
    for (var i = 0; i < text.length; i++) {
      var ch = text.charAt(i);
      if (ch === "\n") {
        if (currentWord) {
          line += currentWord;
          accumWidth += currentWordWidth;
        }
        lines.push(line);
        linesWidths.push(accumWidth);
        line = "";
        currentWord = "";
        currentWordWidth = 0;
        accumWidth = 0;
        continue;
      }
      var chWidth = getWidth(ch, font);
      var inWord = isBreakAll ? false : !isWordBreakChar(ch);
      if (!lines.length ? lastAccumWidth + accumWidth + chWidth > lineWidth : accumWidth + chWidth > lineWidth) {
        if (!accumWidth) {
          if (inWord) {
            lines.push(currentWord);
            linesWidths.push(currentWordWidth);
            currentWord = ch;
            currentWordWidth = chWidth;
          } else {
            lines.push(ch);
            linesWidths.push(chWidth);
          }
        } else if (line || currentWord) {
          if (inWord) {
            if (!line) {
              line = currentWord;
              currentWord = "";
              currentWordWidth = 0;
              accumWidth = currentWordWidth;
            }
            lines.push(line);
            linesWidths.push(accumWidth - currentWordWidth);
            currentWord += ch;
            currentWordWidth += chWidth;
            line = "";
            accumWidth = currentWordWidth;
          } else {
            if (currentWord) {
              line += currentWord;
              currentWord = "";
              currentWordWidth = 0;
            }
            lines.push(line);
            linesWidths.push(accumWidth);
            line = ch;
            accumWidth = chWidth;
          }
        }
        continue;
      }
      accumWidth += chWidth;
      if (inWord) {
        currentWord += ch;
        currentWordWidth += chWidth;
      } else {
        if (currentWord) {
          line += currentWord;
          currentWord = "";
          currentWordWidth = 0;
        }
        line += ch;
      }
    }
    if (!lines.length && !line) {
      line = text;
      currentWord = "";
      currentWordWidth = 0;
    }
    if (currentWord) {
      line += currentWord;
    }
    if (line) {
      lines.push(line);
      linesWidths.push(accumWidth);
    }
    if (lines.length === 1) {
      accumWidth += lastAccumWidth;
    }
    return {
      accumWidth,
      lines,
      linesWidths
    };
  }

  // node_modules/zrender/lib/graphic/Displayable.js
  var STYLE_MAGIC_KEY = "__zr_style_" + Math.round(Math.random() * 10);
  var DEFAULT_COMMON_STYLE = {
    shadowBlur: 0,
    shadowOffsetX: 0,
    shadowOffsetY: 0,
    shadowColor: "#000",
    opacity: 1,
    blend: "source-over"
  };
  var DEFAULT_COMMON_ANIMATION_PROPS = {
    style: {
      shadowBlur: true,
      shadowOffsetX: true,
      shadowOffsetY: true,
      shadowColor: true,
      opacity: true
    }
  };
  DEFAULT_COMMON_STYLE[STYLE_MAGIC_KEY] = true;
  var PRIMARY_STATES_KEYS2 = ["z", "z2", "invisible"];
  var PRIMARY_STATES_KEYS_IN_HOVER_LAYER = ["invisible"];
  var Displayable = function(_super) {
    __extends2(Displayable2, _super);
    function Displayable2(props) {
      return _super.call(this, props) || this;
    }
    Displayable2.prototype._init = function(props) {
      var keysArr = keys(props);
      for (var i = 0; i < keysArr.length; i++) {
        var key = keysArr[i];
        if (key === "style") {
          this.useStyle(props[key]);
        } else {
          _super.prototype.attrKV.call(this, key, props[key]);
        }
      }
      if (!this.style) {
        this.useStyle({});
      }
    };
    Displayable2.prototype.beforeBrush = function() {
    };
    Displayable2.prototype.afterBrush = function() {
    };
    Displayable2.prototype.innerBeforeBrush = function() {
    };
    Displayable2.prototype.innerAfterBrush = function() {
    };
    Displayable2.prototype.shouldBePainted = function(viewWidth, viewHeight, considerClipPath, considerAncestors) {
      var m2 = this.transform;
      if (this.ignore || this.invisible || this.style.opacity === 0 || this.culling && isDisplayableCulled(this, viewWidth, viewHeight) || m2 && !m2[0] && !m2[3]) {
        return false;
      }
      if (considerClipPath && this.__clipPaths) {
        for (var i = 0; i < this.__clipPaths.length; ++i) {
          if (this.__clipPaths[i].isZeroArea()) {
            return false;
          }
        }
      }
      if (considerAncestors && this.parent) {
        var parent_1 = this.parent;
        while (parent_1) {
          if (parent_1.ignore) {
            return false;
          }
          parent_1 = parent_1.parent;
        }
      }
      return true;
    };
    Displayable2.prototype.contain = function(x, y) {
      return this.rectContain(x, y);
    };
    Displayable2.prototype.traverse = function(cb, context) {
      cb.call(context, this);
    };
    Displayable2.prototype.rectContain = function(x, y) {
      var coord = this.transformCoordToLocal(x, y);
      var rect = this.getBoundingRect();
      return rect.contain(coord[0], coord[1]);
    };
    Displayable2.prototype.getPaintRect = function() {
      var rect = this._paintRect;
      if (!this._paintRect || this.__dirty) {
        var transform2 = this.transform;
        var elRect = this.getBoundingRect();
        var style = this.style;
        var shadowSize = style.shadowBlur || 0;
        var shadowOffsetX = style.shadowOffsetX || 0;
        var shadowOffsetY = style.shadowOffsetY || 0;
        rect = this._paintRect || (this._paintRect = new BoundingRect_default(0, 0, 0, 0));
        if (transform2) {
          BoundingRect_default.applyTransform(rect, elRect, transform2);
        } else {
          rect.copy(elRect);
        }
        if (shadowSize || shadowOffsetX || shadowOffsetY) {
          rect.width += shadowSize * 2 + Math.abs(shadowOffsetX);
          rect.height += shadowSize * 2 + Math.abs(shadowOffsetY);
          rect.x = Math.min(rect.x, rect.x + shadowOffsetX - shadowSize);
          rect.y = Math.min(rect.y, rect.y + shadowOffsetY - shadowSize);
        }
        var tolerance = this.dirtyRectTolerance;
        if (!rect.isZero()) {
          rect.x = Math.floor(rect.x - tolerance);
          rect.y = Math.floor(rect.y - tolerance);
          rect.width = Math.ceil(rect.width + 1 + tolerance * 2);
          rect.height = Math.ceil(rect.height + 1 + tolerance * 2);
        }
      }
      return rect;
    };
    Displayable2.prototype.setPrevPaintRect = function(paintRect) {
      if (paintRect) {
        this._prevPaintRect = this._prevPaintRect || new BoundingRect_default(0, 0, 0, 0);
        this._prevPaintRect.copy(paintRect);
      } else {
        this._prevPaintRect = null;
      }
    };
    Displayable2.prototype.getPrevPaintRect = function() {
      return this._prevPaintRect;
    };
    Displayable2.prototype.animateStyle = function(loop) {
      return this.animate("style", loop);
    };
    Displayable2.prototype.updateDuringAnimation = function(targetKey) {
      if (targetKey === "style") {
        this.dirtyStyle();
      } else {
        this.markRedraw();
      }
    };
    Displayable2.prototype.attrKV = function(key, value) {
      if (key !== "style") {
        _super.prototype.attrKV.call(this, key, value);
      } else {
        if (!this.style) {
          this.useStyle(value);
        } else {
          this.setStyle(value);
        }
      }
    };
    Displayable2.prototype.setStyle = function(keyOrObj, value) {
      if (typeof keyOrObj === "string") {
        this.style[keyOrObj] = value;
      } else {
        extend(this.style, keyOrObj);
      }
      this.dirtyStyle();
      return this;
    };
    Displayable2.prototype.dirtyStyle = function(notRedraw) {
      if (!notRedraw) {
        this.markRedraw();
      }
      this.__dirty |= STYLE_CHANGED_BIT;
      if (this._rect) {
        this._rect = null;
      }
    };
    Displayable2.prototype.dirty = function() {
      this.dirtyStyle();
    };
    Displayable2.prototype.styleChanged = function() {
      return !!(this.__dirty & STYLE_CHANGED_BIT);
    };
    Displayable2.prototype.styleUpdated = function() {
      this.__dirty &= ~STYLE_CHANGED_BIT;
    };
    Displayable2.prototype.createStyle = function(obj) {
      return createObject(DEFAULT_COMMON_STYLE, obj);
    };
    Displayable2.prototype.useStyle = function(obj) {
      if (!obj[STYLE_MAGIC_KEY]) {
        obj = this.createStyle(obj);
      }
      if (this.__inHover) {
        this.__hoverStyle = obj;
      } else {
        this.style = obj;
      }
      this.dirtyStyle();
    };
    Displayable2.prototype.isStyleObject = function(obj) {
      return obj[STYLE_MAGIC_KEY];
    };
    Displayable2.prototype._innerSaveToNormal = function(toState) {
      _super.prototype._innerSaveToNormal.call(this, toState);
      var normalState = this._normalState;
      if (toState.style && !normalState.style) {
        normalState.style = this._mergeStyle(this.createStyle(), this.style);
      }
      this._savePrimaryToNormal(toState, normalState, PRIMARY_STATES_KEYS2);
    };
    Displayable2.prototype._applyStateObj = function(stateName, state, normalState, keepCurrentStates, transition, animationCfg) {
      _super.prototype._applyStateObj.call(this, stateName, state, normalState, keepCurrentStates, transition, animationCfg);
      var needsRestoreToNormal = !(state && keepCurrentStates);
      var targetStyle;
      if (state && state.style) {
        if (transition) {
          if (keepCurrentStates) {
            targetStyle = state.style;
          } else {
            targetStyle = this._mergeStyle(this.createStyle(), normalState.style);
            this._mergeStyle(targetStyle, state.style);
          }
        } else {
          targetStyle = this._mergeStyle(this.createStyle(), keepCurrentStates ? this.style : normalState.style);
          this._mergeStyle(targetStyle, state.style);
        }
      } else if (needsRestoreToNormal) {
        targetStyle = normalState.style;
      }
      if (targetStyle) {
        if (transition) {
          var sourceStyle = this.style;
          this.style = this.createStyle(needsRestoreToNormal ? {} : sourceStyle);
          if (needsRestoreToNormal) {
            var changedKeys = keys(sourceStyle);
            for (var i = 0; i < changedKeys.length; i++) {
              var key = changedKeys[i];
              if (key in targetStyle) {
                targetStyle[key] = targetStyle[key];
                this.style[key] = sourceStyle[key];
              }
            }
          }
          var targetKeys = keys(targetStyle);
          for (var i = 0; i < targetKeys.length; i++) {
            var key = targetKeys[i];
            this.style[key] = this.style[key];
          }
          this._transitionState(stateName, {
            style: targetStyle
          }, animationCfg, this.getAnimationStyleProps());
        } else {
          this.useStyle(targetStyle);
        }
      }
      var statesKeys = this.__inHover ? PRIMARY_STATES_KEYS_IN_HOVER_LAYER : PRIMARY_STATES_KEYS2;
      for (var i = 0; i < statesKeys.length; i++) {
        var key = statesKeys[i];
        if (state && state[key] != null) {
          this[key] = state[key];
        } else if (needsRestoreToNormal) {
          if (normalState[key] != null) {
            this[key] = normalState[key];
          }
        }
      }
    };
    Displayable2.prototype._mergeStates = function(states) {
      var mergedState = _super.prototype._mergeStates.call(this, states);
      var mergedStyle;
      for (var i = 0; i < states.length; i++) {
        var state = states[i];
        if (state.style) {
          mergedStyle = mergedStyle || {};
          this._mergeStyle(mergedStyle, state.style);
        }
      }
      if (mergedStyle) {
        mergedState.style = mergedStyle;
      }
      return mergedState;
    };
    Displayable2.prototype._mergeStyle = function(targetStyle, sourceStyle) {
      extend(targetStyle, sourceStyle);
      return targetStyle;
    };
    Displayable2.prototype.getAnimationStyleProps = function() {
      return DEFAULT_COMMON_ANIMATION_PROPS;
    };
    Displayable2.initDefaultProps = function() {
      var dispProto = Displayable2.prototype;
      dispProto.type = "displayable";
      dispProto.invisible = false;
      dispProto.z = 0;
      dispProto.z2 = 0;
      dispProto.zlevel = 0;
      dispProto.culling = false;
      dispProto.cursor = "pointer";
      dispProto.rectHover = false;
      dispProto.incremental = false;
      dispProto._rect = null;
      dispProto.dirtyRectTolerance = 0;
      dispProto.__dirty = REDRAW_BIT | STYLE_CHANGED_BIT;
    }();
    return Displayable2;
  }(Element_default);
  var tmpRect = new BoundingRect_default(0, 0, 0, 0);
  var viewRect = new BoundingRect_default(0, 0, 0, 0);
  function isDisplayableCulled(el, width, height) {
    tmpRect.copy(el.getBoundingRect());
    if (el.transform) {
      tmpRect.applyTransform(el.transform);
    }
    viewRect.width = width;
    viewRect.height = height;
    return !tmpRect.intersect(viewRect);
  }
  var Displayable_default = Displayable;

  // node_modules/zrender/lib/core/bbox.js
  var mathMin2 = Math.min;
  var mathMax2 = Math.max;
  var mathSin = Math.sin;
  var mathCos = Math.cos;
  var PI2 = Math.PI * 2;
  var start = create();
  var end = create();
  var extremity = create();
  function fromPoints(points4, min3, max3) {
    if (points4.length === 0) {
      return;
    }
    var p = points4[0];
    var left = p[0];
    var right = p[0];
    var top = p[1];
    var bottom = p[1];
    for (var i = 1; i < points4.length; i++) {
      p = points4[i];
      left = mathMin2(left, p[0]);
      right = mathMax2(right, p[0]);
      top = mathMin2(top, p[1]);
      bottom = mathMax2(bottom, p[1]);
    }
    min3[0] = left;
    min3[1] = top;
    max3[0] = right;
    max3[1] = bottom;
  }
  function fromLine(x0, y0, x1, y1, min3, max3) {
    min3[0] = mathMin2(x0, x1);
    min3[1] = mathMin2(y0, y1);
    max3[0] = mathMax2(x0, x1);
    max3[1] = mathMax2(y0, y1);
  }
  var xDim = [];
  var yDim = [];
  function fromCubic(x0, y0, x1, y1, x2, y2, x3, y3, min3, max3) {
    var cubicExtrema2 = cubicExtrema;
    var cubicAt2 = cubicAt;
    var n = cubicExtrema2(x0, x1, x2, x3, xDim);
    min3[0] = Infinity;
    min3[1] = Infinity;
    max3[0] = -Infinity;
    max3[1] = -Infinity;
    for (var i = 0; i < n; i++) {
      var x = cubicAt2(x0, x1, x2, x3, xDim[i]);
      min3[0] = mathMin2(x, min3[0]);
      max3[0] = mathMax2(x, max3[0]);
    }
    n = cubicExtrema2(y0, y1, y2, y3, yDim);
    for (var i = 0; i < n; i++) {
      var y = cubicAt2(y0, y1, y2, y3, yDim[i]);
      min3[1] = mathMin2(y, min3[1]);
      max3[1] = mathMax2(y, max3[1]);
    }
    min3[0] = mathMin2(x0, min3[0]);
    max3[0] = mathMax2(x0, max3[0]);
    min3[0] = mathMin2(x3, min3[0]);
    max3[0] = mathMax2(x3, max3[0]);
    min3[1] = mathMin2(y0, min3[1]);
    max3[1] = mathMax2(y0, max3[1]);
    min3[1] = mathMin2(y3, min3[1]);
    max3[1] = mathMax2(y3, max3[1]);
  }
  function fromQuadratic(x0, y0, x1, y1, x2, y2, min3, max3) {
    var quadraticExtremum2 = quadraticExtremum;
    var quadraticAt3 = quadraticAt;
    var tx = mathMax2(mathMin2(quadraticExtremum2(x0, x1, x2), 1), 0);
    var ty = mathMax2(mathMin2(quadraticExtremum2(y0, y1, y2), 1), 0);
    var x = quadraticAt3(x0, x1, x2, tx);
    var y = quadraticAt3(y0, y1, y2, ty);
    min3[0] = mathMin2(x0, x2, x);
    min3[1] = mathMin2(y0, y2, y);
    max3[0] = mathMax2(x0, x2, x);
    max3[1] = mathMax2(y0, y2, y);
  }
  function fromArc(x, y, rx, ry, startAngle, endAngle, anticlockwise, min3, max3) {
    var vec2Min = min;
    var vec2Max = max;
    var diff = Math.abs(startAngle - endAngle);
    if (diff % PI2 < 1e-4 && diff > 1e-4) {
      min3[0] = x - rx;
      min3[1] = y - ry;
      max3[0] = x + rx;
      max3[1] = y + ry;
      return;
    }
    start[0] = mathCos(startAngle) * rx + x;
    start[1] = mathSin(startAngle) * ry + y;
    end[0] = mathCos(endAngle) * rx + x;
    end[1] = mathSin(endAngle) * ry + y;
    vec2Min(min3, start, end);
    vec2Max(max3, start, end);
    startAngle = startAngle % PI2;
    if (startAngle < 0) {
      startAngle = startAngle + PI2;
    }
    endAngle = endAngle % PI2;
    if (endAngle < 0) {
      endAngle = endAngle + PI2;
    }
    if (startAngle > endAngle && !anticlockwise) {
      endAngle += PI2;
    } else if (startAngle < endAngle && anticlockwise) {
      startAngle += PI2;
    }
    if (anticlockwise) {
      var tmp = endAngle;
      endAngle = startAngle;
      startAngle = tmp;
    }
    for (var angle = 0; angle < endAngle; angle += Math.PI / 2) {
      if (angle > startAngle) {
        extremity[0] = mathCos(angle) * rx + x;
        extremity[1] = mathSin(angle) * ry + y;
        vec2Min(min3, extremity, min3);
        vec2Max(max3, extremity, max3);
      }
    }
  }

  // node_modules/zrender/lib/core/PathProxy.js
  var CMD = {
    M: 1,
    L: 2,
    C: 3,
    Q: 4,
    A: 5,
    Z: 6,
    R: 7
  };
  var tmpOutX = [];
  var tmpOutY = [];
  var min2 = [];
  var max2 = [];
  var min22 = [];
  var max22 = [];
  var mathMin3 = Math.min;
  var mathMax3 = Math.max;
  var mathCos2 = Math.cos;
  var mathSin2 = Math.sin;
  var mathAbs = Math.abs;
  var PI = Math.PI;
  var PI22 = PI * 2;
  var hasTypedArray = typeof Float32Array !== "undefined";
  var tmpAngles = [];
  function modPI2(radian) {
    var n = Math.round(radian / PI * 1e8) / 1e8;
    return n % 2 * PI;
  }
  function normalizeArcAngles(angles, anticlockwise) {
    var newStartAngle = modPI2(angles[0]);
    if (newStartAngle < 0) {
      newStartAngle += PI22;
    }
    var delta = newStartAngle - angles[0];
    var newEndAngle = angles[1];
    newEndAngle += delta;
    if (!anticlockwise && newEndAngle - newStartAngle >= PI22) {
      newEndAngle = newStartAngle + PI22;
    } else if (anticlockwise && newStartAngle - newEndAngle >= PI22) {
      newEndAngle = newStartAngle - PI22;
    } else if (!anticlockwise && newStartAngle > newEndAngle) {
      newEndAngle = newStartAngle + (PI22 - modPI2(newStartAngle - newEndAngle));
    } else if (anticlockwise && newStartAngle < newEndAngle) {
      newEndAngle = newStartAngle - (PI22 - modPI2(newEndAngle - newStartAngle));
    }
    angles[0] = newStartAngle;
    angles[1] = newEndAngle;
  }
  var PathProxy = function() {
    function PathProxy2(notSaveData) {
      this.dpr = 1;
      this._xi = 0;
      this._yi = 0;
      this._x0 = 0;
      this._y0 = 0;
      this._len = 0;
      if (notSaveData) {
        this._saveData = false;
      }
      if (this._saveData) {
        this.data = [];
      }
    }
    PathProxy2.prototype.increaseVersion = function() {
      this._version++;
    };
    PathProxy2.prototype.getVersion = function() {
      return this._version;
    };
    PathProxy2.prototype.setScale = function(sx, sy, segmentIgnoreThreshold) {
      segmentIgnoreThreshold = segmentIgnoreThreshold || 0;
      if (segmentIgnoreThreshold > 0) {
        this._ux = mathAbs(segmentIgnoreThreshold / devicePixelRatio / sx) || 0;
        this._uy = mathAbs(segmentIgnoreThreshold / devicePixelRatio / sy) || 0;
      }
    };
    PathProxy2.prototype.setDPR = function(dpr2) {
      this.dpr = dpr2;
    };
    PathProxy2.prototype.setContext = function(ctx) {
      this._ctx = ctx;
    };
    PathProxy2.prototype.getContext = function() {
      return this._ctx;
    };
    PathProxy2.prototype.beginPath = function() {
      this._ctx && this._ctx.beginPath();
      this.reset();
      return this;
    };
    PathProxy2.prototype.reset = function() {
      if (this._saveData) {
        this._len = 0;
      }
      if (this._pathSegLen) {
        this._pathSegLen = null;
        this._pathLen = 0;
      }
      this._version++;
    };
    PathProxy2.prototype.moveTo = function(x, y) {
      this._drawPendingPt();
      this.addData(CMD.M, x, y);
      this._ctx && this._ctx.moveTo(x, y);
      this._x0 = x;
      this._y0 = y;
      this._xi = x;
      this._yi = y;
      return this;
    };
    PathProxy2.prototype.lineTo = function(x, y) {
      var dx = mathAbs(x - this._xi);
      var dy = mathAbs(y - this._yi);
      var exceedUnit = dx > this._ux || dy > this._uy;
      this.addData(CMD.L, x, y);
      if (this._ctx && exceedUnit) {
        this._ctx.lineTo(x, y);
      }
      if (exceedUnit) {
        this._xi = x;
        this._yi = y;
        this._pendingPtDist = 0;
      } else {
        var d2 = dx * dx + dy * dy;
        if (d2 > this._pendingPtDist) {
          this._pendingPtX = x;
          this._pendingPtY = y;
          this._pendingPtDist = d2;
        }
      }
      return this;
    };
    PathProxy2.prototype.bezierCurveTo = function(x1, y1, x2, y2, x3, y3) {
      this._drawPendingPt();
      this.addData(CMD.C, x1, y1, x2, y2, x3, y3);
      if (this._ctx) {
        this._ctx.bezierCurveTo(x1, y1, x2, y2, x3, y3);
      }
      this._xi = x3;
      this._yi = y3;
      return this;
    };
    PathProxy2.prototype.quadraticCurveTo = function(x1, y1, x2, y2) {
      this._drawPendingPt();
      this.addData(CMD.Q, x1, y1, x2, y2);
      if (this._ctx) {
        this._ctx.quadraticCurveTo(x1, y1, x2, y2);
      }
      this._xi = x2;
      this._yi = y2;
      return this;
    };
    PathProxy2.prototype.arc = function(cx, cy, r, startAngle, endAngle, anticlockwise) {
      this._drawPendingPt();
      tmpAngles[0] = startAngle;
      tmpAngles[1] = endAngle;
      normalizeArcAngles(tmpAngles, anticlockwise);
      startAngle = tmpAngles[0];
      endAngle = tmpAngles[1];
      var delta = endAngle - startAngle;
      this.addData(CMD.A, cx, cy, r, r, startAngle, delta, 0, anticlockwise ? 0 : 1);
      this._ctx && this._ctx.arc(cx, cy, r, startAngle, endAngle, anticlockwise);
      this._xi = mathCos2(endAngle) * r + cx;
      this._yi = mathSin2(endAngle) * r + cy;
      return this;
    };
    PathProxy2.prototype.arcTo = function(x1, y1, x2, y2, radius) {
      this._drawPendingPt();
      if (this._ctx) {
        this._ctx.arcTo(x1, y1, x2, y2, radius);
      }
      return this;
    };
    PathProxy2.prototype.rect = function(x, y, w, h) {
      this._drawPendingPt();
      this._ctx && this._ctx.rect(x, y, w, h);
      this.addData(CMD.R, x, y, w, h);
      return this;
    };
    PathProxy2.prototype.closePath = function() {
      this._drawPendingPt();
      this.addData(CMD.Z);
      var ctx = this._ctx;
      var x0 = this._x0;
      var y0 = this._y0;
      if (ctx) {
        ctx.closePath();
      }
      this._xi = x0;
      this._yi = y0;
      return this;
    };
    PathProxy2.prototype.fill = function(ctx) {
      ctx && ctx.fill();
      this.toStatic();
    };
    PathProxy2.prototype.stroke = function(ctx) {
      ctx && ctx.stroke();
      this.toStatic();
    };
    PathProxy2.prototype.len = function() {
      return this._len;
    };
    PathProxy2.prototype.setData = function(data) {
      var len2 = data.length;
      if (!(this.data && this.data.length === len2) && hasTypedArray) {
        this.data = new Float32Array(len2);
      }
      for (var i = 0; i < len2; i++) {
        this.data[i] = data[i];
      }
      this._len = len2;
    };
    PathProxy2.prototype.appendPath = function(path) {
      if (!(path instanceof Array)) {
        path = [path];
      }
      var len2 = path.length;
      var appendSize = 0;
      var offset = this._len;
      for (var i = 0; i < len2; i++) {
        appendSize += path[i].len();
      }
      if (hasTypedArray && this.data instanceof Float32Array) {
        this.data = new Float32Array(offset + appendSize);
      }
      for (var i = 0; i < len2; i++) {
        var appendPathData = path[i].data;
        for (var k = 0; k < appendPathData.length; k++) {
          this.data[offset++] = appendPathData[k];
        }
      }
      this._len = offset;
    };
    PathProxy2.prototype.addData = function(cmd, a, b, c, d, e2, f, g, h) {
      if (!this._saveData) {
        return;
      }
      var data = this.data;
      if (this._len + arguments.length > data.length) {
        this._expandData();
        data = this.data;
      }
      for (var i = 0; i < arguments.length; i++) {
        data[this._len++] = arguments[i];
      }
    };
    PathProxy2.prototype._drawPendingPt = function() {
      if (this._pendingPtDist > 0) {
        this._ctx && this._ctx.lineTo(this._pendingPtX, this._pendingPtY);
        this._pendingPtDist = 0;
      }
    };
    PathProxy2.prototype._expandData = function() {
      if (!(this.data instanceof Array)) {
        var newData = [];
        for (var i = 0; i < this._len; i++) {
          newData[i] = this.data[i];
        }
        this.data = newData;
      }
    };
    PathProxy2.prototype.toStatic = function() {
      if (!this._saveData) {
        return;
      }
      this._drawPendingPt();
      var data = this.data;
      if (data instanceof Array) {
        data.length = this._len;
        if (hasTypedArray && this._len > 11) {
          this.data = new Float32Array(data);
        }
      }
    };
    PathProxy2.prototype.getBoundingRect = function() {
      min2[0] = min2[1] = min22[0] = min22[1] = Number.MAX_VALUE;
      max2[0] = max2[1] = max22[0] = max22[1] = -Number.MAX_VALUE;
      var data = this.data;
      var xi = 0;
      var yi = 0;
      var x0 = 0;
      var y0 = 0;
      var i;
      for (i = 0; i < this._len; ) {
        var cmd = data[i++];
        var isFirst = i === 1;
        if (isFirst) {
          xi = data[i];
          yi = data[i + 1];
          x0 = xi;
          y0 = yi;
        }
        switch (cmd) {
          case CMD.M:
            xi = x0 = data[i++];
            yi = y0 = data[i++];
            min22[0] = x0;
            min22[1] = y0;
            max22[0] = x0;
            max22[1] = y0;
            break;
          case CMD.L:
            fromLine(xi, yi, data[i], data[i + 1], min22, max22);
            xi = data[i++];
            yi = data[i++];
            break;
          case CMD.C:
            fromCubic(xi, yi, data[i++], data[i++], data[i++], data[i++], data[i], data[i + 1], min22, max22);
            xi = data[i++];
            yi = data[i++];
            break;
          case CMD.Q:
            fromQuadratic(xi, yi, data[i++], data[i++], data[i], data[i + 1], min22, max22);
            xi = data[i++];
            yi = data[i++];
            break;
          case CMD.A:
            var cx = data[i++];
            var cy = data[i++];
            var rx = data[i++];
            var ry = data[i++];
            var startAngle = data[i++];
            var endAngle = data[i++] + startAngle;
            i += 1;
            var anticlockwise = !data[i++];
            if (isFirst) {
              x0 = mathCos2(startAngle) * rx + cx;
              y0 = mathSin2(startAngle) * ry + cy;
            }
            fromArc(cx, cy, rx, ry, startAngle, endAngle, anticlockwise, min22, max22);
            xi = mathCos2(endAngle) * rx + cx;
            yi = mathSin2(endAngle) * ry + cy;
            break;
          case CMD.R:
            x0 = xi = data[i++];
            y0 = yi = data[i++];
            var width = data[i++];
            var height = data[i++];
            fromLine(x0, y0, x0 + width, y0 + height, min22, max22);
            break;
          case CMD.Z:
            xi = x0;
            yi = y0;
            break;
        }
        min(min2, min2, min22);
        max(max2, max2, max22);
      }
      if (i === 0) {
        min2[0] = min2[1] = max2[0] = max2[1] = 0;
      }
      return new BoundingRect_default(min2[0], min2[1], max2[0] - min2[0], max2[1] - min2[1]);
    };
    PathProxy2.prototype._calculateLength = function() {
      var data = this.data;
      var len2 = this._len;
      var ux = this._ux;
      var uy = this._uy;
      var xi = 0;
      var yi = 0;
      var x0 = 0;
      var y0 = 0;
      if (!this._pathSegLen) {
        this._pathSegLen = [];
      }
      var pathSegLen = this._pathSegLen;
      var pathTotalLen = 0;
      var segCount = 0;
      for (var i = 0; i < len2; ) {
        var cmd = data[i++];
        var isFirst = i === 1;
        if (isFirst) {
          xi = data[i];
          yi = data[i + 1];
          x0 = xi;
          y0 = yi;
        }
        var l = -1;
        switch (cmd) {
          case CMD.M:
            xi = x0 = data[i++];
            yi = y0 = data[i++];
            break;
          case CMD.L: {
            var x2 = data[i++];
            var y2 = data[i++];
            var dx = x2 - xi;
            var dy = y2 - yi;
            if (mathAbs(dx) > ux || mathAbs(dy) > uy || i === len2 - 1) {
              l = Math.sqrt(dx * dx + dy * dy);
              xi = x2;
              yi = y2;
            }
            break;
          }
          case CMD.C: {
            var x1 = data[i++];
            var y1 = data[i++];
            var x2 = data[i++];
            var y2 = data[i++];
            var x3 = data[i++];
            var y3 = data[i++];
            l = cubicLength(xi, yi, x1, y1, x2, y2, x3, y3, 10);
            xi = x3;
            yi = y3;
            break;
          }
          case CMD.Q: {
            var x1 = data[i++];
            var y1 = data[i++];
            var x2 = data[i++];
            var y2 = data[i++];
            l = quadraticLength(xi, yi, x1, y1, x2, y2, 10);
            xi = x2;
            yi = y2;
            break;
          }
          case CMD.A:
            var cx = data[i++];
            var cy = data[i++];
            var rx = data[i++];
            var ry = data[i++];
            var startAngle = data[i++];
            var delta = data[i++];
            var endAngle = delta + startAngle;
            i += 1;
            var anticlockwise = !data[i++];
            if (isFirst) {
              x0 = mathCos2(startAngle) * rx + cx;
              y0 = mathSin2(startAngle) * ry + cy;
            }
            l = mathMax3(rx, ry) * mathMin3(PI22, Math.abs(delta));
            xi = mathCos2(endAngle) * rx + cx;
            yi = mathSin2(endAngle) * ry + cy;
            break;
          case CMD.R: {
            x0 = xi = data[i++];
            y0 = yi = data[i++];
            var width = data[i++];
            var height = data[i++];
            l = width * 2 + height * 2;
            break;
          }
          case CMD.Z: {
            var dx = x0 - xi;
            var dy = y0 - yi;
            l = Math.sqrt(dx * dx + dy * dy);
            xi = x0;
            yi = y0;
            break;
          }
        }
        if (l >= 0) {
          pathSegLen[segCount++] = l;
          pathTotalLen += l;
        }
      }
      this._pathLen = pathTotalLen;
      return pathTotalLen;
    };
    PathProxy2.prototype.rebuildPath = function(ctx, percent) {
      var d = this.data;
      var ux = this._ux;
      var uy = this._uy;
      var len2 = this._len;
      var x0;
      var y0;
      var xi;
      var yi;
      var x;
      var y;
      var drawPart = percent < 1;
      var pathSegLen;
      var pathTotalLen;
      var accumLength = 0;
      var segCount = 0;
      var displayedLength;
      var pendingPtDist = 0;
      var pendingPtX;
      var pendingPtY;
      if (drawPart) {
        if (!this._pathSegLen) {
          this._calculateLength();
        }
        pathSegLen = this._pathSegLen;
        pathTotalLen = this._pathLen;
        displayedLength = percent * pathTotalLen;
        if (!displayedLength) {
          return;
        }
      }
      lo:
        for (var i = 0; i < len2; ) {
          var cmd = d[i++];
          var isFirst = i === 1;
          if (isFirst) {
            xi = d[i];
            yi = d[i + 1];
            x0 = xi;
            y0 = yi;
          }
          if (cmd !== CMD.L && pendingPtDist > 0) {
            ctx.lineTo(pendingPtX, pendingPtY);
            pendingPtDist = 0;
          }
          switch (cmd) {
            case CMD.M:
              x0 = xi = d[i++];
              y0 = yi = d[i++];
              ctx.moveTo(xi, yi);
              break;
            case CMD.L: {
              x = d[i++];
              y = d[i++];
              var dx = mathAbs(x - xi);
              var dy = mathAbs(y - yi);
              if (dx > ux || dy > uy) {
                if (drawPart) {
                  var l = pathSegLen[segCount++];
                  if (accumLength + l > displayedLength) {
                    var t = (displayedLength - accumLength) / l;
                    ctx.lineTo(xi * (1 - t) + x * t, yi * (1 - t) + y * t);
                    break lo;
                  }
                  accumLength += l;
                }
                ctx.lineTo(x, y);
                xi = x;
                yi = y;
                pendingPtDist = 0;
              } else {
                var d2 = dx * dx + dy * dy;
                if (d2 > pendingPtDist) {
                  pendingPtX = x;
                  pendingPtY = y;
                  pendingPtDist = d2;
                }
              }
              break;
            }
            case CMD.C: {
              var x1 = d[i++];
              var y1 = d[i++];
              var x2 = d[i++];
              var y2 = d[i++];
              var x3 = d[i++];
              var y3 = d[i++];
              if (drawPart) {
                var l = pathSegLen[segCount++];
                if (accumLength + l > displayedLength) {
                  var t = (displayedLength - accumLength) / l;
                  cubicSubdivide(xi, x1, x2, x3, t, tmpOutX);
                  cubicSubdivide(yi, y1, y2, y3, t, tmpOutY);
                  ctx.bezierCurveTo(tmpOutX[1], tmpOutY[1], tmpOutX[2], tmpOutY[2], tmpOutX[3], tmpOutY[3]);
                  break lo;
                }
                accumLength += l;
              }
              ctx.bezierCurveTo(x1, y1, x2, y2, x3, y3);
              xi = x3;
              yi = y3;
              break;
            }
            case CMD.Q: {
              var x1 = d[i++];
              var y1 = d[i++];
              var x2 = d[i++];
              var y2 = d[i++];
              if (drawPart) {
                var l = pathSegLen[segCount++];
                if (accumLength + l > displayedLength) {
                  var t = (displayedLength - accumLength) / l;
                  quadraticSubdivide(xi, x1, x2, t, tmpOutX);
                  quadraticSubdivide(yi, y1, y2, t, tmpOutY);
                  ctx.quadraticCurveTo(tmpOutX[1], tmpOutY[1], tmpOutX[2], tmpOutY[2]);
                  break lo;
                }
                accumLength += l;
              }
              ctx.quadraticCurveTo(x1, y1, x2, y2);
              xi = x2;
              yi = y2;
              break;
            }
            case CMD.A:
              var cx = d[i++];
              var cy = d[i++];
              var rx = d[i++];
              var ry = d[i++];
              var startAngle = d[i++];
              var delta = d[i++];
              var psi = d[i++];
              var anticlockwise = !d[i++];
              var r = rx > ry ? rx : ry;
              var isEllipse = mathAbs(rx - ry) > 1e-3;
              var endAngle = startAngle + delta;
              var breakBuild = false;
              if (drawPart) {
                var l = pathSegLen[segCount++];
                if (accumLength + l > displayedLength) {
                  endAngle = startAngle + delta * (displayedLength - accumLength) / l;
                  breakBuild = true;
                }
                accumLength += l;
              }
              if (isEllipse && ctx.ellipse) {
                ctx.ellipse(cx, cy, rx, ry, psi, startAngle, endAngle, anticlockwise);
              } else {
                ctx.arc(cx, cy, r, startAngle, endAngle, anticlockwise);
              }
              if (breakBuild) {
                break lo;
              }
              if (isFirst) {
                x0 = mathCos2(startAngle) * rx + cx;
                y0 = mathSin2(startAngle) * ry + cy;
              }
              xi = mathCos2(endAngle) * rx + cx;
              yi = mathSin2(endAngle) * ry + cy;
              break;
            case CMD.R:
              x0 = xi = d[i];
              y0 = yi = d[i + 1];
              x = d[i++];
              y = d[i++];
              var width = d[i++];
              var height = d[i++];
              if (drawPart) {
                var l = pathSegLen[segCount++];
                if (accumLength + l > displayedLength) {
                  var d_1 = displayedLength - accumLength;
                  ctx.moveTo(x, y);
                  ctx.lineTo(x + mathMin3(d_1, width), y);
                  d_1 -= width;
                  if (d_1 > 0) {
                    ctx.lineTo(x + width, y + mathMin3(d_1, height));
                  }
                  d_1 -= height;
                  if (d_1 > 0) {
                    ctx.lineTo(x + mathMax3(width - d_1, 0), y + height);
                  }
                  d_1 -= width;
                  if (d_1 > 0) {
                    ctx.lineTo(x, y + mathMax3(height - d_1, 0));
                  }
                  break lo;
                }
                accumLength += l;
              }
              ctx.rect(x, y, width, height);
              break;
            case CMD.Z:
              if (drawPart) {
                var l = pathSegLen[segCount++];
                if (accumLength + l > displayedLength) {
                  var t = (displayedLength - accumLength) / l;
                  ctx.lineTo(xi * (1 - t) + x0 * t, yi * (1 - t) + y0 * t);
                  break lo;
                }
                accumLength += l;
              }
              ctx.closePath();
              xi = x0;
              yi = y0;
          }
        }
    };
    PathProxy2.prototype.clone = function() {
      var newProxy = new PathProxy2();
      var data = this.data;
      newProxy.data = data.slice ? data.slice() : Array.prototype.slice.call(data);
      newProxy._len = this._len;
      return newProxy;
    };
    PathProxy2.CMD = CMD;
    PathProxy2.initDefaultProps = function() {
      var proto2 = PathProxy2.prototype;
      proto2._saveData = true;
      proto2._ux = 0;
      proto2._uy = 0;
      proto2._pendingPtDist = 0;
      proto2._version = 0;
    }();
    return PathProxy2;
  }();
  var PathProxy_default = PathProxy;

  // node_modules/zrender/lib/contain/line.js
  function containStroke(x0, y0, x1, y1, lineWidth, x, y) {
    if (lineWidth === 0) {
      return false;
    }
    var _l = lineWidth;
    var _a2 = 0;
    var _b2 = x0;
    if (y > y0 + _l && y > y1 + _l || y < y0 - _l && y < y1 - _l || x > x0 + _l && x > x1 + _l || x < x0 - _l && x < x1 - _l) {
      return false;
    }
    if (x0 !== x1) {
      _a2 = (y0 - y1) / (x0 - x1);
      _b2 = (x0 * y1 - x1 * y0) / (x0 - x1);
    } else {
      return Math.abs(x - x0) <= _l / 2;
    }
    var tmp = _a2 * x - y + _b2;
    var _s = tmp * tmp / (_a2 * _a2 + 1);
    return _s <= _l / 2 * _l / 2;
  }

  // node_modules/zrender/lib/contain/cubic.js
  function containStroke2(x0, y0, x1, y1, x2, y2, x3, y3, lineWidth, x, y) {
    if (lineWidth === 0) {
      return false;
    }
    var _l = lineWidth;
    if (y > y0 + _l && y > y1 + _l && y > y2 + _l && y > y3 + _l || y < y0 - _l && y < y1 - _l && y < y2 - _l && y < y3 - _l || x > x0 + _l && x > x1 + _l && x > x2 + _l && x > x3 + _l || x < x0 - _l && x < x1 - _l && x < x2 - _l && x < x3 - _l) {
      return false;
    }
    var d = cubicProjectPoint(x0, y0, x1, y1, x2, y2, x3, y3, x, y, null);
    return d <= _l / 2;
  }

  // node_modules/zrender/lib/contain/quadratic.js
  function containStroke3(x0, y0, x1, y1, x2, y2, lineWidth, x, y) {
    if (lineWidth === 0) {
      return false;
    }
    var _l = lineWidth;
    if (y > y0 + _l && y > y1 + _l && y > y2 + _l || y < y0 - _l && y < y1 - _l && y < y2 - _l || x > x0 + _l && x > x1 + _l && x > x2 + _l || x < x0 - _l && x < x1 - _l && x < x2 - _l) {
      return false;
    }
    var d = quadraticProjectPoint(x0, y0, x1, y1, x2, y2, x, y, null);
    return d <= _l / 2;
  }

  // node_modules/zrender/lib/contain/util.js
  var PI23 = Math.PI * 2;
  function normalizeRadian(angle) {
    angle %= PI23;
    if (angle < 0) {
      angle += PI23;
    }
    return angle;
  }

  // node_modules/zrender/lib/contain/arc.js
  var PI24 = Math.PI * 2;
  function containStroke4(cx, cy, r, startAngle, endAngle, anticlockwise, lineWidth, x, y) {
    if (lineWidth === 0) {
      return false;
    }
    var _l = lineWidth;
    x -= cx;
    y -= cy;
    var d = Math.sqrt(x * x + y * y);
    if (d - _l > r || d + _l < r) {
      return false;
    }
    if (Math.abs(startAngle - endAngle) % PI24 < 1e-4) {
      return true;
    }
    if (anticlockwise) {
      var tmp = startAngle;
      startAngle = normalizeRadian(endAngle);
      endAngle = normalizeRadian(tmp);
    } else {
      startAngle = normalizeRadian(startAngle);
      endAngle = normalizeRadian(endAngle);
    }
    if (startAngle > endAngle) {
      endAngle += PI24;
    }
    var angle = Math.atan2(y, x);
    if (angle < 0) {
      angle += PI24;
    }
    return angle >= startAngle && angle <= endAngle || angle + PI24 >= startAngle && angle + PI24 <= endAngle;
  }

  // node_modules/zrender/lib/contain/windingLine.js
  function windingLine(x0, y0, x1, y1, x, y) {
    if (y > y0 && y > y1 || y < y0 && y < y1) {
      return 0;
    }
    if (y1 === y0) {
      return 0;
    }
    var t = (y - y0) / (y1 - y0);
    var dir3 = y1 < y0 ? 1 : -1;
    if (t === 1 || t === 0) {
      dir3 = y1 < y0 ? 0.5 : -0.5;
    }
    var x_ = t * (x1 - x0) + x0;
    return x_ === x ? Infinity : x_ > x ? dir3 : 0;
  }

  // node_modules/zrender/lib/contain/path.js
  var CMD2 = PathProxy_default.CMD;
  var PI25 = Math.PI * 2;
  var EPSILON4 = 1e-4;
  function isAroundEqual(a, b) {
    return Math.abs(a - b) < EPSILON4;
  }
  var roots = [-1, -1, -1];
  var extrema = [-1, -1];
  function swapExtrema() {
    var tmp = extrema[0];
    extrema[0] = extrema[1];
    extrema[1] = tmp;
  }
  function windingCubic(x0, y0, x1, y1, x2, y2, x3, y3, x, y) {
    if (y > y0 && y > y1 && y > y2 && y > y3 || y < y0 && y < y1 && y < y2 && y < y3) {
      return 0;
    }
    var nRoots = cubicRootAt(y0, y1, y2, y3, y, roots);
    if (nRoots === 0) {
      return 0;
    } else {
      var w = 0;
      var nExtrema = -1;
      var y0_ = void 0;
      var y1_ = void 0;
      for (var i = 0; i < nRoots; i++) {
        var t = roots[i];
        var unit = t === 0 || t === 1 ? 0.5 : 1;
        var x_ = cubicAt(x0, x1, x2, x3, t);
        if (x_ < x) {
          continue;
        }
        if (nExtrema < 0) {
          nExtrema = cubicExtrema(y0, y1, y2, y3, extrema);
          if (extrema[1] < extrema[0] && nExtrema > 1) {
            swapExtrema();
          }
          y0_ = cubicAt(y0, y1, y2, y3, extrema[0]);
          if (nExtrema > 1) {
            y1_ = cubicAt(y0, y1, y2, y3, extrema[1]);
          }
        }
        if (nExtrema === 2) {
          if (t < extrema[0]) {
            w += y0_ < y0 ? unit : -unit;
          } else if (t < extrema[1]) {
            w += y1_ < y0_ ? unit : -unit;
          } else {
            w += y3 < y1_ ? unit : -unit;
          }
        } else {
          if (t < extrema[0]) {
            w += y0_ < y0 ? unit : -unit;
          } else {
            w += y3 < y0_ ? unit : -unit;
          }
        }
      }
      return w;
    }
  }
  function windingQuadratic(x0, y0, x1, y1, x2, y2, x, y) {
    if (y > y0 && y > y1 && y > y2 || y < y0 && y < y1 && y < y2) {
      return 0;
    }
    var nRoots = quadraticRootAt(y0, y1, y2, y, roots);
    if (nRoots === 0) {
      return 0;
    } else {
      var t = quadraticExtremum(y0, y1, y2);
      if (t >= 0 && t <= 1) {
        var w = 0;
        var y_ = quadraticAt(y0, y1, y2, t);
        for (var i = 0; i < nRoots; i++) {
          var unit = roots[i] === 0 || roots[i] === 1 ? 0.5 : 1;
          var x_ = quadraticAt(x0, x1, x2, roots[i]);
          if (x_ < x) {
            continue;
          }
          if (roots[i] < t) {
            w += y_ < y0 ? unit : -unit;
          } else {
            w += y2 < y_ ? unit : -unit;
          }
        }
        return w;
      } else {
        var unit = roots[0] === 0 || roots[0] === 1 ? 0.5 : 1;
        var x_ = quadraticAt(x0, x1, x2, roots[0]);
        if (x_ < x) {
          return 0;
        }
        return y2 < y0 ? unit : -unit;
      }
    }
  }
  function windingArc(cx, cy, r, startAngle, endAngle, anticlockwise, x, y) {
    y -= cy;
    if (y > r || y < -r) {
      return 0;
    }
    var tmp = Math.sqrt(r * r - y * y);
    roots[0] = -tmp;
    roots[1] = tmp;
    var dTheta = Math.abs(startAngle - endAngle);
    if (dTheta < 1e-4) {
      return 0;
    }
    if (dTheta >= PI25 - 1e-4) {
      startAngle = 0;
      endAngle = PI25;
      var dir3 = anticlockwise ? 1 : -1;
      if (x >= roots[0] + cx && x <= roots[1] + cx) {
        return dir3;
      } else {
        return 0;
      }
    }
    if (startAngle > endAngle) {
      var tmp_1 = startAngle;
      startAngle = endAngle;
      endAngle = tmp_1;
    }
    if (startAngle < 0) {
      startAngle += PI25;
      endAngle += PI25;
    }
    var w = 0;
    for (var i = 0; i < 2; i++) {
      var x_ = roots[i];
      if (x_ + cx > x) {
        var angle = Math.atan2(y, x_);
        var dir3 = anticlockwise ? 1 : -1;
        if (angle < 0) {
          angle = PI25 + angle;
        }
        if (angle >= startAngle && angle <= endAngle || angle + PI25 >= startAngle && angle + PI25 <= endAngle) {
          if (angle > Math.PI / 2 && angle < Math.PI * 1.5) {
            dir3 = -dir3;
          }
          w += dir3;
        }
      }
    }
    return w;
  }
  function containPath(path, lineWidth, isStroke, x, y) {
    var data = path.data;
    var len2 = path.len();
    var w = 0;
    var xi = 0;
    var yi = 0;
    var x0 = 0;
    var y0 = 0;
    var x1;
    var y1;
    for (var i = 0; i < len2; ) {
      var cmd = data[i++];
      var isFirst = i === 1;
      if (cmd === CMD2.M && i > 1) {
        if (!isStroke) {
          w += windingLine(xi, yi, x0, y0, x, y);
        }
      }
      if (isFirst) {
        xi = data[i];
        yi = data[i + 1];
        x0 = xi;
        y0 = yi;
      }
      switch (cmd) {
        case CMD2.M:
          x0 = data[i++];
          y0 = data[i++];
          xi = x0;
          yi = y0;
          break;
        case CMD2.L:
          if (isStroke) {
            if (containStroke(xi, yi, data[i], data[i + 1], lineWidth, x, y)) {
              return true;
            }
          } else {
            w += windingLine(xi, yi, data[i], data[i + 1], x, y) || 0;
          }
          xi = data[i++];
          yi = data[i++];
          break;
        case CMD2.C:
          if (isStroke) {
            if (containStroke2(xi, yi, data[i++], data[i++], data[i++], data[i++], data[i], data[i + 1], lineWidth, x, y)) {
              return true;
            }
          } else {
            w += windingCubic(xi, yi, data[i++], data[i++], data[i++], data[i++], data[i], data[i + 1], x, y) || 0;
          }
          xi = data[i++];
          yi = data[i++];
          break;
        case CMD2.Q:
          if (isStroke) {
            if (containStroke3(xi, yi, data[i++], data[i++], data[i], data[i + 1], lineWidth, x, y)) {
              return true;
            }
          } else {
            w += windingQuadratic(xi, yi, data[i++], data[i++], data[i], data[i + 1], x, y) || 0;
          }
          xi = data[i++];
          yi = data[i++];
          break;
        case CMD2.A:
          var cx = data[i++];
          var cy = data[i++];
          var rx = data[i++];
          var ry = data[i++];
          var theta = data[i++];
          var dTheta = data[i++];
          i += 1;
          var anticlockwise = !!(1 - data[i++]);
          x1 = Math.cos(theta) * rx + cx;
          y1 = Math.sin(theta) * ry + cy;
          if (!isFirst) {
            w += windingLine(xi, yi, x1, y1, x, y);
          } else {
            x0 = x1;
            y0 = y1;
          }
          var _x = (x - cx) * ry / rx + cx;
          if (isStroke) {
            if (containStroke4(cx, cy, ry, theta, theta + dTheta, anticlockwise, lineWidth, _x, y)) {
              return true;
            }
          } else {
            w += windingArc(cx, cy, ry, theta, theta + dTheta, anticlockwise, _x, y);
          }
          xi = Math.cos(theta + dTheta) * rx + cx;
          yi = Math.sin(theta + dTheta) * ry + cy;
          break;
        case CMD2.R:
          x0 = xi = data[i++];
          y0 = yi = data[i++];
          var width = data[i++];
          var height = data[i++];
          x1 = x0 + width;
          y1 = y0 + height;
          if (isStroke) {
            if (containStroke(x0, y0, x1, y0, lineWidth, x, y) || containStroke(x1, y0, x1, y1, lineWidth, x, y) || containStroke(x1, y1, x0, y1, lineWidth, x, y) || containStroke(x0, y1, x0, y0, lineWidth, x, y)) {
              return true;
            }
          } else {
            w += windingLine(x1, y0, x1, y1, x, y);
            w += windingLine(x0, y1, x0, y0, x, y);
          }
          break;
        case CMD2.Z:
          if (isStroke) {
            if (containStroke(xi, yi, x0, y0, lineWidth, x, y)) {
              return true;
            }
          } else {
            w += windingLine(xi, yi, x0, y0, x, y);
          }
          xi = x0;
          yi = y0;
          break;
      }
    }
    if (!isStroke && !isAroundEqual(yi, y0)) {
      w += windingLine(xi, yi, x0, y0, x, y) || 0;
    }
    return w !== 0;
  }
  function contain(pathProxy, x, y) {
    return containPath(pathProxy, 0, false, x, y);
  }
  function containStroke5(pathProxy, lineWidth, x, y) {
    return containPath(pathProxy, lineWidth, true, x, y);
  }

  // node_modules/zrender/lib/graphic/Path.js
  var DEFAULT_PATH_STYLE = defaults({
    fill: "#000",
    stroke: null,
    strokePercent: 1,
    fillOpacity: 1,
    strokeOpacity: 1,
    lineDashOffset: 0,
    lineWidth: 1,
    lineCap: "butt",
    miterLimit: 10,
    strokeNoScale: false,
    strokeFirst: false
  }, DEFAULT_COMMON_STYLE);
  var DEFAULT_PATH_ANIMATION_PROPS = {
    style: defaults({
      fill: true,
      stroke: true,
      strokePercent: true,
      fillOpacity: true,
      strokeOpacity: true,
      lineDashOffset: true,
      lineWidth: true,
      miterLimit: true
    }, DEFAULT_COMMON_ANIMATION_PROPS.style)
  };
  var pathCopyParams = TRANSFORMABLE_PROPS.concat([
    "invisible",
    "culling",
    "z",
    "z2",
    "zlevel",
    "parent"
  ]);
  var Path = function(_super) {
    __extends2(Path2, _super);
    function Path2(opts) {
      return _super.call(this, opts) || this;
    }
    Path2.prototype.update = function() {
      var _this = this;
      _super.prototype.update.call(this);
      var style = this.style;
      if (style.decal) {
        var decalEl = this._decalEl = this._decalEl || new Path2();
        if (decalEl.buildPath === Path2.prototype.buildPath) {
          decalEl.buildPath = function(ctx) {
            _this.buildPath(ctx, _this.shape);
          };
        }
        decalEl.silent = true;
        var decalElStyle = decalEl.style;
        for (var key in style) {
          if (decalElStyle[key] !== style[key]) {
            decalElStyle[key] = style[key];
          }
        }
        decalElStyle.fill = style.fill ? style.decal : null;
        decalElStyle.decal = null;
        decalElStyle.shadowColor = null;
        style.strokeFirst && (decalElStyle.stroke = null);
        for (var i = 0; i < pathCopyParams.length; ++i) {
          decalEl[pathCopyParams[i]] = this[pathCopyParams[i]];
        }
        decalEl.__dirty |= REDRAW_BIT;
      } else if (this._decalEl) {
        this._decalEl = null;
      }
    };
    Path2.prototype.getDecalElement = function() {
      return this._decalEl;
    };
    Path2.prototype._init = function(props) {
      var keysArr = keys(props);
      this.shape = this.getDefaultShape();
      var defaultStyle = this.getDefaultStyle();
      if (defaultStyle) {
        this.useStyle(defaultStyle);
      }
      for (var i = 0; i < keysArr.length; i++) {
        var key = keysArr[i];
        var value = props[key];
        if (key === "style") {
          if (!this.style) {
            this.useStyle(value);
          } else {
            extend(this.style, value);
          }
        } else if (key === "shape") {
          extend(this.shape, value);
        } else {
          _super.prototype.attrKV.call(this, key, value);
        }
      }
      if (!this.style) {
        this.useStyle({});
      }
    };
    Path2.prototype.getDefaultStyle = function() {
      return null;
    };
    Path2.prototype.getDefaultShape = function() {
      return {};
    };
    Path2.prototype.canBeInsideText = function() {
      return this.hasFill();
    };
    Path2.prototype.getInsideTextFill = function() {
      var pathFill = this.style.fill;
      if (pathFill !== "none") {
        if (isString(pathFill)) {
          var fillLum = lum(pathFill, 0);
          if (fillLum > 0.5) {
            return DARK_LABEL_COLOR;
          } else if (fillLum > 0.2) {
            return LIGHTER_LABEL_COLOR;
          }
          return LIGHT_LABEL_COLOR;
        } else if (pathFill) {
          return LIGHT_LABEL_COLOR;
        }
      }
      return DARK_LABEL_COLOR;
    };
    Path2.prototype.getInsideTextStroke = function(textFill) {
      var pathFill = this.style.fill;
      if (isString(pathFill)) {
        var zr = this.__zr;
        var isDarkMode2 = !!(zr && zr.isDarkMode());
        var isDarkLabel = lum(textFill, 0) < DARK_MODE_THRESHOLD;
        if (isDarkMode2 === isDarkLabel) {
          return pathFill;
        }
      }
    };
    Path2.prototype.buildPath = function(ctx, shapeCfg, inBatch) {
    };
    Path2.prototype.pathUpdated = function() {
      this.__dirty &= ~SHAPE_CHANGED_BIT;
    };
    Path2.prototype.getUpdatedPathProxy = function(inBatch) {
      !this.path && this.createPathProxy();
      this.path.beginPath();
      this.buildPath(this.path, this.shape, inBatch);
      return this.path;
    };
    Path2.prototype.createPathProxy = function() {
      this.path = new PathProxy_default(false);
    };
    Path2.prototype.hasStroke = function() {
      var style = this.style;
      var stroke = style.stroke;
      return !(stroke == null || stroke === "none" || !(style.lineWidth > 0));
    };
    Path2.prototype.hasFill = function() {
      var style = this.style;
      var fill = style.fill;
      return fill != null && fill !== "none";
    };
    Path2.prototype.getBoundingRect = function() {
      var rect = this._rect;
      var style = this.style;
      var needsUpdateRect = !rect;
      if (needsUpdateRect) {
        var firstInvoke = false;
        if (!this.path) {
          firstInvoke = true;
          this.createPathProxy();
        }
        var path = this.path;
        if (firstInvoke || this.__dirty & SHAPE_CHANGED_BIT) {
          path.beginPath();
          this.buildPath(path, this.shape, false);
          this.pathUpdated();
        }
        rect = path.getBoundingRect();
      }
      this._rect = rect;
      if (this.hasStroke() && this.path && this.path.len() > 0) {
        var rectStroke = this._rectStroke || (this._rectStroke = rect.clone());
        if (this.__dirty || needsUpdateRect) {
          rectStroke.copy(rect);
          var lineScale = style.strokeNoScale ? this.getLineScale() : 1;
          var w = style.lineWidth;
          if (!this.hasFill()) {
            var strokeContainThreshold = this.strokeContainThreshold;
            w = Math.max(w, strokeContainThreshold == null ? 4 : strokeContainThreshold);
          }
          if (lineScale > 1e-10) {
            rectStroke.width += w / lineScale;
            rectStroke.height += w / lineScale;
            rectStroke.x -= w / lineScale / 2;
            rectStroke.y -= w / lineScale / 2;
          }
        }
        return rectStroke;
      }
      return rect;
    };
    Path2.prototype.contain = function(x, y) {
      var localPos = this.transformCoordToLocal(x, y);
      var rect = this.getBoundingRect();
      var style = this.style;
      x = localPos[0];
      y = localPos[1];
      if (rect.contain(x, y)) {
        var pathProxy = this.path;
        if (this.hasStroke()) {
          var lineWidth = style.lineWidth;
          var lineScale = style.strokeNoScale ? this.getLineScale() : 1;
          if (lineScale > 1e-10) {
            if (!this.hasFill()) {
              lineWidth = Math.max(lineWidth, this.strokeContainThreshold);
            }
            if (containStroke5(pathProxy, lineWidth / lineScale, x, y)) {
              return true;
            }
          }
        }
        if (this.hasFill()) {
          return contain(pathProxy, x, y);
        }
      }
      return false;
    };
    Path2.prototype.dirtyShape = function() {
      this.__dirty |= SHAPE_CHANGED_BIT;
      if (this._rect) {
        this._rect = null;
      }
      if (this._decalEl) {
        this._decalEl.dirtyShape();
      }
      this.markRedraw();
    };
    Path2.prototype.dirty = function() {
      this.dirtyStyle();
      this.dirtyShape();
    };
    Path2.prototype.animateShape = function(loop) {
      return this.animate("shape", loop);
    };
    Path2.prototype.updateDuringAnimation = function(targetKey) {
      if (targetKey === "style") {
        this.dirtyStyle();
      } else if (targetKey === "shape") {
        this.dirtyShape();
      } else {
        this.markRedraw();
      }
    };
    Path2.prototype.attrKV = function(key, value) {
      if (key === "shape") {
        this.setShape(value);
      } else {
        _super.prototype.attrKV.call(this, key, value);
      }
    };
    Path2.prototype.setShape = function(keyOrObj, value) {
      var shape = this.shape;
      if (!shape) {
        shape = this.shape = {};
      }
      if (typeof keyOrObj === "string") {
        shape[keyOrObj] = value;
      } else {
        extend(shape, keyOrObj);
      }
      this.dirtyShape();
      return this;
    };
    Path2.prototype.shapeChanged = function() {
      return !!(this.__dirty & SHAPE_CHANGED_BIT);
    };
    Path2.prototype.createStyle = function(obj) {
      return createObject(DEFAULT_PATH_STYLE, obj);
    };
    Path2.prototype._innerSaveToNormal = function(toState) {
      _super.prototype._innerSaveToNormal.call(this, toState);
      var normalState = this._normalState;
      if (toState.shape && !normalState.shape) {
        normalState.shape = extend({}, this.shape);
      }
    };
    Path2.prototype._applyStateObj = function(stateName, state, normalState, keepCurrentStates, transition, animationCfg) {
      _super.prototype._applyStateObj.call(this, stateName, state, normalState, keepCurrentStates, transition, animationCfg);
      var needsRestoreToNormal = !(state && keepCurrentStates);
      var targetShape;
      if (state && state.shape) {
        if (transition) {
          if (keepCurrentStates) {
            targetShape = state.shape;
          } else {
            targetShape = extend({}, normalState.shape);
            extend(targetShape, state.shape);
          }
        } else {
          targetShape = extend({}, keepCurrentStates ? this.shape : normalState.shape);
          extend(targetShape, state.shape);
        }
      } else if (needsRestoreToNormal) {
        targetShape = normalState.shape;
      }
      if (targetShape) {
        if (transition) {
          this.shape = extend({}, this.shape);
          var targetShapePrimaryProps = {};
          var shapeKeys = keys(targetShape);
          for (var i = 0; i < shapeKeys.length; i++) {
            var key = shapeKeys[i];
            if (typeof targetShape[key] === "object") {
              this.shape[key] = targetShape[key];
            } else {
              targetShapePrimaryProps[key] = targetShape[key];
            }
          }
          this._transitionState(stateName, {
            shape: targetShapePrimaryProps
          }, animationCfg);
        } else {
          this.shape = targetShape;
          this.dirtyShape();
        }
      }
    };
    Path2.prototype._mergeStates = function(states) {
      var mergedState = _super.prototype._mergeStates.call(this, states);
      var mergedShape;
      for (var i = 0; i < states.length; i++) {
        var state = states[i];
        if (state.shape) {
          mergedShape = mergedShape || {};
          this._mergeStyle(mergedShape, state.shape);
        }
      }
      if (mergedShape) {
        mergedState.shape = mergedShape;
      }
      return mergedState;
    };
    Path2.prototype.getAnimationStyleProps = function() {
      return DEFAULT_PATH_ANIMATION_PROPS;
    };
    Path2.prototype.isZeroArea = function() {
      return false;
    };
    Path2.extend = function(defaultProps) {
      var Sub = function(_super2) {
        __extends2(Sub2, _super2);
        function Sub2(opts) {
          var _this = _super2.call(this, opts) || this;
          defaultProps.init && defaultProps.init.call(_this, opts);
          return _this;
        }
        Sub2.prototype.getDefaultStyle = function() {
          return clone(defaultProps.style);
        };
        Sub2.prototype.getDefaultShape = function() {
          return clone(defaultProps.shape);
        };
        return Sub2;
      }(Path2);
      for (var key in defaultProps) {
        if (typeof defaultProps[key] === "function") {
          Sub.prototype[key] = defaultProps[key];
        }
      }
      return Sub;
    };
    Path2.initDefaultProps = function() {
      var pathProto = Path2.prototype;
      pathProto.type = "path";
      pathProto.strokeContainThreshold = 5;
      pathProto.segmentIgnoreThreshold = 0;
      pathProto.subPixelOptimize = false;
      pathProto.autoBatch = false;
      pathProto.__dirty = REDRAW_BIT | STYLE_CHANGED_BIT | SHAPE_CHANGED_BIT;
    }();
    return Path2;
  }(Displayable_default);
  var Path_default = Path;

  // node_modules/zrender/lib/graphic/TSpan.js
  var DEFAULT_TSPAN_STYLE = defaults({
    strokeFirst: true,
    font: DEFAULT_FONT,
    x: 0,
    y: 0,
    textAlign: "left",
    textBaseline: "top",
    miterLimit: 2
  }, DEFAULT_PATH_STYLE);
  var TSpan = function(_super) {
    __extends2(TSpan2, _super);
    function TSpan2() {
      return _super !== null && _super.apply(this, arguments) || this;
    }
    TSpan2.prototype.hasStroke = function() {
      var style = this.style;
      var stroke = style.stroke;
      return stroke != null && stroke !== "none" && style.lineWidth > 0;
    };
    TSpan2.prototype.hasFill = function() {
      var style = this.style;
      var fill = style.fill;
      return fill != null && fill !== "none";
    };
    TSpan2.prototype.createStyle = function(obj) {
      return createObject(DEFAULT_TSPAN_STYLE, obj);
    };
    TSpan2.prototype.setBoundingRect = function(rect) {
      this._rect = rect;
    };
    TSpan2.prototype.getBoundingRect = function() {
      var style = this.style;
      if (!this._rect) {
        var text = style.text;
        text != null ? text += "" : text = "";
        var rect = getBoundingRect(text, style.font, style.textAlign, style.textBaseline);
        rect.x += style.x || 0;
        rect.y += style.y || 0;
        if (this.hasStroke()) {
          var w = style.lineWidth;
          rect.x -= w / 2;
          rect.y -= w / 2;
          rect.width += w;
          rect.height += w;
        }
        this._rect = rect;
      }
      return this._rect;
    };
    TSpan2.initDefaultProps = function() {
      var tspanProto = TSpan2.prototype;
      tspanProto.dirtyRectTolerance = 10;
    }();
    return TSpan2;
  }(Displayable_default);
  TSpan.prototype.type = "tspan";
  var TSpan_default = TSpan;

  // node_modules/zrender/lib/graphic/Image.js
  var DEFAULT_IMAGE_STYLE = defaults({
    x: 0,
    y: 0
  }, DEFAULT_COMMON_STYLE);
  var DEFAULT_IMAGE_ANIMATION_PROPS = {
    style: defaults({
      x: true,
      y: true,
      width: true,
      height: true,
      sx: true,
      sy: true,
      sWidth: true,
      sHeight: true
    }, DEFAULT_COMMON_ANIMATION_PROPS.style)
  };
  function isImageLike(source) {
    return !!(source && typeof source !== "string" && source.width && source.height);
  }
  var ZRImage = function(_super) {
    __extends2(ZRImage2, _super);
    function ZRImage2() {
      return _super !== null && _super.apply(this, arguments) || this;
    }
    ZRImage2.prototype.createStyle = function(obj) {
      return createObject(DEFAULT_IMAGE_STYLE, obj);
    };
    ZRImage2.prototype._getSize = function(dim) {
      var style = this.style;
      var size = style[dim];
      if (size != null) {
        return size;
      }
      var imageSource = isImageLike(style.image) ? style.image : this.__image;
      if (!imageSource) {
        return 0;
      }
      var otherDim = dim === "width" ? "height" : "width";
      var otherDimSize = style[otherDim];
      if (otherDimSize == null) {
        return imageSource[dim];
      } else {
        return imageSource[dim] / imageSource[otherDim] * otherDimSize;
      }
    };
    ZRImage2.prototype.getWidth = function() {
      return this._getSize("width");
    };
    ZRImage2.prototype.getHeight = function() {
      return this._getSize("height");
    };
    ZRImage2.prototype.getAnimationStyleProps = function() {
      return DEFAULT_IMAGE_ANIMATION_PROPS;
    };
    ZRImage2.prototype.getBoundingRect = function() {
      var style = this.style;
      if (!this._rect) {
        this._rect = new BoundingRect_default(style.x || 0, style.y || 0, this.getWidth(), this.getHeight());
      }
      return this._rect;
    };
    return ZRImage2;
  }(Displayable_default);
  ZRImage.prototype.type = "image";
  var Image_default = ZRImage;

  // node_modules/zrender/lib/graphic/helper/roundRect.js
  function buildPath(ctx, shape) {
    var x = shape.x;
    var y = shape.y;
    var width = shape.width;
    var height = shape.height;
    var r = shape.r;
    var r1;
    var r2;
    var r3;
    var r4;
    if (width < 0) {
      x = x + width;
      width = -width;
    }
    if (height < 0) {
      y = y + height;
      height = -height;
    }
    if (typeof r === "number") {
      r1 = r2 = r3 = r4 = r;
    } else if (r instanceof Array) {
      if (r.length === 1) {
        r1 = r2 = r3 = r4 = r[0];
      } else if (r.length === 2) {
        r1 = r3 = r[0];
        r2 = r4 = r[1];
      } else if (r.length === 3) {
        r1 = r[0];
        r2 = r4 = r[1];
        r3 = r[2];
      } else {
        r1 = r[0];
        r2 = r[1];
        r3 = r[2];
        r4 = r[3];
      }
    } else {
      r1 = r2 = r3 = r4 = 0;
    }
    var total;
    if (r1 + r2 > width) {
      total = r1 + r2;
      r1 *= width / total;
      r2 *= width / total;
    }
    if (r3 + r4 > width) {
      total = r3 + r4;
      r3 *= width / total;
      r4 *= width / total;
    }
    if (r2 + r3 > height) {
      total = r2 + r3;
      r2 *= height / total;
      r3 *= height / total;
    }
    if (r1 + r4 > height) {
      total = r1 + r4;
      r1 *= height / total;
      r4 *= height / total;
    }
    ctx.moveTo(x + r1, y);
    ctx.lineTo(x + width - r2, y);
    r2 !== 0 && ctx.arc(x + width - r2, y + r2, r2, -Math.PI / 2, 0);
    ctx.lineTo(x + width, y + height - r3);
    r3 !== 0 && ctx.arc(x + width - r3, y + height - r3, r3, 0, Math.PI / 2);
    ctx.lineTo(x + r4, y + height);
    r4 !== 0 && ctx.arc(x + r4, y + height - r4, r4, Math.PI / 2, Math.PI);
    ctx.lineTo(x, y + r1);
    r1 !== 0 && ctx.arc(x + r1, y + r1, r1, Math.PI, Math.PI * 1.5);
  }

  // node_modules/zrender/lib/graphic/helper/subPixelOptimize.js
  var round2 = Math.round;
  function subPixelOptimizeLine(outputShape, inputShape, style) {
    if (!inputShape) {
      return;
    }
    var x1 = inputShape.x1;
    var x2 = inputShape.x2;
    var y1 = inputShape.y1;
    var y2 = inputShape.y2;
    outputShape.x1 = x1;
    outputShape.x2 = x2;
    outputShape.y1 = y1;
    outputShape.y2 = y2;
    var lineWidth = style && style.lineWidth;
    if (!lineWidth) {
      return outputShape;
    }
    if (round2(x1 * 2) === round2(x2 * 2)) {
      outputShape.x1 = outputShape.x2 = subPixelOptimize(x1, lineWidth, true);
    }
    if (round2(y1 * 2) === round2(y2 * 2)) {
      outputShape.y1 = outputShape.y2 = subPixelOptimize(y1, lineWidth, true);
    }
    return outputShape;
  }
  function subPixelOptimizeRect(outputShape, inputShape, style) {
    if (!inputShape) {
      return;
    }
    var originX = inputShape.x;
    var originY = inputShape.y;
    var originWidth = inputShape.width;
    var originHeight = inputShape.height;
    outputShape.x = originX;
    outputShape.y = originY;
    outputShape.width = originWidth;
    outputShape.height = originHeight;
    var lineWidth = style && style.lineWidth;
    if (!lineWidth) {
      return outputShape;
    }
    outputShape.x = subPixelOptimize(originX, lineWidth, true);
    outputShape.y = subPixelOptimize(originY, lineWidth, true);
    outputShape.width = Math.max(subPixelOptimize(originX + originWidth, lineWidth, false) - outputShape.x, originWidth === 0 ? 0 : 1);
    outputShape.height = Math.max(subPixelOptimize(originY + originHeight, lineWidth, false) - outputShape.y, originHeight === 0 ? 0 : 1);
    return outputShape;
  }
  function subPixelOptimize(position2, lineWidth, positiveOrNegative) {
    if (!lineWidth) {
      return position2;
    }
    var doubledPosition = round2(position2 * 2);
    return (doubledPosition + round2(lineWidth)) % 2 === 0 ? doubledPosition / 2 : (doubledPosition + (positiveOrNegative ? 1 : -1)) / 2;
  }

  // node_modules/zrender/lib/graphic/shape/Rect.js
  var RectShape = function() {
    function RectShape2() {
      this.x = 0;
      this.y = 0;
      this.width = 0;
      this.height = 0;
    }
    return RectShape2;
  }();
  var subPixelOptimizeOutputShape = {};
  var Rect = function(_super) {
    __extends2(Rect4, _super);
    function Rect4(opts) {
      return _super.call(this, opts) || this;
    }
    Rect4.prototype.getDefaultShape = function() {
      return new RectShape();
    };
    Rect4.prototype.buildPath = function(ctx, shape) {
      var x;
      var y;
      var width;
      var height;
      if (this.subPixelOptimize) {
        var optimizedShape = subPixelOptimizeRect(subPixelOptimizeOutputShape, shape, this.style);
        x = optimizedShape.x;
        y = optimizedShape.y;
        width = optimizedShape.width;
        height = optimizedShape.height;
        optimizedShape.r = shape.r;
        shape = optimizedShape;
      } else {
        x = shape.x;
        y = shape.y;
        width = shape.width;
        height = shape.height;
      }
      if (!shape.r) {
        ctx.rect(x, y, width, height);
      } else {
        buildPath(ctx, shape);
      }
    };
    Rect4.prototype.isZeroArea = function() {
      return !this.shape.width || !this.shape.height;
    };
    return Rect4;
  }(Path_default);
  Rect.prototype.type = "rect";
  var Rect_default = Rect;

  // node_modules/zrender/lib/graphic/Text.js
  var DEFAULT_RICH_TEXT_COLOR = {
    fill: "#000"
  };
  var DEFAULT_STROKE_LINE_WIDTH = 2;
  var DEFAULT_TEXT_ANIMATION_PROPS = {
    style: defaults({
      fill: true,
      stroke: true,
      fillOpacity: true,
      strokeOpacity: true,
      lineWidth: true,
      fontSize: true,
      lineHeight: true,
      width: true,
      height: true,
      textShadowColor: true,
      textShadowBlur: true,
      textShadowOffsetX: true,
      textShadowOffsetY: true,
      backgroundColor: true,
      padding: true,
      borderColor: true,
      borderWidth: true,
      borderRadius: true
    }, DEFAULT_COMMON_ANIMATION_PROPS.style)
  };
  var ZRText = function(_super) {
    __extends2(ZRText2, _super);
    function ZRText2(opts) {
      var _this = _super.call(this) || this;
      _this.type = "text";
      _this._children = [];
      _this._defaultStyle = DEFAULT_RICH_TEXT_COLOR;
      _this.attr(opts);
      return _this;
    }
    ZRText2.prototype.childrenRef = function() {
      return this._children;
    };
    ZRText2.prototype.update = function() {
      _super.prototype.update.call(this);
      if (this.styleChanged()) {
        this._updateSubTexts();
      }
      for (var i = 0; i < this._children.length; i++) {
        var child = this._children[i];
        child.zlevel = this.zlevel;
        child.z = this.z;
        child.z2 = this.z2;
        child.culling = this.culling;
        child.cursor = this.cursor;
        child.invisible = this.invisible;
      }
    };
    ZRText2.prototype.updateTransform = function() {
      var innerTransformable = this.innerTransformable;
      if (innerTransformable) {
        innerTransformable.updateTransform();
        if (innerTransformable.transform) {
          this.transform = innerTransformable.transform;
        }
      } else {
        _super.prototype.updateTransform.call(this);
      }
    };
    ZRText2.prototype.getLocalTransform = function(m2) {
      var innerTransformable = this.innerTransformable;
      return innerTransformable ? innerTransformable.getLocalTransform(m2) : _super.prototype.getLocalTransform.call(this, m2);
    };
    ZRText2.prototype.getComputedTransform = function() {
      if (this.__hostTarget) {
        this.__hostTarget.getComputedTransform();
        this.__hostTarget.updateInnerText(true);
      }
      return _super.prototype.getComputedTransform.call(this);
    };
    ZRText2.prototype._updateSubTexts = function() {
      this._childCursor = 0;
      normalizeTextStyle(this.style);
      this.style.rich ? this._updateRichTexts() : this._updatePlainTexts();
      this._children.length = this._childCursor;
      this.styleUpdated();
    };
    ZRText2.prototype.addSelfToZr = function(zr) {
      _super.prototype.addSelfToZr.call(this, zr);
      for (var i = 0; i < this._children.length; i++) {
        this._children[i].__zr = zr;
      }
    };
    ZRText2.prototype.removeSelfFromZr = function(zr) {
      _super.prototype.removeSelfFromZr.call(this, zr);
      for (var i = 0; i < this._children.length; i++) {
        this._children[i].__zr = null;
      }
    };
    ZRText2.prototype.getBoundingRect = function() {
      if (this.styleChanged()) {
        this._updateSubTexts();
      }
      if (!this._rect) {
        var tmpRect2 = new BoundingRect_default(0, 0, 0, 0);
        var children = this._children;
        var tmpMat = [];
        var rect = null;
        for (var i = 0; i < children.length; i++) {
          var child = children[i];
          var childRect = child.getBoundingRect();
          var transform2 = child.getLocalTransform(tmpMat);
          if (transform2) {
            tmpRect2.copy(childRect);
            tmpRect2.applyTransform(transform2);
            rect = rect || tmpRect2.clone();
            rect.union(tmpRect2);
          } else {
            rect = rect || childRect.clone();
            rect.union(childRect);
          }
        }
        this._rect = rect || tmpRect2;
      }
      return this._rect;
    };
    ZRText2.prototype.setDefaultTextStyle = function(defaultTextStyle) {
      this._defaultStyle = defaultTextStyle || DEFAULT_RICH_TEXT_COLOR;
    };
    ZRText2.prototype.setTextContent = function(textContent) {
      if (true) {
        throw new Error("Can't attach text on another text");
      }
    };
    ZRText2.prototype._mergeStyle = function(targetStyle, sourceStyle) {
      if (!sourceStyle) {
        return targetStyle;
      }
      var sourceRich = sourceStyle.rich;
      var targetRich = targetStyle.rich || sourceRich && {};
      extend(targetStyle, sourceStyle);
      if (sourceRich && targetRich) {
        this._mergeRich(targetRich, sourceRich);
        targetStyle.rich = targetRich;
      } else if (targetRich) {
        targetStyle.rich = targetRich;
      }
      return targetStyle;
    };
    ZRText2.prototype._mergeRich = function(targetRich, sourceRich) {
      var richNames = keys(sourceRich);
      for (var i = 0; i < richNames.length; i++) {
        var richName = richNames[i];
        targetRich[richName] = targetRich[richName] || {};
        extend(targetRich[richName], sourceRich[richName]);
      }
    };
    ZRText2.prototype.getAnimationStyleProps = function() {
      return DEFAULT_TEXT_ANIMATION_PROPS;
    };
    ZRText2.prototype._getOrCreateChild = function(Ctor) {
      var child = this._children[this._childCursor];
      if (!child || !(child instanceof Ctor)) {
        child = new Ctor();
      }
      this._children[this._childCursor++] = child;
      child.__zr = this.__zr;
      child.parent = this;
      return child;
    };
    ZRText2.prototype._updatePlainTexts = function() {
      var style = this.style;
      var textFont = style.font || DEFAULT_FONT;
      var textPadding = style.padding;
      var text = getStyleText(style);
      var contentBlock = parsePlainText(text, style);
      var needDrawBg = needDrawBackground(style);
      var bgColorDrawn = !!style.backgroundColor;
      var outerHeight = contentBlock.outerHeight;
      var outerWidth = contentBlock.outerWidth;
      var contentWidth = contentBlock.contentWidth;
      var textLines = contentBlock.lines;
      var lineHeight = contentBlock.lineHeight;
      var defaultStyle = this._defaultStyle;
      var baseX = style.x || 0;
      var baseY = style.y || 0;
      var textAlign = style.align || defaultStyle.align || "left";
      var verticalAlign = style.verticalAlign || defaultStyle.verticalAlign || "top";
      var textX = baseX;
      var textY = adjustTextY2(baseY, contentBlock.contentHeight, verticalAlign);
      if (needDrawBg || textPadding) {
        var boxX = adjustTextX(baseX, outerWidth, textAlign);
        var boxY = adjustTextY2(baseY, outerHeight, verticalAlign);
        needDrawBg && this._renderBackground(style, style, boxX, boxY, outerWidth, outerHeight);
      }
      textY += lineHeight / 2;
      if (textPadding) {
        textX = getTextXForPadding(baseX, textAlign, textPadding);
        if (verticalAlign === "top") {
          textY += textPadding[0];
        } else if (verticalAlign === "bottom") {
          textY -= textPadding[2];
        }
      }
      var defaultLineWidth = 0;
      var useDefaultFill = false;
      var textFill = getFill("fill" in style ? style.fill : (useDefaultFill = true, defaultStyle.fill));
      var textStroke = getStroke("stroke" in style ? style.stroke : !bgColorDrawn && (!defaultStyle.autoStroke || useDefaultFill) ? (defaultLineWidth = DEFAULT_STROKE_LINE_WIDTH, defaultStyle.stroke) : null);
      var hasShadow2 = style.textShadowBlur > 0;
      var fixedBoundingRect = style.width != null && (style.overflow === "truncate" || style.overflow === "break" || style.overflow === "breakAll");
      var calculatedLineHeight = contentBlock.calculatedLineHeight;
      for (var i = 0; i < textLines.length; i++) {
        var el = this._getOrCreateChild(TSpan_default);
        var subElStyle = el.createStyle();
        el.useStyle(subElStyle);
        subElStyle.text = textLines[i];
        subElStyle.x = textX;
        subElStyle.y = textY;
        if (textAlign) {
          subElStyle.textAlign = textAlign;
        }
        subElStyle.textBaseline = "middle";
        subElStyle.opacity = style.opacity;
        subElStyle.strokeFirst = true;
        if (hasShadow2) {
          subElStyle.shadowBlur = style.textShadowBlur || 0;
          subElStyle.shadowColor = style.textShadowColor || "transparent";
          subElStyle.shadowOffsetX = style.textShadowOffsetX || 0;
          subElStyle.shadowOffsetY = style.textShadowOffsetY || 0;
        }
        subElStyle.stroke = textStroke;
        subElStyle.fill = textFill;
        if (textStroke) {
          subElStyle.lineWidth = style.lineWidth || defaultLineWidth;
          subElStyle.lineDash = style.lineDash;
          subElStyle.lineDashOffset = style.lineDashOffset || 0;
        }
        subElStyle.font = textFont;
        setSeparateFont(subElStyle, style);
        textY += lineHeight;
        if (fixedBoundingRect) {
          el.setBoundingRect(new BoundingRect_default(adjustTextX(subElStyle.x, style.width, subElStyle.textAlign), adjustTextY2(subElStyle.y, calculatedLineHeight, subElStyle.textBaseline), contentWidth, calculatedLineHeight));
        }
      }
    };
    ZRText2.prototype._updateRichTexts = function() {
      var style = this.style;
      var text = getStyleText(style);
      var contentBlock = parseRichText(text, style);
      var contentWidth = contentBlock.width;
      var outerWidth = contentBlock.outerWidth;
      var outerHeight = contentBlock.outerHeight;
      var textPadding = style.padding;
      var baseX = style.x || 0;
      var baseY = style.y || 0;
      var defaultStyle = this._defaultStyle;
      var textAlign = style.align || defaultStyle.align;
      var verticalAlign = style.verticalAlign || defaultStyle.verticalAlign;
      var boxX = adjustTextX(baseX, outerWidth, textAlign);
      var boxY = adjustTextY2(baseY, outerHeight, verticalAlign);
      var xLeft = boxX;
      var lineTop = boxY;
      if (textPadding) {
        xLeft += textPadding[3];
        lineTop += textPadding[0];
      }
      var xRight = xLeft + contentWidth;
      if (needDrawBackground(style)) {
        this._renderBackground(style, style, boxX, boxY, outerWidth, outerHeight);
      }
      var bgColorDrawn = !!style.backgroundColor;
      for (var i = 0; i < contentBlock.lines.length; i++) {
        var line = contentBlock.lines[i];
        var tokens = line.tokens;
        var tokenCount = tokens.length;
        var lineHeight = line.lineHeight;
        var remainedWidth = line.width;
        var leftIndex = 0;
        var lineXLeft = xLeft;
        var lineXRight = xRight;
        var rightIndex = tokenCount - 1;
        var token = void 0;
        while (leftIndex < tokenCount && (token = tokens[leftIndex], !token.align || token.align === "left")) {
          this._placeToken(token, style, lineHeight, lineTop, lineXLeft, "left", bgColorDrawn);
          remainedWidth -= token.width;
          lineXLeft += token.width;
          leftIndex++;
        }
        while (rightIndex >= 0 && (token = tokens[rightIndex], token.align === "right")) {
          this._placeToken(token, style, lineHeight, lineTop, lineXRight, "right", bgColorDrawn);
          remainedWidth -= token.width;
          lineXRight -= token.width;
          rightIndex--;
        }
        lineXLeft += (contentWidth - (lineXLeft - xLeft) - (xRight - lineXRight) - remainedWidth) / 2;
        while (leftIndex <= rightIndex) {
          token = tokens[leftIndex];
          this._placeToken(token, style, lineHeight, lineTop, lineXLeft + token.width / 2, "center", bgColorDrawn);
          lineXLeft += token.width;
          leftIndex++;
        }
        lineTop += lineHeight;
      }
    };
    ZRText2.prototype._placeToken = function(token, style, lineHeight, lineTop, x, textAlign, parentBgColorDrawn) {
      var tokenStyle = style.rich[token.styleName] || {};
      tokenStyle.text = token.text;
      var verticalAlign = token.verticalAlign;
      var y = lineTop + lineHeight / 2;
      if (verticalAlign === "top") {
        y = lineTop + token.height / 2;
      } else if (verticalAlign === "bottom") {
        y = lineTop + lineHeight - token.height / 2;
      }
      var needDrawBg = !token.isLineHolder && needDrawBackground(tokenStyle);
      needDrawBg && this._renderBackground(tokenStyle, style, textAlign === "right" ? x - token.width : textAlign === "center" ? x - token.width / 2 : x, y - token.height / 2, token.width, token.height);
      var bgColorDrawn = !!tokenStyle.backgroundColor;
      var textPadding = token.textPadding;
      if (textPadding) {
        x = getTextXForPadding(x, textAlign, textPadding);
        y -= token.height / 2 - textPadding[0] - token.innerHeight / 2;
      }
      var el = this._getOrCreateChild(TSpan_default);
      var subElStyle = el.createStyle();
      el.useStyle(subElStyle);
      var defaultStyle = this._defaultStyle;
      var useDefaultFill = false;
      var defaultLineWidth = 0;
      var textFill = getFill("fill" in tokenStyle ? tokenStyle.fill : "fill" in style ? style.fill : (useDefaultFill = true, defaultStyle.fill));
      var textStroke = getStroke("stroke" in tokenStyle ? tokenStyle.stroke : "stroke" in style ? style.stroke : !bgColorDrawn && !parentBgColorDrawn && (!defaultStyle.autoStroke || useDefaultFill) ? (defaultLineWidth = DEFAULT_STROKE_LINE_WIDTH, defaultStyle.stroke) : null);
      var hasShadow2 = tokenStyle.textShadowBlur > 0 || style.textShadowBlur > 0;
      subElStyle.text = token.text;
      subElStyle.x = x;
      subElStyle.y = y;
      if (hasShadow2) {
        subElStyle.shadowBlur = tokenStyle.textShadowBlur || style.textShadowBlur || 0;
        subElStyle.shadowColor = tokenStyle.textShadowColor || style.textShadowColor || "transparent";
        subElStyle.shadowOffsetX = tokenStyle.textShadowOffsetX || style.textShadowOffsetX || 0;
        subElStyle.shadowOffsetY = tokenStyle.textShadowOffsetY || style.textShadowOffsetY || 0;
      }
      subElStyle.textAlign = textAlign;
      subElStyle.textBaseline = "middle";
      subElStyle.font = token.font || DEFAULT_FONT;
      subElStyle.opacity = retrieve3(tokenStyle.opacity, style.opacity, 1);
      setSeparateFont(subElStyle, tokenStyle);
      if (textStroke) {
        subElStyle.lineWidth = retrieve3(tokenStyle.lineWidth, style.lineWidth, defaultLineWidth);
        subElStyle.lineDash = retrieve2(tokenStyle.lineDash, style.lineDash);
        subElStyle.lineDashOffset = style.lineDashOffset || 0;
        subElStyle.stroke = textStroke;
      }
      if (textFill) {
        subElStyle.fill = textFill;
      }
      var textWidth = token.contentWidth;
      var textHeight = token.contentHeight;
      el.setBoundingRect(new BoundingRect_default(adjustTextX(subElStyle.x, textWidth, subElStyle.textAlign), adjustTextY2(subElStyle.y, textHeight, subElStyle.textBaseline), textWidth, textHeight));
    };
    ZRText2.prototype._renderBackground = function(style, topStyle, x, y, width, height) {
      var textBackgroundColor = style.backgroundColor;
      var textBorderWidth = style.borderWidth;
      var textBorderColor = style.borderColor;
      var isImageBg = textBackgroundColor && textBackgroundColor.image;
      var isPlainOrGradientBg = textBackgroundColor && !isImageBg;
      var textBorderRadius = style.borderRadius;
      var self2 = this;
      var rectEl;
      var imgEl;
      if (isPlainOrGradientBg || style.lineHeight || textBorderWidth && textBorderColor) {
        rectEl = this._getOrCreateChild(Rect_default);
        rectEl.useStyle(rectEl.createStyle());
        rectEl.style.fill = null;
        var rectShape = rectEl.shape;
        rectShape.x = x;
        rectShape.y = y;
        rectShape.width = width;
        rectShape.height = height;
        rectShape.r = textBorderRadius;
        rectEl.dirtyShape();
      }
      if (isPlainOrGradientBg) {
        var rectStyle = rectEl.style;
        rectStyle.fill = textBackgroundColor || null;
        rectStyle.fillOpacity = retrieve2(style.fillOpacity, 1);
      } else if (isImageBg) {
        imgEl = this._getOrCreateChild(Image_default);
        imgEl.onload = function() {
          self2.dirtyStyle();
        };
        var imgStyle = imgEl.style;
        imgStyle.image = textBackgroundColor.image;
        imgStyle.x = x;
        imgStyle.y = y;
        imgStyle.width = width;
        imgStyle.height = height;
      }
      if (textBorderWidth && textBorderColor) {
        var rectStyle = rectEl.style;
        rectStyle.lineWidth = textBorderWidth;
        rectStyle.stroke = textBorderColor;
        rectStyle.strokeOpacity = retrieve2(style.strokeOpacity, 1);
        rectStyle.lineDash = style.borderDash;
        rectStyle.lineDashOffset = style.borderDashOffset || 0;
        rectEl.strokeContainThreshold = 0;
        if (rectEl.hasFill() && rectEl.hasStroke()) {
          rectStyle.strokeFirst = true;
          rectStyle.lineWidth *= 2;
        }
      }
      var commonStyle = (rectEl || imgEl).style;
      commonStyle.shadowBlur = style.shadowBlur || 0;
      commonStyle.shadowColor = style.shadowColor || "transparent";
      commonStyle.shadowOffsetX = style.shadowOffsetX || 0;
      commonStyle.shadowOffsetY = style.shadowOffsetY || 0;
      commonStyle.opacity = retrieve3(style.opacity, topStyle.opacity, 1);
    };
    ZRText2.makeFont = function(style) {
      var font = "";
      if (hasSeparateFont(style)) {
        font = [
          style.fontStyle,
          style.fontWeight,
          parseFontSize(style.fontSize),
          style.fontFamily || "sans-serif"
        ].join(" ");
      }
      return font && trim(font) || style.textFont || style.font;
    };
    return ZRText2;
  }(Displayable_default);
  var VALID_TEXT_ALIGN = { left: true, right: 1, center: 1 };
  var VALID_TEXT_VERTICAL_ALIGN = { top: 1, bottom: 1, middle: 1 };
  var FONT_PARTS = ["fontStyle", "fontWeight", "fontSize", "fontFamily"];
  function parseFontSize(fontSize) {
    if (typeof fontSize === "string" && (fontSize.indexOf("px") !== -1 || fontSize.indexOf("rem") !== -1 || fontSize.indexOf("em") !== -1)) {
      return fontSize;
    } else if (!isNaN(+fontSize)) {
      return fontSize + "px";
    } else {
      return DEFAULT_FONT_SIZE + "px";
    }
  }
  function setSeparateFont(targetStyle, sourceStyle) {
    for (var i = 0; i < FONT_PARTS.length; i++) {
      var fontProp = FONT_PARTS[i];
      var val = sourceStyle[fontProp];
      if (val != null) {
        targetStyle[fontProp] = val;
      }
    }
  }
  function hasSeparateFont(style) {
    return style.fontSize != null || style.fontFamily || style.fontWeight;
  }
  function normalizeTextStyle(style) {
    normalizeStyle(style);
    each(style.rich, normalizeStyle);
    return style;
  }
  function normalizeStyle(style) {
    if (style) {
      style.font = ZRText.makeFont(style);
      var textAlign = style.align;
      textAlign === "middle" && (textAlign = "center");
      style.align = textAlign == null || VALID_TEXT_ALIGN[textAlign] ? textAlign : "left";
      var verticalAlign = style.verticalAlign;
      verticalAlign === "center" && (verticalAlign = "middle");
      style.verticalAlign = verticalAlign == null || VALID_TEXT_VERTICAL_ALIGN[verticalAlign] ? verticalAlign : "top";
      var textPadding = style.padding;
      if (textPadding) {
        style.padding = normalizeCssArray(style.padding);
      }
    }
  }
  function getStroke(stroke, lineWidth) {
    return stroke == null || lineWidth <= 0 || stroke === "transparent" || stroke === "none" ? null : stroke.image || stroke.colorStops ? "#000" : stroke;
  }
  function getFill(fill) {
    return fill == null || fill === "none" ? null : fill.image || fill.colorStops ? "#000" : fill;
  }
  function getTextXForPadding(x, textAlign, textPadding) {
    return textAlign === "right" ? x - textPadding[1] : textAlign === "center" ? x + textPadding[3] / 2 - textPadding[1] / 2 : x + textPadding[3];
  }
  function getStyleText(style) {
    var text = style.text;
    text != null && (text += "");
    return text;
  }
  function needDrawBackground(style) {
    return !!(style.backgroundColor || style.lineHeight || style.borderWidth && style.borderColor);
  }
  var Text_default = ZRText;

  // node_modules/echarts/lib/util/innerStore.js
  var getECData = makeInner();
  var setCommonECData = function(seriesIndex, dataType, dataIdx, el) {
    if (el) {
      var ecData = getECData(el);
      ecData.dataIndex = dataIdx;
      ecData.dataType = dataType;
      ecData.seriesIndex = seriesIndex;
      if (el.type === "group") {
        el.traverse(function(child) {
          var childECData = getECData(child);
          childECData.seriesIndex = seriesIndex;
          childECData.dataIndex = dataIdx;
          childECData.dataType = dataType;
        });
      }
    }
  };

  // node_modules/echarts/lib/util/states.js
  var _highlightNextDigit = 1;
  var _highlightKeyMap = {};
  var getSavedStates = makeInner();
  var getComponentStates = makeInner();
  var HOVER_STATE_NORMAL = 0;
  var HOVER_STATE_BLUR = 1;
  var HOVER_STATE_EMPHASIS = 2;
  var SPECIAL_STATES = ["emphasis", "blur", "select"];
  var DISPLAY_STATES = ["normal", "emphasis", "blur", "select"];
  var Z2_EMPHASIS_LIFT = 10;
  var Z2_SELECT_LIFT = 9;
  var HIGHLIGHT_ACTION_TYPE = "highlight";
  var DOWNPLAY_ACTION_TYPE = "downplay";
  var SELECT_ACTION_TYPE = "select";
  var UNSELECT_ACTION_TYPE = "unselect";
  var TOGGLE_SELECT_ACTION_TYPE = "toggleSelect";
  function hasFillOrStroke(fillOrStroke) {
    return fillOrStroke != null && fillOrStroke !== "none";
  }
  var liftedColorCache = new LRU_default(100);
  function liftColor(color) {
    if (isString(color)) {
      var liftedColor = liftedColorCache.get(color);
      if (!liftedColor) {
        liftedColor = lift(color, -0.1);
        liftedColorCache.put(color, liftedColor);
      }
      return liftedColor;
    } else if (isGradientObject(color)) {
      var ret = extend({}, color);
      ret.colorStops = map(color.colorStops, function(stop2) {
        return {
          offset: stop2.offset,
          color: lift(stop2.color, -0.1)
        };
      });
      return ret;
    }
    return color;
  }
  function doChangeHoverState(el, stateName, hoverStateEnum) {
    if (el.onHoverStateChange && (el.hoverState || 0) !== hoverStateEnum) {
      el.onHoverStateChange(stateName);
    }
    el.hoverState = hoverStateEnum;
  }
  function singleEnterEmphasis(el) {
    doChangeHoverState(el, "emphasis", HOVER_STATE_EMPHASIS);
  }
  function singleLeaveEmphasis(el) {
    if (el.hoverState === HOVER_STATE_EMPHASIS) {
      doChangeHoverState(el, "normal", HOVER_STATE_NORMAL);
    }
  }
  function singleEnterBlur(el) {
    doChangeHoverState(el, "blur", HOVER_STATE_BLUR);
  }
  function singleLeaveBlur(el) {
    if (el.hoverState === HOVER_STATE_BLUR) {
      doChangeHoverState(el, "normal", HOVER_STATE_NORMAL);
    }
  }
  function singleEnterSelect(el) {
    el.selected = true;
  }
  function singleLeaveSelect(el) {
    el.selected = false;
  }
  function updateElementState(el, updater, commonParam) {
    updater(el, commonParam);
  }
  function traverseUpdateState(el, updater, commonParam) {
    updateElementState(el, updater, commonParam);
    el.isGroup && el.traverse(function(child) {
      updateElementState(child, updater, commonParam);
    });
  }
  function setStatesFlag(el, stateName) {
    switch (stateName) {
      case "emphasis":
        el.hoverState = HOVER_STATE_EMPHASIS;
        break;
      case "normal":
        el.hoverState = HOVER_STATE_NORMAL;
        break;
      case "blur":
        el.hoverState = HOVER_STATE_BLUR;
        break;
      case "select":
        el.selected = true;
    }
  }
  function getFromStateStyle(el, props, toStateName, defaultValue) {
    var style = el.style;
    var fromState = {};
    for (var i = 0; i < props.length; i++) {
      var propName = props[i];
      var val = style[propName];
      fromState[propName] = val == null ? defaultValue && defaultValue[propName] : val;
    }
    for (var i = 0; i < el.animators.length; i++) {
      var animator = el.animators[i];
      if (animator.__fromStateTransition && animator.__fromStateTransition.indexOf(toStateName) < 0 && animator.targetName === "style") {
        animator.saveTo(fromState, props);
      }
    }
    return fromState;
  }
  function createEmphasisDefaultState(el, stateName, targetStates, state) {
    var hasSelect = targetStates && indexOf(targetStates, "select") >= 0;
    var cloned = false;
    if (el instanceof Path_default) {
      var store = getSavedStates(el);
      var fromFill = hasSelect ? store.selectFill || store.normalFill : store.normalFill;
      var fromStroke = hasSelect ? store.selectStroke || store.normalStroke : store.normalStroke;
      if (hasFillOrStroke(fromFill) || hasFillOrStroke(fromStroke)) {
        state = state || {};
        var emphasisStyle = state.style || {};
        if (emphasisStyle.fill === "inherit") {
          cloned = true;
          state = extend({}, state);
          emphasisStyle = extend({}, emphasisStyle);
          emphasisStyle.fill = fromFill;
        } else if (!hasFillOrStroke(emphasisStyle.fill) && hasFillOrStroke(fromFill)) {
          cloned = true;
          state = extend({}, state);
          emphasisStyle = extend({}, emphasisStyle);
          emphasisStyle.fill = liftColor(fromFill);
        } else if (!hasFillOrStroke(emphasisStyle.stroke) && hasFillOrStroke(fromStroke)) {
          if (!cloned) {
            state = extend({}, state);
            emphasisStyle = extend({}, emphasisStyle);
          }
          emphasisStyle.stroke = liftColor(fromStroke);
        }
        state.style = emphasisStyle;
      }
    }
    if (state) {
      if (state.z2 == null) {
        if (!cloned) {
          state = extend({}, state);
        }
        var z2EmphasisLift = el.z2EmphasisLift;
        state.z2 = el.z2 + (z2EmphasisLift != null ? z2EmphasisLift : Z2_EMPHASIS_LIFT);
      }
    }
    return state;
  }
  function createSelectDefaultState(el, stateName, state) {
    if (state) {
      if (state.z2 == null) {
        state = extend({}, state);
        var z2SelectLift = el.z2SelectLift;
        state.z2 = el.z2 + (z2SelectLift != null ? z2SelectLift : Z2_SELECT_LIFT);
      }
    }
    return state;
  }
  function createBlurDefaultState(el, stateName, state) {
    var hasBlur = indexOf(el.currentStates, stateName) >= 0;
    var currentOpacity = el.style.opacity;
    var fromState = !hasBlur ? getFromStateStyle(el, ["opacity"], stateName, {
      opacity: 1
    }) : null;
    state = state || {};
    var blurStyle = state.style || {};
    if (blurStyle.opacity == null) {
      state = extend({}, state);
      blurStyle = extend({
        opacity: hasBlur ? currentOpacity : fromState.opacity * 0.1
      }, blurStyle);
      state.style = blurStyle;
    }
    return state;
  }
  function elementStateProxy(stateName, targetStates) {
    var state = this.states[stateName];
    if (this.style) {
      if (stateName === "emphasis") {
        return createEmphasisDefaultState(this, stateName, targetStates, state);
      } else if (stateName === "blur") {
        return createBlurDefaultState(this, stateName, state);
      } else if (stateName === "select") {
        return createSelectDefaultState(this, stateName, state);
      }
    }
    return state;
  }
  function setDefaultStateProxy(el) {
    el.stateProxy = elementStateProxy;
    var textContent = el.getTextContent();
    var textGuide = el.getTextGuideLine();
    if (textContent) {
      textContent.stateProxy = elementStateProxy;
    }
    if (textGuide) {
      textGuide.stateProxy = elementStateProxy;
    }
  }
  function enterEmphasisWhenMouseOver(el, e2) {
    !shouldSilent(el, e2) && !el.__highByOuter && traverseUpdateState(el, singleEnterEmphasis);
  }
  function leaveEmphasisWhenMouseOut(el, e2) {
    !shouldSilent(el, e2) && !el.__highByOuter && traverseUpdateState(el, singleLeaveEmphasis);
  }
  function enterEmphasis(el, highlightDigit) {
    el.__highByOuter |= 1 << (highlightDigit || 0);
    traverseUpdateState(el, singleEnterEmphasis);
  }
  function leaveEmphasis(el, highlightDigit) {
    !(el.__highByOuter &= ~(1 << (highlightDigit || 0))) && traverseUpdateState(el, singleLeaveEmphasis);
  }
  function enterBlur(el) {
    traverseUpdateState(el, singleEnterBlur);
  }
  function leaveBlur(el) {
    traverseUpdateState(el, singleLeaveBlur);
  }
  function enterSelect(el) {
    traverseUpdateState(el, singleEnterSelect);
  }
  function leaveSelect(el) {
    traverseUpdateState(el, singleLeaveSelect);
  }
  function shouldSilent(el, e2) {
    return el.__highDownSilentOnTouch && e2.zrByTouch;
  }
  function allLeaveBlur(api) {
    var model = api.getModel();
    var leaveBlurredSeries = [];
    var allComponentViews = [];
    model.eachComponent(function(componentType, componentModel) {
      var componentStates = getComponentStates(componentModel);
      var isSeries2 = componentType === "series";
      var view = isSeries2 ? api.getViewOfSeriesModel(componentModel) : api.getViewOfComponentModel(componentModel);
      !isSeries2 && allComponentViews.push(view);
      if (componentStates.isBlured) {
        view.group.traverse(function(child) {
          singleLeaveBlur(child);
        });
        isSeries2 && leaveBlurredSeries.push(componentModel);
      }
      componentStates.isBlured = false;
    });
    each(allComponentViews, function(view) {
      if (view && view.toggleBlurSeries) {
        view.toggleBlurSeries(leaveBlurredSeries, false, model);
      }
    });
  }
  function blurSeries(targetSeriesIndex, focus, blurScope, api) {
    var ecModel = api.getModel();
    blurScope = blurScope || "coordinateSystem";
    function leaveBlurOfIndices(data, dataIndices) {
      for (var i = 0; i < dataIndices.length; i++) {
        var itemEl = data.getItemGraphicEl(dataIndices[i]);
        itemEl && leaveBlur(itemEl);
      }
    }
    if (targetSeriesIndex == null) {
      return;
    }
    if (!focus || focus === "none") {
      return;
    }
    var targetSeriesModel = ecModel.getSeriesByIndex(targetSeriesIndex);
    var targetCoordSys = targetSeriesModel.coordinateSystem;
    if (targetCoordSys && targetCoordSys.master) {
      targetCoordSys = targetCoordSys.master;
    }
    var blurredSeries = [];
    ecModel.eachSeries(function(seriesModel) {
      var sameSeries = targetSeriesModel === seriesModel;
      var coordSys = seriesModel.coordinateSystem;
      if (coordSys && coordSys.master) {
        coordSys = coordSys.master;
      }
      var sameCoordSys = coordSys && targetCoordSys ? coordSys === targetCoordSys : sameSeries;
      if (!(blurScope === "series" && !sameSeries || blurScope === "coordinateSystem" && !sameCoordSys || focus === "series" && sameSeries)) {
        var view = api.getViewOfSeriesModel(seriesModel);
        view.group.traverse(function(child) {
          singleEnterBlur(child);
        });
        if (isArrayLike(focus)) {
          leaveBlurOfIndices(seriesModel.getData(), focus);
        } else if (isObject(focus)) {
          var dataTypes = keys(focus);
          for (var d = 0; d < dataTypes.length; d++) {
            leaveBlurOfIndices(seriesModel.getData(dataTypes[d]), focus[dataTypes[d]]);
          }
        }
        blurredSeries.push(seriesModel);
        getComponentStates(seriesModel).isBlured = true;
      }
    });
    ecModel.eachComponent(function(componentType, componentModel) {
      if (componentType === "series") {
        return;
      }
      var view = api.getViewOfComponentModel(componentModel);
      if (view && view.toggleBlurSeries) {
        view.toggleBlurSeries(blurredSeries, true, ecModel);
      }
    });
  }
  function blurComponent(componentMainType, componentIndex, api) {
    if (componentMainType == null || componentIndex == null) {
      return;
    }
    var componentModel = api.getModel().getComponent(componentMainType, componentIndex);
    if (!componentModel) {
      return;
    }
    getComponentStates(componentModel).isBlured = true;
    var view = api.getViewOfComponentModel(componentModel);
    if (!view || !view.focusBlurEnabled) {
      return;
    }
    view.group.traverse(function(child) {
      singleEnterBlur(child);
    });
  }
  function blurSeriesFromHighlightPayload(seriesModel, payload, api) {
    var seriesIndex = seriesModel.seriesIndex;
    var data = seriesModel.getData(payload.dataType);
    if (!data) {
      if (true) {
        error("Unknown dataType " + payload.dataType);
      }
      return;
    }
    var dataIndex = queryDataIndex(data, payload);
    dataIndex = (isArray(dataIndex) ? dataIndex[0] : dataIndex) || 0;
    var el = data.getItemGraphicEl(dataIndex);
    if (!el) {
      var count2 = data.count();
      var current = 0;
      while (!el && current < count2) {
        el = data.getItemGraphicEl(current++);
      }
    }
    if (el) {
      var ecData = getECData(el);
      blurSeries(seriesIndex, ecData.focus, ecData.blurScope, api);
    } else {
      var focus_1 = seriesModel.get(["emphasis", "focus"]);
      var blurScope = seriesModel.get(["emphasis", "blurScope"]);
      if (focus_1 != null) {
        blurSeries(seriesIndex, focus_1, blurScope, api);
      }
    }
  }
  function findComponentHighDownDispatchers(componentMainType, componentIndex, name, api) {
    var ret = {
      focusSelf: false,
      dispatchers: null
    };
    if (componentMainType == null || componentMainType === "series" || componentIndex == null || name == null) {
      return ret;
    }
    var componentModel = api.getModel().getComponent(componentMainType, componentIndex);
    if (!componentModel) {
      return ret;
    }
    var view = api.getViewOfComponentModel(componentModel);
    if (!view || !view.findHighDownDispatchers) {
      return ret;
    }
    var dispatchers = view.findHighDownDispatchers(name);
    var focusSelf;
    for (var i = 0; i < dispatchers.length; i++) {
      if (!isHighDownDispatcher(dispatchers[i])) {
        error("param should be highDownDispatcher");
      }
      if (getECData(dispatchers[i]).focus === "self") {
        focusSelf = true;
        break;
      }
    }
    return {
      focusSelf,
      dispatchers
    };
  }
  function handleGlobalMouseOverForHighDown(dispatcher, e2, api) {
    if (!isHighDownDispatcher(dispatcher)) {
      error("param should be highDownDispatcher");
    }
    var ecData = getECData(dispatcher);
    var _a2 = findComponentHighDownDispatchers(ecData.componentMainType, ecData.componentIndex, ecData.componentHighDownName, api), dispatchers = _a2.dispatchers, focusSelf = _a2.focusSelf;
    if (dispatchers) {
      if (focusSelf) {
        blurComponent(ecData.componentMainType, ecData.componentIndex, api);
      }
      each(dispatchers, function(dispatcher2) {
        return enterEmphasisWhenMouseOver(dispatcher2, e2);
      });
    } else {
      blurSeries(ecData.seriesIndex, ecData.focus, ecData.blurScope, api);
      if (ecData.focus === "self") {
        blurComponent(ecData.componentMainType, ecData.componentIndex, api);
      }
      enterEmphasisWhenMouseOver(dispatcher, e2);
    }
  }
  function handleGlobalMouseOutForHighDown(dispatcher, e2, api) {
    if (!isHighDownDispatcher(dispatcher)) {
      error("param should be highDownDispatcher");
    }
    allLeaveBlur(api);
    var ecData = getECData(dispatcher);
    var dispatchers = findComponentHighDownDispatchers(ecData.componentMainType, ecData.componentIndex, ecData.componentHighDownName, api).dispatchers;
    if (dispatchers) {
      each(dispatchers, function(dispatcher2) {
        return leaveEmphasisWhenMouseOut(dispatcher2, e2);
      });
    } else {
      leaveEmphasisWhenMouseOut(dispatcher, e2);
    }
  }
  function toggleSelectionFromPayload(seriesModel, payload, api) {
    if (!isSelectChangePayload(payload)) {
      return;
    }
    var dataType = payload.dataType;
    var data = seriesModel.getData(dataType);
    var dataIndex = queryDataIndex(data, payload);
    if (!isArray(dataIndex)) {
      dataIndex = [dataIndex];
    }
    seriesModel[payload.type === TOGGLE_SELECT_ACTION_TYPE ? "toggleSelect" : payload.type === SELECT_ACTION_TYPE ? "select" : "unselect"](dataIndex, dataType);
  }
  function updateSeriesElementSelection(seriesModel) {
    var allData = seriesModel.getAllData();
    each(allData, function(_a2) {
      var data = _a2.data, type = _a2.type;
      data.eachItemGraphicEl(function(el, idx) {
        seriesModel.isSelected(idx, type) ? enterSelect(el) : leaveSelect(el);
      });
    });
  }
  function getAllSelectedIndices(ecModel) {
    var ret = [];
    ecModel.eachSeries(function(seriesModel) {
      var allData = seriesModel.getAllData();
      each(allData, function(_a2) {
        var data = _a2.data, type = _a2.type;
        var dataIndices = seriesModel.getSelectedDataIndices();
        if (dataIndices.length > 0) {
          var item = {
            dataIndex: dataIndices,
            seriesIndex: seriesModel.seriesIndex
          };
          if (type != null) {
            item.dataType = type;
          }
          ret.push(item);
        }
      });
    });
    return ret;
  }
  function enableHoverEmphasis(el, focus, blurScope) {
    setAsHighDownDispatcher(el, true);
    traverseUpdateState(el, setDefaultStateProxy);
    enableHoverFocus(el, focus, blurScope);
  }
  function disableHoverEmphasis(el) {
    setAsHighDownDispatcher(el, false);
  }
  function toggleHoverEmphasis(el, focus, blurScope, isDisabled) {
    isDisabled ? disableHoverEmphasis(el) : enableHoverEmphasis(el, focus, blurScope);
  }
  function enableHoverFocus(el, focus, blurScope) {
    var ecData = getECData(el);
    if (focus != null) {
      ecData.focus = focus;
      ecData.blurScope = blurScope;
    } else if (ecData.focus) {
      ecData.focus = null;
    }
  }
  var OTHER_STATES = ["emphasis", "blur", "select"];
  var defaultStyleGetterMap = {
    itemStyle: "getItemStyle",
    lineStyle: "getLineStyle",
    areaStyle: "getAreaStyle"
  };
  function setStatesStylesFromModel(el, itemModel, styleType, getter) {
    styleType = styleType || "itemStyle";
    for (var i = 0; i < OTHER_STATES.length; i++) {
      var stateName = OTHER_STATES[i];
      var model = itemModel.getModel([stateName, styleType]);
      var state = el.ensureState(stateName);
      state.style = getter ? getter(model) : model[defaultStyleGetterMap[styleType]]();
    }
  }
  function setAsHighDownDispatcher(el, asDispatcher) {
    var disable = asDispatcher === false;
    var extendedEl = el;
    if (el.highDownSilentOnTouch) {
      extendedEl.__highDownSilentOnTouch = el.highDownSilentOnTouch;
    }
    if (!disable || extendedEl.__highDownDispatcher) {
      extendedEl.__highByOuter = extendedEl.__highByOuter || 0;
      extendedEl.__highDownDispatcher = !disable;
    }
  }
  function isHighDownDispatcher(el) {
    return !!(el && el.__highDownDispatcher);
  }
  function enableComponentHighDownFeatures(el, componentModel, componentHighDownName) {
    var ecData = getECData(el);
    ecData.componentMainType = componentModel.mainType;
    ecData.componentIndex = componentModel.componentIndex;
    ecData.componentHighDownName = componentHighDownName;
  }
  function getHighlightDigit(highlightKey) {
    var highlightDigit = _highlightKeyMap[highlightKey];
    if (highlightDigit == null && _highlightNextDigit <= 32) {
      highlightDigit = _highlightKeyMap[highlightKey] = _highlightNextDigit++;
    }
    return highlightDigit;
  }
  function isSelectChangePayload(payload) {
    var payloadType = payload.type;
    return payloadType === SELECT_ACTION_TYPE || payloadType === UNSELECT_ACTION_TYPE || payloadType === TOGGLE_SELECT_ACTION_TYPE;
  }
  function isHighDownPayload(payload) {
    var payloadType = payload.type;
    return payloadType === HIGHLIGHT_ACTION_TYPE || payloadType === DOWNPLAY_ACTION_TYPE;
  }
  function savePathStates(el) {
    var store = getSavedStates(el);
    store.normalFill = el.style.fill;
    store.normalStroke = el.style.stroke;
    var selectState = el.states.select || {};
    store.selectFill = selectState.style && selectState.style.fill || null;
    store.selectStroke = selectState.style && selectState.style.stroke || null;
  }

  // node_modules/echarts/lib/util/graphic.js
  var graphic_exports = {};
  __export(graphic_exports, {
    Arc: () => Arc_default,
    BezierCurve: () => BezierCurve_default,
    BoundingRect: () => BoundingRect_default,
    Circle: () => Circle_default,
    CompoundPath: () => CompoundPath_default,
    Ellipse: () => Ellipse_default,
    Group: () => Group_default,
    Image: () => Image_default,
    IncrementalDisplayable: () => IncrementalDisplayable_default,
    Line: () => Line_default,
    LinearGradient: () => LinearGradient_default,
    OrientedBoundingRect: () => OrientedBoundingRect_default,
    Path: () => Path_default,
    Point: () => Point_default,
    Polygon: () => Polygon_default,
    Polyline: () => Polyline_default,
    RadialGradient: () => RadialGradient_default,
    Rect: () => Rect_default,
    Ring: () => Ring_default,
    Sector: () => Sector_default,
    Text: () => Text_default,
    applyTransform: () => applyTransform2,
    clipPointsByRect: () => clipPointsByRect,
    clipRectByRect: () => clipRectByRect,
    createIcon: () => createIcon,
    extendPath: () => extendPath,
    extendShape: () => extendShape,
    getShapeClass: () => getShapeClass,
    getTransform: () => getTransform,
    groupTransition: () => groupTransition,
    initProps: () => initProps,
    isElementRemoved: () => isElementRemoved,
    lineLineIntersect: () => lineLineIntersect,
    linePolygonIntersect: () => linePolygonIntersect,
    makeImage: () => makeImage,
    makePath: () => makePath,
    mergePath: () => mergePath2,
    registerShape: () => registerShape,
    removeElement: () => removeElement,
    removeElementWithFadeOut: () => removeElementWithFadeOut,
    resizePath: () => resizePath,
    setTooltipConfig: () => setTooltipConfig,
    subPixelOptimize: () => subPixelOptimize2,
    subPixelOptimizeLine: () => subPixelOptimizeLine2,
    subPixelOptimizeRect: () => subPixelOptimizeRect2,
    transformDirection: () => transformDirection,
    traverseElements: () => traverseElements,
    updateProps: () => updateProps
  });

  // node_modules/zrender/lib/tool/transformPath.js
  var CMD3 = PathProxy_default.CMD;
  var points = [[], [], []];
  var mathSqrt2 = Math.sqrt;
  var mathAtan2 = Math.atan2;
  function transformPath(path, m2) {
    if (!m2) {
      return;
    }
    var data = path.data;
    var len2 = path.len();
    var cmd;
    var nPoint;
    var i;
    var j;
    var k;
    var p;
    var M = CMD3.M;
    var C = CMD3.C;
    var L = CMD3.L;
    var R = CMD3.R;
    var A = CMD3.A;
    var Q = CMD3.Q;
    for (i = 0, j = 0; i < len2; ) {
      cmd = data[i++];
      j = i;
      nPoint = 0;
      switch (cmd) {
        case M:
          nPoint = 1;
          break;
        case L:
          nPoint = 1;
          break;
        case C:
          nPoint = 3;
          break;
        case Q:
          nPoint = 2;
          break;
        case A:
          var x = m2[4];
          var y = m2[5];
          var sx = mathSqrt2(m2[0] * m2[0] + m2[1] * m2[1]);
          var sy = mathSqrt2(m2[2] * m2[2] + m2[3] * m2[3]);
          var angle = mathAtan2(-m2[1] / sy, m2[0] / sx);
          data[i] *= sx;
          data[i++] += x;
          data[i] *= sy;
          data[i++] += y;
          data[i++] *= sx;
          data[i++] *= sy;
          data[i++] += angle;
          data[i++] += angle;
          i += 2;
          j = i;
          break;
        case R:
          p[0] = data[i++];
          p[1] = data[i++];
          applyTransform(p, p, m2);
          data[j++] = p[0];
          data[j++] = p[1];
          p[0] += data[i++];
          p[1] += data[i++];
          applyTransform(p, p, m2);
          data[j++] = p[0];
          data[j++] = p[1];
      }
      for (k = 0; k < nPoint; k++) {
        var p_1 = points[k];
        p_1[0] = data[i++];
        p_1[1] = data[i++];
        applyTransform(p_1, p_1, m2);
        data[j++] = p_1[0];
        data[j++] = p_1[1];
      }
    }
    path.increaseVersion();
  }

  // node_modules/zrender/lib/tool/path.js
  var mathSqrt3 = Math.sqrt;
  var mathSin3 = Math.sin;
  var mathCos3 = Math.cos;
  var PI3 = Math.PI;
  function vMag(v) {
    return Math.sqrt(v[0] * v[0] + v[1] * v[1]);
  }
  function vRatio(u, v) {
    return (u[0] * v[0] + u[1] * v[1]) / (vMag(u) * vMag(v));
  }
  function vAngle(u, v) {
    return (u[0] * v[1] < u[1] * v[0] ? -1 : 1) * Math.acos(vRatio(u, v));
  }
  function processArc(x1, y1, x2, y2, fa, fs, rx, ry, psiDeg, cmd, path) {
    var psi = psiDeg * (PI3 / 180);
    var xp = mathCos3(psi) * (x1 - x2) / 2 + mathSin3(psi) * (y1 - y2) / 2;
    var yp = -1 * mathSin3(psi) * (x1 - x2) / 2 + mathCos3(psi) * (y1 - y2) / 2;
    var lambda = xp * xp / (rx * rx) + yp * yp / (ry * ry);
    if (lambda > 1) {
      rx *= mathSqrt3(lambda);
      ry *= mathSqrt3(lambda);
    }
    var f = (fa === fs ? -1 : 1) * mathSqrt3((rx * rx * (ry * ry) - rx * rx * (yp * yp) - ry * ry * (xp * xp)) / (rx * rx * (yp * yp) + ry * ry * (xp * xp))) || 0;
    var cxp = f * rx * yp / ry;
    var cyp = f * -ry * xp / rx;
    var cx = (x1 + x2) / 2 + mathCos3(psi) * cxp - mathSin3(psi) * cyp;
    var cy = (y1 + y2) / 2 + mathSin3(psi) * cxp + mathCos3(psi) * cyp;
    var theta = vAngle([1, 0], [(xp - cxp) / rx, (yp - cyp) / ry]);
    var u = [(xp - cxp) / rx, (yp - cyp) / ry];
    var v = [(-1 * xp - cxp) / rx, (-1 * yp - cyp) / ry];
    var dTheta = vAngle(u, v);
    if (vRatio(u, v) <= -1) {
      dTheta = PI3;
    }
    if (vRatio(u, v) >= 1) {
      dTheta = 0;
    }
    if (dTheta < 0) {
      var n = Math.round(dTheta / PI3 * 1e6) / 1e6;
      dTheta = PI3 * 2 + n % 2 * PI3;
    }
    path.addData(cmd, cx, cy, rx, ry, theta, dTheta, psi, fs);
  }
  var commandReg = /([mlvhzcqtsa])([^mlvhzcqtsa]*)/ig;
  var numberReg = /-?([0-9]*\.)?[0-9]+([eE]-?[0-9]+)?/g;
  function createPathProxyFromString(data) {
    var path = new PathProxy_default();
    if (!data) {
      return path;
    }
    var cpx = 0;
    var cpy = 0;
    var subpathX = cpx;
    var subpathY = cpy;
    var prevCmd;
    var CMD6 = PathProxy_default.CMD;
    var cmdList = data.match(commandReg);
    if (!cmdList) {
      return path;
    }
    for (var l = 0; l < cmdList.length; l++) {
      var cmdText = cmdList[l];
      var cmdStr = cmdText.charAt(0);
      var cmd = void 0;
      var p = cmdText.match(numberReg) || [];
      var pLen = p.length;
      for (var i = 0; i < pLen; i++) {
        p[i] = parseFloat(p[i]);
      }
      var off = 0;
      while (off < pLen) {
        var ctlPtx = void 0;
        var ctlPty = void 0;
        var rx = void 0;
        var ry = void 0;
        var psi = void 0;
        var fa = void 0;
        var fs = void 0;
        var x1 = cpx;
        var y1 = cpy;
        var len2 = void 0;
        var pathData = void 0;
        switch (cmdStr) {
          case "l":
            cpx += p[off++];
            cpy += p[off++];
            cmd = CMD6.L;
            path.addData(cmd, cpx, cpy);
            break;
          case "L":
            cpx = p[off++];
            cpy = p[off++];
            cmd = CMD6.L;
            path.addData(cmd, cpx, cpy);
            break;
          case "m":
            cpx += p[off++];
            cpy += p[off++];
            cmd = CMD6.M;
            path.addData(cmd, cpx, cpy);
            subpathX = cpx;
            subpathY = cpy;
            cmdStr = "l";
            break;
          case "M":
            cpx = p[off++];
            cpy = p[off++];
            cmd = CMD6.M;
            path.addData(cmd, cpx, cpy);
            subpathX = cpx;
            subpathY = cpy;
            cmdStr = "L";
            break;
          case "h":
            cpx += p[off++];
            cmd = CMD6.L;
            path.addData(cmd, cpx, cpy);
            break;
          case "H":
            cpx = p[off++];
            cmd = CMD6.L;
            path.addData(cmd, cpx, cpy);
            break;
          case "v":
            cpy += p[off++];
            cmd = CMD6.L;
            path.addData(cmd, cpx, cpy);
            break;
          case "V":
            cpy = p[off++];
            cmd = CMD6.L;
            path.addData(cmd, cpx, cpy);
            break;
          case "C":
            cmd = CMD6.C;
            path.addData(cmd, p[off++], p[off++], p[off++], p[off++], p[off++], p[off++]);
            cpx = p[off - 2];
            cpy = p[off - 1];
            break;
          case "c":
            cmd = CMD6.C;
            path.addData(cmd, p[off++] + cpx, p[off++] + cpy, p[off++] + cpx, p[off++] + cpy, p[off++] + cpx, p[off++] + cpy);
            cpx += p[off - 2];
            cpy += p[off - 1];
            break;
          case "S":
            ctlPtx = cpx;
            ctlPty = cpy;
            len2 = path.len();
            pathData = path.data;
            if (prevCmd === CMD6.C) {
              ctlPtx += cpx - pathData[len2 - 4];
              ctlPty += cpy - pathData[len2 - 3];
            }
            cmd = CMD6.C;
            x1 = p[off++];
            y1 = p[off++];
            cpx = p[off++];
            cpy = p[off++];
            path.addData(cmd, ctlPtx, ctlPty, x1, y1, cpx, cpy);
            break;
          case "s":
            ctlPtx = cpx;
            ctlPty = cpy;
            len2 = path.len();
            pathData = path.data;
            if (prevCmd === CMD6.C) {
              ctlPtx += cpx - pathData[len2 - 4];
              ctlPty += cpy - pathData[len2 - 3];
            }
            cmd = CMD6.C;
            x1 = cpx + p[off++];
            y1 = cpy + p[off++];
            cpx += p[off++];
            cpy += p[off++];
            path.addData(cmd, ctlPtx, ctlPty, x1, y1, cpx, cpy);
            break;
          case "Q":
            x1 = p[off++];
            y1 = p[off++];
            cpx = p[off++];
            cpy = p[off++];
            cmd = CMD6.Q;
            path.addData(cmd, x1, y1, cpx, cpy);
            break;
          case "q":
            x1 = p[off++] + cpx;
            y1 = p[off++] + cpy;
            cpx += p[off++];
            cpy += p[off++];
            cmd = CMD6.Q;
            path.addData(cmd, x1, y1, cpx, cpy);
            break;
          case "T":
            ctlPtx = cpx;
            ctlPty = cpy;
            len2 = path.len();
            pathData = path.data;
            if (prevCmd === CMD6.Q) {
              ctlPtx += cpx - pathData[len2 - 4];
              ctlPty += cpy - pathData[len2 - 3];
            }
            cpx = p[off++];
            cpy = p[off++];
            cmd = CMD6.Q;
            path.addData(cmd, ctlPtx, ctlPty, cpx, cpy);
            break;
          case "t":
            ctlPtx = cpx;
            ctlPty = cpy;
            len2 = path.len();
            pathData = path.data;
            if (prevCmd === CMD6.Q) {
              ctlPtx += cpx - pathData[len2 - 4];
              ctlPty += cpy - pathData[len2 - 3];
            }
            cpx += p[off++];
            cpy += p[off++];
            cmd = CMD6.Q;
            path.addData(cmd, ctlPtx, ctlPty, cpx, cpy);
            break;
          case "A":
            rx = p[off++];
            ry = p[off++];
            psi = p[off++];
            fa = p[off++];
            fs = p[off++];
            x1 = cpx, y1 = cpy;
            cpx = p[off++];
            cpy = p[off++];
            cmd = CMD6.A;
            processArc(x1, y1, cpx, cpy, fa, fs, rx, ry, psi, cmd, path);
            break;
          case "a":
            rx = p[off++];
            ry = p[off++];
            psi = p[off++];
            fa = p[off++];
            fs = p[off++];
            x1 = cpx, y1 = cpy;
            cpx += p[off++];
            cpy += p[off++];
            cmd = CMD6.A;
            processArc(x1, y1, cpx, cpy, fa, fs, rx, ry, psi, cmd, path);
            break;
        }
      }
      if (cmdStr === "z" || cmdStr === "Z") {
        cmd = CMD6.Z;
        path.addData(cmd);
        cpx = subpathX;
        cpy = subpathY;
      }
      prevCmd = cmd;
    }
    path.toStatic();
    return path;
  }
  var SVGPath = function(_super) {
    __extends2(SVGPath2, _super);
    function SVGPath2() {
      return _super !== null && _super.apply(this, arguments) || this;
    }
    SVGPath2.prototype.applyTransform = function(m2) {
    };
    return SVGPath2;
  }(Path_default);
  function isPathProxy(path) {
    return path.setData != null;
  }
  function createPathOptions(str, opts) {
    var pathProxy = createPathProxyFromString(str);
    var innerOpts = extend({}, opts);
    innerOpts.buildPath = function(path) {
      if (isPathProxy(path)) {
        path.setData(pathProxy.data);
        var ctx = path.getContext();
        if (ctx) {
          path.rebuildPath(ctx, 1);
        }
      } else {
        var ctx = path;
        pathProxy.rebuildPath(ctx, 1);
      }
    };
    innerOpts.applyTransform = function(m2) {
      transformPath(pathProxy, m2);
      this.dirtyShape();
    };
    return innerOpts;
  }
  function createFromString(str, opts) {
    return new SVGPath(createPathOptions(str, opts));
  }
  function extendFromString(str, defaultOpts) {
    var innerOpts = createPathOptions(str, defaultOpts);
    var Sub = function(_super) {
      __extends2(Sub2, _super);
      function Sub2(opts) {
        var _this = _super.call(this, opts) || this;
        _this.applyTransform = innerOpts.applyTransform;
        _this.buildPath = innerOpts.buildPath;
        return _this;
      }
      return Sub2;
    }(SVGPath);
    return Sub;
  }
  function mergePath(pathEls, opts) {
    var pathList = [];
    var len2 = pathEls.length;
    for (var i = 0; i < len2; i++) {
      var pathEl = pathEls[i];
      pathList.push(pathEl.getUpdatedPathProxy(true));
    }
    var pathBundle = new Path_default(opts);
    pathBundle.createPathProxy();
    pathBundle.buildPath = function(path) {
      if (isPathProxy(path)) {
        path.appendPath(pathList);
        var ctx = path.getContext();
        if (ctx) {
          path.rebuildPath(ctx, 1);
        }
      }
    };
    return pathBundle;
  }
  function clonePath(sourcePath, opts) {
    opts = opts || {};
    var path = new Path_default();
    if (sourcePath.shape) {
      path.setShape(sourcePath.shape);
    }
    path.setStyle(sourcePath.style);
    if (opts.bakeTransform) {
      transformPath(path.path, sourcePath.getComputedTransform());
    } else {
      if (opts.toLocal) {
        path.setLocalTransform(sourcePath.getComputedTransform());
      } else {
        path.copyTransform(sourcePath);
      }
    }
    path.buildPath = sourcePath.buildPath;
    path.applyTransform = path.applyTransform;
    path.z = sourcePath.z;
    path.z2 = sourcePath.z2;
    path.zlevel = sourcePath.zlevel;
    return path;
  }

  // node_modules/zrender/lib/graphic/shape/Circle.js
  var CircleShape = function() {
    function CircleShape2() {
      this.cx = 0;
      this.cy = 0;
      this.r = 0;
    }
    return CircleShape2;
  }();
  var Circle = function(_super) {
    __extends2(Circle2, _super);
    function Circle2(opts) {
      return _super.call(this, opts) || this;
    }
    Circle2.prototype.getDefaultShape = function() {
      return new CircleShape();
    };
    Circle2.prototype.buildPath = function(ctx, shape) {
      ctx.moveTo(shape.cx + shape.r, shape.cy);
      ctx.arc(shape.cx, shape.cy, shape.r, 0, Math.PI * 2);
    };
    return Circle2;
  }(Path_default);
  Circle.prototype.type = "circle";
  var Circle_default = Circle;

  // node_modules/zrender/lib/graphic/shape/Ellipse.js
  var EllipseShape = function() {
    function EllipseShape2() {
      this.cx = 0;
      this.cy = 0;
      this.rx = 0;
      this.ry = 0;
    }
    return EllipseShape2;
  }();
  var Ellipse = function(_super) {
    __extends2(Ellipse2, _super);
    function Ellipse2(opts) {
      return _super.call(this, opts) || this;
    }
    Ellipse2.prototype.getDefaultShape = function() {
      return new EllipseShape();
    };
    Ellipse2.prototype.buildPath = function(ctx, shape) {
      var k = 0.5522848;
      var x = shape.cx;
      var y = shape.cy;
      var a = shape.rx;
      var b = shape.ry;
      var ox = a * k;
      var oy = b * k;
      ctx.moveTo(x - a, y);
      ctx.bezierCurveTo(x - a, y - oy, x - ox, y - b, x, y - b);
      ctx.bezierCurveTo(x + ox, y - b, x + a, y - oy, x + a, y);
      ctx.bezierCurveTo(x + a, y + oy, x + ox, y + b, x, y + b);
      ctx.bezierCurveTo(x - ox, y + b, x - a, y + oy, x - a, y);
      ctx.closePath();
    };
    return Ellipse2;
  }(Path_default);
  Ellipse.prototype.type = "ellipse";
  var Ellipse_default = Ellipse;

  // node_modules/zrender/lib/graphic/helper/roundSector.js
  var PI4 = Math.PI;
  var PI26 = PI4 * 2;
  var mathSin4 = Math.sin;
  var mathCos4 = Math.cos;
  var mathACos = Math.acos;
  var mathATan2 = Math.atan2;
  var mathAbs2 = Math.abs;
  var mathSqrt4 = Math.sqrt;
  var mathMax4 = Math.max;
  var mathMin4 = Math.min;
  var e = 1e-4;
  function intersect(x0, y0, x1, y1, x2, y2, x3, y3) {
    var dx10 = x1 - x0;
    var dy10 = y1 - y0;
    var dx32 = x3 - x2;
    var dy32 = y3 - y2;
    var t = dy32 * dx10 - dx32 * dy10;
    if (t * t < e) {
      return;
    }
    t = (dx32 * (y0 - y2) - dy32 * (x0 - x2)) / t;
    return [x0 + t * dx10, y0 + t * dy10];
  }
  function computeCornerTangents(x0, y0, x1, y1, radius, cr, clockwise) {
    var x01 = x0 - x1;
    var y01 = y0 - y1;
    var lo = (clockwise ? cr : -cr) / mathSqrt4(x01 * x01 + y01 * y01);
    var ox = lo * y01;
    var oy = -lo * x01;
    var x11 = x0 + ox;
    var y11 = y0 + oy;
    var x10 = x1 + ox;
    var y10 = y1 + oy;
    var x00 = (x11 + x10) / 2;
    var y00 = (y11 + y10) / 2;
    var dx = x10 - x11;
    var dy = y10 - y11;
    var d2 = dx * dx + dy * dy;
    var r = radius - cr;
    var s = x11 * y10 - x10 * y11;
    var d = (dy < 0 ? -1 : 1) * mathSqrt4(mathMax4(0, r * r * d2 - s * s));
    var cx0 = (s * dy - dx * d) / d2;
    var cy0 = (-s * dx - dy * d) / d2;
    var cx1 = (s * dy + dx * d) / d2;
    var cy1 = (-s * dx + dy * d) / d2;
    var dx0 = cx0 - x00;
    var dy0 = cy0 - y00;
    var dx1 = cx1 - x00;
    var dy1 = cy1 - y00;
    if (dx0 * dx0 + dy0 * dy0 > dx1 * dx1 + dy1 * dy1) {
      cx0 = cx1;
      cy0 = cy1;
    }
    return {
      cx: cx0,
      cy: cy0,
      x0: -ox,
      y0: -oy,
      x1: cx0 * (radius / r - 1),
      y1: cy0 * (radius / r - 1)
    };
  }
  function normalizeCornerRadius(cr) {
    var arr;
    if (isArray(cr)) {
      var len2 = cr.length;
      if (!len2) {
        return cr;
      }
      if (len2 === 1) {
        arr = [cr[0], cr[0], 0, 0];
      } else if (len2 === 2) {
        arr = [cr[0], cr[0], cr[1], cr[1]];
      } else if (len2 === 3) {
        arr = cr.concat(cr[2]);
      } else {
        arr = cr;
      }
    } else {
      arr = [cr, cr, cr, cr];
    }
    return arr;
  }
  function buildPath2(ctx, shape) {
    var _a2;
    var radius = mathMax4(shape.r, 0);
    var innerRadius = mathMax4(shape.r0 || 0, 0);
    var hasRadius = radius > 0;
    var hasInnerRadius = innerRadius > 0;
    if (!hasRadius && !hasInnerRadius) {
      return;
    }
    if (!hasRadius) {
      radius = innerRadius;
      innerRadius = 0;
    }
    if (innerRadius > radius) {
      var tmp = radius;
      radius = innerRadius;
      innerRadius = tmp;
    }
    var startAngle = shape.startAngle, endAngle = shape.endAngle;
    if (isNaN(startAngle) || isNaN(endAngle)) {
      return;
    }
    var cx = shape.cx, cy = shape.cy;
    var clockwise = !!shape.clockwise;
    var arc = mathAbs2(endAngle - startAngle);
    var mod = arc > PI26 && arc % PI26;
    mod > e && (arc = mod);
    if (!(radius > e)) {
      ctx.moveTo(cx, cy);
    } else if (arc > PI26 - e) {
      ctx.moveTo(cx + radius * mathCos4(startAngle), cy + radius * mathSin4(startAngle));
      ctx.arc(cx, cy, radius, startAngle, endAngle, !clockwise);
      if (innerRadius > e) {
        ctx.moveTo(cx + innerRadius * mathCos4(endAngle), cy + innerRadius * mathSin4(endAngle));
        ctx.arc(cx, cy, innerRadius, endAngle, startAngle, clockwise);
      }
    } else {
      var icrStart = void 0;
      var icrEnd = void 0;
      var ocrStart = void 0;
      var ocrEnd = void 0;
      var ocrs = void 0;
      var ocre = void 0;
      var icrs = void 0;
      var icre = void 0;
      var ocrMax = void 0;
      var icrMax = void 0;
      var limitedOcrMax = void 0;
      var limitedIcrMax = void 0;
      var xre = void 0;
      var yre = void 0;
      var xirs = void 0;
      var yirs = void 0;
      var xrs = radius * mathCos4(startAngle);
      var yrs = radius * mathSin4(startAngle);
      var xire = innerRadius * mathCos4(endAngle);
      var yire = innerRadius * mathSin4(endAngle);
      var hasArc = arc > e;
      if (hasArc) {
        var cornerRadius = shape.cornerRadius;
        if (cornerRadius) {
          _a2 = normalizeCornerRadius(cornerRadius), icrStart = _a2[0], icrEnd = _a2[1], ocrStart = _a2[2], ocrEnd = _a2[3];
        }
        var halfRd = mathAbs2(radius - innerRadius) / 2;
        ocrs = mathMin4(halfRd, ocrStart);
        ocre = mathMin4(halfRd, ocrEnd);
        icrs = mathMin4(halfRd, icrStart);
        icre = mathMin4(halfRd, icrEnd);
        limitedOcrMax = ocrMax = mathMax4(ocrs, ocre);
        limitedIcrMax = icrMax = mathMax4(icrs, icre);
        if (ocrMax > e || icrMax > e) {
          xre = radius * mathCos4(endAngle);
          yre = radius * mathSin4(endAngle);
          xirs = innerRadius * mathCos4(startAngle);
          yirs = innerRadius * mathSin4(startAngle);
          if (arc < PI4) {
            var it_1 = intersect(xrs, yrs, xirs, yirs, xre, yre, xire, yire);
            if (it_1) {
              var x0 = xrs - it_1[0];
              var y0 = yrs - it_1[1];
              var x1 = xre - it_1[0];
              var y1 = yre - it_1[1];
              var a = 1 / mathSin4(mathACos((x0 * x1 + y0 * y1) / (mathSqrt4(x0 * x0 + y0 * y0) * mathSqrt4(x1 * x1 + y1 * y1))) / 2);
              var b = mathSqrt4(it_1[0] * it_1[0] + it_1[1] * it_1[1]);
              limitedOcrMax = mathMin4(ocrMax, (radius - b) / (a + 1));
              limitedIcrMax = mathMin4(icrMax, (innerRadius - b) / (a - 1));
            }
          }
        }
      }
      if (!hasArc) {
        ctx.moveTo(cx + xrs, cy + yrs);
      } else if (limitedOcrMax > e) {
        var crStart = mathMin4(ocrStart, limitedOcrMax);
        var crEnd = mathMin4(ocrEnd, limitedOcrMax);
        var ct0 = computeCornerTangents(xirs, yirs, xrs, yrs, radius, crStart, clockwise);
        var ct1 = computeCornerTangents(xre, yre, xire, yire, radius, crEnd, clockwise);
        ctx.moveTo(cx + ct0.cx + ct0.x0, cy + ct0.cy + ct0.y0);
        if (limitedOcrMax < ocrMax && crStart === crEnd) {
          ctx.arc(cx + ct0.cx, cy + ct0.cy, limitedOcrMax, mathATan2(ct0.y0, ct0.x0), mathATan2(ct1.y0, ct1.x0), !clockwise);
        } else {
          crStart > 0 && ctx.arc(cx + ct0.cx, cy + ct0.cy, crStart, mathATan2(ct0.y0, ct0.x0), mathATan2(ct0.y1, ct0.x1), !clockwise);
          ctx.arc(cx, cy, radius, mathATan2(ct0.cy + ct0.y1, ct0.cx + ct0.x1), mathATan2(ct1.cy + ct1.y1, ct1.cx + ct1.x1), !clockwise);
          crEnd > 0 && ctx.arc(cx + ct1.cx, cy + ct1.cy, crEnd, mathATan2(ct1.y1, ct1.x1), mathATan2(ct1.y0, ct1.x0), !clockwise);
        }
      } else {
        ctx.moveTo(cx + xrs, cy + yrs);
        ctx.arc(cx, cy, radius, startAngle, endAngle, !clockwise);
      }
      if (!(innerRadius > e) || !hasArc) {
        ctx.lineTo(cx + xire, cy + yire);
      } else if (limitedIcrMax > e) {
        var crStart = mathMin4(icrStart, limitedIcrMax);
        var crEnd = mathMin4(icrEnd, limitedIcrMax);
        var ct0 = computeCornerTangents(xire, yire, xre, yre, innerRadius, -crEnd, clockwise);
        var ct1 = computeCornerTangents(xrs, yrs, xirs, yirs, innerRadius, -crStart, clockwise);
        ctx.lineTo(cx + ct0.cx + ct0.x0, cy + ct0.cy + ct0.y0);
        if (limitedIcrMax < icrMax && crStart === crEnd) {
          ctx.arc(cx + ct0.cx, cy + ct0.cy, limitedIcrMax, mathATan2(ct0.y0, ct0.x0), mathATan2(ct1.y0, ct1.x0), !clockwise);
        } else {
          crEnd > 0 && ctx.arc(cx + ct0.cx, cy + ct0.cy, crEnd, mathATan2(ct0.y0, ct0.x0), mathATan2(ct0.y1, ct0.x1), !clockwise);
          ctx.arc(cx, cy, innerRadius, mathATan2(ct0.cy + ct0.y1, ct0.cx + ct0.x1), mathATan2(ct1.cy + ct1.y1, ct1.cx + ct1.x1), clockwise);
          crStart > 0 && ctx.arc(cx + ct1.cx, cy + ct1.cy, crStart, mathATan2(ct1.y1, ct1.x1), mathATan2(ct1.y0, ct1.x0), !clockwise);
        }
      } else {
        ctx.lineTo(cx + xire, cy + yire);
        ctx.arc(cx, cy, innerRadius, endAngle, startAngle, clockwise);
      }
    }
    ctx.closePath();
  }

  // node_modules/zrender/lib/graphic/shape/Sector.js
  var SectorShape = function() {
    function SectorShape2() {
      this.cx = 0;
      this.cy = 0;
      this.r0 = 0;
      this.r = 0;
      this.startAngle = 0;
      this.endAngle = Math.PI * 2;
      this.clockwise = true;
      this.cornerRadius = 0;
    }
    return SectorShape2;
  }();
  var Sector = function(_super) {
    __extends2(Sector2, _super);
    function Sector2(opts) {
      return _super.call(this, opts) || this;
    }
    Sector2.prototype.getDefaultShape = function() {
      return new SectorShape();
    };
    Sector2.prototype.buildPath = function(ctx, shape) {
      buildPath2(ctx, shape);
    };
    Sector2.prototype.isZeroArea = function() {
      return this.shape.startAngle === this.shape.endAngle || this.shape.r === this.shape.r0;
    };
    return Sector2;
  }(Path_default);
  Sector.prototype.type = "sector";
  var Sector_default = Sector;

  // node_modules/zrender/lib/graphic/shape/Ring.js
  var RingShape = function() {
    function RingShape2() {
      this.cx = 0;
      this.cy = 0;
      this.r = 0;
      this.r0 = 0;
    }
    return RingShape2;
  }();
  var Ring = function(_super) {
    __extends2(Ring2, _super);
    function Ring2(opts) {
      return _super.call(this, opts) || this;
    }
    Ring2.prototype.getDefaultShape = function() {
      return new RingShape();
    };
    Ring2.prototype.buildPath = function(ctx, shape) {
      var x = shape.cx;
      var y = shape.cy;
      var PI210 = Math.PI * 2;
      ctx.moveTo(x + shape.r, y);
      ctx.arc(x, y, shape.r, 0, PI210, false);
      ctx.moveTo(x + shape.r0, y);
      ctx.arc(x, y, shape.r0, 0, PI210, true);
    };
    return Ring2;
  }(Path_default);
  Ring.prototype.type = "ring";
  var Ring_default = Ring;

  // node_modules/zrender/lib/graphic/helper/smoothBezier.js
  function smoothBezier(points4, smooth, isLoop, constraint) {
    var cps = [];
    var v = [];
    var v12 = [];
    var v22 = [];
    var prevPoint;
    var nextPoint;
    var min3;
    var max3;
    if (constraint) {
      min3 = [Infinity, Infinity];
      max3 = [-Infinity, -Infinity];
      for (var i = 0, len2 = points4.length; i < len2; i++) {
        min(min3, min3, points4[i]);
        max(max3, max3, points4[i]);
      }
      min(min3, min3, constraint[0]);
      max(max3, max3, constraint[1]);
    }
    for (var i = 0, len2 = points4.length; i < len2; i++) {
      var point = points4[i];
      if (isLoop) {
        prevPoint = points4[i ? i - 1 : len2 - 1];
        nextPoint = points4[(i + 1) % len2];
      } else {
        if (i === 0 || i === len2 - 1) {
          cps.push(clone2(points4[i]));
          continue;
        } else {
          prevPoint = points4[i - 1];
          nextPoint = points4[i + 1];
        }
      }
      sub(v, nextPoint, prevPoint);
      scale(v, v, smooth);
      var d0 = distance(point, prevPoint);
      var d1 = distance(point, nextPoint);
      var sum2 = d0 + d1;
      if (sum2 !== 0) {
        d0 /= sum2;
        d1 /= sum2;
      }
      scale(v12, v, -d0);
      scale(v22, v, d1);
      var cp0 = add([], point, v12);
      var cp1 = add([], point, v22);
      if (constraint) {
        max(cp0, cp0, min3);
        min(cp0, cp0, max3);
        max(cp1, cp1, min3);
        min(cp1, cp1, max3);
      }
      cps.push(cp0);
      cps.push(cp1);
    }
    if (isLoop) {
      cps.push(cps.shift());
    }
    return cps;
  }

  // node_modules/zrender/lib/graphic/helper/poly.js
  function buildPath3(ctx, shape, closePath) {
    var smooth = shape.smooth;
    var points4 = shape.points;
    if (points4 && points4.length >= 2) {
      if (smooth) {
        var controlPoints = smoothBezier(points4, smooth, closePath, shape.smoothConstraint);
        ctx.moveTo(points4[0][0], points4[0][1]);
        var len2 = points4.length;
        for (var i = 0; i < (closePath ? len2 : len2 - 1); i++) {
          var cp1 = controlPoints[i * 2];
          var cp2 = controlPoints[i * 2 + 1];
          var p = points4[(i + 1) % len2];
          ctx.bezierCurveTo(cp1[0], cp1[1], cp2[0], cp2[1], p[0], p[1]);
        }
      } else {
        ctx.moveTo(points4[0][0], points4[0][1]);
        for (var i = 1, l = points4.length; i < l; i++) {
          ctx.lineTo(points4[i][0], points4[i][1]);
        }
      }
      closePath && ctx.closePath();
    }
  }

  // node_modules/zrender/lib/graphic/shape/Polygon.js
  var PolygonShape = function() {
    function PolygonShape2() {
      this.points = null;
      this.smooth = 0;
      this.smoothConstraint = null;
    }
    return PolygonShape2;
  }();
  var Polygon = function(_super) {
    __extends2(Polygon2, _super);
    function Polygon2(opts) {
      return _super.call(this, opts) || this;
    }
    Polygon2.prototype.getDefaultShape = function() {
      return new PolygonShape();
    };
    Polygon2.prototype.buildPath = function(ctx, shape) {
      buildPath3(ctx, shape, true);
    };
    return Polygon2;
  }(Path_default);
  Polygon.prototype.type = "polygon";
  var Polygon_default = Polygon;

  // node_modules/zrender/lib/graphic/shape/Polyline.js
  var PolylineShape = function() {
    function PolylineShape2() {
      this.points = null;
      this.percent = 1;
      this.smooth = 0;
      this.smoothConstraint = null;
    }
    return PolylineShape2;
  }();
  var Polyline = function(_super) {
    __extends2(Polyline3, _super);
    function Polyline3(opts) {
      return _super.call(this, opts) || this;
    }
    Polyline3.prototype.getDefaultStyle = function() {
      return {
        stroke: "#000",
        fill: null
      };
    };
    Polyline3.prototype.getDefaultShape = function() {
      return new PolylineShape();
    };
    Polyline3.prototype.buildPath = function(ctx, shape) {
      buildPath3(ctx, shape, false);
    };
    return Polyline3;
  }(Path_default);
  Polyline.prototype.type = "polyline";
  var Polyline_default = Polyline;

  // node_modules/zrender/lib/graphic/shape/Line.js
  var subPixelOptimizeOutputShape2 = {};
  var LineShape = function() {
    function LineShape2() {
      this.x1 = 0;
      this.y1 = 0;
      this.x2 = 0;
      this.y2 = 0;
      this.percent = 1;
    }
    return LineShape2;
  }();
  var Line = function(_super) {
    __extends2(Line3, _super);
    function Line3(opts) {
      return _super.call(this, opts) || this;
    }
    Line3.prototype.getDefaultStyle = function() {
      return {
        stroke: "#000",
        fill: null
      };
    };
    Line3.prototype.getDefaultShape = function() {
      return new LineShape();
    };
    Line3.prototype.buildPath = function(ctx, shape) {
      var x1;
      var y1;
      var x2;
      var y2;
      if (this.subPixelOptimize) {
        var optimizedShape = subPixelOptimizeLine(subPixelOptimizeOutputShape2, shape, this.style);
        x1 = optimizedShape.x1;
        y1 = optimizedShape.y1;
        x2 = optimizedShape.x2;
        y2 = optimizedShape.y2;
      } else {
        x1 = shape.x1;
        y1 = shape.y1;
        x2 = shape.x2;
        y2 = shape.y2;
      }
      var percent = shape.percent;
      if (percent === 0) {
        return;
      }
      ctx.moveTo(x1, y1);
      if (percent < 1) {
        x2 = x1 * (1 - percent) + x2 * percent;
        y2 = y1 * (1 - percent) + y2 * percent;
      }
      ctx.lineTo(x2, y2);
    };
    Line3.prototype.pointAt = function(p) {
      var shape = this.shape;
      return [
        shape.x1 * (1 - p) + shape.x2 * p,
        shape.y1 * (1 - p) + shape.y2 * p
      ];
    };
    return Line3;
  }(Path_default);
  Line.prototype.type = "line";
  var Line_default = Line;

  // node_modules/zrender/lib/graphic/shape/BezierCurve.js
  var out = [];
  var BezierCurveShape = function() {
    function BezierCurveShape2() {
      this.x1 = 0;
      this.y1 = 0;
      this.x2 = 0;
      this.y2 = 0;
      this.cpx1 = 0;
      this.cpy1 = 0;
      this.percent = 1;
    }
    return BezierCurveShape2;
  }();
  function someVectorAt(shape, t, isTangent) {
    var cpx2 = shape.cpx2;
    var cpy2 = shape.cpy2;
    if (cpx2 != null || cpy2 != null) {
      return [
        (isTangent ? cubicDerivativeAt : cubicAt)(shape.x1, shape.cpx1, shape.cpx2, shape.x2, t),
        (isTangent ? cubicDerivativeAt : cubicAt)(shape.y1, shape.cpy1, shape.cpy2, shape.y2, t)
      ];
    } else {
      return [
        (isTangent ? quadraticDerivativeAt : quadraticAt)(shape.x1, shape.cpx1, shape.x2, t),
        (isTangent ? quadraticDerivativeAt : quadraticAt)(shape.y1, shape.cpy1, shape.y2, t)
      ];
    }
  }
  var BezierCurve = function(_super) {
    __extends2(BezierCurve2, _super);
    function BezierCurve2(opts) {
      return _super.call(this, opts) || this;
    }
    BezierCurve2.prototype.getDefaultStyle = function() {
      return {
        stroke: "#000",
        fill: null
      };
    };
    BezierCurve2.prototype.getDefaultShape = function() {
      return new BezierCurveShape();
    };
    BezierCurve2.prototype.buildPath = function(ctx, shape) {
      var x1 = shape.x1;
      var y1 = shape.y1;
      var x2 = shape.x2;
      var y2 = shape.y2;
      var cpx1 = shape.cpx1;
      var cpy1 = shape.cpy1;
      var cpx2 = shape.cpx2;
      var cpy2 = shape.cpy2;
      var percent = shape.percent;
      if (percent === 0) {
        return;
      }
      ctx.moveTo(x1, y1);
      if (cpx2 == null || cpy2 == null) {
        if (percent < 1) {
          quadraticSubdivide(x1, cpx1, x2, percent, out);
          cpx1 = out[1];
          x2 = out[2];
          quadraticSubdivide(y1, cpy1, y2, percent, out);
          cpy1 = out[1];
          y2 = out[2];
        }
        ctx.quadraticCurveTo(cpx1, cpy1, x2, y2);
      } else {
        if (percent < 1) {
          cubicSubdivide(x1, cpx1, cpx2, x2, percent, out);
          cpx1 = out[1];
          cpx2 = out[2];
          x2 = out[3];
          cubicSubdivide(y1, cpy1, cpy2, y2, percent, out);
          cpy1 = out[1];
          cpy2 = out[2];
          y2 = out[3];
        }
        ctx.bezierCurveTo(cpx1, cpy1, cpx2, cpy2, x2, y2);
      }
    };
    BezierCurve2.prototype.pointAt = function(t) {
      return someVectorAt(this.shape, t, false);
    };
    BezierCurve2.prototype.tangentAt = function(t) {
      var p = someVectorAt(this.shape, t, true);
      return normalize(p, p);
    };
    return BezierCurve2;
  }(Path_default);
  BezierCurve.prototype.type = "bezier-curve";
  var BezierCurve_default = BezierCurve;

  // node_modules/zrender/lib/graphic/shape/Arc.js
  var ArcShape = function() {
    function ArcShape2() {
      this.cx = 0;
      this.cy = 0;
      this.r = 0;
      this.startAngle = 0;
      this.endAngle = Math.PI * 2;
      this.clockwise = true;
    }
    return ArcShape2;
  }();
  var Arc = function(_super) {
    __extends2(Arc2, _super);
    function Arc2(opts) {
      return _super.call(this, opts) || this;
    }
    Arc2.prototype.getDefaultStyle = function() {
      return {
        stroke: "#000",
        fill: null
      };
    };
    Arc2.prototype.getDefaultShape = function() {
      return new ArcShape();
    };
    Arc2.prototype.buildPath = function(ctx, shape) {
      var x = shape.cx;
      var y = shape.cy;
      var r = Math.max(shape.r, 0);
      var startAngle = shape.startAngle;
      var endAngle = shape.endAngle;
      var clockwise = shape.clockwise;
      var unitX = Math.cos(startAngle);
      var unitY = Math.sin(startAngle);
      ctx.moveTo(unitX * r + x, unitY * r + y);
      ctx.arc(x, y, r, startAngle, endAngle, !clockwise);
    };
    return Arc2;
  }(Path_default);
  Arc.prototype.type = "arc";
  var Arc_default = Arc;

  // node_modules/zrender/lib/graphic/CompoundPath.js
  var CompoundPath = function(_super) {
    __extends2(CompoundPath2, _super);
    function CompoundPath2() {
      var _this = _super !== null && _super.apply(this, arguments) || this;
      _this.type = "compound";
      return _this;
    }
    CompoundPath2.prototype._updatePathDirty = function() {
      var paths = this.shape.paths;
      var dirtyPath = this.shapeChanged();
      for (var i = 0; i < paths.length; i++) {
        dirtyPath = dirtyPath || paths[i].shapeChanged();
      }
      if (dirtyPath) {
        this.dirtyShape();
      }
    };
    CompoundPath2.prototype.beforeBrush = function() {
      this._updatePathDirty();
      var paths = this.shape.paths || [];
      var scale4 = this.getGlobalScale();
      for (var i = 0; i < paths.length; i++) {
        if (!paths[i].path) {
          paths[i].createPathProxy();
        }
        paths[i].path.setScale(scale4[0], scale4[1], paths[i].segmentIgnoreThreshold);
      }
    };
    CompoundPath2.prototype.buildPath = function(ctx, shape) {
      var paths = shape.paths || [];
      for (var i = 0; i < paths.length; i++) {
        paths[i].buildPath(ctx, paths[i].shape, true);
      }
    };
    CompoundPath2.prototype.afterBrush = function() {
      var paths = this.shape.paths || [];
      for (var i = 0; i < paths.length; i++) {
        paths[i].pathUpdated();
      }
    };
    CompoundPath2.prototype.getBoundingRect = function() {
      this._updatePathDirty.call(this);
      return Path_default.prototype.getBoundingRect.call(this);
    };
    return CompoundPath2;
  }(Path_default);
  var CompoundPath_default = CompoundPath;

  // node_modules/zrender/lib/graphic/Gradient.js
  var Gradient = function() {
    function Gradient2(colorStops) {
      this.colorStops = colorStops || [];
    }
    Gradient2.prototype.addColorStop = function(offset, color) {
      this.colorStops.push({
        offset,
        color
      });
    };
    return Gradient2;
  }();
  var Gradient_default = Gradient;

  // node_modules/zrender/lib/graphic/LinearGradient.js
  var LinearGradient = function(_super) {
    __extends2(LinearGradient2, _super);
    function LinearGradient2(x, y, x2, y2, colorStops, globalCoord) {
      var _this = _super.call(this, colorStops) || this;
      _this.x = x == null ? 0 : x;
      _this.y = y == null ? 0 : y;
      _this.x2 = x2 == null ? 1 : x2;
      _this.y2 = y2 == null ? 0 : y2;
      _this.type = "linear";
      _this.global = globalCoord || false;
      return _this;
    }
    return LinearGradient2;
  }(Gradient_default);
  var LinearGradient_default = LinearGradient;

  // node_modules/zrender/lib/graphic/RadialGradient.js
  var RadialGradient = function(_super) {
    __extends2(RadialGradient2, _super);
    function RadialGradient2(x, y, r, colorStops, globalCoord) {
      var _this = _super.call(this, colorStops) || this;
      _this.x = x == null ? 0.5 : x;
      _this.y = y == null ? 0.5 : y;
      _this.r = r == null ? 0.5 : r;
      _this.type = "radial";
      _this.global = globalCoord || false;
      return _this;
    }
    return RadialGradient2;
  }(Gradient_default);
  var RadialGradient_default = RadialGradient;

  // node_modules/zrender/lib/core/OrientedBoundingRect.js
  var extent = [0, 0];
  var extent2 = [0, 0];
  var minTv2 = new Point_default();
  var maxTv2 = new Point_default();
  var OrientedBoundingRect = function() {
    function OrientedBoundingRect2(rect, transform2) {
      this._corners = [];
      this._axes = [];
      this._origin = [0, 0];
      for (var i = 0; i < 4; i++) {
        this._corners[i] = new Point_default();
      }
      for (var i = 0; i < 2; i++) {
        this._axes[i] = new Point_default();
      }
      if (rect) {
        this.fromBoundingRect(rect, transform2);
      }
    }
    OrientedBoundingRect2.prototype.fromBoundingRect = function(rect, transform2) {
      var corners = this._corners;
      var axes = this._axes;
      var x = rect.x;
      var y = rect.y;
      var x2 = x + rect.width;
      var y2 = y + rect.height;
      corners[0].set(x, y);
      corners[1].set(x2, y);
      corners[2].set(x2, y2);
      corners[3].set(x, y2);
      if (transform2) {
        for (var i = 0; i < 4; i++) {
          corners[i].transform(transform2);
        }
      }
      Point_default.sub(axes[0], corners[1], corners[0]);
      Point_default.sub(axes[1], corners[3], corners[0]);
      axes[0].normalize();
      axes[1].normalize();
      for (var i = 0; i < 2; i++) {
        this._origin[i] = axes[i].dot(corners[0]);
      }
    };
    OrientedBoundingRect2.prototype.intersect = function(other, mtv) {
      var overlapped = true;
      var noMtv = !mtv;
      minTv2.set(Infinity, Infinity);
      maxTv2.set(0, 0);
      if (!this._intersectCheckOneSide(this, other, minTv2, maxTv2, noMtv, 1)) {
        overlapped = false;
        if (noMtv) {
          return overlapped;
        }
      }
      if (!this._intersectCheckOneSide(other, this, minTv2, maxTv2, noMtv, -1)) {
        overlapped = false;
        if (noMtv) {
          return overlapped;
        }
      }
      if (!noMtv) {
        Point_default.copy(mtv, overlapped ? minTv2 : maxTv2);
      }
      return overlapped;
    };
    OrientedBoundingRect2.prototype._intersectCheckOneSide = function(self2, other, minTv3, maxTv3, noMtv, inverse) {
      var overlapped = true;
      for (var i = 0; i < 2; i++) {
        var axis = this._axes[i];
        this._getProjMinMaxOnAxis(i, self2._corners, extent);
        this._getProjMinMaxOnAxis(i, other._corners, extent2);
        if (extent[1] < extent2[0] || extent[0] > extent2[1]) {
          overlapped = false;
          if (noMtv) {
            return overlapped;
          }
          var dist0 = Math.abs(extent2[0] - extent[1]);
          var dist1 = Math.abs(extent[0] - extent2[1]);
          if (Math.min(dist0, dist1) > maxTv3.len()) {
            if (dist0 < dist1) {
              Point_default.scale(maxTv3, axis, -dist0 * inverse);
            } else {
              Point_default.scale(maxTv3, axis, dist1 * inverse);
            }
          }
        } else if (minTv3) {
          var dist0 = Math.abs(extent2[0] - extent[1]);
          var dist1 = Math.abs(extent[0] - extent2[1]);
          if (Math.min(dist0, dist1) < minTv3.len()) {
            if (dist0 < dist1) {
              Point_default.scale(minTv3, axis, dist0 * inverse);
            } else {
              Point_default.scale(minTv3, axis, -dist1 * inverse);
            }
          }
        }
      }
      return overlapped;
    };
    OrientedBoundingRect2.prototype._getProjMinMaxOnAxis = function(dim, corners, out2) {
      var axis = this._axes[dim];
      var origin = this._origin;
      var proj = corners[0].dot(axis) + origin[dim];
      var min3 = proj;
      var max3 = proj;
      for (var i = 1; i < corners.length; i++) {
        var proj_1 = corners[i].dot(axis) + origin[dim];
        min3 = Math.min(proj_1, min3);
        max3 = Math.max(proj_1, max3);
      }
      out2[0] = min3;
      out2[1] = max3;
    };
    return OrientedBoundingRect2;
  }();
  var OrientedBoundingRect_default = OrientedBoundingRect;

  // node_modules/zrender/lib/graphic/IncrementalDisplayable.js
  var m = [];
  var IncrementalDisplayable = function(_super) {
    __extends2(IncrementalDisplayable2, _super);
    function IncrementalDisplayable2() {
      var _this = _super !== null && _super.apply(this, arguments) || this;
      _this.notClear = true;
      _this.incremental = true;
      _this._displayables = [];
      _this._temporaryDisplayables = [];
      _this._cursor = 0;
      return _this;
    }
    IncrementalDisplayable2.prototype.traverse = function(cb, context) {
      cb.call(context, this);
    };
    IncrementalDisplayable2.prototype.useStyle = function() {
      this.style = {};
    };
    IncrementalDisplayable2.prototype.getCursor = function() {
      return this._cursor;
    };
    IncrementalDisplayable2.prototype.innerAfterBrush = function() {
      this._cursor = this._displayables.length;
    };
    IncrementalDisplayable2.prototype.clearDisplaybles = function() {
      this._displayables = [];
      this._temporaryDisplayables = [];
      this._cursor = 0;
      this.markRedraw();
      this.notClear = false;
    };
    IncrementalDisplayable2.prototype.clearTemporalDisplayables = function() {
      this._temporaryDisplayables = [];
    };
    IncrementalDisplayable2.prototype.addDisplayable = function(displayable, notPersistent) {
      if (notPersistent) {
        this._temporaryDisplayables.push(displayable);
      } else {
        this._displayables.push(displayable);
      }
      this.markRedraw();
    };
    IncrementalDisplayable2.prototype.addDisplayables = function(displayables, notPersistent) {
      notPersistent = notPersistent || false;
      for (var i = 0; i < displayables.length; i++) {
        this.addDisplayable(displayables[i], notPersistent);
      }
    };
    IncrementalDisplayable2.prototype.getDisplayables = function() {
      return this._displayables;
    };
    IncrementalDisplayable2.prototype.getTemporalDisplayables = function() {
      return this._temporaryDisplayables;
    };
    IncrementalDisplayable2.prototype.eachPendingDisplayable = function(cb) {
      for (var i = this._cursor; i < this._displayables.length; i++) {
        cb && cb(this._displayables[i]);
      }
      for (var i = 0; i < this._temporaryDisplayables.length; i++) {
        cb && cb(this._temporaryDisplayables[i]);
      }
    };
    IncrementalDisplayable2.prototype.update = function() {
      this.updateTransform();
      for (var i = this._cursor; i < this._displayables.length; i++) {
        var displayable = this._displayables[i];
        displayable.parent = this;
        displayable.update();
        displayable.parent = null;
      }
      for (var i = 0; i < this._temporaryDisplayables.length; i++) {
        var displayable = this._temporaryDisplayables[i];
        displayable.parent = this;
        displayable.update();
        displayable.parent = null;
      }
    };
    IncrementalDisplayable2.prototype.getBoundingRect = function() {
      if (!this._rect) {
        var rect = new BoundingRect_default(Infinity, Infinity, -Infinity, -Infinity);
        for (var i = 0; i < this._displayables.length; i++) {
          var displayable = this._displayables[i];
          var childRect = displayable.getBoundingRect().clone();
          if (displayable.needLocalTransform()) {
            childRect.applyTransform(displayable.getLocalTransform(m));
          }
          rect.union(childRect);
        }
        this._rect = rect;
      }
      return this._rect;
    };
    IncrementalDisplayable2.prototype.contain = function(x, y) {
      var localPos = this.transformCoordToLocal(x, y);
      var rect = this.getBoundingRect();
      if (rect.contain(localPos[0], localPos[1])) {
        for (var i = 0; i < this._displayables.length; i++) {
          var displayable = this._displayables[i];
          if (displayable.contain(x, y)) {
            return true;
          }
        }
      }
      return false;
    };
    return IncrementalDisplayable2;
  }(Displayable_default);
  var IncrementalDisplayable_default = IncrementalDisplayable;

  // node_modules/echarts/lib/animation/basicTrasition.js
  var transitionStore = makeInner();
  function getAnimationConfig(animationType, animatableModel, dataIndex, extraOpts, extraDelayParams) {
    var animationPayload;
    if (animatableModel && animatableModel.ecModel) {
      var updatePayload = animatableModel.ecModel.getUpdatePayload();
      animationPayload = updatePayload && updatePayload.animation;
    }
    var animationEnabled = animatableModel && animatableModel.isAnimationEnabled();
    var isUpdate = animationType === "update";
    if (animationEnabled) {
      var duration = void 0;
      var easing = void 0;
      var delay = void 0;
      if (extraOpts) {
        duration = retrieve2(extraOpts.duration, 200);
        easing = retrieve2(extraOpts.easing, "cubicOut");
        delay = 0;
      } else {
        duration = animatableModel.getShallow(isUpdate ? "animationDurationUpdate" : "animationDuration");
        easing = animatableModel.getShallow(isUpdate ? "animationEasingUpdate" : "animationEasing");
        delay = animatableModel.getShallow(isUpdate ? "animationDelayUpdate" : "animationDelay");
      }
      if (animationPayload) {
        animationPayload.duration != null && (duration = animationPayload.duration);
        animationPayload.easing != null && (easing = animationPayload.easing);
        animationPayload.delay != null && (delay = animationPayload.delay);
      }
      if (isFunction(delay)) {
        delay = delay(dataIndex, extraDelayParams);
      }
      if (isFunction(duration)) {
        duration = duration(dataIndex);
      }
      var config = {
        duration: duration || 0,
        delay,
        easing
      };
      return config;
    } else {
      return null;
    }
  }
  function animateOrSetProps(animationType, el, props, animatableModel, dataIndex, cb, during) {
    var isFrom = false;
    var removeOpt;
    if (isFunction(dataIndex)) {
      during = cb;
      cb = dataIndex;
      dataIndex = null;
    } else if (isObject(dataIndex)) {
      cb = dataIndex.cb;
      during = dataIndex.during;
      isFrom = dataIndex.isFrom;
      removeOpt = dataIndex.removeOpt;
      dataIndex = dataIndex.dataIndex;
    }
    var isRemove = animationType === "leave";
    if (!isRemove) {
      el.stopAnimation("leave");
    }
    var animationConfig = getAnimationConfig(animationType, animatableModel, dataIndex, isRemove ? removeOpt || {} : null, animatableModel && animatableModel.getAnimationDelayParams ? animatableModel.getAnimationDelayParams(el, dataIndex) : null);
    if (animationConfig && animationConfig.duration > 0) {
      var duration = animationConfig.duration;
      var animationDelay = animationConfig.delay;
      var animationEasing = animationConfig.easing;
      var animateConfig = {
        duration,
        delay: animationDelay || 0,
        easing: animationEasing,
        done: cb,
        force: !!cb || !!during,
        setToFinal: !isRemove,
        scope: animationType,
        during
      };
      isFrom ? el.animateFrom(props, animateConfig) : el.animateTo(props, animateConfig);
    } else {
      el.stopAnimation();
      !isFrom && el.attr(props);
      during && during(1);
      cb && cb();
    }
  }
  function updateProps(el, props, animatableModel, dataIndex, cb, during) {
    animateOrSetProps("update", el, props, animatableModel, dataIndex, cb, during);
  }
  function initProps(el, props, animatableModel, dataIndex, cb, during) {
    animateOrSetProps("enter", el, props, animatableModel, dataIndex, cb, during);
  }
  function isElementRemoved(el) {
    if (!el.__zr) {
      return true;
    }
    for (var i = 0; i < el.animators.length; i++) {
      var animator = el.animators[i];
      if (animator.scope === "leave") {
        return true;
      }
    }
    return false;
  }
  function removeElement(el, props, animatableModel, dataIndex, cb, during) {
    if (isElementRemoved(el)) {
      return;
    }
    animateOrSetProps("leave", el, props, animatableModel, dataIndex, cb, during);
  }
  function fadeOutDisplayable(el, animatableModel, dataIndex, done) {
    el.removeTextContent();
    el.removeTextGuideLine();
    removeElement(el, {
      style: {
        opacity: 0
      }
    }, animatableModel, dataIndex, done);
  }
  function removeElementWithFadeOut(el, animatableModel, dataIndex) {
    function doRemove() {
      el.parent && el.parent.remove(el);
    }
    if (!el.isGroup) {
      fadeOutDisplayable(el, animatableModel, dataIndex, doRemove);
    } else {
      el.traverse(function(disp) {
        if (!disp.isGroup) {
          fadeOutDisplayable(disp, animatableModel, dataIndex, doRemove);
        }
      });
    }
  }
  function saveOldStyle(el) {
    transitionStore(el).oldStyle = el.style;
  }
  function getOldStyle(el) {
    return transitionStore(el).oldStyle;
  }

  // node_modules/echarts/lib/util/graphic.js
  var mathMax5 = Math.max;
  var mathMin5 = Math.min;
  var _customShapeMap = {};
  function extendShape(opts) {
    return Path_default.extend(opts);
  }
  var extendPathFromString = extendFromString;
  function extendPath(pathData, opts) {
    return extendPathFromString(pathData, opts);
  }
  function registerShape(name, ShapeClass) {
    _customShapeMap[name] = ShapeClass;
  }
  function getShapeClass(name) {
    if (_customShapeMap.hasOwnProperty(name)) {
      return _customShapeMap[name];
    }
  }
  function makePath(pathData, opts, rect, layout5) {
    var path = createFromString(pathData, opts);
    if (rect) {
      if (layout5 === "center") {
        rect = centerGraphic(rect, path.getBoundingRect());
      }
      resizePath(path, rect);
    }
    return path;
  }
  function makeImage(imageUrl, rect, layout5) {
    var zrImg = new Image_default({
      style: {
        image: imageUrl,
        x: rect.x,
        y: rect.y,
        width: rect.width,
        height: rect.height
      },
      onload: function(img) {
        if (layout5 === "center") {
          var boundingRect = {
            width: img.width,
            height: img.height
          };
          zrImg.setStyle(centerGraphic(rect, boundingRect));
        }
      }
    });
    return zrImg;
  }
  function centerGraphic(rect, boundingRect) {
    var aspect = boundingRect.width / boundingRect.height;
    var width = rect.height * aspect;
    var height;
    if (width <= rect.width) {
      height = rect.height;
    } else {
      width = rect.width;
      height = width / aspect;
    }
    var cx = rect.x + rect.width / 2;
    var cy = rect.y + rect.height / 2;
    return {
      x: cx - width / 2,
      y: cy - height / 2,
      width,
      height
    };
  }
  var mergePath2 = mergePath;
  function resizePath(path, rect) {
    if (!path.applyTransform) {
      return;
    }
    var pathRect = path.getBoundingRect();
    var m2 = pathRect.calculateTransform(rect);
    path.applyTransform(m2);
  }
  function subPixelOptimizeLine2(param) {
    subPixelOptimizeLine(param.shape, param.shape, param.style);
    return param;
  }
  function subPixelOptimizeRect2(param) {
    subPixelOptimizeRect(param.shape, param.shape, param.style);
    return param;
  }
  var subPixelOptimize2 = subPixelOptimize;
  function getTransform(target, ancestor) {
    var mat = identity([]);
    while (target && target !== ancestor) {
      mul2(mat, target.getLocalTransform(), mat);
      target = target.parent;
    }
    return mat;
  }
  function applyTransform2(target, transform2, invert2) {
    if (transform2 && !isArrayLike(transform2)) {
      transform2 = Transformable_default.getLocalTransform(transform2);
    }
    if (invert2) {
      transform2 = invert([], transform2);
    }
    return applyTransform([], target, transform2);
  }
  function transformDirection(direction, transform2, invert2) {
    var hBase = transform2[4] === 0 || transform2[5] === 0 || transform2[0] === 0 ? 1 : Math.abs(2 * transform2[4] / transform2[0]);
    var vBase = transform2[4] === 0 || transform2[5] === 0 || transform2[2] === 0 ? 1 : Math.abs(2 * transform2[4] / transform2[2]);
    var vertex = [direction === "left" ? -hBase : direction === "right" ? hBase : 0, direction === "top" ? -vBase : direction === "bottom" ? vBase : 0];
    vertex = applyTransform2(vertex, transform2, invert2);
    return Math.abs(vertex[0]) > Math.abs(vertex[1]) ? vertex[0] > 0 ? "right" : "left" : vertex[1] > 0 ? "bottom" : "top";
  }
  function isNotGroup(el) {
    return !el.isGroup;
  }
  function isPath(el) {
    return el.shape != null;
  }
  function groupTransition(g1, g2, animatableModel) {
    if (!g1 || !g2) {
      return;
    }
    function getElMap(g) {
      var elMap = {};
      g.traverse(function(el) {
        if (isNotGroup(el) && el.anid) {
          elMap[el.anid] = el;
        }
      });
      return elMap;
    }
    function getAnimatableProps(el) {
      var obj = {
        x: el.x,
        y: el.y,
        rotation: el.rotation
      };
      if (isPath(el)) {
        obj.shape = extend({}, el.shape);
      }
      return obj;
    }
    var elMap1 = getElMap(g1);
    g2.traverse(function(el) {
      if (isNotGroup(el) && el.anid) {
        var oldEl = elMap1[el.anid];
        if (oldEl) {
          var newProp = getAnimatableProps(el);
          el.attr(getAnimatableProps(oldEl));
          updateProps(el, newProp, animatableModel, getECData(el).dataIndex);
        }
      }
    });
  }
  function clipPointsByRect(points4, rect) {
    return map(points4, function(point) {
      var x = point[0];
      x = mathMax5(x, rect.x);
      x = mathMin5(x, rect.x + rect.width);
      var y = point[1];
      y = mathMax5(y, rect.y);
      y = mathMin5(y, rect.y + rect.height);
      return [x, y];
    });
  }
  function clipRectByRect(targetRect, rect) {
    var x = mathMax5(targetRect.x, rect.x);
    var x2 = mathMin5(targetRect.x + targetRect.width, rect.x + rect.width);
    var y = mathMax5(targetRect.y, rect.y);
    var y2 = mathMin5(targetRect.y + targetRect.height, rect.y + rect.height);
    if (x2 >= x && y2 >= y) {
      return {
        x,
        y,
        width: x2 - x,
        height: y2 - y
      };
    }
  }
  function createIcon(iconStr, opt, rect) {
    var innerOpts = extend({
      rectHover: true
    }, opt);
    var style = innerOpts.style = {
      strokeNoScale: true
    };
    rect = rect || {
      x: -1,
      y: -1,
      width: 2,
      height: 2
    };
    if (iconStr) {
      return iconStr.indexOf("image://") === 0 ? (style.image = iconStr.slice(8), defaults(style, rect), new Image_default(innerOpts)) : makePath(iconStr.replace("path://", ""), innerOpts, rect, "center");
    }
  }
  function linePolygonIntersect(a1x, a1y, a2x, a2y, points4) {
    for (var i = 0, p2 = points4[points4.length - 1]; i < points4.length; i++) {
      var p = points4[i];
      if (lineLineIntersect(a1x, a1y, a2x, a2y, p[0], p[1], p2[0], p2[1])) {
        return true;
      }
      p2 = p;
    }
  }
  function lineLineIntersect(a1x, a1y, a2x, a2y, b1x, b1y, b2x, b2y) {
    var mx = a2x - a1x;
    var my = a2y - a1y;
    var nx = b2x - b1x;
    var ny = b2y - b1y;
    var nmCrossProduct = crossProduct2d(nx, ny, mx, my);
    if (nearZero(nmCrossProduct)) {
      return false;
    }
    var b1a1x = a1x - b1x;
    var b1a1y = a1y - b1y;
    var q = crossProduct2d(b1a1x, b1a1y, mx, my) / nmCrossProduct;
    if (q < 0 || q > 1) {
      return false;
    }
    var p = crossProduct2d(b1a1x, b1a1y, nx, ny) / nmCrossProduct;
    if (p < 0 || p > 1) {
      return false;
    }
    return true;
  }
  function crossProduct2d(x1, y1, x2, y2) {
    return x1 * y2 - x2 * y1;
  }
  function nearZero(val) {
    return val <= 1e-6 && val >= -1e-6;
  }
  function setTooltipConfig(opt) {
    var itemTooltipOption = opt.itemTooltipOption;
    var componentModel = opt.componentModel;
    var itemName = opt.itemName;
    var itemTooltipOptionObj = isString(itemTooltipOption) ? {
      formatter: itemTooltipOption
    } : itemTooltipOption;
    var mainType = componentModel.mainType;
    var componentIndex = componentModel.componentIndex;
    var formatterParams = {
      componentType: mainType,
      name: itemName,
      $vars: ["name"]
    };
    formatterParams[mainType + "Index"] = componentIndex;
    var formatterParamsExtra = opt.formatterParamsExtra;
    if (formatterParamsExtra) {
      each(keys(formatterParamsExtra), function(key) {
        if (!hasOwn(formatterParams, key)) {
          formatterParams[key] = formatterParamsExtra[key];
          formatterParams.$vars.push(key);
        }
      });
    }
    var ecData = getECData(opt.el);
    ecData.componentMainType = mainType;
    ecData.componentIndex = componentIndex;
    ecData.tooltipConfig = {
      name: itemName,
      option: defaults({
        content: itemName,
        formatterParams
      }, itemTooltipOptionObj)
    };
  }
  function traverseElement(el, cb) {
    var stopped;
    if (el.isGroup) {
      stopped = cb(el);
    }
    if (!stopped) {
      el.traverse(cb);
    }
  }
  function traverseElements(els, cb) {
    if (els) {
      if (isArray(els)) {
        for (var i = 0; i < els.length; i++) {
          traverseElement(els[i], cb);
        }
      } else {
        traverseElement(els, cb);
      }
    }
  }
  registerShape("circle", Circle_default);
  registerShape("ellipse", Ellipse_default);
  registerShape("sector", Sector_default);
  registerShape("ring", Ring_default);
  registerShape("polygon", Polygon_default);
  registerShape("polyline", Polyline_default);
  registerShape("rect", Rect_default);
  registerShape("line", Line_default);
  registerShape("bezierCurve", BezierCurve_default);
  registerShape("arc", Arc_default);

  // node_modules/echarts/lib/label/labelStyle.js
  var EMPTY_OBJ = {};
  function setLabelText(label, labelTexts) {
    for (var i = 0; i < SPECIAL_STATES.length; i++) {
      var stateName = SPECIAL_STATES[i];
      var text = labelTexts[stateName];
      var state = label.ensureState(stateName);
      state.style = state.style || {};
      state.style.text = text;
    }
    var oldStates = label.currentStates.slice();
    label.clearStates(true);
    label.setStyle({
      text: labelTexts.normal
    });
    label.useStates(oldStates, true);
  }
  function getLabelText(opt, stateModels, interpolatedValue) {
    var labelFetcher = opt.labelFetcher;
    var labelDataIndex = opt.labelDataIndex;
    var labelDimIndex = opt.labelDimIndex;
    var normalModel = stateModels.normal;
    var baseText;
    if (labelFetcher) {
      baseText = labelFetcher.getFormattedLabel(labelDataIndex, "normal", null, labelDimIndex, normalModel && normalModel.get("formatter"), interpolatedValue != null ? {
        interpolatedValue
      } : null);
    }
    if (baseText == null) {
      baseText = isFunction(opt.defaultText) ? opt.defaultText(labelDataIndex, opt, interpolatedValue) : opt.defaultText;
    }
    var statesText = {
      normal: baseText
    };
    for (var i = 0; i < SPECIAL_STATES.length; i++) {
      var stateName = SPECIAL_STATES[i];
      var stateModel = stateModels[stateName];
      statesText[stateName] = retrieve2(labelFetcher ? labelFetcher.getFormattedLabel(labelDataIndex, stateName, null, labelDimIndex, stateModel && stateModel.get("formatter")) : null, baseText);
    }
    return statesText;
  }
  function setLabelStyle(targetEl, labelStatesModels, opt, stateSpecified) {
    opt = opt || EMPTY_OBJ;
    var isSetOnText = targetEl instanceof Text_default;
    var needsCreateText = false;
    for (var i = 0; i < DISPLAY_STATES.length; i++) {
      var stateModel = labelStatesModels[DISPLAY_STATES[i]];
      if (stateModel && stateModel.getShallow("show")) {
        needsCreateText = true;
        break;
      }
    }
    var textContent = isSetOnText ? targetEl : targetEl.getTextContent();
    if (needsCreateText) {
      if (!isSetOnText) {
        if (!textContent) {
          textContent = new Text_default();
          targetEl.setTextContent(textContent);
        }
        if (targetEl.stateProxy) {
          textContent.stateProxy = targetEl.stateProxy;
        }
      }
      var labelStatesTexts = getLabelText(opt, labelStatesModels);
      var normalModel = labelStatesModels.normal;
      var showNormal = !!normalModel.getShallow("show");
      var normalStyle = createTextStyle(normalModel, stateSpecified && stateSpecified.normal, opt, false, !isSetOnText);
      normalStyle.text = labelStatesTexts.normal;
      if (!isSetOnText) {
        targetEl.setTextConfig(createTextConfig(normalModel, opt, false));
      }
      for (var i = 0; i < SPECIAL_STATES.length; i++) {
        var stateName = SPECIAL_STATES[i];
        var stateModel = labelStatesModels[stateName];
        if (stateModel) {
          var stateObj = textContent.ensureState(stateName);
          var stateShow = !!retrieve2(stateModel.getShallow("show"), showNormal);
          if (stateShow !== showNormal) {
            stateObj.ignore = !stateShow;
          }
          stateObj.style = createTextStyle(stateModel, stateSpecified && stateSpecified[stateName], opt, true, !isSetOnText);
          stateObj.style.text = labelStatesTexts[stateName];
          if (!isSetOnText) {
            var targetElEmphasisState = targetEl.ensureState(stateName);
            targetElEmphasisState.textConfig = createTextConfig(stateModel, opt, true);
          }
        }
      }
      textContent.silent = !!normalModel.getShallow("silent");
      if (textContent.style.x != null) {
        normalStyle.x = textContent.style.x;
      }
      if (textContent.style.y != null) {
        normalStyle.y = textContent.style.y;
      }
      textContent.ignore = !showNormal;
      textContent.useStyle(normalStyle);
      textContent.dirty();
      if (opt.enableTextSetter) {
        labelInner(textContent).setLabelText = function(interpolatedValue) {
          var labelStatesTexts2 = getLabelText(opt, labelStatesModels, interpolatedValue);
          setLabelText(textContent, labelStatesTexts2);
        };
      }
    } else if (textContent) {
      textContent.ignore = true;
    }
    targetEl.dirty();
  }
  function getLabelStatesModels(itemModel, labelName) {
    labelName = labelName || "label";
    var statesModels = {
      normal: itemModel.getModel(labelName)
    };
    for (var i = 0; i < SPECIAL_STATES.length; i++) {
      var stateName = SPECIAL_STATES[i];
      statesModels[stateName] = itemModel.getModel([stateName, labelName]);
    }
    return statesModels;
  }
  function createTextStyle(textStyleModel, specifiedTextStyle, opt, isNotNormal, isAttached) {
    var textStyle = {};
    setTextStyleCommon(textStyle, textStyleModel, opt, isNotNormal, isAttached);
    specifiedTextStyle && extend(textStyle, specifiedTextStyle);
    return textStyle;
  }
  function createTextConfig(textStyleModel, opt, isNotNormal) {
    opt = opt || {};
    var textConfig = {};
    var labelPosition;
    var labelRotate = textStyleModel.getShallow("rotate");
    var labelDistance = retrieve2(textStyleModel.getShallow("distance"), isNotNormal ? null : 5);
    var labelOffset = textStyleModel.getShallow("offset");
    labelPosition = textStyleModel.getShallow("position") || (isNotNormal ? null : "inside");
    labelPosition === "outside" && (labelPosition = opt.defaultOutsidePosition || "top");
    if (labelPosition != null) {
      textConfig.position = labelPosition;
    }
    if (labelOffset != null) {
      textConfig.offset = labelOffset;
    }
    if (labelRotate != null) {
      labelRotate *= Math.PI / 180;
      textConfig.rotation = labelRotate;
    }
    if (labelDistance != null) {
      textConfig.distance = labelDistance;
    }
    textConfig.outsideFill = textStyleModel.get("color") === "inherit" ? opt.inheritColor || null : "auto";
    return textConfig;
  }
  function setTextStyleCommon(textStyle, textStyleModel, opt, isNotNormal, isAttached) {
    opt = opt || EMPTY_OBJ;
    var ecModel = textStyleModel.ecModel;
    var globalTextStyle = ecModel && ecModel.option.textStyle;
    var richItemNames = getRichItemNames(textStyleModel);
    var richResult;
    if (richItemNames) {
      richResult = {};
      for (var name_1 in richItemNames) {
        if (richItemNames.hasOwnProperty(name_1)) {
          var richTextStyle = textStyleModel.getModel(["rich", name_1]);
          setTokenTextStyle(richResult[name_1] = {}, richTextStyle, globalTextStyle, opt, isNotNormal, isAttached, false, true);
        }
      }
    }
    if (richResult) {
      textStyle.rich = richResult;
    }
    var overflow = textStyleModel.get("overflow");
    if (overflow) {
      textStyle.overflow = overflow;
    }
    var margin = textStyleModel.get("minMargin");
    if (margin != null) {
      textStyle.margin = margin;
    }
    setTokenTextStyle(textStyle, textStyleModel, globalTextStyle, opt, isNotNormal, isAttached, true, false);
  }
  function getRichItemNames(textStyleModel) {
    var richItemNameMap;
    while (textStyleModel && textStyleModel !== textStyleModel.ecModel) {
      var rich = (textStyleModel.option || EMPTY_OBJ).rich;
      if (rich) {
        richItemNameMap = richItemNameMap || {};
        var richKeys = keys(rich);
        for (var i = 0; i < richKeys.length; i++) {
          var richKey = richKeys[i];
          richItemNameMap[richKey] = 1;
        }
      }
      textStyleModel = textStyleModel.parentModel;
    }
    return richItemNameMap;
  }
  var TEXT_PROPS_WITH_GLOBAL = ["fontStyle", "fontWeight", "fontSize", "fontFamily", "textShadowColor", "textShadowBlur", "textShadowOffsetX", "textShadowOffsetY"];
  var TEXT_PROPS_SELF = ["align", "lineHeight", "width", "height", "tag", "verticalAlign"];
  var TEXT_PROPS_BOX = ["padding", "borderWidth", "borderRadius", "borderDashOffset", "backgroundColor", "borderColor", "shadowColor", "shadowBlur", "shadowOffsetX", "shadowOffsetY"];
  function setTokenTextStyle(textStyle, textStyleModel, globalTextStyle, opt, isNotNormal, isAttached, isBlock, inRich) {
    globalTextStyle = !isNotNormal && globalTextStyle || EMPTY_OBJ;
    var inheritColor = opt && opt.inheritColor;
    var fillColor = textStyleModel.getShallow("color");
    var strokeColor = textStyleModel.getShallow("textBorderColor");
    var opacity = retrieve2(textStyleModel.getShallow("opacity"), globalTextStyle.opacity);
    if (fillColor === "inherit" || fillColor === "auto") {
      if (true) {
        if (fillColor === "auto") {
          deprecateReplaceLog("color: 'auto'", "color: 'inherit'");
        }
      }
      if (inheritColor) {
        fillColor = inheritColor;
      } else {
        fillColor = null;
      }
    }
    if (strokeColor === "inherit" || strokeColor === "auto") {
      if (true) {
        if (strokeColor === "auto") {
          deprecateReplaceLog("color: 'auto'", "color: 'inherit'");
        }
      }
      if (inheritColor) {
        strokeColor = inheritColor;
      } else {
        strokeColor = null;
      }
    }
    if (!isAttached) {
      fillColor = fillColor || globalTextStyle.color;
      strokeColor = strokeColor || globalTextStyle.textBorderColor;
    }
    if (fillColor != null) {
      textStyle.fill = fillColor;
    }
    if (strokeColor != null) {
      textStyle.stroke = strokeColor;
    }
    var textBorderWidth = retrieve2(textStyleModel.getShallow("textBorderWidth"), globalTextStyle.textBorderWidth);
    if (textBorderWidth != null) {
      textStyle.lineWidth = textBorderWidth;
    }
    var textBorderType = retrieve2(textStyleModel.getShallow("textBorderType"), globalTextStyle.textBorderType);
    if (textBorderType != null) {
      textStyle.lineDash = textBorderType;
    }
    var textBorderDashOffset = retrieve2(textStyleModel.getShallow("textBorderDashOffset"), globalTextStyle.textBorderDashOffset);
    if (textBorderDashOffset != null) {
      textStyle.lineDashOffset = textBorderDashOffset;
    }
    if (!isNotNormal && opacity == null && !inRich) {
      opacity = opt && opt.defaultOpacity;
    }
    if (opacity != null) {
      textStyle.opacity = opacity;
    }
    if (!isNotNormal && !isAttached) {
      if (textStyle.fill == null && opt.inheritColor) {
        textStyle.fill = opt.inheritColor;
      }
    }
    for (var i = 0; i < TEXT_PROPS_WITH_GLOBAL.length; i++) {
      var key = TEXT_PROPS_WITH_GLOBAL[i];
      var val = retrieve2(textStyleModel.getShallow(key), globalTextStyle[key]);
      if (val != null) {
        textStyle[key] = val;
      }
    }
    for (var i = 0; i < TEXT_PROPS_SELF.length; i++) {
      var key = TEXT_PROPS_SELF[i];
      var val = textStyleModel.getShallow(key);
      if (val != null) {
        textStyle[key] = val;
      }
    }
    if (textStyle.verticalAlign == null) {
      var baseline = textStyleModel.getShallow("baseline");
      if (baseline != null) {
        textStyle.verticalAlign = baseline;
      }
    }
    if (!isBlock || !opt.disableBox) {
      for (var i = 0; i < TEXT_PROPS_BOX.length; i++) {
        var key = TEXT_PROPS_BOX[i];
        var val = textStyleModel.getShallow(key);
        if (val != null) {
          textStyle[key] = val;
        }
      }
      var borderType = textStyleModel.getShallow("borderType");
      if (borderType != null) {
        textStyle.borderDash = borderType;
      }
      if ((textStyle.backgroundColor === "auto" || textStyle.backgroundColor === "inherit") && inheritColor) {
        if (true) {
          if (textStyle.backgroundColor === "auto") {
            deprecateReplaceLog("backgroundColor: 'auto'", "backgroundColor: 'inherit'");
          }
        }
        textStyle.backgroundColor = inheritColor;
      }
      if ((textStyle.borderColor === "auto" || textStyle.borderColor === "inherit") && inheritColor) {
        if (true) {
          if (textStyle.borderColor === "auto") {
            deprecateReplaceLog("borderColor: 'auto'", "borderColor: 'inherit'");
          }
        }
        textStyle.borderColor = inheritColor;
      }
    }
  }
  function getFont(opt, ecModel) {
    var gTextStyleModel = ecModel && ecModel.getModel("textStyle");
    return trim([
      opt.fontStyle || gTextStyleModel && gTextStyleModel.getShallow("fontStyle") || "",
      opt.fontWeight || gTextStyleModel && gTextStyleModel.getShallow("fontWeight") || "",
      (opt.fontSize || gTextStyleModel && gTextStyleModel.getShallow("fontSize") || 12) + "px",
      opt.fontFamily || gTextStyleModel && gTextStyleModel.getShallow("fontFamily") || "sans-serif"
    ].join(" "));
  }
  var labelInner = makeInner();
  function setLabelValueAnimation(label, labelStatesModels, value, getDefaultText) {
    if (!label) {
      return;
    }
    var obj = labelInner(label);
    obj.prevValue = obj.value;
    obj.value = value;
    var normalLabelModel = labelStatesModels.normal;
    obj.valueAnimation = normalLabelModel.get("valueAnimation");
    if (obj.valueAnimation) {
      obj.precision = normalLabelModel.get("precision");
      obj.defaultInterpolatedText = getDefaultText;
      obj.statesModels = labelStatesModels;
    }
  }
  function animateLabelValue(textEl, dataIndex, data, animatableModel, labelFetcher) {
    var labelInnerStore = labelInner(textEl);
    if (!labelInnerStore.valueAnimation || labelInnerStore.prevValue === labelInnerStore.value) {
      return;
    }
    var defaultInterpolatedText = labelInnerStore.defaultInterpolatedText;
    var currValue = retrieve2(labelInnerStore.interpolatedValue, labelInnerStore.prevValue);
    var targetValue = labelInnerStore.value;
    function during(percent) {
      var interpolated = interpolateRawValues(data, labelInnerStore.precision, currValue, targetValue, percent);
      labelInnerStore.interpolatedValue = percent === 1 ? null : interpolated;
      var labelText = getLabelText({
        labelDataIndex: dataIndex,
        labelFetcher,
        defaultText: defaultInterpolatedText ? defaultInterpolatedText(interpolated) : interpolated + ""
      }, labelInnerStore.statesModels, interpolated);
      setLabelText(textEl, labelText);
    }
    textEl.percent = 0;
    (labelInnerStore.prevValue == null ? initProps : updateProps)(textEl, {
      percent: 1
    }, animatableModel, dataIndex, null, during);
  }

  // node_modules/echarts/lib/model/mixin/textStyle.js
  var PATH_COLOR = ["textStyle", "color"];
  var textStyleParams = ["fontStyle", "fontWeight", "fontSize", "fontFamily", "padding", "lineHeight", "rich", "width", "height", "overflow"];
  var tmpText = new Text_default();
  var TextStyleMixin = function() {
    function TextStyleMixin2() {
    }
    TextStyleMixin2.prototype.getTextColor = function(isEmphasis) {
      var ecModel = this.ecModel;
      return this.getShallow("color") || (!isEmphasis && ecModel ? ecModel.get(PATH_COLOR) : null);
    };
    TextStyleMixin2.prototype.getFont = function() {
      return getFont({
        fontStyle: this.getShallow("fontStyle"),
        fontWeight: this.getShallow("fontWeight"),
        fontSize: this.getShallow("fontSize"),
        fontFamily: this.getShallow("fontFamily")
      }, this.ecModel);
    };
    TextStyleMixin2.prototype.getTextRect = function(text) {
      var style = {
        text,
        verticalAlign: this.getShallow("verticalAlign") || this.getShallow("baseline")
      };
      for (var i = 0; i < textStyleParams.length; i++) {
        style[textStyleParams[i]] = this.getShallow(textStyleParams[i]);
      }
      tmpText.useStyle(style);
      tmpText.update();
      return tmpText.getBoundingRect();
    };
    return TextStyleMixin2;
  }();
  var textStyle_default = TextStyleMixin;

  // node_modules/echarts/lib/model/mixin/lineStyle.js
  var LINE_STYLE_KEY_MAP = [
    ["lineWidth", "width"],
    ["stroke", "color"],
    ["opacity"],
    ["shadowBlur"],
    ["shadowOffsetX"],
    ["shadowOffsetY"],
    ["shadowColor"],
    ["lineDash", "type"],
    ["lineDashOffset", "dashOffset"],
    ["lineCap", "cap"],
    ["lineJoin", "join"],
    ["miterLimit"]
  ];
  var getLineStyle = makeStyleMapper(LINE_STYLE_KEY_MAP);
  var LineStyleMixin = function() {
    function LineStyleMixin2() {
    }
    LineStyleMixin2.prototype.getLineStyle = function(excludes) {
      return getLineStyle(this, excludes);
    };
    return LineStyleMixin2;
  }();

  // node_modules/echarts/lib/model/mixin/itemStyle.js
  var ITEM_STYLE_KEY_MAP = [
    ["fill", "color"],
    ["stroke", "borderColor"],
    ["lineWidth", "borderWidth"],
    ["opacity"],
    ["shadowBlur"],
    ["shadowOffsetX"],
    ["shadowOffsetY"],
    ["shadowColor"],
    ["lineDash", "borderType"],
    ["lineDashOffset", "borderDashOffset"],
    ["lineCap", "borderCap"],
    ["lineJoin", "borderJoin"],
    ["miterLimit", "borderMiterLimit"]
  ];
  var getItemStyle = makeStyleMapper(ITEM_STYLE_KEY_MAP);
  var ItemStyleMixin = function() {
    function ItemStyleMixin2() {
    }
    ItemStyleMixin2.prototype.getItemStyle = function(excludes, includes) {
      return getItemStyle(this, excludes, includes);
    };
    return ItemStyleMixin2;
  }();

  // node_modules/echarts/lib/model/Model.js
  var Model = function() {
    function Model2(option, parentModel, ecModel) {
      this.parentModel = parentModel;
      this.ecModel = ecModel;
      this.option = option;
    }
    Model2.prototype.init = function(option, parentModel, ecModel) {
      var rest = [];
      for (var _i = 3; _i < arguments.length; _i++) {
        rest[_i - 3] = arguments[_i];
      }
    };
    Model2.prototype.mergeOption = function(option, ecModel) {
      merge(this.option, option, true);
    };
    Model2.prototype.get = function(path, ignoreParent) {
      if (path == null) {
        return this.option;
      }
      return this._doGet(this.parsePath(path), !ignoreParent && this.parentModel);
    };
    Model2.prototype.getShallow = function(key, ignoreParent) {
      var option = this.option;
      var val = option == null ? option : option[key];
      if (val == null && !ignoreParent) {
        var parentModel = this.parentModel;
        if (parentModel) {
          val = parentModel.getShallow(key);
        }
      }
      return val;
    };
    Model2.prototype.getModel = function(path, parentModel) {
      var hasPath = path != null;
      var pathFinal = hasPath ? this.parsePath(path) : null;
      var obj = hasPath ? this._doGet(pathFinal) : this.option;
      parentModel = parentModel || this.parentModel && this.parentModel.getModel(this.resolveParentPath(pathFinal));
      return new Model2(obj, parentModel, this.ecModel);
    };
    Model2.prototype.isEmpty = function() {
      return this.option == null;
    };
    Model2.prototype.restoreData = function() {
    };
    Model2.prototype.clone = function() {
      var Ctor = this.constructor;
      return new Ctor(clone(this.option));
    };
    Model2.prototype.parsePath = function(path) {
      if (typeof path === "string") {
        return path.split(".");
      }
      return path;
    };
    Model2.prototype.resolveParentPath = function(path) {
      return path;
    };
    Model2.prototype.isAnimationEnabled = function() {
      if (!env_default.node && this.option) {
        if (this.option.animation != null) {
          return !!this.option.animation;
        } else if (this.parentModel) {
          return this.parentModel.isAnimationEnabled();
        }
      }
    };
    Model2.prototype._doGet = function(pathArr, parentModel) {
      var obj = this.option;
      if (!pathArr) {
        return obj;
      }
      for (var i = 0; i < pathArr.length; i++) {
        if (!pathArr[i]) {
          continue;
        }
        obj = obj && typeof obj === "object" ? obj[pathArr[i]] : null;
        if (obj == null) {
          break;
        }
      }
      if (obj == null && parentModel) {
        obj = parentModel._doGet(this.resolveParentPath(pathArr), parentModel.parentModel);
      }
      return obj;
    };
    return Model2;
  }();
  enableClassExtend(Model);
  enableClassCheck(Model);
  mixin(Model, LineStyleMixin);
  mixin(Model, ItemStyleMixin);
  mixin(Model, AreaStyleMixin);
  mixin(Model, textStyle_default);
  var Model_default = Model;

  // node_modules/echarts/lib/util/component.js
  var base = Math.round(Math.random() * 10);
  function getUID(type) {
    return [type || "", base++].join("_");
  }
  function enableSubTypeDefaulter(target) {
    var subTypeDefaulters = {};
    target.registerSubTypeDefaulter = function(componentType, defaulter) {
      var componentTypeInfo = parseClassType(componentType);
      subTypeDefaulters[componentTypeInfo.main] = defaulter;
    };
    target.determineSubType = function(componentType, option) {
      var type = option.type;
      if (!type) {
        var componentTypeMain = parseClassType(componentType).main;
        if (target.hasSubTypes(componentType) && subTypeDefaulters[componentTypeMain]) {
          type = subTypeDefaulters[componentTypeMain](option);
        }
      }
      return type;
    };
  }
  function enableTopologicalTravel(entity, dependencyGetter) {
    entity.topologicalTravel = function(targetNameList, fullNameList, callback, context) {
      if (!targetNameList.length) {
        return;
      }
      var result = makeDepndencyGraph(fullNameList);
      var graph = result.graph;
      var noEntryList = result.noEntryList;
      var targetNameSet = {};
      each(targetNameList, function(name) {
        targetNameSet[name] = true;
      });
      while (noEntryList.length) {
        var currComponentType = noEntryList.pop();
        var currVertex = graph[currComponentType];
        var isInTargetNameSet = !!targetNameSet[currComponentType];
        if (isInTargetNameSet) {
          callback.call(context, currComponentType, currVertex.originalDeps.slice());
          delete targetNameSet[currComponentType];
        }
        each(currVertex.successor, isInTargetNameSet ? removeEdgeAndAdd : removeEdge);
      }
      each(targetNameSet, function() {
        var errMsg = "";
        if (true) {
          errMsg = makePrintable("Circular dependency may exists: ", targetNameSet, targetNameList, fullNameList);
        }
        throw new Error(errMsg);
      });
      function removeEdge(succComponentType) {
        graph[succComponentType].entryCount--;
        if (graph[succComponentType].entryCount === 0) {
          noEntryList.push(succComponentType);
        }
      }
      function removeEdgeAndAdd(succComponentType) {
        targetNameSet[succComponentType] = true;
        removeEdge(succComponentType);
      }
    };
    function makeDepndencyGraph(fullNameList) {
      var graph = {};
      var noEntryList = [];
      each(fullNameList, function(name) {
        var thisItem = createDependencyGraphItem(graph, name);
        var originalDeps = thisItem.originalDeps = dependencyGetter(name);
        var availableDeps = getAvailableDependencies(originalDeps, fullNameList);
        thisItem.entryCount = availableDeps.length;
        if (thisItem.entryCount === 0) {
          noEntryList.push(name);
        }
        each(availableDeps, function(dependentName) {
          if (indexOf(thisItem.predecessor, dependentName) < 0) {
            thisItem.predecessor.push(dependentName);
          }
          var thatItem = createDependencyGraphItem(graph, dependentName);
          if (indexOf(thatItem.successor, dependentName) < 0) {
            thatItem.successor.push(name);
          }
        });
      });
      return {
        graph,
        noEntryList
      };
    }
    function createDependencyGraphItem(graph, name) {
      if (!graph[name]) {
        graph[name] = {
          predecessor: [],
          successor: []
        };
      }
      return graph[name];
    }
    function getAvailableDependencies(originalDeps, fullNameList) {
      var availableDeps = [];
      each(originalDeps, function(dep) {
        indexOf(fullNameList, dep) >= 0 && availableDeps.push(dep);
      });
      return availableDeps;
    }
  }
  function inheritDefaultOption(superOption, subOption) {
    return merge(merge({}, superOption, true), subOption, true);
  }

  // node_modules/echarts/lib/i18n/langEN.js
  var langEN_default = {
    time: {
      month: ["January", "February", "March", "April", "May", "June", "July", "August", "September", "October", "November", "December"],
      monthAbbr: ["Jan", "Feb", "Mar", "Apr", "May", "Jun", "Jul", "Aug", "Sep", "Oct", "Nov", "Dec"],
      dayOfWeek: ["Sunday", "Monday", "Tuesday", "Wednesday", "Thursday", "Friday", "Saturday"],
      dayOfWeekAbbr: ["Sun", "Mon", "Tue", "Wed", "Thu", "Fri", "Sat"]
    },
    legend: {
      selector: {
        all: "All",
        inverse: "Inv"
      }
    },
    toolbox: {
      brush: {
        title: {
          rect: "Box Select",
          polygon: "Lasso Select",
          lineX: "Horizontally Select",
          lineY: "Vertically Select",
          keep: "Keep Selections",
          clear: "Clear Selections"
        }
      },
      dataView: {
        title: "Data View",
        lang: ["Data View", "Close", "Refresh"]
      },
      dataZoom: {
        title: {
          zoom: "Zoom",
          back: "Zoom Reset"
        }
      },
      magicType: {
        title: {
          line: "Switch to Line Chart",
          bar: "Switch to Bar Chart",
          stack: "Stack",
          tiled: "Tile"
        }
      },
      restore: {
        title: "Restore"
      },
      saveAsImage: {
        title: "Save as Image",
        lang: ["Right Click to Save Image"]
      }
    },
    series: {
      typeNames: {
        pie: "Pie chart",
        bar: "Bar chart",
        line: "Line chart",
        scatter: "Scatter plot",
        effectScatter: "Ripple scatter plot",
        radar: "Radar chart",
        tree: "Tree",
        treemap: "Treemap",
        boxplot: "Boxplot",
        candlestick: "Candlestick",
        k: "K line chart",
        heatmap: "Heat map",
        map: "Map",
        parallel: "Parallel coordinate map",
        lines: "Line graph",
        graph: "Relationship graph",
        sankey: "Sankey diagram",
        funnel: "Funnel chart",
        gauge: "Gauge",
        pictorialBar: "Pictorial bar",
        themeRiver: "Theme River Map",
        sunburst: "Sunburst"
      }
    },
    aria: {
      general: {
        withTitle: 'This is a chart about "{title}"',
        withoutTitle: "This is a chart"
      },
      series: {
        single: {
          prefix: "",
          withName: " with type {seriesType} named {seriesName}.",
          withoutName: " with type {seriesType}."
        },
        multiple: {
          prefix: ". It consists of {seriesCount} series count.",
          withName: " The {seriesId} series is a {seriesType} representing {seriesName}.",
          withoutName: " The {seriesId} series is a {seriesType}.",
          separator: {
            middle: "",
            end: ""
          }
        }
      },
      data: {
        allData: "The data is as follows: ",
        partialData: "The first {displayCnt} items are: ",
        withName: "the data for {name} is {value}",
        withoutName: "{value}",
        separator: {
          middle: ", ",
          end: ". "
        }
      }
    }
  };

  // node_modules/echarts/lib/i18n/langZH.js
  var langZH_default = {
    time: {
      month: ["一月", "二月", "三月", "四月", "五月", "六月", "七月", "八月", "九月", "十月", "十一月", "十二月"],
      monthAbbr: ["1月", "2月", "3月", "4月", "5月", "6月", "7月", "8月", "9月", "10月", "11月", "12月"],
      dayOfWeek: ["星期日", "星期一", "星期二", "星期三", "星期四", "星期五", "星期六"],
      dayOfWeekAbbr: ["日", "一", "二", "三", "四", "五", "六"]
    },
    legend: {
      selector: {
        all: "全选",
        inverse: "反选"
      }
    },
    toolbox: {
      brush: {
        title: {
          rect: "矩形选择",
          polygon: "圈选",
          lineX: "横向选择",
          lineY: "纵向选择",
          keep: "保持选择",
          clear: "清除选择"
        }
      },
      dataView: {
        title: "数据视图",
        lang: ["数据视图", "关闭", "刷新"]
      },
      dataZoom: {
        title: {
          zoom: "区域缩放",
          back: "区域缩放还原"
        }
      },
      magicType: {
        title: {
          line: "切换为折线图",
          bar: "切换为柱状图",
          stack: "切换为堆叠",
          tiled: "切换为平铺"
        }
      },
      restore: {
        title: "还原"
      },
      saveAsImage: {
        title: "保存为图片",
        lang: ["右键另存为图片"]
      }
    },
    series: {
      typeNames: {
        pie: "饼图",
        bar: "柱状图",
        line: "折线图",
        scatter: "散点图",
        effectScatter: "涟漪散点图",
        radar: "雷达图",
        tree: "树图",
        treemap: "矩形树图",
        boxplot: "箱型图",
        candlestick: "K线图",
        k: "K线图",
        heatmap: "热力图",
        map: "地图",
        parallel: "平行坐标图",
        lines: "线图",
        graph: "关系图",
        sankey: "桑基图",
        funnel: "漏斗图",
        gauge: "仪表盘图",
        pictorialBar: "象形柱图",
        themeRiver: "主题河流图",
        sunburst: "旭日图"
      }
    },
    aria: {
      general: {
        withTitle: "这是一个关于“{title}”的图表。",
        withoutTitle: "这是一个图表，"
      },
      series: {
        single: {
          prefix: "",
          withName: "图表类型是{seriesType}，表示{seriesName}。",
          withoutName: "图表类型是{seriesType}。"
        },
        multiple: {
          prefix: "它由{seriesCount}个图表系列组成。",
          withName: "第{seriesId}个系列是一个表示{seriesName}的{seriesType}，",
          withoutName: "第{seriesId}个系列是一个{seriesType}，",
          separator: {
            middle: "；",
            end: "。"
          }
        }
      },
      data: {
        allData: "其数据是——",
        partialData: "其中，前{displayCnt}项是——",
        withName: "{name}的数据是{value}",
        withoutName: "{value}",
        separator: {
          middle: "，",
          end: ""
        }
      }
    }
  };

  // node_modules/echarts/lib/core/locale.js
  var LOCALE_ZH = "ZH";
  var LOCALE_EN = "EN";
  var DEFAULT_LOCALE = LOCALE_EN;
  var localeStorage = {};
  var localeModels = {};
  var SYSTEM_LANG = !env_default.domSupported ? DEFAULT_LOCALE : function() {
    var langStr = (document.documentElement.lang || navigator.language || navigator.browserLanguage).toUpperCase();
    return langStr.indexOf(LOCALE_ZH) > -1 ? LOCALE_ZH : DEFAULT_LOCALE;
  }();
  function registerLocale(locale, localeObj) {
    locale = locale.toUpperCase();
    localeModels[locale] = new Model_default(localeObj);
    localeStorage[locale] = localeObj;
  }
  function createLocaleObject(locale) {
    if (isString(locale)) {
      var localeObj = localeStorage[locale.toUpperCase()] || {};
      if (locale === LOCALE_ZH || locale === LOCALE_EN) {
        return clone(localeObj);
      } else {
        return merge(clone(localeObj), clone(localeStorage[DEFAULT_LOCALE]), false);
      }
    } else {
      return merge(clone(locale), clone(localeStorage[DEFAULT_LOCALE]), false);
    }
  }
  function getLocaleModel(lang) {
    return localeModels[lang];
  }
  function getDefaultLocaleModel() {
    return localeModels[DEFAULT_LOCALE];
  }
  registerLocale(LOCALE_EN, langEN_default);
  registerLocale(LOCALE_ZH, langZH_default);

  // node_modules/echarts/lib/util/time.js
  var ONE_SECOND = 1e3;
  var ONE_MINUTE = ONE_SECOND * 60;
  var ONE_HOUR = ONE_MINUTE * 60;
  var ONE_DAY = ONE_HOUR * 24;
  var ONE_YEAR = ONE_DAY * 365;
  var defaultLeveledFormatter = {
    year: "{yyyy}",
    month: "{MMM}",
    day: "{d}",
    hour: "{HH}:{mm}",
    minute: "{HH}:{mm}",
    second: "{HH}:{mm}:{ss}",
    millisecond: "{HH}:{mm}:{ss} {SSS}",
    none: "{yyyy}-{MM}-{dd} {HH}:{mm}:{ss} {SSS}"
  };
  var fullDayFormatter = "{yyyy}-{MM}-{dd}";
  var fullLeveledFormatter = {
    year: "{yyyy}",
    month: "{yyyy}-{MM}",
    day: fullDayFormatter,
    hour: fullDayFormatter + " " + defaultLeveledFormatter.hour,
    minute: fullDayFormatter + " " + defaultLeveledFormatter.minute,
    second: fullDayFormatter + " " + defaultLeveledFormatter.second,
    millisecond: defaultLeveledFormatter.none
  };
  var primaryTimeUnits = ["year", "month", "day", "hour", "minute", "second", "millisecond"];
  var timeUnits = ["year", "half-year", "quarter", "month", "week", "half-week", "day", "half-day", "quarter-day", "hour", "minute", "second", "millisecond"];
  function pad(str, len2) {
    str += "";
    return "0000".substr(0, len2 - str.length) + str;
  }
  function getPrimaryTimeUnit(timeUnit) {
    switch (timeUnit) {
      case "half-year":
      case "quarter":
        return "month";
      case "week":
      case "half-week":
        return "day";
      case "half-day":
      case "quarter-day":
        return "hour";
      default:
        return timeUnit;
    }
  }
  function isPrimaryTimeUnit(timeUnit) {
    return timeUnit === getPrimaryTimeUnit(timeUnit);
  }
  function getDefaultFormatPrecisionOfInterval(timeUnit) {
    switch (timeUnit) {
      case "year":
      case "month":
        return "day";
      case "millisecond":
        return "millisecond";
      default:
        return "second";
    }
  }
  function format(time, template, isUTC, lang) {
    var date = parseDate(time);
    var y = date[fullYearGetterName(isUTC)]();
    var M = date[monthGetterName(isUTC)]() + 1;
    var q = Math.floor((M - 1) / 3) + 1;
    var d = date[dateGetterName(isUTC)]();
    var e2 = date["get" + (isUTC ? "UTC" : "") + "Day"]();
    var H = date[hoursGetterName(isUTC)]();
    var h = (H - 1) % 12 + 1;
    var m2 = date[minutesGetterName(isUTC)]();
    var s = date[secondsGetterName(isUTC)]();
    var S = date[millisecondsGetterName(isUTC)]();
    var localeModel = lang instanceof Model_default ? lang : getLocaleModel(lang || SYSTEM_LANG) || getDefaultLocaleModel();
    var timeModel = localeModel.getModel("time");
    var month = timeModel.get("month");
    var monthAbbr = timeModel.get("monthAbbr");
    var dayOfWeek = timeModel.get("dayOfWeek");
    var dayOfWeekAbbr = timeModel.get("dayOfWeekAbbr");
    return (template || "").replace(/{yyyy}/g, y + "").replace(/{yy}/g, y % 100 + "").replace(/{Q}/g, q + "").replace(/{MMMM}/g, month[M - 1]).replace(/{MMM}/g, monthAbbr[M - 1]).replace(/{MM}/g, pad(M, 2)).replace(/{M}/g, M + "").replace(/{dd}/g, pad(d, 2)).replace(/{d}/g, d + "").replace(/{eeee}/g, dayOfWeek[e2]).replace(/{ee}/g, dayOfWeekAbbr[e2]).replace(/{e}/g, e2 + "").replace(/{HH}/g, pad(H, 2)).replace(/{H}/g, H + "").replace(/{hh}/g, pad(h + "", 2)).replace(/{h}/g, h + "").replace(/{mm}/g, pad(m2, 2)).replace(/{m}/g, m2 + "").replace(/{ss}/g, pad(s, 2)).replace(/{s}/g, s + "").replace(/{SSS}/g, pad(S, 3)).replace(/{S}/g, S + "");
  }
  function leveledFormat(tick, idx, formatter, lang, isUTC) {
    var template = null;
    if (isString(formatter)) {
      template = formatter;
    } else if (isFunction(formatter)) {
      template = formatter(tick.value, idx, {
        level: tick.level
      });
    } else {
      var defaults2 = extend({}, defaultLeveledFormatter);
      if (tick.level > 0) {
        for (var i = 0; i < primaryTimeUnits.length; ++i) {
          defaults2[primaryTimeUnits[i]] = "{primary|" + defaults2[primaryTimeUnits[i]] + "}";
        }
      }
      var mergedFormatter = formatter ? formatter.inherit === false ? formatter : defaults(formatter, defaults2) : defaults2;
      var unit = getUnitFromValue(tick.value, isUTC);
      if (mergedFormatter[unit]) {
        template = mergedFormatter[unit];
      } else if (mergedFormatter.inherit) {
        var targetId = timeUnits.indexOf(unit);
        for (var i = targetId - 1; i >= 0; --i) {
          if (mergedFormatter[unit]) {
            template = mergedFormatter[unit];
            break;
          }
        }
        template = template || defaults2.none;
      }
      if (isArray(template)) {
        var levelId = tick.level == null ? 0 : tick.level >= 0 ? tick.level : template.length + tick.level;
        levelId = Math.min(levelId, template.length - 1);
        template = template[levelId];
      }
    }
    return format(new Date(tick.value), template, isUTC, lang);
  }
  function getUnitFromValue(value, isUTC) {
    var date = parseDate(value);
    var M = date[monthGetterName(isUTC)]() + 1;
    var d = date[dateGetterName(isUTC)]();
    var h = date[hoursGetterName(isUTC)]();
    var m2 = date[minutesGetterName(isUTC)]();
    var s = date[secondsGetterName(isUTC)]();
    var S = date[millisecondsGetterName(isUTC)]();
    var isSecond = S === 0;
    var isMinute = isSecond && s === 0;
    var isHour = isMinute && m2 === 0;
    var isDay = isHour && h === 0;
    var isMonth = isDay && d === 1;
    var isYear = isMonth && M === 1;
    if (isYear) {
      return "year";
    } else if (isMonth) {
      return "month";
    } else if (isDay) {
      return "day";
    } else if (isHour) {
      return "hour";
    } else if (isMinute) {
      return "minute";
    } else if (isSecond) {
      return "second";
    } else {
      return "millisecond";
    }
  }
  function getUnitValue(value, unit, isUTC) {
    var date = isNumber(value) ? parseDate(value) : value;
    unit = unit || getUnitFromValue(value, isUTC);
    switch (unit) {
      case "year":
        return date[fullYearGetterName(isUTC)]();
      case "half-year":
        return date[monthGetterName(isUTC)]() >= 6 ? 1 : 0;
      case "quarter":
        return Math.floor((date[monthGetterName(isUTC)]() + 1) / 4);
      case "month":
        return date[monthGetterName(isUTC)]();
      case "day":
        return date[dateGetterName(isUTC)]();
      case "half-day":
        return date[hoursGetterName(isUTC)]() / 24;
      case "hour":
        return date[hoursGetterName(isUTC)]();
      case "minute":
        return date[minutesGetterName(isUTC)]();
      case "second":
        return date[secondsGetterName(isUTC)]();
      case "millisecond":
        return date[millisecondsGetterName(isUTC)]();
    }
  }
  function fullYearGetterName(isUTC) {
    return isUTC ? "getUTCFullYear" : "getFullYear";
  }
  function monthGetterName(isUTC) {
    return isUTC ? "getUTCMonth" : "getMonth";
  }
  function dateGetterName(isUTC) {
    return isUTC ? "getUTCDate" : "getDate";
  }
  function hoursGetterName(isUTC) {
    return isUTC ? "getUTCHours" : "getHours";
  }
  function minutesGetterName(isUTC) {
    return isUTC ? "getUTCMinutes" : "getMinutes";
  }
  function secondsGetterName(isUTC) {
    return isUTC ? "getUTCSeconds" : "getSeconds";
  }
  function millisecondsGetterName(isUTC) {
    return isUTC ? "getUTCMilliseconds" : "getMilliseconds";
  }
  function fullYearSetterName(isUTC) {
    return isUTC ? "setUTCFullYear" : "setFullYear";
  }
  function monthSetterName(isUTC) {
    return isUTC ? "setUTCMonth" : "setMonth";
  }
  function dateSetterName(isUTC) {
    return isUTC ? "setUTCDate" : "setDate";
  }
  function hoursSetterName(isUTC) {
    return isUTC ? "setUTCHours" : "setHours";
  }
  function minutesSetterName(isUTC) {
    return isUTC ? "setUTCMinutes" : "setMinutes";
  }
  function secondsSetterName(isUTC) {
    return isUTC ? "setUTCSeconds" : "setSeconds";
  }
  function millisecondsSetterName(isUTC) {
    return isUTC ? "setUTCMilliseconds" : "setMilliseconds";
  }

  // node_modules/echarts/lib/legacy/getTextRect.js
  function getTextRect(text, font, align, verticalAlign, padding, rich, truncate, lineHeight) {
    var textEl = new Text_default({
      style: {
        text,
        font,
        align,
        verticalAlign,
        padding,
        rich,
        overflow: truncate ? "truncate" : null,
        lineHeight
      }
    });
    return textEl.getBoundingRect();
  }

  // node_modules/echarts/lib/util/format.js
  function addCommas(x) {
    if (!isNumeric(x)) {
      return isString(x) ? x : "-";
    }
    var parts = (x + "").split(".");
    return parts[0].replace(/(\d{1,3})(?=(?:\d{3})+(?!\d))/g, "$1,") + (parts.length > 1 ? "." + parts[1] : "");
  }
  function toCamelCase(str, upperCaseFirst) {
    str = (str || "").toLowerCase().replace(/-(.)/g, function(match, group1) {
      return group1.toUpperCase();
    });
    if (upperCaseFirst && str) {
      str = str.charAt(0).toUpperCase() + str.slice(1);
    }
    return str;
  }
  var normalizeCssArray2 = normalizeCssArray;
  var replaceReg = /([&<>"'])/g;
  var replaceMap = {
    "&": "&amp;",
    "<": "&lt;",
    ">": "&gt;",
    '"': "&quot;",
    "'": "&#39;"
  };
  function encodeHTML(source) {
    return source == null ? "" : (source + "").replace(replaceReg, function(str, c) {
      return replaceMap[c];
    });
  }
  function makeValueReadable(value, valueType, useUTC) {
    var USER_READABLE_DEFUALT_TIME_PATTERN = "{yyyy}-{MM}-{dd} {HH}:{mm}:{ss}";
    function stringToUserReadable(str) {
      return str && trim(str) ? str : "-";
    }
    function isNumberUserReadable(num) {
      return !!(num != null && !isNaN(num) && isFinite(num));
    }
    var isTypeTime = valueType === "time";
    var isValueDate = value instanceof Date;
    if (isTypeTime || isValueDate) {
      var date = isTypeTime ? parseDate(value) : value;
      if (!isNaN(+date)) {
        return format(date, USER_READABLE_DEFUALT_TIME_PATTERN, useUTC);
      } else if (isValueDate) {
        return "-";
      }
    }
    if (valueType === "ordinal") {
      return isStringSafe(value) ? stringToUserReadable(value) : isNumber(value) ? isNumberUserReadable(value) ? value + "" : "-" : "-";
    }
    var numericResult = numericToNumber(value);
    return isNumberUserReadable(numericResult) ? addCommas(numericResult) : isStringSafe(value) ? stringToUserReadable(value) : typeof value === "boolean" ? value + "" : "-";
  }
  var TPL_VAR_ALIAS = ["a", "b", "c", "d", "e", "f", "g"];
  var wrapVar = function(varName, seriesIdx) {
    return "{" + varName + (seriesIdx == null ? "" : seriesIdx) + "}";
  };
  function formatTpl(tpl, paramsList, encode) {
    if (!isArray(paramsList)) {
      paramsList = [paramsList];
    }
    var seriesLen = paramsList.length;
    if (!seriesLen) {
      return "";
    }
    var $vars = paramsList[0].$vars || [];
    for (var i = 0; i < $vars.length; i++) {
      var alias = TPL_VAR_ALIAS[i];
      tpl = tpl.replace(wrapVar(alias), wrapVar(alias, 0));
    }
    for (var seriesIdx = 0; seriesIdx < seriesLen; seriesIdx++) {
      for (var k = 0; k < $vars.length; k++) {
        var val = paramsList[seriesIdx][$vars[k]];
        tpl = tpl.replace(wrapVar(TPL_VAR_ALIAS[k], seriesIdx), encode ? encodeHTML(val) : val);
      }
    }
    return tpl;
  }
  function formatTplSimple(tpl, param, encode) {
    each(param, function(value, key) {
      tpl = tpl.replace("{" + key + "}", encode ? encodeHTML(value) : value);
    });
    return tpl;
  }
  function getTooltipMarker(inOpt, extraCssText) {
    var opt = isString(inOpt) ? {
      color: inOpt,
      extraCssText
    } : inOpt || {};
    var color = opt.color;
    var type = opt.type;
    extraCssText = opt.extraCssText;
    var renderMode = opt.renderMode || "html";
    if (!color) {
      return "";
    }
    if (renderMode === "html") {
      return type === "subItem" ? '<span style="display:inline-block;vertical-align:middle;margin-right:8px;margin-left:3px;border-radius:4px;width:4px;height:4px;background-color:' + encodeHTML(color) + ";" + (extraCssText || "") + '"></span>' : '<span style="display:inline-block;margin-right:4px;border-radius:10px;width:10px;height:10px;background-color:' + encodeHTML(color) + ";" + (extraCssText || "") + '"></span>';
    } else {
      var markerId = opt.markerId || "markerX";
      return {
        renderMode,
        content: "{" + markerId + "|}  ",
        style: type === "subItem" ? {
          width: 4,
          height: 4,
          borderRadius: 2,
          backgroundColor: color
        } : {
          width: 10,
          height: 10,
          borderRadius: 5,
          backgroundColor: color
        }
      };
    }
  }
  function formatTime(tpl, value, isUTC) {
    if (true) {
      deprecateReplaceLog("echarts.format.formatTime", "echarts.time.format");
    }
    if (tpl === "week" || tpl === "month" || tpl === "quarter" || tpl === "half-year" || tpl === "year") {
      tpl = "MM-dd\nyyyy";
    }
    var date = parseDate(value);
    var getUTC = isUTC ? "getUTC" : "get";
    var y = date[getUTC + "FullYear"]();
    var M = date[getUTC + "Month"]() + 1;
    var d = date[getUTC + "Date"]();
    var h = date[getUTC + "Hours"]();
    var m2 = date[getUTC + "Minutes"]();
    var s = date[getUTC + "Seconds"]();
    var S = date[getUTC + "Milliseconds"]();
    tpl = tpl.replace("MM", pad(M, 2)).replace("M", M).replace("yyyy", y).replace("yy", pad(y % 100 + "", 2)).replace("dd", pad(d, 2)).replace("d", d).replace("hh", pad(h, 2)).replace("h", h).replace("mm", pad(m2, 2)).replace("m", m2).replace("ss", pad(s, 2)).replace("s", s).replace("SSS", pad(S, 3));
    return tpl;
  }
  function capitalFirst(str) {
    return str ? str.charAt(0).toUpperCase() + str.substr(1) : str;
  }
  function convertToColorString(color, defaultColor) {
    defaultColor = defaultColor || "transparent";
    return isString(color) ? color : isObject(color) ? color.colorStops && (color.colorStops[0] || {}).color || defaultColor : defaultColor;
  }
  function windowOpen(link, target) {
    if (target === "_blank" || target === "blank") {
      var blank = window.open();
      blank.opener = null;
      blank.location.href = link;
    } else {
      window.open(link, target);
    }
  }

  // node_modules/echarts/lib/util/layout.js
  var each2 = each;
  var LOCATION_PARAMS = ["left", "right", "top", "bottom", "width", "height"];
  var HV_NAMES = [["width", "left", "right"], ["height", "top", "bottom"]];
  function boxLayout(orient, group, gap, maxWidth, maxHeight) {
    var x = 0;
    var y = 0;
    if (maxWidth == null) {
      maxWidth = Infinity;
    }
    if (maxHeight == null) {
      maxHeight = Infinity;
    }
    var currentLineMaxSize = 0;
    group.eachChild(function(child, idx) {
      var rect = child.getBoundingRect();
      var nextChild = group.childAt(idx + 1);
      var nextChildRect = nextChild && nextChild.getBoundingRect();
      var nextX;
      var nextY;
      if (orient === "horizontal") {
        var moveX = rect.width + (nextChildRect ? -nextChildRect.x + rect.x : 0);
        nextX = x + moveX;
        if (nextX > maxWidth || child.newline) {
          x = 0;
          nextX = moveX;
          y += currentLineMaxSize + gap;
          currentLineMaxSize = rect.height;
        } else {
          currentLineMaxSize = Math.max(currentLineMaxSize, rect.height);
        }
      } else {
        var moveY = rect.height + (nextChildRect ? -nextChildRect.y + rect.y : 0);
        nextY = y + moveY;
        if (nextY > maxHeight || child.newline) {
          x += currentLineMaxSize + gap;
          y = 0;
          nextY = moveY;
          currentLineMaxSize = rect.width;
        } else {
          currentLineMaxSize = Math.max(currentLineMaxSize, rect.width);
        }
      }
      if (child.newline) {
        return;
      }
      child.x = x;
      child.y = y;
      child.markRedraw();
      orient === "horizontal" ? x = nextX + gap : y = nextY + gap;
    });
  }
  var box = boxLayout;
  var vbox = curry(boxLayout, "vertical");
  var hbox = curry(boxLayout, "horizontal");
  function getAvailableSize(positionInfo, containerRect, margin) {
    var containerWidth = containerRect.width;
    var containerHeight = containerRect.height;
    var x = parsePercent2(positionInfo.left, containerWidth);
    var y = parsePercent2(positionInfo.top, containerHeight);
    var x2 = parsePercent2(positionInfo.right, containerWidth);
    var y2 = parsePercent2(positionInfo.bottom, containerHeight);
    (isNaN(x) || isNaN(parseFloat(positionInfo.left))) && (x = 0);
    (isNaN(x2) || isNaN(parseFloat(positionInfo.right))) && (x2 = containerWidth);
    (isNaN(y) || isNaN(parseFloat(positionInfo.top))) && (y = 0);
    (isNaN(y2) || isNaN(parseFloat(positionInfo.bottom))) && (y2 = containerHeight);
    margin = normalizeCssArray2(margin || 0);
    return {
      width: Math.max(x2 - x - margin[1] - margin[3], 0),
      height: Math.max(y2 - y - margin[0] - margin[2], 0)
    };
  }
  function getLayoutRect(positionInfo, containerRect, margin) {
    margin = normalizeCssArray2(margin || 0);
    var containerWidth = containerRect.width;
    var containerHeight = containerRect.height;
    var left = parsePercent2(positionInfo.left, containerWidth);
    var top = parsePercent2(positionInfo.top, containerHeight);
    var right = parsePercent2(positionInfo.right, containerWidth);
    var bottom = parsePercent2(positionInfo.bottom, containerHeight);
    var width = parsePercent2(positionInfo.width, containerWidth);
    var height = parsePercent2(positionInfo.height, containerHeight);
    var verticalMargin = margin[2] + margin[0];
    var horizontalMargin = margin[1] + margin[3];
    var aspect = positionInfo.aspect;
    if (isNaN(width)) {
      width = containerWidth - right - horizontalMargin - left;
    }
    if (isNaN(height)) {
      height = containerHeight - bottom - verticalMargin - top;
    }
    if (aspect != null) {
      if (isNaN(width) && isNaN(height)) {
        if (aspect > containerWidth / containerHeight) {
          width = containerWidth * 0.8;
        } else {
          height = containerHeight * 0.8;
        }
      }
      if (isNaN(width)) {
        width = aspect * height;
      }
      if (isNaN(height)) {
        height = width / aspect;
      }
    }
    if (isNaN(left)) {
      left = containerWidth - right - width - horizontalMargin;
    }
    if (isNaN(top)) {
      top = containerHeight - bottom - height - verticalMargin;
    }
    switch (positionInfo.left || positionInfo.right) {
      case "center":
        left = containerWidth / 2 - width / 2 - margin[3];
        break;
      case "right":
        left = containerWidth - width - horizontalMargin;
        break;
    }
    switch (positionInfo.top || positionInfo.bottom) {
      case "middle":
      case "center":
        top = containerHeight / 2 - height / 2 - margin[0];
        break;
      case "bottom":
        top = containerHeight - height - verticalMargin;
        break;
    }
    left = left || 0;
    top = top || 0;
    if (isNaN(width)) {
      width = containerWidth - horizontalMargin - left - (right || 0);
    }
    if (isNaN(height)) {
      height = containerHeight - verticalMargin - top - (bottom || 0);
    }
    var rect = new BoundingRect_default(left + margin[3], top + margin[0], width, height);
    rect.margin = margin;
    return rect;
  }
  function positionElement(el, positionInfo, containerRect, margin, opt, out2) {
    var h = !opt || !opt.hv || opt.hv[0];
    var v = !opt || !opt.hv || opt.hv[1];
    var boundingMode = opt && opt.boundingMode || "all";
    out2 = out2 || el;
    out2.x = el.x;
    out2.y = el.y;
    if (!h && !v) {
      return false;
    }
    var rect;
    if (boundingMode === "raw") {
      rect = el.type === "group" ? new BoundingRect_default(0, 0, +positionInfo.width || 0, +positionInfo.height || 0) : el.getBoundingRect();
    } else {
      rect = el.getBoundingRect();
      if (el.needLocalTransform()) {
        var transform2 = el.getLocalTransform();
        rect = rect.clone();
        rect.applyTransform(transform2);
      }
    }
    var layoutRect = getLayoutRect(defaults({
      width: rect.width,
      height: rect.height
    }, positionInfo), containerRect, margin);
    var dx = h ? layoutRect.x - rect.x : 0;
    var dy = v ? layoutRect.y - rect.y : 0;
    if (boundingMode === "raw") {
      out2.x = dx;
      out2.y = dy;
    } else {
      out2.x += dx;
      out2.y += dy;
    }
    if (out2 === el) {
      el.markRedraw();
    }
    return true;
  }
  function sizeCalculable(option, hvIdx) {
    return option[HV_NAMES[hvIdx][0]] != null || option[HV_NAMES[hvIdx][1]] != null && option[HV_NAMES[hvIdx][2]] != null;
  }
  function fetchLayoutMode(ins) {
    var layoutMode = ins.layoutMode || ins.constructor.layoutMode;
    return isObject(layoutMode) ? layoutMode : layoutMode ? {
      type: layoutMode
    } : null;
  }
  function mergeLayoutParam(targetOption, newOption, opt) {
    var ignoreSize = opt && opt.ignoreSize;
    !isArray(ignoreSize) && (ignoreSize = [ignoreSize, ignoreSize]);
    var hResult = merge2(HV_NAMES[0], 0);
    var vResult = merge2(HV_NAMES[1], 1);
    copy3(HV_NAMES[0], targetOption, hResult);
    copy3(HV_NAMES[1], targetOption, vResult);
    function merge2(names, hvIdx) {
      var newParams = {};
      var newValueCount = 0;
      var merged = {};
      var mergedValueCount = 0;
      var enoughParamNumber = 2;
      each2(names, function(name) {
        merged[name] = targetOption[name];
      });
      each2(names, function(name) {
        hasProp(newOption, name) && (newParams[name] = merged[name] = newOption[name]);
        hasValue(newParams, name) && newValueCount++;
        hasValue(merged, name) && mergedValueCount++;
      });
      if (ignoreSize[hvIdx]) {
        if (hasValue(newOption, names[1])) {
          merged[names[2]] = null;
        } else if (hasValue(newOption, names[2])) {
          merged[names[1]] = null;
        }
        return merged;
      }
      if (mergedValueCount === enoughParamNumber || !newValueCount) {
        return merged;
      } else if (newValueCount >= enoughParamNumber) {
        return newParams;
      } else {
        for (var i = 0; i < names.length; i++) {
          var name_1 = names[i];
          if (!hasProp(newParams, name_1) && hasProp(targetOption, name_1)) {
            newParams[name_1] = targetOption[name_1];
            break;
          }
        }
        return newParams;
      }
    }
    function hasProp(obj, name) {
      return obj.hasOwnProperty(name);
    }
    function hasValue(obj, name) {
      return obj[name] != null && obj[name] !== "auto";
    }
    function copy3(names, target, source) {
      each2(names, function(name) {
        target[name] = source[name];
      });
    }
  }
  function getLayoutParams(source) {
    return copyLayoutParams({}, source);
  }
  function copyLayoutParams(target, source) {
    source && target && each2(LOCATION_PARAMS, function(name) {
      source.hasOwnProperty(name) && (target[name] = source[name]);
    });
    return target;
  }

  // node_modules/echarts/lib/model/Component.js
  var inner = makeInner();
  var ComponentModel = function(_super) {
    __extends(ComponentModel2, _super);
    function ComponentModel2(option, parentModel, ecModel) {
      var _this = _super.call(this, option, parentModel, ecModel) || this;
      _this.uid = getUID("ec_cpt_model");
      return _this;
    }
    ComponentModel2.prototype.init = function(option, parentModel, ecModel) {
      this.mergeDefaultAndTheme(option, ecModel);
    };
    ComponentModel2.prototype.mergeDefaultAndTheme = function(option, ecModel) {
      var layoutMode = fetchLayoutMode(this);
      var inputPositionParams = layoutMode ? getLayoutParams(option) : {};
      var themeModel = ecModel.getTheme();
      merge(option, themeModel.get(this.mainType));
      merge(option, this.getDefaultOption());
      if (layoutMode) {
        mergeLayoutParam(option, inputPositionParams, layoutMode);
      }
    };
    ComponentModel2.prototype.mergeOption = function(option, ecModel) {
      merge(this.option, option, true);
      var layoutMode = fetchLayoutMode(this);
      if (layoutMode) {
        mergeLayoutParam(this.option, option, layoutMode);
      }
    };
    ComponentModel2.prototype.optionUpdated = function(newCptOption, isInit) {
    };
    ComponentModel2.prototype.getDefaultOption = function() {
      var ctor = this.constructor;
      if (!isExtendedClass(ctor)) {
        return ctor.defaultOption;
      }
      var fields = inner(this);
      if (!fields.defaultOption) {
        var optList = [];
        var clz = ctor;
        while (clz) {
          var opt = clz.prototype.defaultOption;
          opt && optList.push(opt);
          clz = clz.superClass;
        }
        var defaultOption3 = {};
        for (var i = optList.length - 1; i >= 0; i--) {
          defaultOption3 = merge(defaultOption3, optList[i], true);
        }
        fields.defaultOption = defaultOption3;
      }
      return fields.defaultOption;
    };
    ComponentModel2.prototype.getReferringComponents = function(mainType, opt) {
      var indexKey = mainType + "Index";
      var idKey = mainType + "Id";
      return queryReferringComponents(this.ecModel, mainType, {
        index: this.get(indexKey, true),
        id: this.get(idKey, true)
      }, opt);
    };
    ComponentModel2.prototype.getBoxLayoutParams = function() {
      var boxLayoutModel = this;
      return {
        left: boxLayoutModel.get("left"),
        top: boxLayoutModel.get("top"),
        right: boxLayoutModel.get("right"),
        bottom: boxLayoutModel.get("bottom"),
        width: boxLayoutModel.get("width"),
        height: boxLayoutModel.get("height")
      };
    };
    ComponentModel2.prototype.getZLevelKey = function() {
      return "";
    };
    ComponentModel2.prototype.setZLevel = function(zlevel) {
      this.option.zlevel = zlevel;
    };
    ComponentModel2.protoInitialize = function() {
      var proto2 = ComponentModel2.prototype;
      proto2.type = "component";
      proto2.id = "";
      proto2.name = "";
      proto2.mainType = "";
      proto2.subType = "";
      proto2.componentIndex = 0;
    }();
    return ComponentModel2;
  }(Model_default);
  mountExtend(ComponentModel, Model_default);
  enableClassManagement(ComponentModel);
  enableSubTypeDefaulter(ComponentModel);
  enableTopologicalTravel(ComponentModel, getDependencies);
  function getDependencies(componentType) {
    var deps = [];
    each(ComponentModel.getClassesByMainType(componentType), function(clz) {
      deps = deps.concat(clz.dependencies || clz.prototype.dependencies || []);
    });
    deps = map(deps, function(type) {
      return parseClassType(type).main;
    });
    if (componentType !== "dataset" && indexOf(deps, "dataset") <= 0) {
      deps.unshift("dataset");
    }
    return deps;
  }
  var Component_default = ComponentModel;

  // node_modules/echarts/lib/model/globalDefault.js
  var platform = "";
  if (typeof navigator !== "undefined") {
    platform = navigator.platform || "";
  }
  var decalColor = "rgba(0, 0, 0, 0.2)";
  var globalDefault_default = {
    darkMode: "auto",
    colorBy: "series",
    color: ["#5470c6", "#91cc75", "#fac858", "#ee6666", "#73c0de", "#3ba272", "#fc8452", "#9a60b4", "#ea7ccc"],
    gradientColor: ["#f6efa6", "#d88273", "#bf444c"],
    aria: {
      decal: {
        decals: [{
          color: decalColor,
          dashArrayX: [1, 0],
          dashArrayY: [2, 5],
          symbolSize: 1,
          rotation: Math.PI / 6
        }, {
          color: decalColor,
          symbol: "circle",
          dashArrayX: [[8, 8], [0, 8, 8, 0]],
          dashArrayY: [6, 0],
          symbolSize: 0.8
        }, {
          color: decalColor,
          dashArrayX: [1, 0],
          dashArrayY: [4, 3],
          rotation: -Math.PI / 4
        }, {
          color: decalColor,
          dashArrayX: [[6, 6], [0, 6, 6, 0]],
          dashArrayY: [6, 0]
        }, {
          color: decalColor,
          dashArrayX: [[1, 0], [1, 6]],
          dashArrayY: [1, 0, 6, 0],
          rotation: Math.PI / 4
        }, {
          color: decalColor,
          symbol: "triangle",
          dashArrayX: [[9, 9], [0, 9, 9, 0]],
          dashArrayY: [7, 2],
          symbolSize: 0.75
        }]
      }
    },
    textStyle: {
      fontFamily: platform.match(/^Win/) ? "Microsoft YaHei" : "sans-serif",
      fontSize: 12,
      fontStyle: "normal",
      fontWeight: "normal"
    },
    blendMode: null,
    stateAnimation: {
      duration: 300,
      easing: "cubicOut"
    },
    animation: "auto",
    animationDuration: 1e3,
    animationDurationUpdate: 500,
    animationEasing: "cubicInOut",
    animationEasingUpdate: "cubicInOut",
    animationThreshold: 2e3,
    progressiveThreshold: 3e3,
    progressive: 400,
    hoverLayerThreshold: 3e3,
    useUTC: false
  };

  // node_modules/echarts/lib/util/types.js
  var VISUAL_DIMENSIONS = createHashMap(["tooltip", "label", "itemName", "itemId", "itemGroupId", "seriesName"]);
  var SOURCE_FORMAT_ORIGINAL = "original";
  var SOURCE_FORMAT_ARRAY_ROWS = "arrayRows";
  var SOURCE_FORMAT_OBJECT_ROWS = "objectRows";
  var SOURCE_FORMAT_KEYED_COLUMNS = "keyedColumns";
  var SOURCE_FORMAT_TYPED_ARRAY = "typedArray";
  var SOURCE_FORMAT_UNKNOWN = "unknown";
  var SERIES_LAYOUT_BY_COLUMN = "column";
  var SERIES_LAYOUT_BY_ROW = "row";

  // node_modules/echarts/lib/data/helper/sourceHelper.js
  var BE_ORDINAL = {
    Must: 1,
    Might: 2,
    Not: 3
  };
  var innerGlobalModel = makeInner();
  function resetSourceDefaulter(ecModel) {
    innerGlobalModel(ecModel).datasetMap = createHashMap();
  }
  function makeSeriesEncodeForAxisCoordSys(coordDimensions, seriesModel, source) {
    var encode = {};
    var datasetModel = querySeriesUpstreamDatasetModel(seriesModel);
    if (!datasetModel || !coordDimensions) {
      return encode;
    }
    var encodeItemName = [];
    var encodeSeriesName = [];
    var ecModel = seriesModel.ecModel;
    var datasetMap = innerGlobalModel(ecModel).datasetMap;
    var key = datasetModel.uid + "_" + source.seriesLayoutBy;
    var baseCategoryDimIndex;
    var categoryWayValueDimStart;
    coordDimensions = coordDimensions.slice();
    each(coordDimensions, function(coordDimInfoLoose, coordDimIdx) {
      var coordDimInfo = isObject(coordDimInfoLoose) ? coordDimInfoLoose : coordDimensions[coordDimIdx] = {
        name: coordDimInfoLoose
      };
      if (coordDimInfo.type === "ordinal" && baseCategoryDimIndex == null) {
        baseCategoryDimIndex = coordDimIdx;
        categoryWayValueDimStart = getDataDimCountOnCoordDim(coordDimInfo);
      }
      encode[coordDimInfo.name] = [];
    });
    var datasetRecord = datasetMap.get(key) || datasetMap.set(key, {
      categoryWayDim: categoryWayValueDimStart,
      valueWayDim: 0
    });
    each(coordDimensions, function(coordDimInfo, coordDimIdx) {
      var coordDimName = coordDimInfo.name;
      var count2 = getDataDimCountOnCoordDim(coordDimInfo);
      if (baseCategoryDimIndex == null) {
        var start2 = datasetRecord.valueWayDim;
        pushDim(encode[coordDimName], start2, count2);
        pushDim(encodeSeriesName, start2, count2);
        datasetRecord.valueWayDim += count2;
      } else if (baseCategoryDimIndex === coordDimIdx) {
        pushDim(encode[coordDimName], 0, count2);
        pushDim(encodeItemName, 0, count2);
      } else {
        var start2 = datasetRecord.categoryWayDim;
        pushDim(encode[coordDimName], start2, count2);
        pushDim(encodeSeriesName, start2, count2);
        datasetRecord.categoryWayDim += count2;
      }
    });
    function pushDim(dimIdxArr, idxFrom, idxCount) {
      for (var i = 0; i < idxCount; i++) {
        dimIdxArr.push(idxFrom + i);
      }
    }
    function getDataDimCountOnCoordDim(coordDimInfo) {
      var dimsDef = coordDimInfo.dimsDef;
      return dimsDef ? dimsDef.length : 1;
    }
    encodeItemName.length && (encode.itemName = encodeItemName);
    encodeSeriesName.length && (encode.seriesName = encodeSeriesName);
    return encode;
  }
  function makeSeriesEncodeForNameBased(seriesModel, source, dimCount) {
    var encode = {};
    var datasetModel = querySeriesUpstreamDatasetModel(seriesModel);
    if (!datasetModel) {
      return encode;
    }
    var sourceFormat = source.sourceFormat;
    var dimensionsDefine = source.dimensionsDefine;
    var potentialNameDimIndex;
    if (sourceFormat === SOURCE_FORMAT_OBJECT_ROWS || sourceFormat === SOURCE_FORMAT_KEYED_COLUMNS) {
      each(dimensionsDefine, function(dim, idx) {
        if ((isObject(dim) ? dim.name : dim) === "name") {
          potentialNameDimIndex = idx;
        }
      });
    }
    var idxResult = function() {
      var idxRes0 = {};
      var idxRes1 = {};
      var guessRecords = [];
      for (var i = 0, len2 = Math.min(5, dimCount); i < len2; i++) {
        var guessResult = doGuessOrdinal(source.data, sourceFormat, source.seriesLayoutBy, dimensionsDefine, source.startIndex, i);
        guessRecords.push(guessResult);
        var isPureNumber = guessResult === BE_ORDINAL.Not;
        if (isPureNumber && idxRes0.v == null && i !== potentialNameDimIndex) {
          idxRes0.v = i;
        }
        if (idxRes0.n == null || idxRes0.n === idxRes0.v || !isPureNumber && guessRecords[idxRes0.n] === BE_ORDINAL.Not) {
          idxRes0.n = i;
        }
        if (fulfilled(idxRes0) && guessRecords[idxRes0.n] !== BE_ORDINAL.Not) {
          return idxRes0;
        }
        if (!isPureNumber) {
          if (guessResult === BE_ORDINAL.Might && idxRes1.v == null && i !== potentialNameDimIndex) {
            idxRes1.v = i;
          }
          if (idxRes1.n == null || idxRes1.n === idxRes1.v) {
            idxRes1.n = i;
          }
        }
      }
      function fulfilled(idxResult2) {
        return idxResult2.v != null && idxResult2.n != null;
      }
      return fulfilled(idxRes0) ? idxRes0 : fulfilled(idxRes1) ? idxRes1 : null;
    }();
    if (idxResult) {
      encode.value = [idxResult.v];
      var nameDimIndex = potentialNameDimIndex != null ? potentialNameDimIndex : idxResult.n;
      encode.itemName = [nameDimIndex];
      encode.seriesName = [nameDimIndex];
    }
    return encode;
  }
  function querySeriesUpstreamDatasetModel(seriesModel) {
    var thisData = seriesModel.get("data", true);
    if (!thisData) {
      return queryReferringComponents(seriesModel.ecModel, "dataset", {
        index: seriesModel.get("datasetIndex", true),
        id: seriesModel.get("datasetId", true)
      }, SINGLE_REFERRING).models[0];
    }
  }
  function queryDatasetUpstreamDatasetModels(datasetModel) {
    if (!datasetModel.get("transform", true) && !datasetModel.get("fromTransformResult", true)) {
      return [];
    }
    return queryReferringComponents(datasetModel.ecModel, "dataset", {
      index: datasetModel.get("fromDatasetIndex", true),
      id: datasetModel.get("fromDatasetId", true)
    }, SINGLE_REFERRING).models;
  }
  function guessOrdinal(source, dimIndex) {
    return doGuessOrdinal(source.data, source.sourceFormat, source.seriesLayoutBy, source.dimensionsDefine, source.startIndex, dimIndex);
  }
  function doGuessOrdinal(data, sourceFormat, seriesLayoutBy, dimensionsDefine, startIndex, dimIndex) {
    var result;
    var maxLoop = 5;
    if (isTypedArray(data)) {
      return BE_ORDINAL.Not;
    }
    var dimName;
    var dimType;
    if (dimensionsDefine) {
      var dimDefItem = dimensionsDefine[dimIndex];
      if (isObject(dimDefItem)) {
        dimName = dimDefItem.name;
        dimType = dimDefItem.type;
      } else if (isString(dimDefItem)) {
        dimName = dimDefItem;
      }
    }
    if (dimType != null) {
      return dimType === "ordinal" ? BE_ORDINAL.Must : BE_ORDINAL.Not;
    }
    if (sourceFormat === SOURCE_FORMAT_ARRAY_ROWS) {
      var dataArrayRows = data;
      if (seriesLayoutBy === SERIES_LAYOUT_BY_ROW) {
        var sample = dataArrayRows[dimIndex];
        for (var i = 0; i < (sample || []).length && i < maxLoop; i++) {
          if ((result = detectValue(sample[startIndex + i])) != null) {
            return result;
          }
        }
      } else {
        for (var i = 0; i < dataArrayRows.length && i < maxLoop; i++) {
          var row = dataArrayRows[startIndex + i];
          if (row && (result = detectValue(row[dimIndex])) != null) {
            return result;
          }
        }
      }
    } else if (sourceFormat === SOURCE_FORMAT_OBJECT_ROWS) {
      var dataObjectRows = data;
      if (!dimName) {
        return BE_ORDINAL.Not;
      }
      for (var i = 0; i < dataObjectRows.length && i < maxLoop; i++) {
        var item = dataObjectRows[i];
        if (item && (result = detectValue(item[dimName])) != null) {
          return result;
        }
      }
    } else if (sourceFormat === SOURCE_FORMAT_KEYED_COLUMNS) {
      var dataKeyedColumns = data;
      if (!dimName) {
        return BE_ORDINAL.Not;
      }
      var sample = dataKeyedColumns[dimName];
      if (!sample || isTypedArray(sample)) {
        return BE_ORDINAL.Not;
      }
      for (var i = 0; i < sample.length && i < maxLoop; i++) {
        if ((result = detectValue(sample[i])) != null) {
          return result;
        }
      }
    } else if (sourceFormat === SOURCE_FORMAT_ORIGINAL) {
      var dataOriginal = data;
      for (var i = 0; i < dataOriginal.length && i < maxLoop; i++) {
        var item = dataOriginal[i];
        var val = getDataItemValue(item);
        if (!isArray(val)) {
          return BE_ORDINAL.Not;
        }
        if ((result = detectValue(val[dimIndex])) != null) {
          return result;
        }
      }
    }
    function detectValue(val2) {
      var beStr = isString(val2);
      if (val2 != null && isFinite(val2) && val2 !== "") {
        return beStr ? BE_ORDINAL.Might : BE_ORDINAL.Not;
      } else if (beStr && val2 !== "-") {
        return BE_ORDINAL.Must;
      }
    }
    return BE_ORDINAL.Not;
  }

  // node_modules/echarts/lib/model/internalComponentCreator.js
  var internalOptionCreatorMap = createHashMap();
  function registerInternalOptionCreator(mainType, creator) {
    assert(internalOptionCreatorMap.get(mainType) == null && creator);
    internalOptionCreatorMap.set(mainType, creator);
  }
  function concatInternalOptions(ecModel, mainType, newCmptOptionList) {
    var internalOptionCreator = internalOptionCreatorMap.get(mainType);
    if (!internalOptionCreator) {
      return newCmptOptionList;
    }
    var internalOptions = internalOptionCreator(ecModel);
    if (!internalOptions) {
      return newCmptOptionList;
    }
    if (true) {
      for (var i = 0; i < internalOptions.length; i++) {
        assert(isComponentIdInternal(internalOptions[i]));
      }
    }
    return newCmptOptionList.concat(internalOptions);
  }

  // node_modules/echarts/lib/model/mixin/palette.js
  var innerColor = makeInner();
  var innerDecal = makeInner();
  var PaletteMixin = function() {
    function PaletteMixin2() {
    }
    PaletteMixin2.prototype.getColorFromPalette = function(name, scope, requestNum) {
      var defaultPalette = normalizeToArray(this.get("color", true));
      var layeredPalette = this.get("colorLayer", true);
      return getFromPalette(this, innerColor, defaultPalette, layeredPalette, name, scope, requestNum);
    };
    PaletteMixin2.prototype.clearColorPalette = function() {
      clearPalette(this, innerColor);
    };
    return PaletteMixin2;
  }();
  function getDecalFromPalette(ecModel, name, scope, requestNum) {
    var defaultDecals = normalizeToArray(ecModel.get(["aria", "decal", "decals"]));
    return getFromPalette(ecModel, innerDecal, defaultDecals, null, name, scope, requestNum);
  }
  function getNearestPalette(palettes, requestColorNum) {
    var paletteNum = palettes.length;
    for (var i = 0; i < paletteNum; i++) {
      if (palettes[i].length > requestColorNum) {
        return palettes[i];
      }
    }
    return palettes[paletteNum - 1];
  }
  function getFromPalette(that, inner23, defaultPalette, layeredPalette, name, scope, requestNum) {
    scope = scope || that;
    var scopeFields = inner23(scope);
    var paletteIdx = scopeFields.paletteIdx || 0;
    var paletteNameMap = scopeFields.paletteNameMap = scopeFields.paletteNameMap || {};
    if (paletteNameMap.hasOwnProperty(name)) {
      return paletteNameMap[name];
    }
    var palette = requestNum == null || !layeredPalette ? defaultPalette : getNearestPalette(layeredPalette, requestNum);
    palette = palette || defaultPalette;
    if (!palette || !palette.length) {
      return;
    }
    var pickedPaletteItem = palette[paletteIdx];
    if (name) {
      paletteNameMap[name] = pickedPaletteItem;
    }
    scopeFields.paletteIdx = (paletteIdx + 1) % palette.length;
    return pickedPaletteItem;
  }
  function clearPalette(that, inner23) {
    inner23(that).paletteIdx = 0;
    inner23(that).paletteNameMap = {};
  }

  // node_modules/echarts/lib/model/Global.js
  var reCreateSeriesIndices;
  var assertSeriesInitialized;
  var initBase;
  var OPTION_INNER_KEY = "\0_ec_inner";
  var OPTION_INNER_VALUE = 1;
  var BUITIN_COMPONENTS_MAP = {
    grid: "GridComponent",
    polar: "PolarComponent",
    geo: "GeoComponent",
    singleAxis: "SingleAxisComponent",
    parallel: "ParallelComponent",
    calendar: "CalendarComponent",
    graphic: "GraphicComponent",
    toolbox: "ToolboxComponent",
    tooltip: "TooltipComponent",
    axisPointer: "AxisPointerComponent",
    brush: "BrushComponent",
    title: "TitleComponent",
    timeline: "TimelineComponent",
    markPoint: "MarkPointComponent",
    markLine: "MarkLineComponent",
    markArea: "MarkAreaComponent",
    legend: "LegendComponent",
    dataZoom: "DataZoomComponent",
    visualMap: "VisualMapComponent",
    xAxis: "GridComponent",
    yAxis: "GridComponent",
    angleAxis: "PolarComponent",
    radiusAxis: "PolarComponent"
  };
  var BUILTIN_CHARTS_MAP = {
    line: "LineChart",
    bar: "BarChart",
    pie: "PieChart",
    scatter: "ScatterChart",
    radar: "RadarChart",
    map: "MapChart",
    tree: "TreeChart",
    treemap: "TreemapChart",
    graph: "GraphChart",
    gauge: "GaugeChart",
    funnel: "FunnelChart",
    parallel: "ParallelChart",
    sankey: "SankeyChart",
    boxplot: "BoxplotChart",
    candlestick: "CandlestickChart",
    effectScatter: "EffectScatterChart",
    lines: "LinesChart",
    heatmap: "HeatmapChart",
    pictorialBar: "PictorialBarChart",
    themeRiver: "ThemeRiverChart",
    sunburst: "SunburstChart",
    custom: "CustomChart"
  };
  var componetsMissingLogPrinted = {};
  function checkMissingComponents(option) {
    each(option, function(componentOption, mainType) {
      if (!Component_default.hasClass(mainType)) {
        var componentImportName = BUITIN_COMPONENTS_MAP[mainType];
        if (componentImportName && !componetsMissingLogPrinted[componentImportName]) {
          error("Component " + mainType + " is used but not imported.\nimport { " + componentImportName + " } from 'echarts/components';\necharts.use([" + componentImportName + "]);");
          componetsMissingLogPrinted[componentImportName] = true;
        }
      }
    });
  }
  var GlobalModel = function(_super) {
    __extends(GlobalModel2, _super);
    function GlobalModel2() {
      return _super !== null && _super.apply(this, arguments) || this;
    }
    GlobalModel2.prototype.init = function(option, parentModel, ecModel, theme2, locale, optionManager) {
      theme2 = theme2 || {};
      this.option = null;
      this._theme = new Model_default(theme2);
      this._locale = new Model_default(locale);
      this._optionManager = optionManager;
    };
    GlobalModel2.prototype.setOption = function(option, opts, optionPreprocessorFuncs2) {
      if (true) {
        assert(option != null, "option is null/undefined");
        assert(option[OPTION_INNER_KEY] !== OPTION_INNER_VALUE, "please use chart.getOption()");
      }
      var innerOpt = normalizeSetOptionInput(opts);
      this._optionManager.setOption(option, optionPreprocessorFuncs2, innerOpt);
      this._resetOption(null, innerOpt);
    };
    GlobalModel2.prototype.resetOption = function(type, opt) {
      return this._resetOption(type, normalizeSetOptionInput(opt));
    };
    GlobalModel2.prototype._resetOption = function(type, opt) {
      var optionChanged = false;
      var optionManager = this._optionManager;
      if (!type || type === "recreate") {
        var baseOption = optionManager.mountOption(type === "recreate");
        if (true) {
          checkMissingComponents(baseOption);
        }
        if (!this.option || type === "recreate") {
          initBase(this, baseOption);
        } else {
          this.restoreData();
          this._mergeOption(baseOption, opt);
        }
        optionChanged = true;
      }
      if (type === "timeline" || type === "media") {
        this.restoreData();
      }
      if (!type || type === "recreate" || type === "timeline") {
        var timelineOption = optionManager.getTimelineOption(this);
        if (timelineOption) {
          optionChanged = true;
          this._mergeOption(timelineOption, opt);
        }
      }
      if (!type || type === "recreate" || type === "media") {
        var mediaOptions = optionManager.getMediaOption(this);
        if (mediaOptions.length) {
          each(mediaOptions, function(mediaOption) {
            optionChanged = true;
            this._mergeOption(mediaOption, opt);
          }, this);
        }
      }
      return optionChanged;
    };
    GlobalModel2.prototype.mergeOption = function(option) {
      this._mergeOption(option, null);
    };
    GlobalModel2.prototype._mergeOption = function(newOption, opt) {
      var option = this.option;
      var componentsMap = this._componentsMap;
      var componentsCount = this._componentsCount;
      var newCmptTypes = [];
      var newCmptTypeMap = createHashMap();
      var replaceMergeMainTypeMap = opt && opt.replaceMergeMainTypeMap;
      resetSourceDefaulter(this);
      each(newOption, function(componentOption, mainType) {
        if (componentOption == null) {
          return;
        }
        if (!Component_default.hasClass(mainType)) {
          option[mainType] = option[mainType] == null ? clone(componentOption) : merge(option[mainType], componentOption, true);
        } else if (mainType) {
          newCmptTypes.push(mainType);
          newCmptTypeMap.set(mainType, true);
        }
      });
      if (replaceMergeMainTypeMap) {
        replaceMergeMainTypeMap.each(function(val, mainTypeInReplaceMerge) {
          if (Component_default.hasClass(mainTypeInReplaceMerge) && !newCmptTypeMap.get(mainTypeInReplaceMerge)) {
            newCmptTypes.push(mainTypeInReplaceMerge);
            newCmptTypeMap.set(mainTypeInReplaceMerge, true);
          }
        });
      }
      Component_default.topologicalTravel(newCmptTypes, Component_default.getAllClassMainTypes(), visitComponent, this);
      function visitComponent(mainType) {
        var newCmptOptionList = concatInternalOptions(this, mainType, normalizeToArray(newOption[mainType]));
        var oldCmptList = componentsMap.get(mainType);
        var mergeMode = !oldCmptList ? "replaceAll" : replaceMergeMainTypeMap && replaceMergeMainTypeMap.get(mainType) ? "replaceMerge" : "normalMerge";
        var mappingResult = mappingToExists(oldCmptList, newCmptOptionList, mergeMode);
        setComponentTypeToKeyInfo(mappingResult, mainType, Component_default);
        option[mainType] = null;
        componentsMap.set(mainType, null);
        componentsCount.set(mainType, 0);
        var optionsByMainType = [];
        var cmptsByMainType = [];
        var cmptsCountByMainType = 0;
        var tooltipExists;
        var tooltipWarningLogged;
        each(mappingResult, function(resultItem, index) {
          var componentModel = resultItem.existing;
          var newCmptOption = resultItem.newOption;
          if (!newCmptOption) {
            if (componentModel) {
              componentModel.mergeOption({}, this);
              componentModel.optionUpdated({}, false);
            }
          } else {
            var isSeriesType = mainType === "series";
            var ComponentModelClass = Component_default.getClass(mainType, resultItem.keyInfo.subType, !isSeriesType);
            if (!ComponentModelClass) {
              if (true) {
                var subType = resultItem.keyInfo.subType;
                var seriesImportName = BUILTIN_CHARTS_MAP[subType];
                if (!componetsMissingLogPrinted[subType]) {
                  componetsMissingLogPrinted[subType] = true;
                  if (seriesImportName) {
                    error("Series " + subType + " is used but not imported.\nimport { " + seriesImportName + " } from 'echarts/charts';\necharts.use([" + seriesImportName + "]);");
                  } else {
                    error("Unkown series " + subType);
                  }
                }
              }
              return;
            }
            if (mainType === "tooltip") {
              if (tooltipExists) {
                if (true) {
                  if (!tooltipWarningLogged) {
                    warn("Currently only one tooltip component is allowed.");
                    tooltipWarningLogged = true;
                  }
                }
                return;
              }
              tooltipExists = true;
            }
            if (componentModel && componentModel.constructor === ComponentModelClass) {
              componentModel.name = resultItem.keyInfo.name;
              componentModel.mergeOption(newCmptOption, this);
              componentModel.optionUpdated(newCmptOption, false);
            } else {
              var extraOpt = extend({
                componentIndex: index
              }, resultItem.keyInfo);
              componentModel = new ComponentModelClass(newCmptOption, this, this, extraOpt);
              extend(componentModel, extraOpt);
              if (resultItem.brandNew) {
                componentModel.__requireNewView = true;
              }
              componentModel.init(newCmptOption, this, this);
              componentModel.optionUpdated(null, true);
            }
          }
          if (componentModel) {
            optionsByMainType.push(componentModel.option);
            cmptsByMainType.push(componentModel);
            cmptsCountByMainType++;
          } else {
            optionsByMainType.push(void 0);
            cmptsByMainType.push(void 0);
          }
        }, this);
        option[mainType] = optionsByMainType;
        componentsMap.set(mainType, cmptsByMainType);
        componentsCount.set(mainType, cmptsCountByMainType);
        if (mainType === "series") {
          reCreateSeriesIndices(this);
        }
      }
      if (!this._seriesIndices) {
        reCreateSeriesIndices(this);
      }
    };
    GlobalModel2.prototype.getOption = function() {
      var option = clone(this.option);
      each(option, function(optInMainType, mainType) {
        if (Component_default.hasClass(mainType)) {
          var opts = normalizeToArray(optInMainType);
          var realLen = opts.length;
          var metNonInner = false;
          for (var i = realLen - 1; i >= 0; i--) {
            if (opts[i] && !isComponentIdInternal(opts[i])) {
              metNonInner = true;
            } else {
              opts[i] = null;
              !metNonInner && realLen--;
            }
          }
          opts.length = realLen;
          option[mainType] = opts;
        }
      });
      delete option[OPTION_INNER_KEY];
      return option;
    };
    GlobalModel2.prototype.getTheme = function() {
      return this._theme;
    };
    GlobalModel2.prototype.getLocaleModel = function() {
      return this._locale;
    };
    GlobalModel2.prototype.setUpdatePayload = function(payload) {
      this._payload = payload;
    };
    GlobalModel2.prototype.getUpdatePayload = function() {
      return this._payload;
    };
    GlobalModel2.prototype.getComponent = function(mainType, idx) {
      var list = this._componentsMap.get(mainType);
      if (list) {
        var cmpt = list[idx || 0];
        if (cmpt) {
          return cmpt;
        } else if (idx == null) {
          for (var i = 0; i < list.length; i++) {
            if (list[i]) {
              return list[i];
            }
          }
        }
      }
    };
    GlobalModel2.prototype.queryComponents = function(condition) {
      var mainType = condition.mainType;
      if (!mainType) {
        return [];
      }
      var index = condition.index;
      var id = condition.id;
      var name = condition.name;
      var cmpts = this._componentsMap.get(mainType);
      if (!cmpts || !cmpts.length) {
        return [];
      }
      var result;
      if (index != null) {
        result = [];
        each(normalizeToArray(index), function(idx) {
          cmpts[idx] && result.push(cmpts[idx]);
        });
      } else if (id != null) {
        result = queryByIdOrName("id", id, cmpts);
      } else if (name != null) {
        result = queryByIdOrName("name", name, cmpts);
      } else {
        result = filter(cmpts, function(cmpt) {
          return !!cmpt;
        });
      }
      return filterBySubType(result, condition);
    };
    GlobalModel2.prototype.findComponents = function(condition) {
      var query = condition.query;
      var mainType = condition.mainType;
      var queryCond = getQueryCond(query);
      var result = queryCond ? this.queryComponents(queryCond) : filter(this._componentsMap.get(mainType), function(cmpt) {
        return !!cmpt;
      });
      return doFilter(filterBySubType(result, condition));
      function getQueryCond(q) {
        var indexAttr = mainType + "Index";
        var idAttr = mainType + "Id";
        var nameAttr = mainType + "Name";
        return q && (q[indexAttr] != null || q[idAttr] != null || q[nameAttr] != null) ? {
          mainType,
          index: q[indexAttr],
          id: q[idAttr],
          name: q[nameAttr]
        } : null;
      }
      function doFilter(res) {
        return condition.filter ? filter(res, condition.filter) : res;
      }
    };
    GlobalModel2.prototype.eachComponent = function(mainType, cb, context) {
      var componentsMap = this._componentsMap;
      if (isFunction(mainType)) {
        var ctxForAll_1 = cb;
        var cbForAll_1 = mainType;
        componentsMap.each(function(cmpts2, componentType) {
          for (var i2 = 0; cmpts2 && i2 < cmpts2.length; i2++) {
            var cmpt2 = cmpts2[i2];
            cmpt2 && cbForAll_1.call(ctxForAll_1, componentType, cmpt2, cmpt2.componentIndex);
          }
        });
      } else {
        var cmpts = isString(mainType) ? componentsMap.get(mainType) : isObject(mainType) ? this.findComponents(mainType) : null;
        for (var i = 0; cmpts && i < cmpts.length; i++) {
          var cmpt = cmpts[i];
          cmpt && cb.call(context, cmpt, cmpt.componentIndex);
        }
      }
    };
    GlobalModel2.prototype.getSeriesByName = function(name) {
      var nameStr = convertOptionIdName(name, null);
      return filter(this._componentsMap.get("series"), function(oneSeries) {
        return !!oneSeries && nameStr != null && oneSeries.name === nameStr;
      });
    };
    GlobalModel2.prototype.getSeriesByIndex = function(seriesIndex) {
      return this._componentsMap.get("series")[seriesIndex];
    };
    GlobalModel2.prototype.getSeriesByType = function(subType) {
      return filter(this._componentsMap.get("series"), function(oneSeries) {
        return !!oneSeries && oneSeries.subType === subType;
      });
    };
    GlobalModel2.prototype.getSeries = function() {
      return filter(this._componentsMap.get("series"), function(oneSeries) {
        return !!oneSeries;
      });
    };
    GlobalModel2.prototype.getSeriesCount = function() {
      return this._componentsCount.get("series");
    };
    GlobalModel2.prototype.eachSeries = function(cb, context) {
      assertSeriesInitialized(this);
      each(this._seriesIndices, function(rawSeriesIndex) {
        var series = this._componentsMap.get("series")[rawSeriesIndex];
        cb.call(context, series, rawSeriesIndex);
      }, this);
    };
    GlobalModel2.prototype.eachRawSeries = function(cb, context) {
      each(this._componentsMap.get("series"), function(series) {
        series && cb.call(context, series, series.componentIndex);
      });
    };
    GlobalModel2.prototype.eachSeriesByType = function(subType, cb, context) {
      assertSeriesInitialized(this);
      each(this._seriesIndices, function(rawSeriesIndex) {
        var series = this._componentsMap.get("series")[rawSeriesIndex];
        if (series.subType === subType) {
          cb.call(context, series, rawSeriesIndex);
        }
      }, this);
    };
    GlobalModel2.prototype.eachRawSeriesByType = function(subType, cb, context) {
      return each(this.getSeriesByType(subType), cb, context);
    };
    GlobalModel2.prototype.isSeriesFiltered = function(seriesModel) {
      assertSeriesInitialized(this);
      return this._seriesIndicesMap.get(seriesModel.componentIndex) == null;
    };
    GlobalModel2.prototype.getCurrentSeriesIndices = function() {
      return (this._seriesIndices || []).slice();
    };
    GlobalModel2.prototype.filterSeries = function(cb, context) {
      assertSeriesInitialized(this);
      var newSeriesIndices = [];
      each(this._seriesIndices, function(seriesRawIdx) {
        var series = this._componentsMap.get("series")[seriesRawIdx];
        cb.call(context, series, seriesRawIdx) && newSeriesIndices.push(seriesRawIdx);
      }, this);
      this._seriesIndices = newSeriesIndices;
      this._seriesIndicesMap = createHashMap(newSeriesIndices);
    };
    GlobalModel2.prototype.restoreData = function(payload) {
      reCreateSeriesIndices(this);
      var componentsMap = this._componentsMap;
      var componentTypes = [];
      componentsMap.each(function(components, componentType) {
        if (Component_default.hasClass(componentType)) {
          componentTypes.push(componentType);
        }
      });
      Component_default.topologicalTravel(componentTypes, Component_default.getAllClassMainTypes(), function(componentType) {
        each(componentsMap.get(componentType), function(component) {
          if (component && (componentType !== "series" || !isNotTargetSeries(component, payload))) {
            component.restoreData();
          }
        });
      });
    };
    GlobalModel2.internalField = function() {
      reCreateSeriesIndices = function(ecModel) {
        var seriesIndices = ecModel._seriesIndices = [];
        each(ecModel._componentsMap.get("series"), function(series) {
          series && seriesIndices.push(series.componentIndex);
        });
        ecModel._seriesIndicesMap = createHashMap(seriesIndices);
      };
      assertSeriesInitialized = function(ecModel) {
        if (true) {
          if (!ecModel._seriesIndices) {
            throw new Error("Option should contains series.");
          }
        }
      };
      initBase = function(ecModel, baseOption) {
        ecModel.option = {};
        ecModel.option[OPTION_INNER_KEY] = OPTION_INNER_VALUE;
        ecModel._componentsMap = createHashMap({
          series: []
        });
        ecModel._componentsCount = createHashMap();
        var airaOption = baseOption.aria;
        if (isObject(airaOption) && airaOption.enabled == null) {
          airaOption.enabled = true;
        }
        mergeTheme(baseOption, ecModel._theme.option);
        merge(baseOption, globalDefault_default, false);
        ecModel._mergeOption(baseOption, null);
      };
    }();
    return GlobalModel2;
  }(Model_default);
  function isNotTargetSeries(seriesModel, payload) {
    if (payload) {
      var index = payload.seriesIndex;
      var id = payload.seriesId;
      var name_1 = payload.seriesName;
      return index != null && seriesModel.componentIndex !== index || id != null && seriesModel.id !== id || name_1 != null && seriesModel.name !== name_1;
    }
  }
  function mergeTheme(option, theme2) {
    var notMergeColorLayer = option.color && !option.colorLayer;
    each(theme2, function(themeItem, name) {
      if (name === "colorLayer" && notMergeColorLayer) {
        return;
      }
      if (!Component_default.hasClass(name)) {
        if (typeof themeItem === "object") {
          option[name] = !option[name] ? clone(themeItem) : merge(option[name], themeItem, false);
        } else {
          if (option[name] == null) {
            option[name] = themeItem;
          }
        }
      }
    });
  }
  function queryByIdOrName(attr, idOrName, cmpts) {
    if (isArray(idOrName)) {
      var keyMap_1 = createHashMap();
      each(idOrName, function(idOrNameItem) {
        if (idOrNameItem != null) {
          var idName = convertOptionIdName(idOrNameItem, null);
          idName != null && keyMap_1.set(idOrNameItem, true);
        }
      });
      return filter(cmpts, function(cmpt) {
        return cmpt && keyMap_1.get(cmpt[attr]);
      });
    } else {
      var idName_1 = convertOptionIdName(idOrName, null);
      return filter(cmpts, function(cmpt) {
        return cmpt && idName_1 != null && cmpt[attr] === idName_1;
      });
    }
  }
  function filterBySubType(components, condition) {
    return condition.hasOwnProperty("subType") ? filter(components, function(cmpt) {
      return cmpt && cmpt.subType === condition.subType;
    }) : components;
  }
  function normalizeSetOptionInput(opts) {
    var replaceMergeMainTypeMap = createHashMap();
    opts && each(normalizeToArray(opts.replaceMerge), function(mainType) {
      if (true) {
        assert(Component_default.hasClass(mainType), '"' + mainType + '" is not valid component main type in "replaceMerge"');
      }
      replaceMergeMainTypeMap.set(mainType, true);
    });
    return {
      replaceMergeMainTypeMap
    };
  }
  mixin(GlobalModel, PaletteMixin);
  var Global_default = GlobalModel;

  // node_modules/echarts/lib/core/ExtensionAPI.js
  var availableMethods = [
    "getDom",
    "getZr",
    "getWidth",
    "getHeight",
    "getDevicePixelRatio",
    "dispatchAction",
    "isSSR",
    "isDisposed",
    "on",
    "off",
    "getDataURL",
    "getConnectedDataURL",
    "getOption",
    "getId",
    "updateLabelLayout"
  ];
  var ExtensionAPI = function() {
    function ExtensionAPI2(ecInstance) {
      each(availableMethods, function(methodName) {
        this[methodName] = bind(ecInstance[methodName], ecInstance);
      }, this);
    }
    return ExtensionAPI2;
  }();
  var ExtensionAPI_default = ExtensionAPI;

  // node_modules/echarts/lib/core/CoordinateSystem.js
  var coordinateSystemCreators = {};
  var CoordinateSystemManager = function() {
    function CoordinateSystemManager2() {
      this._coordinateSystems = [];
    }
    CoordinateSystemManager2.prototype.create = function(ecModel, api) {
      var coordinateSystems = [];
      each(coordinateSystemCreators, function(creater, type) {
        var list = creater.create(ecModel, api);
        coordinateSystems = coordinateSystems.concat(list || []);
      });
      this._coordinateSystems = coordinateSystems;
    };
    CoordinateSystemManager2.prototype.update = function(ecModel, api) {
      each(this._coordinateSystems, function(coordSys) {
        coordSys.update && coordSys.update(ecModel, api);
      });
    };
    CoordinateSystemManager2.prototype.getCoordinateSystems = function() {
      return this._coordinateSystems.slice();
    };
    CoordinateSystemManager2.register = function(type, creator) {
      coordinateSystemCreators[type] = creator;
    };
    CoordinateSystemManager2.get = function(type) {
      return coordinateSystemCreators[type];
    };
    return CoordinateSystemManager2;
  }();
  var CoordinateSystem_default = CoordinateSystemManager;

  // node_modules/echarts/lib/model/OptionManager.js
  var QUERY_REG = /^(min|max)?(.+)$/;
  var OptionManager = function() {
    function OptionManager2(api) {
      this._timelineOptions = [];
      this._mediaList = [];
      this._currentMediaIndices = [];
      this._api = api;
    }
    OptionManager2.prototype.setOption = function(rawOption, optionPreprocessorFuncs2, opt) {
      if (rawOption) {
        each(normalizeToArray(rawOption.series), function(series) {
          series && series.data && isTypedArray(series.data) && setAsPrimitive(series.data);
        });
        each(normalizeToArray(rawOption.dataset), function(dataset) {
          dataset && dataset.source && isTypedArray(dataset.source) && setAsPrimitive(dataset.source);
        });
      }
      rawOption = clone(rawOption);
      var optionBackup = this._optionBackup;
      var newParsedOption = parseRawOption(rawOption, optionPreprocessorFuncs2, !optionBackup);
      this._newBaseOption = newParsedOption.baseOption;
      if (optionBackup) {
        if (newParsedOption.timelineOptions.length) {
          optionBackup.timelineOptions = newParsedOption.timelineOptions;
        }
        if (newParsedOption.mediaList.length) {
          optionBackup.mediaList = newParsedOption.mediaList;
        }
        if (newParsedOption.mediaDefault) {
          optionBackup.mediaDefault = newParsedOption.mediaDefault;
        }
      } else {
        this._optionBackup = newParsedOption;
      }
    };
    OptionManager2.prototype.mountOption = function(isRecreate) {
      var optionBackup = this._optionBackup;
      this._timelineOptions = optionBackup.timelineOptions;
      this._mediaList = optionBackup.mediaList;
      this._mediaDefault = optionBackup.mediaDefault;
      this._currentMediaIndices = [];
      return clone(isRecreate ? optionBackup.baseOption : this._newBaseOption);
    };
    OptionManager2.prototype.getTimelineOption = function(ecModel) {
      var option;
      var timelineOptions = this._timelineOptions;
      if (timelineOptions.length) {
        var timelineModel = ecModel.getComponent("timeline");
        if (timelineModel) {
          option = clone(timelineOptions[timelineModel.getCurrentIndex()]);
        }
      }
      return option;
    };
    OptionManager2.prototype.getMediaOption = function(ecModel) {
      var ecWidth = this._api.getWidth();
      var ecHeight = this._api.getHeight();
      var mediaList = this._mediaList;
      var mediaDefault = this._mediaDefault;
      var indices = [];
      var result = [];
      if (!mediaList.length && !mediaDefault) {
        return result;
      }
      for (var i = 0, len2 = mediaList.length; i < len2; i++) {
        if (applyMediaQuery(mediaList[i].query, ecWidth, ecHeight)) {
          indices.push(i);
        }
      }
      if (!indices.length && mediaDefault) {
        indices = [-1];
      }
      if (indices.length && !indicesEquals(indices, this._currentMediaIndices)) {
        result = map(indices, function(index) {
          return clone(index === -1 ? mediaDefault.option : mediaList[index].option);
        });
      }
      this._currentMediaIndices = indices;
      return result;
    };
    return OptionManager2;
  }();
  function parseRawOption(rawOption, optionPreprocessorFuncs2, isNew) {
    var mediaList = [];
    var mediaDefault;
    var baseOption;
    var declaredBaseOption = rawOption.baseOption;
    var timelineOnRoot = rawOption.timeline;
    var timelineOptionsOnRoot = rawOption.options;
    var mediaOnRoot = rawOption.media;
    var hasMedia = !!rawOption.media;
    var hasTimeline = !!(timelineOptionsOnRoot || timelineOnRoot || declaredBaseOption && declaredBaseOption.timeline);
    if (declaredBaseOption) {
      baseOption = declaredBaseOption;
      if (!baseOption.timeline) {
        baseOption.timeline = timelineOnRoot;
      }
    } else {
      if (hasTimeline || hasMedia) {
        rawOption.options = rawOption.media = null;
      }
      baseOption = rawOption;
    }
    if (hasMedia) {
      if (isArray(mediaOnRoot)) {
        each(mediaOnRoot, function(singleMedia) {
          if (true) {
            if (singleMedia && !singleMedia.option && isObject(singleMedia.query) && isObject(singleMedia.query.option)) {
              error("Illegal media option. Must be like { media: [ { query: {}, option: {} } ] }");
            }
          }
          if (singleMedia && singleMedia.option) {
            if (singleMedia.query) {
              mediaList.push(singleMedia);
            } else if (!mediaDefault) {
              mediaDefault = singleMedia;
            }
          }
        });
      } else {
        if (true) {
          error("Illegal media option. Must be an array. Like { media: [ {...}, {...} ] }");
        }
      }
    }
    doPreprocess(baseOption);
    each(timelineOptionsOnRoot, function(option) {
      return doPreprocess(option);
    });
    each(mediaList, function(media) {
      return doPreprocess(media.option);
    });
    function doPreprocess(option) {
      each(optionPreprocessorFuncs2, function(preProcess) {
        preProcess(option, isNew);
      });
    }
    return {
      baseOption,
      timelineOptions: timelineOptionsOnRoot || [],
      mediaDefault,
      mediaList
    };
  }
  function applyMediaQuery(query, ecWidth, ecHeight) {
    var realMap = {
      width: ecWidth,
      height: ecHeight,
      aspectratio: ecWidth / ecHeight
    };
    var applicatable = true;
    each(query, function(value, attr) {
      var matched = attr.match(QUERY_REG);
      if (!matched || !matched[1] || !matched[2]) {
        return;
      }
      var operator = matched[1];
      var realAttr = matched[2].toLowerCase();
      if (!compare(realMap[realAttr], value, operator)) {
        applicatable = false;
      }
    });
    return applicatable;
  }
  function compare(real, expect, operator) {
    if (operator === "min") {
      return real >= expect;
    } else if (operator === "max") {
      return real <= expect;
    } else {
      return real === expect;
    }
  }
  function indicesEquals(indices1, indices2) {
    return indices1.join(",") === indices2.join(",");
  }
  var OptionManager_default = OptionManager;

  // node_modules/echarts/lib/preprocessor/helper/compatStyle.js
  var each3 = each;
  var isObject2 = isObject;
  var POSSIBLE_STYLES = ["areaStyle", "lineStyle", "nodeStyle", "linkStyle", "chordStyle", "label", "labelLine"];
  function compatEC2ItemStyle(opt) {
    var itemStyleOpt = opt && opt.itemStyle;
    if (!itemStyleOpt) {
      return;
    }
    for (var i = 0, len2 = POSSIBLE_STYLES.length; i < len2; i++) {
      var styleName = POSSIBLE_STYLES[i];
      var normalItemStyleOpt = itemStyleOpt.normal;
      var emphasisItemStyleOpt = itemStyleOpt.emphasis;
      if (normalItemStyleOpt && normalItemStyleOpt[styleName]) {
        if (true) {
          deprecateReplaceLog("itemStyle.normal." + styleName, styleName);
        }
        opt[styleName] = opt[styleName] || {};
        if (!opt[styleName].normal) {
          opt[styleName].normal = normalItemStyleOpt[styleName];
        } else {
          merge(opt[styleName].normal, normalItemStyleOpt[styleName]);
        }
        normalItemStyleOpt[styleName] = null;
      }
      if (emphasisItemStyleOpt && emphasisItemStyleOpt[styleName]) {
        if (true) {
          deprecateReplaceLog("itemStyle.emphasis." + styleName, "emphasis." + styleName);
        }
        opt[styleName] = opt[styleName] || {};
        if (!opt[styleName].emphasis) {
          opt[styleName].emphasis = emphasisItemStyleOpt[styleName];
        } else {
          merge(opt[styleName].emphasis, emphasisItemStyleOpt[styleName]);
        }
        emphasisItemStyleOpt[styleName] = null;
      }
    }
  }
  function convertNormalEmphasis(opt, optType, useExtend) {
    if (opt && opt[optType] && (opt[optType].normal || opt[optType].emphasis)) {
      var normalOpt = opt[optType].normal;
      var emphasisOpt = opt[optType].emphasis;
      if (normalOpt) {
        if (true) {
          deprecateLog("'normal' hierarchy in " + optType + " has been removed since 4.0. All style properties are configured in " + optType + " directly now.");
        }
        if (useExtend) {
          opt[optType].normal = opt[optType].emphasis = null;
          defaults(opt[optType], normalOpt);
        } else {
          opt[optType] = normalOpt;
        }
      }
      if (emphasisOpt) {
        if (true) {
          deprecateLog(optType + ".emphasis has been changed to emphasis." + optType + " since 4.0");
        }
        opt.emphasis = opt.emphasis || {};
        opt.emphasis[optType] = emphasisOpt;
        if (emphasisOpt.focus) {
          opt.emphasis.focus = emphasisOpt.focus;
        }
        if (emphasisOpt.blurScope) {
          opt.emphasis.blurScope = emphasisOpt.blurScope;
        }
      }
    }
  }
  function removeEC3NormalStatus(opt) {
    convertNormalEmphasis(opt, "itemStyle");
    convertNormalEmphasis(opt, "lineStyle");
    convertNormalEmphasis(opt, "areaStyle");
    convertNormalEmphasis(opt, "label");
    convertNormalEmphasis(opt, "labelLine");
    convertNormalEmphasis(opt, "upperLabel");
    convertNormalEmphasis(opt, "edgeLabel");
  }
  function compatTextStyle(opt, propName) {
    var labelOptSingle = isObject2(opt) && opt[propName];
    var textStyle = isObject2(labelOptSingle) && labelOptSingle.textStyle;
    if (textStyle) {
      if (true) {
        deprecateLog("textStyle hierarchy in " + propName + " has been removed since 4.0. All textStyle properties are configured in " + propName + " directly now.");
      }
      for (var i = 0, len2 = TEXT_STYLE_OPTIONS.length; i < len2; i++) {
        var textPropName = TEXT_STYLE_OPTIONS[i];
        if (textStyle.hasOwnProperty(textPropName)) {
          labelOptSingle[textPropName] = textStyle[textPropName];
        }
      }
    }
  }
  function compatEC3CommonStyles(opt) {
    if (opt) {
      removeEC3NormalStatus(opt);
      compatTextStyle(opt, "label");
      opt.emphasis && compatTextStyle(opt.emphasis, "label");
    }
  }
  function processSeries(seriesOpt) {
    if (!isObject2(seriesOpt)) {
      return;
    }
    compatEC2ItemStyle(seriesOpt);
    removeEC3NormalStatus(seriesOpt);
    compatTextStyle(seriesOpt, "label");
    compatTextStyle(seriesOpt, "upperLabel");
    compatTextStyle(seriesOpt, "edgeLabel");
    if (seriesOpt.emphasis) {
      compatTextStyle(seriesOpt.emphasis, "label");
      compatTextStyle(seriesOpt.emphasis, "upperLabel");
      compatTextStyle(seriesOpt.emphasis, "edgeLabel");
    }
    var markPoint = seriesOpt.markPoint;
    if (markPoint) {
      compatEC2ItemStyle(markPoint);
      compatEC3CommonStyles(markPoint);
    }
    var markLine = seriesOpt.markLine;
    if (markLine) {
      compatEC2ItemStyle(markLine);
      compatEC3CommonStyles(markLine);
    }
    var markArea = seriesOpt.markArea;
    if (markArea) {
      compatEC3CommonStyles(markArea);
    }
    var data = seriesOpt.data;
    if (seriesOpt.type === "graph") {
      data = data || seriesOpt.nodes;
      var edgeData = seriesOpt.links || seriesOpt.edges;
      if (edgeData && !isTypedArray(edgeData)) {
        for (var i = 0; i < edgeData.length; i++) {
          compatEC3CommonStyles(edgeData[i]);
        }
      }
      each(seriesOpt.categories, function(opt) {
        removeEC3NormalStatus(opt);
      });
    }
    if (data && !isTypedArray(data)) {
      for (var i = 0; i < data.length; i++) {
        compatEC3CommonStyles(data[i]);
      }
    }
    markPoint = seriesOpt.markPoint;
    if (markPoint && markPoint.data) {
      var mpData = markPoint.data;
      for (var i = 0; i < mpData.length; i++) {
        compatEC3CommonStyles(mpData[i]);
      }
    }
    markLine = seriesOpt.markLine;
    if (markLine && markLine.data) {
      var mlData = markLine.data;
      for (var i = 0; i < mlData.length; i++) {
        if (isArray(mlData[i])) {
          compatEC3CommonStyles(mlData[i][0]);
          compatEC3CommonStyles(mlData[i][1]);
        } else {
          compatEC3CommonStyles(mlData[i]);
        }
      }
    }
    if (seriesOpt.type === "gauge") {
      compatTextStyle(seriesOpt, "axisLabel");
      compatTextStyle(seriesOpt, "title");
      compatTextStyle(seriesOpt, "detail");
    } else if (seriesOpt.type === "treemap") {
      convertNormalEmphasis(seriesOpt.breadcrumb, "itemStyle");
      each(seriesOpt.levels, function(opt) {
        removeEC3NormalStatus(opt);
      });
    } else if (seriesOpt.type === "tree") {
      removeEC3NormalStatus(seriesOpt.leaves);
    }
  }
  function toArr(o) {
    return isArray(o) ? o : o ? [o] : [];
  }
  function toObj(o) {
    return (isArray(o) ? o[0] : o) || {};
  }
  function globalCompatStyle(option, isTheme) {
    each3(toArr(option.series), function(seriesOpt) {
      isObject2(seriesOpt) && processSeries(seriesOpt);
    });
    var axes = ["xAxis", "yAxis", "radiusAxis", "angleAxis", "singleAxis", "parallelAxis", "radar"];
    isTheme && axes.push("valueAxis", "categoryAxis", "logAxis", "timeAxis");
    each3(axes, function(axisName) {
      each3(toArr(option[axisName]), function(axisOpt) {
        if (axisOpt) {
          compatTextStyle(axisOpt, "axisLabel");
          compatTextStyle(axisOpt.axisPointer, "label");
        }
      });
    });
    each3(toArr(option.parallel), function(parallelOpt) {
      var parallelAxisDefault = parallelOpt && parallelOpt.parallelAxisDefault;
      compatTextStyle(parallelAxisDefault, "axisLabel");
      compatTextStyle(parallelAxisDefault && parallelAxisDefault.axisPointer, "label");
    });
    each3(toArr(option.calendar), function(calendarOpt) {
      convertNormalEmphasis(calendarOpt, "itemStyle");
      compatTextStyle(calendarOpt, "dayLabel");
      compatTextStyle(calendarOpt, "monthLabel");
      compatTextStyle(calendarOpt, "yearLabel");
    });
    each3(toArr(option.radar), function(radarOpt) {
      compatTextStyle(radarOpt, "name");
      if (radarOpt.name && radarOpt.axisName == null) {
        radarOpt.axisName = radarOpt.name;
        delete radarOpt.name;
        if (true) {
          deprecateLog("name property in radar component has been changed to axisName");
        }
      }
      if (radarOpt.nameGap != null && radarOpt.axisNameGap == null) {
        radarOpt.axisNameGap = radarOpt.nameGap;
        delete radarOpt.nameGap;
        if (true) {
          deprecateLog("nameGap property in radar component has been changed to axisNameGap");
        }
      }
      if (true) {
        each3(radarOpt.indicator, function(indicatorOpt) {
          if (indicatorOpt.text) {
            deprecateReplaceLog("text", "name", "radar.indicator");
          }
        });
      }
    });
    each3(toArr(option.geo), function(geoOpt) {
      if (isObject2(geoOpt)) {
        compatEC3CommonStyles(geoOpt);
        each3(toArr(geoOpt.regions), function(regionObj) {
          compatEC3CommonStyles(regionObj);
        });
      }
    });
    each3(toArr(option.timeline), function(timelineOpt) {
      compatEC3CommonStyles(timelineOpt);
      convertNormalEmphasis(timelineOpt, "label");
      convertNormalEmphasis(timelineOpt, "itemStyle");
      convertNormalEmphasis(timelineOpt, "controlStyle", true);
      var data = timelineOpt.data;
      isArray(data) && each(data, function(item) {
        if (isObject(item)) {
          convertNormalEmphasis(item, "label");
          convertNormalEmphasis(item, "itemStyle");
        }
      });
    });
    each3(toArr(option.toolbox), function(toolboxOpt) {
      convertNormalEmphasis(toolboxOpt, "iconStyle");
      each3(toolboxOpt.feature, function(featureOpt) {
        convertNormalEmphasis(featureOpt, "iconStyle");
      });
    });
    compatTextStyle(toObj(option.axisPointer), "label");
    compatTextStyle(toObj(option.tooltip).axisPointer, "label");
  }

  // node_modules/echarts/lib/preprocessor/backwardCompat.js
  function get(opt, path) {
    var pathArr = path.split(",");
    var obj = opt;
    for (var i = 0; i < pathArr.length; i++) {
      obj = obj && obj[pathArr[i]];
      if (obj == null) {
        break;
      }
    }
    return obj;
  }
  function set2(opt, path, val, overwrite) {
    var pathArr = path.split(",");
    var obj = opt;
    var key;
    var i = 0;
    for (; i < pathArr.length - 1; i++) {
      key = pathArr[i];
      if (obj[key] == null) {
        obj[key] = {};
      }
      obj = obj[key];
    }
    if (overwrite || obj[pathArr[i]] == null) {
      obj[pathArr[i]] = val;
    }
  }
  function compatLayoutProperties(option) {
    option && each(LAYOUT_PROPERTIES, function(prop) {
      if (prop[0] in option && !(prop[1] in option)) {
        option[prop[1]] = option[prop[0]];
      }
    });
  }
  var LAYOUT_PROPERTIES = [["x", "left"], ["y", "top"], ["x2", "right"], ["y2", "bottom"]];
  var COMPATITABLE_COMPONENTS = ["grid", "geo", "parallel", "legend", "toolbox", "title", "visualMap", "dataZoom", "timeline"];
  var BAR_ITEM_STYLE_MAP = [["borderRadius", "barBorderRadius"], ["borderColor", "barBorderColor"], ["borderWidth", "barBorderWidth"]];
  function compatBarItemStyle(option) {
    var itemStyle = option && option.itemStyle;
    if (itemStyle) {
      for (var i = 0; i < BAR_ITEM_STYLE_MAP.length; i++) {
        var oldName = BAR_ITEM_STYLE_MAP[i][1];
        var newName = BAR_ITEM_STYLE_MAP[i][0];
        if (itemStyle[oldName] != null) {
          itemStyle[newName] = itemStyle[oldName];
          if (true) {
            deprecateReplaceLog(oldName, newName);
          }
        }
      }
    }
  }
  function compatPieLabel(option) {
    if (!option) {
      return;
    }
    if (option.alignTo === "edge" && option.margin != null && option.edgeDistance == null) {
      if (true) {
        deprecateReplaceLog("label.margin", "label.edgeDistance", "pie");
      }
      option.edgeDistance = option.margin;
    }
  }
  function compatSunburstState(option) {
    if (!option) {
      return;
    }
    if (option.downplay && !option.blur) {
      option.blur = option.downplay;
      if (true) {
        deprecateReplaceLog("downplay", "blur", "sunburst");
      }
    }
  }
  function compatGraphFocus(option) {
    if (!option) {
      return;
    }
    if (option.focusNodeAdjacency != null) {
      option.emphasis = option.emphasis || {};
      if (option.emphasis.focus == null) {
        if (true) {
          deprecateReplaceLog("focusNodeAdjacency", "emphasis: { focus: 'adjacency'}", "graph/sankey");
        }
        option.emphasis.focus = "adjacency";
      }
    }
  }
  function traverseTree(data, cb) {
    if (data) {
      for (var i = 0; i < data.length; i++) {
        cb(data[i]);
        data[i] && traverseTree(data[i].children, cb);
      }
    }
  }
  function globalBackwardCompat(option, isTheme) {
    globalCompatStyle(option, isTheme);
    option.series = normalizeToArray(option.series);
    each(option.series, function(seriesOpt) {
      if (!isObject(seriesOpt)) {
        return;
      }
      var seriesType2 = seriesOpt.type;
      if (seriesType2 === "line") {
        if (seriesOpt.clipOverflow != null) {
          seriesOpt.clip = seriesOpt.clipOverflow;
          if (true) {
            deprecateReplaceLog("clipOverflow", "clip", "line");
          }
        }
      } else if (seriesType2 === "pie" || seriesType2 === "gauge") {
        if (seriesOpt.clockWise != null) {
          seriesOpt.clockwise = seriesOpt.clockWise;
          if (true) {
            deprecateReplaceLog("clockWise", "clockwise");
          }
        }
        compatPieLabel(seriesOpt.label);
        var data = seriesOpt.data;
        if (data && !isTypedArray(data)) {
          for (var i = 0; i < data.length; i++) {
            compatPieLabel(data[i]);
          }
        }
        if (seriesOpt.hoverOffset != null) {
          seriesOpt.emphasis = seriesOpt.emphasis || {};
          if (seriesOpt.emphasis.scaleSize = null) {
            if (true) {
              deprecateReplaceLog("hoverOffset", "emphasis.scaleSize");
            }
            seriesOpt.emphasis.scaleSize = seriesOpt.hoverOffset;
          }
        }
      } else if (seriesType2 === "gauge") {
        var pointerColor = get(seriesOpt, "pointer.color");
        pointerColor != null && set2(seriesOpt, "itemStyle.color", pointerColor);
      } else if (seriesType2 === "bar") {
        compatBarItemStyle(seriesOpt);
        compatBarItemStyle(seriesOpt.backgroundStyle);
        compatBarItemStyle(seriesOpt.emphasis);
        var data = seriesOpt.data;
        if (data && !isTypedArray(data)) {
          for (var i = 0; i < data.length; i++) {
            if (typeof data[i] === "object") {
              compatBarItemStyle(data[i]);
              compatBarItemStyle(data[i] && data[i].emphasis);
            }
          }
        }
      } else if (seriesType2 === "sunburst") {
        var highlightPolicy = seriesOpt.highlightPolicy;
        if (highlightPolicy) {
          seriesOpt.emphasis = seriesOpt.emphasis || {};
          if (!seriesOpt.emphasis.focus) {
            seriesOpt.emphasis.focus = highlightPolicy;
            if (true) {
              deprecateReplaceLog("highlightPolicy", "emphasis.focus", "sunburst");
            }
          }
        }
        compatSunburstState(seriesOpt);
        traverseTree(seriesOpt.data, compatSunburstState);
      } else if (seriesType2 === "graph" || seriesType2 === "sankey") {
        compatGraphFocus(seriesOpt);
      } else if (seriesType2 === "map") {
        if (seriesOpt.mapType && !seriesOpt.map) {
          if (true) {
            deprecateReplaceLog("mapType", "map", "map");
          }
          seriesOpt.map = seriesOpt.mapType;
        }
        if (seriesOpt.mapLocation) {
          if (true) {
            deprecateLog("`mapLocation` is not used anymore.");
          }
          defaults(seriesOpt, seriesOpt.mapLocation);
        }
      }
      if (seriesOpt.hoverAnimation != null) {
        seriesOpt.emphasis = seriesOpt.emphasis || {};
        if (seriesOpt.emphasis && seriesOpt.emphasis.scale == null) {
          if (true) {
            deprecateReplaceLog("hoverAnimation", "emphasis.scale");
          }
          seriesOpt.emphasis.scale = seriesOpt.hoverAnimation;
        }
      }
      compatLayoutProperties(seriesOpt);
    });
    if (option.dataRange) {
      option.visualMap = option.dataRange;
    }
    each(COMPATITABLE_COMPONENTS, function(componentName) {
      var options = option[componentName];
      if (options) {
        if (!isArray(options)) {
          options = [options];
        }
        each(options, function(option2) {
          compatLayoutProperties(option2);
        });
      }
    });
  }

  // node_modules/echarts/lib/processor/dataStack.js
  function dataStack(ecModel) {
    var stackInfoMap = createHashMap();
    ecModel.eachSeries(function(seriesModel) {
      var stack = seriesModel.get("stack");
      if (stack) {
        var stackInfoList = stackInfoMap.get(stack) || stackInfoMap.set(stack, []);
        var data = seriesModel.getData();
        var stackInfo = {
          stackResultDimension: data.getCalculationInfo("stackResultDimension"),
          stackedOverDimension: data.getCalculationInfo("stackedOverDimension"),
          stackedDimension: data.getCalculationInfo("stackedDimension"),
          stackedByDimension: data.getCalculationInfo("stackedByDimension"),
          isStackedByIndex: data.getCalculationInfo("isStackedByIndex"),
          data,
          seriesModel
        };
        if (!stackInfo.stackedDimension || !(stackInfo.isStackedByIndex || stackInfo.stackedByDimension)) {
          return;
        }
        stackInfoList.length && data.setCalculationInfo("stackedOnSeries", stackInfoList[stackInfoList.length - 1].seriesModel);
        stackInfoList.push(stackInfo);
      }
    });
    stackInfoMap.each(calculateStack);
  }
  function calculateStack(stackInfoList) {
    each(stackInfoList, function(targetStackInfo, idxInStack) {
      var resultVal = [];
      var resultNaN = [NaN, NaN];
      var dims = [targetStackInfo.stackResultDimension, targetStackInfo.stackedOverDimension];
      var targetData = targetStackInfo.data;
      var isStackedByIndex = targetStackInfo.isStackedByIndex;
      var stackStrategy = targetStackInfo.seriesModel.get("stackStrategy") || "samesign";
      targetData.modify(dims, function(v0, v12, dataIndex) {
        var sum2 = targetData.get(targetStackInfo.stackedDimension, dataIndex);
        if (isNaN(sum2)) {
          return resultNaN;
        }
        var byValue;
        var stackedDataRawIndex;
        if (isStackedByIndex) {
          stackedDataRawIndex = targetData.getRawIndex(dataIndex);
        } else {
          byValue = targetData.get(targetStackInfo.stackedByDimension, dataIndex);
        }
        var stackedOver = NaN;
        for (var j = idxInStack - 1; j >= 0; j--) {
          var stackInfo = stackInfoList[j];
          if (!isStackedByIndex) {
            stackedDataRawIndex = stackInfo.data.rawIndexOf(stackInfo.stackedByDimension, byValue);
          }
          if (stackedDataRawIndex >= 0) {
            var val = stackInfo.data.getByRawIndex(stackInfo.stackResultDimension, stackedDataRawIndex);
            if (stackStrategy === "all" || stackStrategy === "positive" && val > 0 || stackStrategy === "negative" && val < 0 || stackStrategy === "samesign" && sum2 >= 0 && val > 0 || stackStrategy === "samesign" && sum2 <= 0 && val < 0) {
              sum2 = addSafe(sum2, val);
              stackedOver = val;
              break;
            }
          }
        }
        resultVal[0] = sum2;
        resultVal[1] = stackedOver;
        return resultVal;
      });
    });
  }

  // node_modules/echarts/lib/data/Source.js
  var SourceImpl = function() {
    function SourceImpl2(fields) {
      this.data = fields.data || (fields.sourceFormat === SOURCE_FORMAT_KEYED_COLUMNS ? {} : []);
      this.sourceFormat = fields.sourceFormat || SOURCE_FORMAT_UNKNOWN;
      this.seriesLayoutBy = fields.seriesLayoutBy || SERIES_LAYOUT_BY_COLUMN;
      this.startIndex = fields.startIndex || 0;
      this.dimensionsDetectedCount = fields.dimensionsDetectedCount;
      this.metaRawOption = fields.metaRawOption;
      var dimensionsDefine = this.dimensionsDefine = fields.dimensionsDefine;
      if (dimensionsDefine) {
        for (var i = 0; i < dimensionsDefine.length; i++) {
          var dim = dimensionsDefine[i];
          if (dim.type == null) {
            if (guessOrdinal(this, i) === BE_ORDINAL.Must) {
              dim.type = "ordinal";
            }
          }
        }
      }
    }
    return SourceImpl2;
  }();
  function isSourceInstance(val) {
    return val instanceof SourceImpl;
  }
  function createSource(sourceData, thisMetaRawOption, sourceFormat) {
    sourceFormat = sourceFormat || detectSourceFormat(sourceData);
    var seriesLayoutBy = thisMetaRawOption.seriesLayoutBy;
    var determined = determineSourceDimensions(sourceData, sourceFormat, seriesLayoutBy, thisMetaRawOption.sourceHeader, thisMetaRawOption.dimensions);
    var source = new SourceImpl({
      data: sourceData,
      sourceFormat,
      seriesLayoutBy,
      dimensionsDefine: determined.dimensionsDefine,
      startIndex: determined.startIndex,
      dimensionsDetectedCount: determined.dimensionsDetectedCount,
      metaRawOption: clone(thisMetaRawOption)
    });
    return source;
  }
  function createSourceFromSeriesDataOption(data) {
    return new SourceImpl({
      data,
      sourceFormat: isTypedArray(data) ? SOURCE_FORMAT_TYPED_ARRAY : SOURCE_FORMAT_ORIGINAL
    });
  }
  function cloneSourceShallow(source) {
    return new SourceImpl({
      data: source.data,
      sourceFormat: source.sourceFormat,
      seriesLayoutBy: source.seriesLayoutBy,
      dimensionsDefine: clone(source.dimensionsDefine),
      startIndex: source.startIndex,
      dimensionsDetectedCount: source.dimensionsDetectedCount
    });
  }
  function detectSourceFormat(data) {
    var sourceFormat = SOURCE_FORMAT_UNKNOWN;
    if (isTypedArray(data)) {
      sourceFormat = SOURCE_FORMAT_TYPED_ARRAY;
    } else if (isArray(data)) {
      if (data.length === 0) {
        sourceFormat = SOURCE_FORMAT_ARRAY_ROWS;
      }
      for (var i = 0, len2 = data.length; i < len2; i++) {
        var item = data[i];
        if (item == null) {
          continue;
        } else if (isArray(item)) {
          sourceFormat = SOURCE_FORMAT_ARRAY_ROWS;
          break;
        } else if (isObject(item)) {
          sourceFormat = SOURCE_FORMAT_OBJECT_ROWS;
          break;
        }
      }
    } else if (isObject(data)) {
      for (var key in data) {
        if (hasOwn(data, key) && isArrayLike(data[key])) {
          sourceFormat = SOURCE_FORMAT_KEYED_COLUMNS;
          break;
        }
      }
    }
    return sourceFormat;
  }
  function determineSourceDimensions(data, sourceFormat, seriesLayoutBy, sourceHeader, dimensionsDefine) {
    var dimensionsDetectedCount;
    var startIndex;
    if (!data) {
      return {
        dimensionsDefine: normalizeDimensionsOption(dimensionsDefine),
        startIndex,
        dimensionsDetectedCount
      };
    }
    if (sourceFormat === SOURCE_FORMAT_ARRAY_ROWS) {
      var dataArrayRows = data;
      if (sourceHeader === "auto" || sourceHeader == null) {
        arrayRowsTravelFirst(function(val) {
          if (val != null && val !== "-") {
            if (isString(val)) {
              startIndex == null && (startIndex = 1);
            } else {
              startIndex = 0;
            }
          }
        }, seriesLayoutBy, dataArrayRows, 10);
      } else {
        startIndex = isNumber(sourceHeader) ? sourceHeader : sourceHeader ? 1 : 0;
      }
      if (!dimensionsDefine && startIndex === 1) {
        dimensionsDefine = [];
        arrayRowsTravelFirst(function(val, index) {
          dimensionsDefine[index] = val != null ? val + "" : "";
        }, seriesLayoutBy, dataArrayRows, Infinity);
      }
      dimensionsDetectedCount = dimensionsDefine ? dimensionsDefine.length : seriesLayoutBy === SERIES_LAYOUT_BY_ROW ? dataArrayRows.length : dataArrayRows[0] ? dataArrayRows[0].length : null;
    } else if (sourceFormat === SOURCE_FORMAT_OBJECT_ROWS) {
      if (!dimensionsDefine) {
        dimensionsDefine = objectRowsCollectDimensions(data);
      }
    } else if (sourceFormat === SOURCE_FORMAT_KEYED_COLUMNS) {
      if (!dimensionsDefine) {
        dimensionsDefine = [];
        each(data, function(colArr, key) {
          dimensionsDefine.push(key);
        });
      }
    } else if (sourceFormat === SOURCE_FORMAT_ORIGINAL) {
      var value0 = getDataItemValue(data[0]);
      dimensionsDetectedCount = isArray(value0) && value0.length || 1;
    } else if (sourceFormat === SOURCE_FORMAT_TYPED_ARRAY) {
      if (true) {
        assert(!!dimensionsDefine, "dimensions must be given if data is TypedArray.");
      }
    }
    return {
      startIndex,
      dimensionsDefine: normalizeDimensionsOption(dimensionsDefine),
      dimensionsDetectedCount
    };
  }
  function objectRowsCollectDimensions(data) {
    var firstIndex = 0;
    var obj;
    while (firstIndex < data.length && !(obj = data[firstIndex++])) {
    }
    if (obj) {
      var dimensions_1 = [];
      each(obj, function(value, key) {
        dimensions_1.push(key);
      });
      return dimensions_1;
    }
  }
  function normalizeDimensionsOption(dimensionsDefine) {
    if (!dimensionsDefine) {
      return;
    }
    var nameMap = createHashMap();
    return map(dimensionsDefine, function(rawItem, index) {
      rawItem = isObject(rawItem) ? rawItem : {
        name: rawItem
      };
      var item = {
        name: rawItem.name,
        displayName: rawItem.displayName,
        type: rawItem.type
      };
      if (item.name == null) {
        return item;
      }
      item.name += "";
      if (item.displayName == null) {
        item.displayName = item.name;
      }
      var exist = nameMap.get(item.name);
      if (!exist) {
        nameMap.set(item.name, {
          count: 1
        });
      } else {
        item.name += "-" + exist.count++;
      }
      return item;
    });
  }
  function arrayRowsTravelFirst(cb, seriesLayoutBy, data, maxLoop) {
    if (seriesLayoutBy === SERIES_LAYOUT_BY_ROW) {
      for (var i = 0; i < data.length && i < maxLoop; i++) {
        cb(data[i] ? data[i][0] : null, i);
      }
    } else {
      var value0 = data[0] || [];
      for (var i = 0; i < value0.length && i < maxLoop; i++) {
        cb(value0[i], i);
      }
    }
  }
  function shouldRetrieveDataByName(source) {
    var sourceFormat = source.sourceFormat;
    return sourceFormat === SOURCE_FORMAT_OBJECT_ROWS || sourceFormat === SOURCE_FORMAT_KEYED_COLUMNS;
  }

  // node_modules/echarts/lib/data/helper/dataProvider.js
  var _a;
  var _b;
  var _c;
  var providerMethods;
  var mountMethods;
  var DefaultDataProvider = function() {
    function DefaultDataProvider2(sourceParam, dimSize) {
      var source = !isSourceInstance(sourceParam) ? createSourceFromSeriesDataOption(sourceParam) : sourceParam;
      this._source = source;
      var data = this._data = source.data;
      if (source.sourceFormat === SOURCE_FORMAT_TYPED_ARRAY) {
        if (true) {
          if (dimSize == null) {
            throw new Error("Typed array data must specify dimension size");
          }
        }
        this._offset = 0;
        this._dimSize = dimSize;
        this._data = data;
      }
      mountMethods(this, data, source);
    }
    DefaultDataProvider2.prototype.getSource = function() {
      return this._source;
    };
    DefaultDataProvider2.prototype.count = function() {
      return 0;
    };
    DefaultDataProvider2.prototype.getItem = function(idx, out2) {
      return;
    };
    DefaultDataProvider2.prototype.appendData = function(newData) {
    };
    DefaultDataProvider2.prototype.clean = function() {
    };
    DefaultDataProvider2.protoInitialize = function() {
      var proto2 = DefaultDataProvider2.prototype;
      proto2.pure = false;
      proto2.persistent = true;
    }();
    DefaultDataProvider2.internalField = function() {
      var _a2;
      mountMethods = function(provider, data, source) {
        var sourceFormat = source.sourceFormat;
        var seriesLayoutBy = source.seriesLayoutBy;
        var startIndex = source.startIndex;
        var dimsDef = source.dimensionsDefine;
        var methods = providerMethods[getMethodMapKey(sourceFormat, seriesLayoutBy)];
        if (true) {
          assert(methods, "Invalide sourceFormat: " + sourceFormat);
        }
        extend(provider, methods);
        if (sourceFormat === SOURCE_FORMAT_TYPED_ARRAY) {
          provider.getItem = getItemForTypedArray;
          provider.count = countForTypedArray;
          provider.fillStorage = fillStorageForTypedArray;
        } else {
          var rawItemGetter = getRawSourceItemGetter(sourceFormat, seriesLayoutBy);
          provider.getItem = bind(rawItemGetter, null, data, startIndex, dimsDef);
          var rawCounter = getRawSourceDataCounter(sourceFormat, seriesLayoutBy);
          provider.count = bind(rawCounter, null, data, startIndex, dimsDef);
        }
      };
      var getItemForTypedArray = function(idx, out2) {
        idx = idx - this._offset;
        out2 = out2 || [];
        var data = this._data;
        var dimSize = this._dimSize;
        var offset = dimSize * idx;
        for (var i = 0; i < dimSize; i++) {
          out2[i] = data[offset + i];
        }
        return out2;
      };
      var fillStorageForTypedArray = function(start2, end2, storage2, extent3) {
        var data = this._data;
        var dimSize = this._dimSize;
        for (var dim = 0; dim < dimSize; dim++) {
          var dimExtent = extent3[dim];
          var min3 = dimExtent[0] == null ? Infinity : dimExtent[0];
          var max3 = dimExtent[1] == null ? -Infinity : dimExtent[1];
          var count2 = end2 - start2;
          var arr = storage2[dim];
          for (var i = 0; i < count2; i++) {
            var val = data[i * dimSize + dim];
            arr[start2 + i] = val;
            val < min3 && (min3 = val);
            val > max3 && (max3 = val);
          }
          dimExtent[0] = min3;
          dimExtent[1] = max3;
        }
      };
      var countForTypedArray = function() {
        return this._data ? this._data.length / this._dimSize : 0;
      };
      providerMethods = (_a2 = {}, _a2[SOURCE_FORMAT_ARRAY_ROWS + "_" + SERIES_LAYOUT_BY_COLUMN] = {
        pure: true,
        appendData: appendDataSimply
      }, _a2[SOURCE_FORMAT_ARRAY_ROWS + "_" + SERIES_LAYOUT_BY_ROW] = {
        pure: true,
        appendData: function() {
          throw new Error('Do not support appendData when set seriesLayoutBy: "row".');
        }
      }, _a2[SOURCE_FORMAT_OBJECT_ROWS] = {
        pure: true,
        appendData: appendDataSimply
      }, _a2[SOURCE_FORMAT_KEYED_COLUMNS] = {
        pure: true,
        appendData: function(newData) {
          var data = this._data;
          each(newData, function(newCol, key) {
            var oldCol = data[key] || (data[key] = []);
            for (var i = 0; i < (newCol || []).length; i++) {
              oldCol.push(newCol[i]);
            }
          });
        }
      }, _a2[SOURCE_FORMAT_ORIGINAL] = {
        appendData: appendDataSimply
      }, _a2[SOURCE_FORMAT_TYPED_ARRAY] = {
        persistent: false,
        pure: true,
        appendData: function(newData) {
          if (true) {
            assert(isTypedArray(newData), "Added data must be TypedArray if data in initialization is TypedArray");
          }
          this._data = newData;
        },
        clean: function() {
          this._offset += this.count();
          this._data = null;
        }
      }, _a2);
      function appendDataSimply(newData) {
        for (var i = 0; i < newData.length; i++) {
          this._data.push(newData[i]);
        }
      }
    }();
    return DefaultDataProvider2;
  }();
  var getItemSimply = function(rawData, startIndex, dimsDef, idx) {
    return rawData[idx];
  };
  var rawSourceItemGetterMap = (_a = {}, _a[SOURCE_FORMAT_ARRAY_ROWS + "_" + SERIES_LAYOUT_BY_COLUMN] = function(rawData, startIndex, dimsDef, idx) {
    return rawData[idx + startIndex];
  }, _a[SOURCE_FORMAT_ARRAY_ROWS + "_" + SERIES_LAYOUT_BY_ROW] = function(rawData, startIndex, dimsDef, idx, out2) {
    idx += startIndex;
    var item = out2 || [];
    var data = rawData;
    for (var i = 0; i < data.length; i++) {
      var row = data[i];
      item[i] = row ? row[idx] : null;
    }
    return item;
  }, _a[SOURCE_FORMAT_OBJECT_ROWS] = getItemSimply, _a[SOURCE_FORMAT_KEYED_COLUMNS] = function(rawData, startIndex, dimsDef, idx, out2) {
    var item = out2 || [];
    for (var i = 0; i < dimsDef.length; i++) {
      var dimName = dimsDef[i].name;
      if (true) {
        if (dimName == null) {
          throw new Error();
        }
      }
      var col = rawData[dimName];
      item[i] = col ? col[idx] : null;
    }
    return item;
  }, _a[SOURCE_FORMAT_ORIGINAL] = getItemSimply, _a);
  function getRawSourceItemGetter(sourceFormat, seriesLayoutBy) {
    var method = rawSourceItemGetterMap[getMethodMapKey(sourceFormat, seriesLayoutBy)];
    if (true) {
      assert(method, 'Do not support get item on "' + sourceFormat + '", "' + seriesLayoutBy + '".');
    }
    return method;
  }
  var countSimply = function(rawData, startIndex, dimsDef) {
    return rawData.length;
  };
  var rawSourceDataCounterMap = (_b = {}, _b[SOURCE_FORMAT_ARRAY_ROWS + "_" + SERIES_LAYOUT_BY_COLUMN] = function(rawData, startIndex, dimsDef) {
    return Math.max(0, rawData.length - startIndex);
  }, _b[SOURCE_FORMAT_ARRAY_ROWS + "_" + SERIES_LAYOUT_BY_ROW] = function(rawData, startIndex, dimsDef) {
    var row = rawData[0];
    return row ? Math.max(0, row.length - startIndex) : 0;
  }, _b[SOURCE_FORMAT_OBJECT_ROWS] = countSimply, _b[SOURCE_FORMAT_KEYED_COLUMNS] = function(rawData, startIndex, dimsDef) {
    var dimName = dimsDef[0].name;
    if (true) {
      if (dimName == null) {
        throw new Error();
      }
    }
    var col = rawData[dimName];
    return col ? col.length : 0;
  }, _b[SOURCE_FORMAT_ORIGINAL] = countSimply, _b);
  function getRawSourceDataCounter(sourceFormat, seriesLayoutBy) {
    var method = rawSourceDataCounterMap[getMethodMapKey(sourceFormat, seriesLayoutBy)];
    if (true) {
      assert(method, 'Do not suppport count on "' + sourceFormat + '", "' + seriesLayoutBy + '".');
    }
    return method;
  }
  var getRawValueSimply = function(dataItem, dimIndex, property) {
    return dataItem[dimIndex];
  };
  var rawSourceValueGetterMap = (_c = {}, _c[SOURCE_FORMAT_ARRAY_ROWS] = getRawValueSimply, _c[SOURCE_FORMAT_OBJECT_ROWS] = function(dataItem, dimIndex, property) {
    return dataItem[property];
  }, _c[SOURCE_FORMAT_KEYED_COLUMNS] = getRawValueSimply, _c[SOURCE_FORMAT_ORIGINAL] = function(dataItem, dimIndex, property) {
    var value = getDataItemValue(dataItem);
    return !(value instanceof Array) ? value : value[dimIndex];
  }, _c[SOURCE_FORMAT_TYPED_ARRAY] = getRawValueSimply, _c);
  function getRawSourceValueGetter(sourceFormat) {
    var method = rawSourceValueGetterMap[sourceFormat];
    if (true) {
      assert(method, 'Do not suppport get value on "' + sourceFormat + '".');
    }
    return method;
  }
  function getMethodMapKey(sourceFormat, seriesLayoutBy) {
    return sourceFormat === SOURCE_FORMAT_ARRAY_ROWS ? sourceFormat + "_" + seriesLayoutBy : sourceFormat;
  }
  function retrieveRawValue(data, dataIndex, dim) {
    if (!data) {
      return;
    }
    var dataItem = data.getRawDataItem(dataIndex);
    if (dataItem == null) {
      return;
    }
    var store = data.getStore();
    var sourceFormat = store.getSource().sourceFormat;
    if (dim != null) {
      var dimIndex = data.getDimensionIndex(dim);
      var property = store.getDimensionProperty(dimIndex);
      return getRawSourceValueGetter(sourceFormat)(dataItem, dimIndex, property);
    } else {
      var result = dataItem;
      if (sourceFormat === SOURCE_FORMAT_ORIGINAL) {
        result = getDataItemValue(dataItem);
      }
      return result;
    }
  }

  // node_modules/echarts/lib/model/mixin/dataFormat.js
  var DIMENSION_LABEL_REG = /\{@(.+?)\}/g;
  var DataFormatMixin = function() {
    function DataFormatMixin2() {
    }
    DataFormatMixin2.prototype.getDataParams = function(dataIndex, dataType) {
      var data = this.getData(dataType);
      var rawValue = this.getRawValue(dataIndex, dataType);
      var rawDataIndex = data.getRawIndex(dataIndex);
      var name = data.getName(dataIndex);
      var itemOpt = data.getRawDataItem(dataIndex);
      var style = data.getItemVisual(dataIndex, "style");
      var color = style && style[data.getItemVisual(dataIndex, "drawType") || "fill"];
      var borderColor = style && style.stroke;
      var mainType = this.mainType;
      var isSeries2 = mainType === "series";
      var userOutput = data.userOutput && data.userOutput.get();
      return {
        componentType: mainType,
        componentSubType: this.subType,
        componentIndex: this.componentIndex,
        seriesType: isSeries2 ? this.subType : null,
        seriesIndex: this.seriesIndex,
        seriesId: isSeries2 ? this.id : null,
        seriesName: isSeries2 ? this.name : null,
        name,
        dataIndex: rawDataIndex,
        data: itemOpt,
        dataType,
        value: rawValue,
        color,
        borderColor,
        dimensionNames: userOutput ? userOutput.fullDimensions : null,
        encode: userOutput ? userOutput.encode : null,
        $vars: ["seriesName", "name", "value"]
      };
    };
    DataFormatMixin2.prototype.getFormattedLabel = function(dataIndex, status, dataType, labelDimIndex, formatter, extendParams) {
      status = status || "normal";
      var data = this.getData(dataType);
      var params = this.getDataParams(dataIndex, dataType);
      if (extendParams) {
        params.value = extendParams.interpolatedValue;
      }
      if (labelDimIndex != null && isArray(params.value)) {
        params.value = params.value[labelDimIndex];
      }
      if (!formatter) {
        var itemModel = data.getItemModel(dataIndex);
        formatter = itemModel.get(status === "normal" ? ["label", "formatter"] : [status, "label", "formatter"]);
      }
      if (isFunction(formatter)) {
        params.status = status;
        params.dimensionIndex = labelDimIndex;
        return formatter(params);
      } else if (isString(formatter)) {
        var str = formatTpl(formatter, params);
        return str.replace(DIMENSION_LABEL_REG, function(origin, dimStr) {
          var len2 = dimStr.length;
          var dimLoose = dimStr;
          if (dimLoose.charAt(0) === "[" && dimLoose.charAt(len2 - 1) === "]") {
            dimLoose = +dimLoose.slice(1, len2 - 1);
            if (true) {
              if (isNaN(dimLoose)) {
                error("Invalide label formatter: @" + dimStr + ", only support @[0], @[1], @[2], ...");
              }
            }
          }
          var val = retrieveRawValue(data, dataIndex, dimLoose);
          if (extendParams && isArray(extendParams.interpolatedValue)) {
            var dimIndex = data.getDimensionIndex(dimLoose);
            if (dimIndex >= 0) {
              val = extendParams.interpolatedValue[dimIndex];
            }
          }
          return val != null ? val + "" : "";
        });
      }
    };
    DataFormatMixin2.prototype.getRawValue = function(idx, dataType) {
      return retrieveRawValue(this.getData(dataType), idx);
    };
    DataFormatMixin2.prototype.formatTooltip = function(dataIndex, multipleSeries, dataType) {
      return;
    };
    return DataFormatMixin2;
  }();
  function normalizeTooltipFormatResult(result) {
    var markupText;
    var markupFragment;
    if (isObject(result)) {
      if (result.type) {
        markupFragment = result;
      } else {
        if (true) {
          console.warn("The return type of `formatTooltip` is not supported: " + makePrintable(result));
        }
      }
    } else {
      markupText = result;
    }
    return {
      text: markupText,
      frag: markupFragment
    };
  }

  // node_modules/echarts/lib/core/task.js
  function createTask(define2) {
    return new Task(define2);
  }
  var Task = function() {
    function Task2(define2) {
      define2 = define2 || {};
      this._reset = define2.reset;
      this._plan = define2.plan;
      this._count = define2.count;
      this._onDirty = define2.onDirty;
      this._dirty = true;
    }
    Task2.prototype.perform = function(performArgs) {
      var upTask = this._upstream;
      var skip = performArgs && performArgs.skip;
      if (this._dirty && upTask) {
        var context = this.context;
        context.data = context.outputData = upTask.context.outputData;
      }
      if (this.__pipeline) {
        this.__pipeline.currentTask = this;
      }
      var planResult;
      if (this._plan && !skip) {
        planResult = this._plan(this.context);
      }
      var lastModBy = normalizeModBy(this._modBy);
      var lastModDataCount = this._modDataCount || 0;
      var modBy = normalizeModBy(performArgs && performArgs.modBy);
      var modDataCount = performArgs && performArgs.modDataCount || 0;
      if (lastModBy !== modBy || lastModDataCount !== modDataCount) {
        planResult = "reset";
      }
      function normalizeModBy(val) {
        !(val >= 1) && (val = 1);
        return val;
      }
      var forceFirstProgress;
      if (this._dirty || planResult === "reset") {
        this._dirty = false;
        forceFirstProgress = this._doReset(skip);
      }
      this._modBy = modBy;
      this._modDataCount = modDataCount;
      var step = performArgs && performArgs.step;
      if (upTask) {
        if (true) {
          assert(upTask._outputDueEnd != null);
        }
        this._dueEnd = upTask._outputDueEnd;
      } else {
        if (true) {
          assert(!this._progress || this._count);
        }
        this._dueEnd = this._count ? this._count(this.context) : Infinity;
      }
      if (this._progress) {
        var start2 = this._dueIndex;
        var end2 = Math.min(step != null ? this._dueIndex + step : Infinity, this._dueEnd);
        if (!skip && (forceFirstProgress || start2 < end2)) {
          var progress = this._progress;
          if (isArray(progress)) {
            for (var i = 0; i < progress.length; i++) {
              this._doProgress(progress[i], start2, end2, modBy, modDataCount);
            }
          } else {
            this._doProgress(progress, start2, end2, modBy, modDataCount);
          }
        }
        this._dueIndex = end2;
        var outputDueEnd = this._settedOutputEnd != null ? this._settedOutputEnd : end2;
        if (true) {
          assert(outputDueEnd >= this._outputDueEnd);
        }
        this._outputDueEnd = outputDueEnd;
      } else {
        this._dueIndex = this._outputDueEnd = this._settedOutputEnd != null ? this._settedOutputEnd : this._dueEnd;
      }
      return this.unfinished();
    };
    Task2.prototype.dirty = function() {
      this._dirty = true;
      this._onDirty && this._onDirty(this.context);
    };
    Task2.prototype._doProgress = function(progress, start2, end2, modBy, modDataCount) {
      iterator.reset(start2, end2, modBy, modDataCount);
      this._callingProgress = progress;
      this._callingProgress({
        start: start2,
        end: end2,
        count: end2 - start2,
        next: iterator.next
      }, this.context);
    };
    Task2.prototype._doReset = function(skip) {
      this._dueIndex = this._outputDueEnd = this._dueEnd = 0;
      this._settedOutputEnd = null;
      var progress;
      var forceFirstProgress;
      if (!skip && this._reset) {
        progress = this._reset(this.context);
        if (progress && progress.progress) {
          forceFirstProgress = progress.forceFirstProgress;
          progress = progress.progress;
        }
        if (isArray(progress) && !progress.length) {
          progress = null;
        }
      }
      this._progress = progress;
      this._modBy = this._modDataCount = null;
      var downstream = this._downstream;
      downstream && downstream.dirty();
      return forceFirstProgress;
    };
    Task2.prototype.unfinished = function() {
      return this._progress && this._dueIndex < this._dueEnd;
    };
    Task2.prototype.pipe = function(downTask) {
      if (true) {
        assert(downTask && !downTask._disposed && downTask !== this);
      }
      if (this._downstream !== downTask || this._dirty) {
        this._downstream = downTask;
        downTask._upstream = this;
        downTask.dirty();
      }
    };
    Task2.prototype.dispose = function() {
      if (this._disposed) {
        return;
      }
      this._upstream && (this._upstream._downstream = null);
      this._downstream && (this._downstream._upstream = null);
      this._dirty = false;
      this._disposed = true;
    };
    Task2.prototype.getUpstream = function() {
      return this._upstream;
    };
    Task2.prototype.getDownstream = function() {
      return this._downstream;
    };
    Task2.prototype.setOutputEnd = function(end2) {
      this._outputDueEnd = this._settedOutputEnd = end2;
    };
    return Task2;
  }();
  var iterator = function() {
    var end2;
    var current;
    var modBy;
    var modDataCount;
    var winCount;
    var it = {
      reset: function(s, e2, sStep, sCount) {
        current = s;
        end2 = e2;
        modBy = sStep;
        modDataCount = sCount;
        winCount = Math.ceil(modDataCount / modBy);
        it.next = modBy > 1 && modDataCount > 0 ? modNext : sequentialNext;
      }
    };
    return it;
    function sequentialNext() {
      return current < end2 ? current++ : null;
    }
    function modNext() {
      var dataIndex = current % winCount * modBy + Math.ceil(current / winCount);
      var result = current >= end2 ? null : dataIndex < modDataCount ? dataIndex : current;
      current++;
      return result;
    }
  }();

  // node_modules/echarts/lib/data/helper/dataValueHelper.js
  function parseDataValue(value, opt) {
    var dimType = opt && opt.type;
    if (dimType === "ordinal") {
      return value;
    }
    if (dimType === "time" && !isNumber(value) && value != null && value !== "-") {
      value = +parseDate(value);
    }
    return value == null || value === "" ? NaN : +value;
  }
  var valueParserMap = createHashMap({
    "number": function(val) {
      return parseFloat(val);
    },
    "time": function(val) {
      return +parseDate(val);
    },
    "trim": function(val) {
      return isString(val) ? trim(val) : val;
    }
  });
  function getRawValueParser(type) {
    return valueParserMap.get(type);
  }
  var ORDER_COMPARISON_OP_MAP = {
    lt: function(lval, rval) {
      return lval < rval;
    },
    lte: function(lval, rval) {
      return lval <= rval;
    },
    gt: function(lval, rval) {
      return lval > rval;
    },
    gte: function(lval, rval) {
      return lval >= rval;
    }
  };
  var FilterOrderComparator = function() {
    function FilterOrderComparator2(op, rval) {
      if (!isNumber(rval)) {
        var errMsg = "";
        if (true) {
          errMsg = 'rvalue of "<", ">", "<=", ">=" can only be number in filter.';
        }
        throwError(errMsg);
      }
      this._opFn = ORDER_COMPARISON_OP_MAP[op];
      this._rvalFloat = numericToNumber(rval);
    }
    FilterOrderComparator2.prototype.evaluate = function(lval) {
      return isNumber(lval) ? this._opFn(lval, this._rvalFloat) : this._opFn(numericToNumber(lval), this._rvalFloat);
    };
    return FilterOrderComparator2;
  }();
  var SortOrderComparator = function() {
    function SortOrderComparator2(order, incomparable) {
      var isDesc = order === "desc";
      this._resultLT = isDesc ? 1 : -1;
      if (incomparable == null) {
        incomparable = isDesc ? "min" : "max";
      }
      this._incomparable = incomparable === "min" ? -Infinity : Infinity;
    }
    SortOrderComparator2.prototype.evaluate = function(lval, rval) {
      var lvalFloat = isNumber(lval) ? lval : numericToNumber(lval);
      var rvalFloat = isNumber(rval) ? rval : numericToNumber(rval);
      var lvalNotNumeric = isNaN(lvalFloat);
      var rvalNotNumeric = isNaN(rvalFloat);
      if (lvalNotNumeric) {
        lvalFloat = this._incomparable;
      }
      if (rvalNotNumeric) {
        rvalFloat = this._incomparable;
      }
      if (lvalNotNumeric && rvalNotNumeric) {
        var lvalIsStr = isString(lval);
        var rvalIsStr = isString(rval);
        if (lvalIsStr) {
          lvalFloat = rvalIsStr ? lval : 0;
        }
        if (rvalIsStr) {
          rvalFloat = lvalIsStr ? rval : 0;
        }
      }
      return lvalFloat < rvalFloat ? this._resultLT : lvalFloat > rvalFloat ? -this._resultLT : 0;
    };
    return SortOrderComparator2;
  }();
  var FilterEqualityComparator = function() {
    function FilterEqualityComparator2(isEq, rval) {
      this._rval = rval;
      this._isEQ = isEq;
      this._rvalTypeof = typeof rval;
      this._rvalFloat = numericToNumber(rval);
    }
    FilterEqualityComparator2.prototype.evaluate = function(lval) {
      var eqResult = lval === this._rval;
      if (!eqResult) {
        var lvalTypeof = typeof lval;
        if (lvalTypeof !== this._rvalTypeof && (lvalTypeof === "number" || this._rvalTypeof === "number")) {
          eqResult = numericToNumber(lval) === this._rvalFloat;
        }
      }
      return this._isEQ ? eqResult : !eqResult;
    };
    return FilterEqualityComparator2;
  }();
  function createFilterComparator(op, rval) {
    return op === "eq" || op === "ne" ? new FilterEqualityComparator(op === "eq", rval) : hasOwn(ORDER_COMPARISON_OP_MAP, op) ? new FilterOrderComparator(op, rval) : null;
  }

  // node_modules/echarts/lib/data/helper/transform.js
  var ExternalSource = function() {
    function ExternalSource2() {
    }
    ExternalSource2.prototype.getRawData = function() {
      throw new Error("not supported");
    };
    ExternalSource2.prototype.getRawDataItem = function(dataIndex) {
      throw new Error("not supported");
    };
    ExternalSource2.prototype.cloneRawData = function() {
      return;
    };
    ExternalSource2.prototype.getDimensionInfo = function(dim) {
      return;
    };
    ExternalSource2.prototype.cloneAllDimensionInfo = function() {
      return;
    };
    ExternalSource2.prototype.count = function() {
      return;
    };
    ExternalSource2.prototype.retrieveValue = function(dataIndex, dimIndex) {
      return;
    };
    ExternalSource2.prototype.retrieveValueFromItem = function(dataItem, dimIndex) {
      return;
    };
    ExternalSource2.prototype.convertValue = function(rawVal, dimInfo) {
      return parseDataValue(rawVal, dimInfo);
    };
    return ExternalSource2;
  }();
  function createExternalSource(internalSource, externalTransform) {
    var extSource = new ExternalSource();
    var data = internalSource.data;
    var sourceFormat = extSource.sourceFormat = internalSource.sourceFormat;
    var sourceHeaderCount = internalSource.startIndex;
    var errMsg = "";
    if (internalSource.seriesLayoutBy !== SERIES_LAYOUT_BY_COLUMN) {
      if (true) {
        errMsg = '`seriesLayoutBy` of upstream dataset can only be "column" in data transform.';
      }
      throwError(errMsg);
    }
    var dimensions = [];
    var dimsByName = {};
    var dimsDef = internalSource.dimensionsDefine;
    if (dimsDef) {
      each(dimsDef, function(dimDef, idx) {
        var name = dimDef.name;
        var dimDefExt = {
          index: idx,
          name,
          displayName: dimDef.displayName
        };
        dimensions.push(dimDefExt);
        if (name != null) {
          var errMsg_1 = "";
          if (hasOwn(dimsByName, name)) {
            if (true) {
              errMsg_1 = 'dimension name "' + name + '" duplicated.';
            }
            throwError(errMsg_1);
          }
          dimsByName[name] = dimDefExt;
        }
      });
    } else {
      for (var i = 0; i < internalSource.dimensionsDetectedCount || 0; i++) {
        dimensions.push({
          index: i
        });
      }
    }
    var rawItemGetter = getRawSourceItemGetter(sourceFormat, SERIES_LAYOUT_BY_COLUMN);
    if (externalTransform.__isBuiltIn) {
      extSource.getRawDataItem = function(dataIndex) {
        return rawItemGetter(data, sourceHeaderCount, dimensions, dataIndex);
      };
      extSource.getRawData = bind(getRawData, null, internalSource);
    }
    extSource.cloneRawData = bind(cloneRawData, null, internalSource);
    var rawCounter = getRawSourceDataCounter(sourceFormat, SERIES_LAYOUT_BY_COLUMN);
    extSource.count = bind(rawCounter, null, data, sourceHeaderCount, dimensions);
    var rawValueGetter = getRawSourceValueGetter(sourceFormat);
    extSource.retrieveValue = function(dataIndex, dimIndex) {
      var rawItem = rawItemGetter(data, sourceHeaderCount, dimensions, dataIndex);
      return retrieveValueFromItem(rawItem, dimIndex);
    };
    var retrieveValueFromItem = extSource.retrieveValueFromItem = function(dataItem, dimIndex) {
      if (dataItem == null) {
        return;
      }
      var dimDef = dimensions[dimIndex];
      if (dimDef) {
        return rawValueGetter(dataItem, dimIndex, dimDef.name);
      }
    };
    extSource.getDimensionInfo = bind(getDimensionInfo, null, dimensions, dimsByName);
    extSource.cloneAllDimensionInfo = bind(cloneAllDimensionInfo, null, dimensions);
    return extSource;
  }
  function getRawData(upstream) {
    var sourceFormat = upstream.sourceFormat;
    if (!isSupportedSourceFormat(sourceFormat)) {
      var errMsg = "";
      if (true) {
        errMsg = "`getRawData` is not supported in source format " + sourceFormat;
      }
      throwError(errMsg);
    }
    return upstream.data;
  }
  function cloneRawData(upstream) {
    var sourceFormat = upstream.sourceFormat;
    var data = upstream.data;
    if (!isSupportedSourceFormat(sourceFormat)) {
      var errMsg = "";
      if (true) {
        errMsg = "`cloneRawData` is not supported in source format " + sourceFormat;
      }
      throwError(errMsg);
    }
    if (sourceFormat === SOURCE_FORMAT_ARRAY_ROWS) {
      var result = [];
      for (var i = 0, len2 = data.length; i < len2; i++) {
        result.push(data[i].slice());
      }
      return result;
    } else if (sourceFormat === SOURCE_FORMAT_OBJECT_ROWS) {
      var result = [];
      for (var i = 0, len2 = data.length; i < len2; i++) {
        result.push(extend({}, data[i]));
      }
      return result;
    }
  }
  function getDimensionInfo(dimensions, dimsByName, dim) {
    if (dim == null) {
      return;
    }
    if (isNumber(dim) || !isNaN(dim) && !hasOwn(dimsByName, dim)) {
      return dimensions[dim];
    } else if (hasOwn(dimsByName, dim)) {
      return dimsByName[dim];
    }
  }
  function cloneAllDimensionInfo(dimensions) {
    return clone(dimensions);
  }
  var externalTransformMap = createHashMap();
  function registerExternalTransform(externalTransform) {
    externalTransform = clone(externalTransform);
    var type = externalTransform.type;
    var errMsg = "";
    if (!type) {
      if (true) {
        errMsg = "Must have a `type` when `registerTransform`.";
      }
      throwError(errMsg);
    }
    var typeParsed = type.split(":");
    if (typeParsed.length !== 2) {
      if (true) {
        errMsg = 'Name must include namespace like "ns:regression".';
      }
      throwError(errMsg);
    }
    var isBuiltIn = false;
    if (typeParsed[0] === "echarts") {
      type = typeParsed[1];
      isBuiltIn = true;
    }
    externalTransform.__isBuiltIn = isBuiltIn;
    externalTransformMap.set(type, externalTransform);
  }
  function applyDataTransform(rawTransOption, sourceList, infoForPrint) {
    var pipedTransOption = normalizeToArray(rawTransOption);
    var pipeLen = pipedTransOption.length;
    var errMsg = "";
    if (!pipeLen) {
      if (true) {
        errMsg = "If `transform` declared, it should at least contain one transform.";
      }
      throwError(errMsg);
    }
    for (var i = 0, len2 = pipeLen; i < len2; i++) {
      var transOption = pipedTransOption[i];
      sourceList = applySingleDataTransform(transOption, sourceList, infoForPrint, pipeLen === 1 ? null : i);
      if (i !== len2 - 1) {
        sourceList.length = Math.max(sourceList.length, 1);
      }
    }
    return sourceList;
  }
  function applySingleDataTransform(transOption, upSourceList, infoForPrint, pipeIndex) {
    var errMsg = "";
    if (!upSourceList.length) {
      if (true) {
        errMsg = "Must have at least one upstream dataset.";
      }
      throwError(errMsg);
    }
    if (!isObject(transOption)) {
      if (true) {
        errMsg = "transform declaration must be an object rather than " + typeof transOption + ".";
      }
      throwError(errMsg);
    }
    var transType = transOption.type;
    var externalTransform = externalTransformMap.get(transType);
    if (!externalTransform) {
      if (true) {
        errMsg = 'Can not find transform on type "' + transType + '".';
      }
      throwError(errMsg);
    }
    var extUpSourceList = map(upSourceList, function(upSource) {
      return createExternalSource(upSource, externalTransform);
    });
    var resultList = normalizeToArray(externalTransform.transform({
      upstream: extUpSourceList[0],
      upstreamList: extUpSourceList,
      config: clone(transOption.config)
    }));
    if (true) {
      if (transOption.print) {
        var printStrArr = map(resultList, function(extSource) {
          var pipeIndexStr = pipeIndex != null ? " === pipe index: " + pipeIndex : "";
          return ["=== dataset index: " + infoForPrint.datasetIndex + pipeIndexStr + " ===", "- transform result data:", makePrintable(extSource.data), "- transform result dimensions:", makePrintable(extSource.dimensions)].join("\n");
        }).join("\n");
        log(printStrArr);
      }
    }
    return map(resultList, function(result, resultIndex) {
      var errMsg2 = "";
      if (!isObject(result)) {
        if (true) {
          errMsg2 = "A transform should not return some empty results.";
        }
        throwError(errMsg2);
      }
      if (!result.data) {
        if (true) {
          errMsg2 = "Transform result data should be not be null or undefined";
        }
        throwError(errMsg2);
      }
      var sourceFormat = detectSourceFormat(result.data);
      if (!isSupportedSourceFormat(sourceFormat)) {
        if (true) {
          errMsg2 = "Transform result data should be array rows or object rows.";
        }
        throwError(errMsg2);
      }
      var resultMetaRawOption;
      var firstUpSource = upSourceList[0];
      if (firstUpSource && resultIndex === 0 && !result.dimensions) {
        var startIndex = firstUpSource.startIndex;
        if (startIndex) {
          result.data = firstUpSource.data.slice(0, startIndex).concat(result.data);
        }
        resultMetaRawOption = {
          seriesLayoutBy: SERIES_LAYOUT_BY_COLUMN,
          sourceHeader: startIndex,
          dimensions: firstUpSource.metaRawOption.dimensions
        };
      } else {
        resultMetaRawOption = {
          seriesLayoutBy: SERIES_LAYOUT_BY_COLUMN,
          sourceHeader: 0,
          dimensions: result.dimensions
        };
      }
      return createSource(result.data, resultMetaRawOption, null);
    });
  }
  function isSupportedSourceFormat(sourceFormat) {
    return sourceFormat === SOURCE_FORMAT_ARRAY_ROWS || sourceFormat === SOURCE_FORMAT_OBJECT_ROWS;
  }

  // node_modules/echarts/lib/data/DataStore.js
  var UNDEFINED = "undefined";
  var CtorUint32Array = typeof Uint32Array === UNDEFINED ? Array : Uint32Array;
  var CtorUint16Array = typeof Uint16Array === UNDEFINED ? Array : Uint16Array;
  var CtorInt32Array = typeof Int32Array === UNDEFINED ? Array : Int32Array;
  var CtorFloat64Array = typeof Float64Array === UNDEFINED ? Array : Float64Array;
  var dataCtors = {
    "float": CtorFloat64Array,
    "int": CtorInt32Array,
    "ordinal": Array,
    "number": Array,
    "time": CtorFloat64Array
  };
  var defaultDimValueGetters;
  function getIndicesCtor(rawCount) {
    return rawCount > 65535 ? CtorUint32Array : CtorUint16Array;
  }
  function getInitialExtent() {
    return [Infinity, -Infinity];
  }
  function cloneChunk(originalChunk) {
    var Ctor = originalChunk.constructor;
    return Ctor === Array ? originalChunk.slice() : new Ctor(originalChunk);
  }
  function prepareStore(store, dimIdx, dimType, end2, append) {
    var DataCtor = dataCtors[dimType || "float"];
    if (append) {
      var oldStore = store[dimIdx];
      var oldLen = oldStore && oldStore.length;
      if (!(oldLen === end2)) {
        var newStore = new DataCtor(end2);
        for (var j = 0; j < oldLen; j++) {
          newStore[j] = oldStore[j];
        }
        store[dimIdx] = newStore;
      }
    } else {
      store[dimIdx] = new DataCtor(end2);
    }
  }
  var DataStore = function() {
    function DataStore2() {
      this._chunks = [];
      this._rawExtent = [];
      this._extent = [];
      this._count = 0;
      this._rawCount = 0;
      this._calcDimNameToIdx = createHashMap();
    }
    DataStore2.prototype.initData = function(provider, inputDimensions, dimValueGetter) {
      if (true) {
        assert(isFunction(provider.getItem) && isFunction(provider.count), "Invalid data provider.");
      }
      this._provider = provider;
      this._chunks = [];
      this._indices = null;
      this.getRawIndex = this._getRawIdxIdentity;
      var source = provider.getSource();
      var defaultGetter = this.defaultDimValueGetter = defaultDimValueGetters[source.sourceFormat];
      this._dimValueGetter = dimValueGetter || defaultGetter;
      this._rawExtent = [];
      var willRetrieveDataByName = shouldRetrieveDataByName(source);
      this._dimensions = map(inputDimensions, function(dim) {
        if (true) {
          if (willRetrieveDataByName) {
            assert(dim.property != null);
          }
        }
        return {
          type: dim.type,
          property: dim.property
        };
      });
      this._initDataFromProvider(0, provider.count());
    };
    DataStore2.prototype.getProvider = function() {
      return this._provider;
    };
    DataStore2.prototype.getSource = function() {
      return this._provider.getSource();
    };
    DataStore2.prototype.ensureCalculationDimension = function(dimName, type) {
      var calcDimNameToIdx = this._calcDimNameToIdx;
      var dimensions = this._dimensions;
      var calcDimIdx = calcDimNameToIdx.get(dimName);
      if (calcDimIdx != null) {
        if (dimensions[calcDimIdx].type === type) {
          return calcDimIdx;
        }
      } else {
        calcDimIdx = dimensions.length;
      }
      dimensions[calcDimIdx] = {
        type
      };
      calcDimNameToIdx.set(dimName, calcDimIdx);
      this._chunks[calcDimIdx] = new dataCtors[type || "float"](this._rawCount);
      this._rawExtent[calcDimIdx] = getInitialExtent();
      return calcDimIdx;
    };
    DataStore2.prototype.collectOrdinalMeta = function(dimIdx, ordinalMeta) {
      var chunk = this._chunks[dimIdx];
      var dim = this._dimensions[dimIdx];
      var rawExtents = this._rawExtent;
      var offset = dim.ordinalOffset || 0;
      var len2 = chunk.length;
      if (offset === 0) {
        rawExtents[dimIdx] = getInitialExtent();
      }
      var dimRawExtent = rawExtents[dimIdx];
      for (var i = offset; i < len2; i++) {
        var val = chunk[i] = ordinalMeta.parseAndCollect(chunk[i]);
        if (!isNaN(val)) {
          dimRawExtent[0] = Math.min(val, dimRawExtent[0]);
          dimRawExtent[1] = Math.max(val, dimRawExtent[1]);
        }
      }
      dim.ordinalMeta = ordinalMeta;
      dim.ordinalOffset = len2;
      dim.type = "ordinal";
    };
    DataStore2.prototype.getOrdinalMeta = function(dimIdx) {
      var dimInfo = this._dimensions[dimIdx];
      var ordinalMeta = dimInfo.ordinalMeta;
      return ordinalMeta;
    };
    DataStore2.prototype.getDimensionProperty = function(dimIndex) {
      var item = this._dimensions[dimIndex];
      return item && item.property;
    };
    DataStore2.prototype.appendData = function(data) {
      if (true) {
        assert(!this._indices, "appendData can only be called on raw data.");
      }
      var provider = this._provider;
      var start2 = this.count();
      provider.appendData(data);
      var end2 = provider.count();
      if (!provider.persistent) {
        end2 += start2;
      }
      if (start2 < end2) {
        this._initDataFromProvider(start2, end2, true);
      }
      return [start2, end2];
    };
    DataStore2.prototype.appendValues = function(values, minFillLen) {
      var chunks = this._chunks;
      var dimensions = this._dimensions;
      var dimLen = dimensions.length;
      var rawExtent = this._rawExtent;
      var start2 = this.count();
      var end2 = start2 + Math.max(values.length, minFillLen || 0);
      for (var i = 0; i < dimLen; i++) {
        var dim = dimensions[i];
        prepareStore(chunks, i, dim.type, end2, true);
      }
      var emptyDataItem = [];
      for (var idx = start2; idx < end2; idx++) {
        var sourceIdx = idx - start2;
        for (var dimIdx = 0; dimIdx < dimLen; dimIdx++) {
          var dim = dimensions[dimIdx];
          var val = defaultDimValueGetters.arrayRows.call(this, values[sourceIdx] || emptyDataItem, dim.property, sourceIdx, dimIdx);
          chunks[dimIdx][idx] = val;
          var dimRawExtent = rawExtent[dimIdx];
          val < dimRawExtent[0] && (dimRawExtent[0] = val);
          val > dimRawExtent[1] && (dimRawExtent[1] = val);
        }
      }
      this._rawCount = this._count = end2;
      return {
        start: start2,
        end: end2
      };
    };
    DataStore2.prototype._initDataFromProvider = function(start2, end2, append) {
      var provider = this._provider;
      var chunks = this._chunks;
      var dimensions = this._dimensions;
      var dimLen = dimensions.length;
      var rawExtent = this._rawExtent;
      var dimNames = map(dimensions, function(dim2) {
        return dim2.property;
      });
      for (var i = 0; i < dimLen; i++) {
        var dim = dimensions[i];
        if (!rawExtent[i]) {
          rawExtent[i] = getInitialExtent();
        }
        prepareStore(chunks, i, dim.type, end2, append);
      }
      if (provider.fillStorage) {
        provider.fillStorage(start2, end2, chunks, rawExtent);
      } else {
        var dataItem = [];
        for (var idx = start2; idx < end2; idx++) {
          dataItem = provider.getItem(idx, dataItem);
          for (var dimIdx = 0; dimIdx < dimLen; dimIdx++) {
            var dimStorage = chunks[dimIdx];
            var val = this._dimValueGetter(dataItem, dimNames[dimIdx], idx, dimIdx);
            dimStorage[idx] = val;
            var dimRawExtent = rawExtent[dimIdx];
            val < dimRawExtent[0] && (dimRawExtent[0] = val);
            val > dimRawExtent[1] && (dimRawExtent[1] = val);
          }
        }
      }
      if (!provider.persistent && provider.clean) {
        provider.clean();
      }
      this._rawCount = this._count = end2;
      this._extent = [];
    };
    DataStore2.prototype.count = function() {
      return this._count;
    };
    DataStore2.prototype.get = function(dim, idx) {
      if (!(idx >= 0 && idx < this._count)) {
        return NaN;
      }
      var dimStore = this._chunks[dim];
      return dimStore ? dimStore[this.getRawIndex(idx)] : NaN;
    };
    DataStore2.prototype.getValues = function(dimensions, idx) {
      var values = [];
      var dimArr = [];
      if (idx == null) {
        idx = dimensions;
        dimensions = [];
        for (var i = 0; i < this._dimensions.length; i++) {
          dimArr.push(i);
        }
      } else {
        dimArr = dimensions;
      }
      for (var i = 0, len2 = dimArr.length; i < len2; i++) {
        values.push(this.get(dimArr[i], idx));
      }
      return values;
    };
    DataStore2.prototype.getByRawIndex = function(dim, rawIdx) {
      if (!(rawIdx >= 0 && rawIdx < this._rawCount)) {
        return NaN;
      }
      var dimStore = this._chunks[dim];
      return dimStore ? dimStore[rawIdx] : NaN;
    };
    DataStore2.prototype.getSum = function(dim) {
      var dimData = this._chunks[dim];
      var sum2 = 0;
      if (dimData) {
        for (var i = 0, len2 = this.count(); i < len2; i++) {
          var value = this.get(dim, i);
          if (!isNaN(value)) {
            sum2 += value;
          }
        }
      }
      return sum2;
    };
    DataStore2.prototype.getMedian = function(dim) {
      var dimDataArray = [];
      this.each([dim], function(val) {
        if (!isNaN(val)) {
          dimDataArray.push(val);
        }
      });
      var sortedDimDataArray = dimDataArray.sort(function(a, b) {
        return a - b;
      });
      var len2 = this.count();
      return len2 === 0 ? 0 : len2 % 2 === 1 ? sortedDimDataArray[(len2 - 1) / 2] : (sortedDimDataArray[len2 / 2] + sortedDimDataArray[len2 / 2 - 1]) / 2;
    };
    DataStore2.prototype.indexOfRawIndex = function(rawIndex) {
      if (rawIndex >= this._rawCount || rawIndex < 0) {
        return -1;
      }
      if (!this._indices) {
        return rawIndex;
      }
      var indices = this._indices;
      var rawDataIndex = indices[rawIndex];
      if (rawDataIndex != null && rawDataIndex < this._count && rawDataIndex === rawIndex) {
        return rawIndex;
      }
      var left = 0;
      var right = this._count - 1;
      while (left <= right) {
        var mid = (left + right) / 2 | 0;
        if (indices[mid] < rawIndex) {
          left = mid + 1;
        } else if (indices[mid] > rawIndex) {
          right = mid - 1;
        } else {
          return mid;
        }
      }
      return -1;
    };
    DataStore2.prototype.indicesOfNearest = function(dim, value, maxDistance) {
      var chunks = this._chunks;
      var dimData = chunks[dim];
      var nearestIndices = [];
      if (!dimData) {
        return nearestIndices;
      }
      if (maxDistance == null) {
        maxDistance = Infinity;
      }
      var minDist = Infinity;
      var minDiff = -1;
      var nearestIndicesLen = 0;
      for (var i = 0, len2 = this.count(); i < len2; i++) {
        var dataIndex = this.getRawIndex(i);
        var diff = value - dimData[dataIndex];
        var dist3 = Math.abs(diff);
        if (dist3 <= maxDistance) {
          if (dist3 < minDist || dist3 === minDist && diff >= 0 && minDiff < 0) {
            minDist = dist3;
            minDiff = diff;
            nearestIndicesLen = 0;
          }
          if (diff === minDiff) {
            nearestIndices[nearestIndicesLen++] = i;
          }
        }
      }
      nearestIndices.length = nearestIndicesLen;
      return nearestIndices;
    };
    DataStore2.prototype.getIndices = function() {
      var newIndices;
      var indices = this._indices;
      if (indices) {
        var Ctor = indices.constructor;
        var thisCount = this._count;
        if (Ctor === Array) {
          newIndices = new Ctor(thisCount);
          for (var i = 0; i < thisCount; i++) {
            newIndices[i] = indices[i];
          }
        } else {
          newIndices = new Ctor(indices.buffer, 0, thisCount);
        }
      } else {
        var Ctor = getIndicesCtor(this._rawCount);
        newIndices = new Ctor(this.count());
        for (var i = 0; i < newIndices.length; i++) {
          newIndices[i] = i;
        }
      }
      return newIndices;
    };
    DataStore2.prototype.filter = function(dims, cb) {
      if (!this._count) {
        return this;
      }
      var newStore = this.clone();
      var count2 = newStore.count();
      var Ctor = getIndicesCtor(newStore._rawCount);
      var newIndices = new Ctor(count2);
      var value = [];
      var dimSize = dims.length;
      var offset = 0;
      var dim0 = dims[0];
      var chunks = newStore._chunks;
      for (var i = 0; i < count2; i++) {
        var keep = void 0;
        var rawIdx = newStore.getRawIndex(i);
        if (dimSize === 0) {
          keep = cb(i);
        } else if (dimSize === 1) {
          var val = chunks[dim0][rawIdx];
          keep = cb(val, i);
        } else {
          var k = 0;
          for (; k < dimSize; k++) {
            value[k] = chunks[dims[k]][rawIdx];
          }
          value[k] = i;
          keep = cb.apply(null, value);
        }
        if (keep) {
          newIndices[offset++] = rawIdx;
        }
      }
      if (offset < count2) {
        newStore._indices = newIndices;
      }
      newStore._count = offset;
      newStore._extent = [];
      newStore._updateGetRawIdx();
      return newStore;
    };
    DataStore2.prototype.selectRange = function(range) {
      var newStore = this.clone();
      var len2 = newStore._count;
      if (!len2) {
        return this;
      }
      var dims = keys(range);
      var dimSize = dims.length;
      if (!dimSize) {
        return this;
      }
      var originalCount = newStore.count();
      var Ctor = getIndicesCtor(newStore._rawCount);
      var newIndices = new Ctor(originalCount);
      var offset = 0;
      var dim0 = dims[0];
      var min3 = range[dim0][0];
      var max3 = range[dim0][1];
      var storeArr = newStore._chunks;
      var quickFinished = false;
      if (!newStore._indices) {
        var idx = 0;
        if (dimSize === 1) {
          var dimStorage = storeArr[dims[0]];
          for (var i = 0; i < len2; i++) {
            var val = dimStorage[i];
            if (val >= min3 && val <= max3 || isNaN(val)) {
              newIndices[offset++] = idx;
            }
            idx++;
          }
          quickFinished = true;
        } else if (dimSize === 2) {
          var dimStorage = storeArr[dims[0]];
          var dimStorage2 = storeArr[dims[1]];
          var min23 = range[dims[1]][0];
          var max23 = range[dims[1]][1];
          for (var i = 0; i < len2; i++) {
            var val = dimStorage[i];
            var val2 = dimStorage2[i];
            if ((val >= min3 && val <= max3 || isNaN(val)) && (val2 >= min23 && val2 <= max23 || isNaN(val2))) {
              newIndices[offset++] = idx;
            }
            idx++;
          }
          quickFinished = true;
        }
      }
      if (!quickFinished) {
        if (dimSize === 1) {
          for (var i = 0; i < originalCount; i++) {
            var rawIndex = newStore.getRawIndex(i);
            var val = storeArr[dims[0]][rawIndex];
            if (val >= min3 && val <= max3 || isNaN(val)) {
              newIndices[offset++] = rawIndex;
            }
          }
        } else {
          for (var i = 0; i < originalCount; i++) {
            var keep = true;
            var rawIndex = newStore.getRawIndex(i);
            for (var k = 0; k < dimSize; k++) {
              var dimk = dims[k];
              var val = storeArr[dimk][rawIndex];
              if (val < range[dimk][0] || val > range[dimk][1]) {
                keep = false;
              }
            }
            if (keep) {
              newIndices[offset++] = newStore.getRawIndex(i);
            }
          }
        }
      }
      if (offset < originalCount) {
        newStore._indices = newIndices;
      }
      newStore._count = offset;
      newStore._extent = [];
      newStore._updateGetRawIdx();
      return newStore;
    };
    DataStore2.prototype.map = function(dims, cb) {
      var target = this.clone(dims);
      this._updateDims(target, dims, cb);
      return target;
    };
    DataStore2.prototype.modify = function(dims, cb) {
      this._updateDims(this, dims, cb);
    };
    DataStore2.prototype._updateDims = function(target, dims, cb) {
      var targetChunks = target._chunks;
      var tmpRetValue = [];
      var dimSize = dims.length;
      var dataCount = target.count();
      var values = [];
      var rawExtent = target._rawExtent;
      for (var i = 0; i < dims.length; i++) {
        rawExtent[dims[i]] = getInitialExtent();
      }
      for (var dataIndex = 0; dataIndex < dataCount; dataIndex++) {
        var rawIndex = target.getRawIndex(dataIndex);
        for (var k = 0; k < dimSize; k++) {
          values[k] = targetChunks[dims[k]][rawIndex];
        }
        values[dimSize] = dataIndex;
        var retValue = cb && cb.apply(null, values);
        if (retValue != null) {
          if (typeof retValue !== "object") {
            tmpRetValue[0] = retValue;
            retValue = tmpRetValue;
          }
          for (var i = 0; i < retValue.length; i++) {
            var dim = dims[i];
            var val = retValue[i];
            var rawExtentOnDim = rawExtent[dim];
            var dimStore = targetChunks[dim];
            if (dimStore) {
              dimStore[rawIndex] = val;
            }
            if (val < rawExtentOnDim[0]) {
              rawExtentOnDim[0] = val;
            }
            if (val > rawExtentOnDim[1]) {
              rawExtentOnDim[1] = val;
            }
          }
        }
      }
    };
    DataStore2.prototype.lttbDownSample = function(valueDimension, rate) {
      var target = this.clone([valueDimension], true);
      var targetStorage = target._chunks;
      var dimStore = targetStorage[valueDimension];
      var len2 = this.count();
      var sampledIndex = 0;
      var frameSize = Math.floor(1 / rate);
      var currentRawIndex = this.getRawIndex(0);
      var maxArea;
      var area;
      var nextRawIndex;
      var newIndices = new (getIndicesCtor(this._rawCount))(Math.min((Math.ceil(len2 / frameSize) + 2) * 2, len2));
      newIndices[sampledIndex++] = currentRawIndex;
      for (var i = 1; i < len2 - 1; i += frameSize) {
        var nextFrameStart = Math.min(i + frameSize, len2 - 1);
        var nextFrameEnd = Math.min(i + frameSize * 2, len2);
        var avgX = (nextFrameEnd + nextFrameStart) / 2;
        var avgY = 0;
        for (var idx = nextFrameStart; idx < nextFrameEnd; idx++) {
          var rawIndex = this.getRawIndex(idx);
          var y = dimStore[rawIndex];
          if (isNaN(y)) {
            continue;
          }
          avgY += y;
        }
        avgY /= nextFrameEnd - nextFrameStart;
        var frameStart = i;
        var frameEnd = Math.min(i + frameSize, len2);
        var pointAX = i - 1;
        var pointAY = dimStore[currentRawIndex];
        maxArea = -1;
        nextRawIndex = frameStart;
        var firstNaNIndex = -1;
        var countNaN = 0;
        for (var idx = frameStart; idx < frameEnd; idx++) {
          var rawIndex = this.getRawIndex(idx);
          var y = dimStore[rawIndex];
          if (isNaN(y)) {
            countNaN++;
            if (firstNaNIndex < 0) {
              firstNaNIndex = rawIndex;
            }
            continue;
          }
          area = Math.abs((pointAX - avgX) * (y - pointAY) - (pointAX - idx) * (avgY - pointAY));
          if (area > maxArea) {
            maxArea = area;
            nextRawIndex = rawIndex;
          }
        }
        if (countNaN > 0 && countNaN < frameEnd - frameStart) {
          newIndices[sampledIndex++] = Math.min(firstNaNIndex, nextRawIndex);
          nextRawIndex = Math.max(firstNaNIndex, nextRawIndex);
        }
        newIndices[sampledIndex++] = nextRawIndex;
        currentRawIndex = nextRawIndex;
      }
      newIndices[sampledIndex++] = this.getRawIndex(len2 - 1);
      target._count = sampledIndex;
      target._indices = newIndices;
      target.getRawIndex = this._getRawIdx;
      return target;
    };
    DataStore2.prototype.downSample = function(dimension, rate, sampleValue, sampleIndex) {
      var target = this.clone([dimension], true);
      var targetStorage = target._chunks;
      var frameValues = [];
      var frameSize = Math.floor(1 / rate);
      var dimStore = targetStorage[dimension];
      var len2 = this.count();
      var rawExtentOnDim = target._rawExtent[dimension] = getInitialExtent();
      var newIndices = new (getIndicesCtor(this._rawCount))(Math.ceil(len2 / frameSize));
      var offset = 0;
      for (var i = 0; i < len2; i += frameSize) {
        if (frameSize > len2 - i) {
          frameSize = len2 - i;
          frameValues.length = frameSize;
        }
        for (var k = 0; k < frameSize; k++) {
          var dataIdx = this.getRawIndex(i + k);
          frameValues[k] = dimStore[dataIdx];
        }
        var value = sampleValue(frameValues);
        var sampleFrameIdx = this.getRawIndex(Math.min(i + sampleIndex(frameValues, value) || 0, len2 - 1));
        dimStore[sampleFrameIdx] = value;
        if (value < rawExtentOnDim[0]) {
          rawExtentOnDim[0] = value;
        }
        if (value > rawExtentOnDim[1]) {
          rawExtentOnDim[1] = value;
        }
        newIndices[offset++] = sampleFrameIdx;
      }
      target._count = offset;
      target._indices = newIndices;
      target._updateGetRawIdx();
      return target;
    };
    DataStore2.prototype.each = function(dims, cb) {
      if (!this._count) {
        return;
      }
      var dimSize = dims.length;
      var chunks = this._chunks;
      for (var i = 0, len2 = this.count(); i < len2; i++) {
        var rawIdx = this.getRawIndex(i);
        switch (dimSize) {
          case 0:
            cb(i);
            break;
          case 1:
            cb(chunks[dims[0]][rawIdx], i);
            break;
          case 2:
            cb(chunks[dims[0]][rawIdx], chunks[dims[1]][rawIdx], i);
            break;
          default:
            var k = 0;
            var value = [];
            for (; k < dimSize; k++) {
              value[k] = chunks[dims[k]][rawIdx];
            }
            value[k] = i;
            cb.apply(null, value);
        }
      }
    };
    DataStore2.prototype.getDataExtent = function(dim) {
      var dimData = this._chunks[dim];
      var initialExtent = getInitialExtent();
      if (!dimData) {
        return initialExtent;
      }
      var currEnd = this.count();
      var useRaw = !this._indices;
      var dimExtent;
      if (useRaw) {
        return this._rawExtent[dim].slice();
      }
      dimExtent = this._extent[dim];
      if (dimExtent) {
        return dimExtent.slice();
      }
      dimExtent = initialExtent;
      var min3 = dimExtent[0];
      var max3 = dimExtent[1];
      for (var i = 0; i < currEnd; i++) {
        var rawIdx = this.getRawIndex(i);
        var value = dimData[rawIdx];
        value < min3 && (min3 = value);
        value > max3 && (max3 = value);
      }
      dimExtent = [min3, max3];
      this._extent[dim] = dimExtent;
      return dimExtent;
    };
    DataStore2.prototype.getRawDataItem = function(idx) {
      var rawIdx = this.getRawIndex(idx);
      if (!this._provider.persistent) {
        var val = [];
        var chunks = this._chunks;
        for (var i = 0; i < chunks.length; i++) {
          val.push(chunks[i][rawIdx]);
        }
        return val;
      } else {
        return this._provider.getItem(rawIdx);
      }
    };
    DataStore2.prototype.clone = function(clonedDims, ignoreIndices) {
      var target = new DataStore2();
      var chunks = this._chunks;
      var clonedDimsMap = clonedDims && reduce(clonedDims, function(obj, dimIdx) {
        obj[dimIdx] = true;
        return obj;
      }, {});
      if (clonedDimsMap) {
        for (var i = 0; i < chunks.length; i++) {
          target._chunks[i] = !clonedDimsMap[i] ? chunks[i] : cloneChunk(chunks[i]);
        }
      } else {
        target._chunks = chunks;
      }
      this._copyCommonProps(target);
      if (!ignoreIndices) {
        target._indices = this._cloneIndices();
      }
      target._updateGetRawIdx();
      return target;
    };
    DataStore2.prototype._copyCommonProps = function(target) {
      target._count = this._count;
      target._rawCount = this._rawCount;
      target._provider = this._provider;
      target._dimensions = this._dimensions;
      target._extent = clone(this._extent);
      target._rawExtent = clone(this._rawExtent);
    };
    DataStore2.prototype._cloneIndices = function() {
      if (this._indices) {
        var Ctor = this._indices.constructor;
        var indices = void 0;
        if (Ctor === Array) {
          var thisCount = this._indices.length;
          indices = new Ctor(thisCount);
          for (var i = 0; i < thisCount; i++) {
            indices[i] = this._indices[i];
          }
        } else {
          indices = new Ctor(this._indices);
        }
        return indices;
      }
      return null;
    };
    DataStore2.prototype._getRawIdxIdentity = function(idx) {
      return idx;
    };
    DataStore2.prototype._getRawIdx = function(idx) {
      if (idx < this._count && idx >= 0) {
        return this._indices[idx];
      }
      return -1;
    };
    DataStore2.prototype._updateGetRawIdx = function() {
      this.getRawIndex = this._indices ? this._getRawIdx : this._getRawIdxIdentity;
    };
    DataStore2.internalField = function() {
      function getDimValueSimply(dataItem, property, dataIndex, dimIndex) {
        return parseDataValue(dataItem[dimIndex], this._dimensions[dimIndex]);
      }
      defaultDimValueGetters = {
        arrayRows: getDimValueSimply,
        objectRows: function(dataItem, property, dataIndex, dimIndex) {
          return parseDataValue(dataItem[property], this._dimensions[dimIndex]);
        },
        keyedColumns: getDimValueSimply,
        original: function(dataItem, property, dataIndex, dimIndex) {
          var value = dataItem && (dataItem.value == null ? dataItem : dataItem.value);
          return parseDataValue(value instanceof Array ? value[dimIndex] : value, this._dimensions[dimIndex]);
        },
        typedArray: function(dataItem, property, dataIndex, dimIndex) {
          return dataItem[dimIndex];
        }
      };
    }();
    return DataStore2;
  }();
  var DataStore_default = DataStore;

  // node_modules/echarts/lib/data/helper/sourceManager.js
  var SourceManager = function() {
    function SourceManager2(sourceHost) {
      this._sourceList = [];
      this._storeList = [];
      this._upstreamSignList = [];
      this._versionSignBase = 0;
      this._dirty = true;
      this._sourceHost = sourceHost;
    }
    SourceManager2.prototype.dirty = function() {
      this._setLocalSource([], []);
      this._storeList = [];
      this._dirty = true;
    };
    SourceManager2.prototype._setLocalSource = function(sourceList, upstreamSignList) {
      this._sourceList = sourceList;
      this._upstreamSignList = upstreamSignList;
      this._versionSignBase++;
      if (this._versionSignBase > 9e10) {
        this._versionSignBase = 0;
      }
    };
    SourceManager2.prototype._getVersionSign = function() {
      return this._sourceHost.uid + "_" + this._versionSignBase;
    };
    SourceManager2.prototype.prepareSource = function() {
      if (this._isDirty()) {
        this._createSource();
        this._dirty = false;
      }
    };
    SourceManager2.prototype._createSource = function() {
      this._setLocalSource([], []);
      var sourceHost = this._sourceHost;
      var upSourceMgrList = this._getUpstreamSourceManagers();
      var hasUpstream = !!upSourceMgrList.length;
      var resultSourceList;
      var upstreamSignList;
      if (isSeries(sourceHost)) {
        var seriesModel = sourceHost;
        var data = void 0;
        var sourceFormat = void 0;
        var upSource = void 0;
        if (hasUpstream) {
          var upSourceMgr = upSourceMgrList[0];
          upSourceMgr.prepareSource();
          upSource = upSourceMgr.getSource();
          data = upSource.data;
          sourceFormat = upSource.sourceFormat;
          upstreamSignList = [upSourceMgr._getVersionSign()];
        } else {
          data = seriesModel.get("data", true);
          sourceFormat = isTypedArray(data) ? SOURCE_FORMAT_TYPED_ARRAY : SOURCE_FORMAT_ORIGINAL;
          upstreamSignList = [];
        }
        var newMetaRawOption = this._getSourceMetaRawOption() || {};
        var upMetaRawOption = upSource && upSource.metaRawOption || {};
        var seriesLayoutBy = retrieve2(newMetaRawOption.seriesLayoutBy, upMetaRawOption.seriesLayoutBy) || null;
        var sourceHeader = retrieve2(newMetaRawOption.sourceHeader, upMetaRawOption.sourceHeader);
        var dimensions = retrieve2(newMetaRawOption.dimensions, upMetaRawOption.dimensions);
        var needsCreateSource = seriesLayoutBy !== upMetaRawOption.seriesLayoutBy || !!sourceHeader !== !!upMetaRawOption.sourceHeader || dimensions;
        resultSourceList = needsCreateSource ? [createSource(data, {
          seriesLayoutBy,
          sourceHeader,
          dimensions
        }, sourceFormat)] : [];
      } else {
        var datasetModel = sourceHost;
        if (hasUpstream) {
          var result = this._applyTransform(upSourceMgrList);
          resultSourceList = result.sourceList;
          upstreamSignList = result.upstreamSignList;
        } else {
          var sourceData = datasetModel.get("source", true);
          resultSourceList = [createSource(sourceData, this._getSourceMetaRawOption(), null)];
          upstreamSignList = [];
        }
      }
      if (true) {
        assert(resultSourceList && upstreamSignList);
      }
      this._setLocalSource(resultSourceList, upstreamSignList);
    };
    SourceManager2.prototype._applyTransform = function(upMgrList) {
      var datasetModel = this._sourceHost;
      var transformOption = datasetModel.get("transform", true);
      var fromTransformResult = datasetModel.get("fromTransformResult", true);
      if (true) {
        assert(fromTransformResult != null || transformOption != null);
      }
      if (fromTransformResult != null) {
        var errMsg = "";
        if (upMgrList.length !== 1) {
          if (true) {
            errMsg = "When using `fromTransformResult`, there should be only one upstream dataset";
          }
          doThrow(errMsg);
        }
      }
      var sourceList;
      var upSourceList = [];
      var upstreamSignList = [];
      each(upMgrList, function(upMgr) {
        upMgr.prepareSource();
        var upSource = upMgr.getSource(fromTransformResult || 0);
        var errMsg2 = "";
        if (fromTransformResult != null && !upSource) {
          if (true) {
            errMsg2 = "Can not retrieve result by `fromTransformResult`: " + fromTransformResult;
          }
          doThrow(errMsg2);
        }
        upSourceList.push(upSource);
        upstreamSignList.push(upMgr._getVersionSign());
      });
      if (transformOption) {
        sourceList = applyDataTransform(transformOption, upSourceList, {
          datasetIndex: datasetModel.componentIndex
        });
      } else if (fromTransformResult != null) {
        sourceList = [cloneSourceShallow(upSourceList[0])];
      }
      return {
        sourceList,
        upstreamSignList
      };
    };
    SourceManager2.prototype._isDirty = function() {
      if (this._dirty) {
        return true;
      }
      var upSourceMgrList = this._getUpstreamSourceManagers();
      for (var i = 0; i < upSourceMgrList.length; i++) {
        var upSrcMgr = upSourceMgrList[i];
        if (upSrcMgr._isDirty() || this._upstreamSignList[i] !== upSrcMgr._getVersionSign()) {
          return true;
        }
      }
    };
    SourceManager2.prototype.getSource = function(sourceIndex) {
      sourceIndex = sourceIndex || 0;
      var source = this._sourceList[sourceIndex];
      if (!source) {
        var upSourceMgrList = this._getUpstreamSourceManagers();
        return upSourceMgrList[0] && upSourceMgrList[0].getSource(sourceIndex);
      }
      return source;
    };
    SourceManager2.prototype.getSharedDataStore = function(seriesDimRequest) {
      if (true) {
        assert(isSeries(this._sourceHost), "Can only call getDataStore on series source manager.");
      }
      var schema = seriesDimRequest.makeStoreSchema();
      return this._innerGetDataStore(schema.dimensions, seriesDimRequest.source, schema.hash);
    };
    SourceManager2.prototype._innerGetDataStore = function(storeDims, seriesSource, sourceReadKey) {
      var sourceIndex = 0;
      var storeList = this._storeList;
      var cachedStoreMap = storeList[sourceIndex];
      if (!cachedStoreMap) {
        cachedStoreMap = storeList[sourceIndex] = {};
      }
      var cachedStore = cachedStoreMap[sourceReadKey];
      if (!cachedStore) {
        var upSourceMgr = this._getUpstreamSourceManagers()[0];
        if (isSeries(this._sourceHost) && upSourceMgr) {
          cachedStore = upSourceMgr._innerGetDataStore(storeDims, seriesSource, sourceReadKey);
        } else {
          cachedStore = new DataStore_default();
          cachedStore.initData(new DefaultDataProvider(seriesSource, storeDims.length), storeDims);
        }
        cachedStoreMap[sourceReadKey] = cachedStore;
      }
      return cachedStore;
    };
    SourceManager2.prototype._getUpstreamSourceManagers = function() {
      var sourceHost = this._sourceHost;
      if (isSeries(sourceHost)) {
        var datasetModel = querySeriesUpstreamDatasetModel(sourceHost);
        return !datasetModel ? [] : [datasetModel.getSourceManager()];
      } else {
        return map(queryDatasetUpstreamDatasetModels(sourceHost), function(datasetModel2) {
          return datasetModel2.getSourceManager();
        });
      }
    };
    SourceManager2.prototype._getSourceMetaRawOption = function() {
      var sourceHost = this._sourceHost;
      var seriesLayoutBy;
      var sourceHeader;
      var dimensions;
      if (isSeries(sourceHost)) {
        seriesLayoutBy = sourceHost.get("seriesLayoutBy", true);
        sourceHeader = sourceHost.get("sourceHeader", true);
        dimensions = sourceHost.get("dimensions", true);
      } else if (!this._getUpstreamSourceManagers().length) {
        var model = sourceHost;
        seriesLayoutBy = model.get("seriesLayoutBy", true);
        sourceHeader = model.get("sourceHeader", true);
        dimensions = model.get("dimensions", true);
      }
      return {
        seriesLayoutBy,
        sourceHeader,
        dimensions
      };
    };
    return SourceManager2;
  }();
  function disableTransformOptionMerge(datasetModel) {
    var transformOption = datasetModel.option.transform;
    transformOption && setAsPrimitive(datasetModel.option.transform);
  }
  function isSeries(sourceHost) {
    return sourceHost.mainType === "series";
  }
  function doThrow(errMsg) {
    throw new Error(errMsg);
  }

  // node_modules/echarts/lib/component/tooltip/tooltipMarkup.js
  var TOOLTIP_LINE_HEIGHT_CSS = "line-height:1";
  function getTooltipTextStyle(textStyle, renderMode) {
    var nameFontColor = textStyle.color || "#6e7079";
    var nameFontSize = textStyle.fontSize || 12;
    var nameFontWeight = textStyle.fontWeight || "400";
    var valueFontColor = textStyle.color || "#464646";
    var valueFontSize = textStyle.fontSize || 14;
    var valueFontWeight = textStyle.fontWeight || "900";
    if (renderMode === "html") {
      return {
        nameStyle: "font-size:" + encodeHTML(nameFontSize + "") + "px;color:" + encodeHTML(nameFontColor) + ";font-weight:" + encodeHTML(nameFontWeight + ""),
        valueStyle: "font-size:" + encodeHTML(valueFontSize + "") + "px;color:" + encodeHTML(valueFontColor) + ";font-weight:" + encodeHTML(valueFontWeight + "")
      };
    } else {
      return {
        nameStyle: {
          fontSize: nameFontSize,
          fill: nameFontColor,
          fontWeight: nameFontWeight
        },
        valueStyle: {
          fontSize: valueFontSize,
          fill: valueFontColor,
          fontWeight: valueFontWeight
        }
      };
    }
  }
  var HTML_GAPS = [0, 10, 20, 30];
  var RICH_TEXT_GAPS = ["", "\n", "\n\n", "\n\n\n"];
  function createTooltipMarkup(type, option) {
    option.type = type;
    return option;
  }
  function isSectionFragment(frag) {
    return frag.type === "section";
  }
  function getBuilder(frag) {
    return isSectionFragment(frag) ? buildSection : buildNameValue;
  }
  function getBlockGapLevel(frag) {
    if (isSectionFragment(frag)) {
      var gapLevel_1 = 0;
      var subBlockLen = frag.blocks.length;
      var hasInnerGap_1 = subBlockLen > 1 || subBlockLen > 0 && !frag.noHeader;
      each(frag.blocks, function(subBlock) {
        var subGapLevel = getBlockGapLevel(subBlock);
        if (subGapLevel >= gapLevel_1) {
          gapLevel_1 = subGapLevel + +(hasInnerGap_1 && (!subGapLevel || isSectionFragment(subBlock) && !subBlock.noHeader));
        }
      });
      return gapLevel_1;
    }
    return 0;
  }
  function buildSection(ctx, fragment, topMarginForOuterGap, toolTipTextStyle) {
    var noHeader = fragment.noHeader;
    var gaps = getGap(getBlockGapLevel(fragment));
    var subMarkupTextList = [];
    var subBlocks = fragment.blocks || [];
    assert(!subBlocks || isArray(subBlocks));
    subBlocks = subBlocks || [];
    var orderMode = ctx.orderMode;
    if (fragment.sortBlocks && orderMode) {
      subBlocks = subBlocks.slice();
      var orderMap = {
        valueAsc: "asc",
        valueDesc: "desc"
      };
      if (hasOwn(orderMap, orderMode)) {
        var comparator_1 = new SortOrderComparator(orderMap[orderMode], null);
        subBlocks.sort(function(a, b) {
          return comparator_1.evaluate(a.sortParam, b.sortParam);
        });
      } else if (orderMode === "seriesDesc") {
        subBlocks.reverse();
      }
    }
    each(subBlocks, function(subBlock, idx) {
      var valueFormatter = fragment.valueFormatter;
      var subMarkupText2 = getBuilder(subBlock)(valueFormatter ? extend(extend({}, ctx), {
        valueFormatter
      }) : ctx, subBlock, idx > 0 ? gaps.html : 0, toolTipTextStyle);
      subMarkupText2 != null && subMarkupTextList.push(subMarkupText2);
    });
    var subMarkupText = ctx.renderMode === "richText" ? subMarkupTextList.join(gaps.richText) : wrapBlockHTML(subMarkupTextList.join(""), noHeader ? topMarginForOuterGap : gaps.html);
    if (noHeader) {
      return subMarkupText;
    }
    var displayableHeader = makeValueReadable(fragment.header, "ordinal", ctx.useUTC);
    var nameStyle = getTooltipTextStyle(toolTipTextStyle, ctx.renderMode).nameStyle;
    if (ctx.renderMode === "richText") {
      return wrapInlineNameRichText(ctx, displayableHeader, nameStyle) + gaps.richText + subMarkupText;
    } else {
      return wrapBlockHTML('<div style="' + nameStyle + ";" + TOOLTIP_LINE_HEIGHT_CSS + ';">' + encodeHTML(displayableHeader) + "</div>" + subMarkupText, topMarginForOuterGap);
    }
  }
  function buildNameValue(ctx, fragment, topMarginForOuterGap, toolTipTextStyle) {
    var renderMode = ctx.renderMode;
    var noName = fragment.noName;
    var noValue = fragment.noValue;
    var noMarker = !fragment.markerType;
    var name = fragment.name;
    var useUTC = ctx.useUTC;
    var valueFormatter = fragment.valueFormatter || ctx.valueFormatter || function(value) {
      value = isArray(value) ? value : [value];
      return map(value, function(val, idx) {
        return makeValueReadable(val, isArray(valueTypeOption) ? valueTypeOption[idx] : valueTypeOption, useUTC);
      });
    };
    if (noName && noValue) {
      return;
    }
    var markerStr = noMarker ? "" : ctx.markupStyleCreator.makeTooltipMarker(fragment.markerType, fragment.markerColor || "#333", renderMode);
    var readableName = noName ? "" : makeValueReadable(name, "ordinal", useUTC);
    var valueTypeOption = fragment.valueType;
    var readableValueList = noValue ? [] : valueFormatter(fragment.value);
    var valueAlignRight = !noMarker || !noName;
    var valueCloseToMarker = !noMarker && noName;
    var _a2 = getTooltipTextStyle(toolTipTextStyle, renderMode), nameStyle = _a2.nameStyle, valueStyle = _a2.valueStyle;
    return renderMode === "richText" ? (noMarker ? "" : markerStr) + (noName ? "" : wrapInlineNameRichText(ctx, readableName, nameStyle)) + (noValue ? "" : wrapInlineValueRichText(ctx, readableValueList, valueAlignRight, valueCloseToMarker, valueStyle)) : wrapBlockHTML((noMarker ? "" : markerStr) + (noName ? "" : wrapInlineNameHTML(readableName, !noMarker, nameStyle)) + (noValue ? "" : wrapInlineValueHTML(readableValueList, valueAlignRight, valueCloseToMarker, valueStyle)), topMarginForOuterGap);
  }
  function buildTooltipMarkup(fragment, markupStyleCreator, renderMode, orderMode, useUTC, toolTipTextStyle) {
    if (!fragment) {
      return;
    }
    var builder = getBuilder(fragment);
    var ctx = {
      useUTC,
      renderMode,
      orderMode,
      markupStyleCreator,
      valueFormatter: fragment.valueFormatter
    };
    return builder(ctx, fragment, 0, toolTipTextStyle);
  }
  function getGap(gapLevel) {
    return {
      html: HTML_GAPS[gapLevel],
      richText: RICH_TEXT_GAPS[gapLevel]
    };
  }
  function wrapBlockHTML(encodedContent, topGap) {
    var clearfix = '<div style="clear:both"></div>';
    var marginCSS = "margin: " + topGap + "px 0 0";
    return '<div style="' + marginCSS + ";" + TOOLTIP_LINE_HEIGHT_CSS + ';">' + encodedContent + clearfix + "</div>";
  }
  function wrapInlineNameHTML(name, leftHasMarker, style) {
    var marginCss = leftHasMarker ? "margin-left:2px" : "";
    return '<span style="' + style + ";" + marginCss + '">' + encodeHTML(name) + "</span>";
  }
  function wrapInlineValueHTML(valueList, alignRight, valueCloseToMarker, style) {
    var paddingStr = valueCloseToMarker ? "10px" : "20px";
    var alignCSS = alignRight ? "float:right;margin-left:" + paddingStr : "";
    valueList = isArray(valueList) ? valueList : [valueList];
    return '<span style="' + alignCSS + ";" + style + '">' + map(valueList, function(value) {
      return encodeHTML(value);
    }).join("&nbsp;&nbsp;") + "</span>";
  }
  function wrapInlineNameRichText(ctx, name, style) {
    return ctx.markupStyleCreator.wrapRichTextStyle(name, style);
  }
  function wrapInlineValueRichText(ctx, values, alignRight, valueCloseToMarker, style) {
    var styles = [style];
    var paddingLeft = valueCloseToMarker ? 10 : 20;
    alignRight && styles.push({
      padding: [0, 0, 0, paddingLeft],
      align: "right"
    });
    return ctx.markupStyleCreator.wrapRichTextStyle(isArray(values) ? values.join("  ") : values, styles);
  }
  function retrieveVisualColorForTooltipMarker(series, dataIndex) {
    var style = series.getData().getItemVisual(dataIndex, "style");
    var color = style[series.visualDrawType];
    return convertToColorString(color);
  }
  function getPaddingFromTooltipModel(model, renderMode) {
    var padding = model.get("padding");
    return padding != null ? padding : renderMode === "richText" ? [8, 10] : 10;
  }
  var TooltipMarkupStyleCreator = function() {
    function TooltipMarkupStyleCreator2() {
      this.richTextStyles = {};
      this._nextStyleNameId = getRandomIdBase();
    }
    TooltipMarkupStyleCreator2.prototype._generateStyleName = function() {
      return "__EC_aUTo_" + this._nextStyleNameId++;
    };
    TooltipMarkupStyleCreator2.prototype.makeTooltipMarker = function(markerType, colorStr, renderMode) {
      var markerId = renderMode === "richText" ? this._generateStyleName() : null;
      var marker = getTooltipMarker({
        color: colorStr,
        type: markerType,
        renderMode,
        markerId
      });
      if (isString(marker)) {
        return marker;
      } else {
        if (true) {
          assert(markerId);
        }
        this.richTextStyles[markerId] = marker.style;
        return marker.content;
      }
    };
    TooltipMarkupStyleCreator2.prototype.wrapRichTextStyle = function(text, styles) {
      var finalStl = {};
      if (isArray(styles)) {
        each(styles, function(stl) {
          return extend(finalStl, stl);
        });
      } else {
        extend(finalStl, styles);
      }
      var styleName = this._generateStyleName();
      this.richTextStyles[styleName] = finalStl;
      return "{" + styleName + "|" + text + "}";
    };
    return TooltipMarkupStyleCreator2;
  }();

  // node_modules/echarts/lib/component/tooltip/seriesFormatTooltip.js
  function defaultSeriesFormatTooltip(opt) {
    var series = opt.series;
    var dataIndex = opt.dataIndex;
    var multipleSeries = opt.multipleSeries;
    var data = series.getData();
    var tooltipDims = data.mapDimensionsAll("defaultedTooltip");
    var tooltipDimLen = tooltipDims.length;
    var value = series.getRawValue(dataIndex);
    var isValueArr = isArray(value);
    var markerColor = retrieveVisualColorForTooltipMarker(series, dataIndex);
    var inlineValue;
    var inlineValueType;
    var subBlocks;
    var sortParam;
    if (tooltipDimLen > 1 || isValueArr && !tooltipDimLen) {
      var formatArrResult = formatTooltipArrayValue(value, series, dataIndex, tooltipDims, markerColor);
      inlineValue = formatArrResult.inlineValues;
      inlineValueType = formatArrResult.inlineValueTypes;
      subBlocks = formatArrResult.blocks;
      sortParam = formatArrResult.inlineValues[0];
    } else if (tooltipDimLen) {
      var dimInfo = data.getDimensionInfo(tooltipDims[0]);
      sortParam = inlineValue = retrieveRawValue(data, dataIndex, tooltipDims[0]);
      inlineValueType = dimInfo.type;
    } else {
      sortParam = inlineValue = isValueArr ? value[0] : value;
    }
    var seriesNameSpecified = isNameSpecified(series);
    var seriesName = seriesNameSpecified && series.name || "";
    var itemName = data.getName(dataIndex);
    var inlineName = multipleSeries ? seriesName : itemName;
    return createTooltipMarkup("section", {
      header: seriesName,
      noHeader: multipleSeries || !seriesNameSpecified,
      sortParam,
      blocks: [createTooltipMarkup("nameValue", {
        markerType: "item",
        markerColor,
        name: inlineName,
        noName: !trim(inlineName),
        value: inlineValue,
        valueType: inlineValueType
      })].concat(subBlocks || [])
    });
  }
  function formatTooltipArrayValue(value, series, dataIndex, tooltipDims, colorStr) {
    var data = series.getData();
    var isValueMultipleLine = reduce(value, function(isValueMultipleLine2, val, idx) {
      var dimItem = data.getDimensionInfo(idx);
      return isValueMultipleLine2 = isValueMultipleLine2 || dimItem && dimItem.tooltip !== false && dimItem.displayName != null;
    }, false);
    var inlineValues = [];
    var inlineValueTypes = [];
    var blocks = [];
    tooltipDims.length ? each(tooltipDims, function(dim) {
      setEachItem(retrieveRawValue(data, dataIndex, dim), dim);
    }) : each(value, setEachItem);
    function setEachItem(val, dim) {
      var dimInfo = data.getDimensionInfo(dim);
      if (!dimInfo || dimInfo.otherDims.tooltip === false) {
        return;
      }
      if (isValueMultipleLine) {
        blocks.push(createTooltipMarkup("nameValue", {
          markerType: "subItem",
          markerColor: colorStr,
          name: dimInfo.displayName,
          value: val,
          valueType: dimInfo.type
        }));
      } else {
        inlineValues.push(val);
        inlineValueTypes.push(dimInfo.type);
      }
    }
    return {
      inlineValues,
      inlineValueTypes,
      blocks
    };
  }

  // node_modules/echarts/lib/model/Series.js
  var inner2 = makeInner();
  function getSelectionKey(data, dataIndex) {
    return data.getName(dataIndex) || data.getId(dataIndex);
  }
  var SERIES_UNIVERSAL_TRANSITION_PROP = "__universalTransitionEnabled";
  var SeriesModel = function(_super) {
    __extends(SeriesModel2, _super);
    function SeriesModel2() {
      var _this = _super !== null && _super.apply(this, arguments) || this;
      _this._selectedDataIndicesMap = {};
      return _this;
    }
    SeriesModel2.prototype.init = function(option, parentModel, ecModel) {
      this.seriesIndex = this.componentIndex;
      this.dataTask = createTask({
        count: dataTaskCount,
        reset: dataTaskReset
      });
      this.dataTask.context = {
        model: this
      };
      this.mergeDefaultAndTheme(option, ecModel);
      var sourceManager = inner2(this).sourceManager = new SourceManager(this);
      sourceManager.prepareSource();
      var data = this.getInitialData(option, ecModel);
      wrapData(data, this);
      this.dataTask.context.data = data;
      if (true) {
        assert(data, "getInitialData returned invalid data.");
      }
      inner2(this).dataBeforeProcessed = data;
      autoSeriesName(this);
      this._initSelectedMapFromData(data);
    };
    SeriesModel2.prototype.mergeDefaultAndTheme = function(option, ecModel) {
      var layoutMode = fetchLayoutMode(this);
      var inputPositionParams = layoutMode ? getLayoutParams(option) : {};
      var themeSubType = this.subType;
      if (Component_default.hasClass(themeSubType)) {
        themeSubType += "Series";
      }
      merge(option, ecModel.getTheme().get(this.subType));
      merge(option, this.getDefaultOption());
      defaultEmphasis(option, "label", ["show"]);
      this.fillDataTextStyle(option.data);
      if (layoutMode) {
        mergeLayoutParam(option, inputPositionParams, layoutMode);
      }
    };
    SeriesModel2.prototype.mergeOption = function(newSeriesOption, ecModel) {
      newSeriesOption = merge(this.option, newSeriesOption, true);
      this.fillDataTextStyle(newSeriesOption.data);
      var layoutMode = fetchLayoutMode(this);
      if (layoutMode) {
        mergeLayoutParam(this.option, newSeriesOption, layoutMode);
      }
      var sourceManager = inner2(this).sourceManager;
      sourceManager.dirty();
      sourceManager.prepareSource();
      var data = this.getInitialData(newSeriesOption, ecModel);
      wrapData(data, this);
      this.dataTask.dirty();
      this.dataTask.context.data = data;
      inner2(this).dataBeforeProcessed = data;
      autoSeriesName(this);
      this._initSelectedMapFromData(data);
    };
    SeriesModel2.prototype.fillDataTextStyle = function(data) {
      if (data && !isTypedArray(data)) {
        var props = ["show"];
        for (var i = 0; i < data.length; i++) {
          if (data[i] && data[i].label) {
            defaultEmphasis(data[i], "label", props);
          }
        }
      }
    };
    SeriesModel2.prototype.getInitialData = function(option, ecModel) {
      return;
    };
    SeriesModel2.prototype.appendData = function(params) {
      var data = this.getRawData();
      data.appendData(params.data);
    };
    SeriesModel2.prototype.getData = function(dataType) {
      var task = getCurrentTask(this);
      if (task) {
        var data = task.context.data;
        return dataType == null ? data : data.getLinkedData(dataType);
      } else {
        return inner2(this).data;
      }
    };
    SeriesModel2.prototype.getAllData = function() {
      var mainData = this.getData();
      return mainData && mainData.getLinkedDataAll ? mainData.getLinkedDataAll() : [{
        data: mainData
      }];
    };
    SeriesModel2.prototype.setData = function(data) {
      var task = getCurrentTask(this);
      if (task) {
        var context = task.context;
        context.outputData = data;
        if (task !== this.dataTask) {
          context.data = data;
        }
      }
      inner2(this).data = data;
    };
    SeriesModel2.prototype.getEncode = function() {
      var encode = this.get("encode", true);
      if (encode) {
        return createHashMap(encode);
      }
    };
    SeriesModel2.prototype.getSourceManager = function() {
      return inner2(this).sourceManager;
    };
    SeriesModel2.prototype.getSource = function() {
      return this.getSourceManager().getSource();
    };
    SeriesModel2.prototype.getRawData = function() {
      return inner2(this).dataBeforeProcessed;
    };
    SeriesModel2.prototype.getColorBy = function() {
      var colorBy = this.get("colorBy");
      return colorBy || "series";
    };
    SeriesModel2.prototype.isColorBySeries = function() {
      return this.getColorBy() === "series";
    };
    SeriesModel2.prototype.getBaseAxis = function() {
      var coordSys = this.coordinateSystem;
      return coordSys && coordSys.getBaseAxis && coordSys.getBaseAxis();
    };
    SeriesModel2.prototype.formatTooltip = function(dataIndex, multipleSeries, dataType) {
      return defaultSeriesFormatTooltip({
        series: this,
        dataIndex,
        multipleSeries
      });
    };
    SeriesModel2.prototype.isAnimationEnabled = function() {
      var ecModel = this.ecModel;
      if (env_default.node && !(ecModel && ecModel.ssr)) {
        return false;
      }
      var animationEnabled = this.getShallow("animation");
      if (animationEnabled) {
        if (this.getData().count() > this.getShallow("animationThreshold")) {
          animationEnabled = false;
        }
      }
      return !!animationEnabled;
    };
    SeriesModel2.prototype.restoreData = function() {
      this.dataTask.dirty();
    };
    SeriesModel2.prototype.getColorFromPalette = function(name, scope, requestColorNum) {
      var ecModel = this.ecModel;
      var color = PaletteMixin.prototype.getColorFromPalette.call(this, name, scope, requestColorNum);
      if (!color) {
        color = ecModel.getColorFromPalette(name, scope, requestColorNum);
      }
      return color;
    };
    SeriesModel2.prototype.coordDimToDataDim = function(coordDim) {
      return this.getRawData().mapDimensionsAll(coordDim);
    };
    SeriesModel2.prototype.getProgressive = function() {
      return this.get("progressive");
    };
    SeriesModel2.prototype.getProgressiveThreshold = function() {
      return this.get("progressiveThreshold");
    };
    SeriesModel2.prototype.select = function(innerDataIndices, dataType) {
      this._innerSelect(this.getData(dataType), innerDataIndices);
    };
    SeriesModel2.prototype.unselect = function(innerDataIndices, dataType) {
      var selectedMap = this.option.selectedMap;
      if (!selectedMap) {
        return;
      }
      var selectedMode = this.option.selectedMode;
      var data = this.getData(dataType);
      if (selectedMode === "series" || selectedMap === "all") {
        this.option.selectedMap = {};
        this._selectedDataIndicesMap = {};
        return;
      }
      for (var i = 0; i < innerDataIndices.length; i++) {
        var dataIndex = innerDataIndices[i];
        var nameOrId = getSelectionKey(data, dataIndex);
        selectedMap[nameOrId] = false;
        this._selectedDataIndicesMap[nameOrId] = -1;
      }
    };
    SeriesModel2.prototype.toggleSelect = function(innerDataIndices, dataType) {
      var tmpArr2 = [];
      for (var i = 0; i < innerDataIndices.length; i++) {
        tmpArr2[0] = innerDataIndices[i];
        this.isSelected(innerDataIndices[i], dataType) ? this.unselect(tmpArr2, dataType) : this.select(tmpArr2, dataType);
      }
    };
    SeriesModel2.prototype.getSelectedDataIndices = function() {
      if (this.option.selectedMap === "all") {
        return [].slice.call(this.getData().getIndices());
      }
      var selectedDataIndicesMap = this._selectedDataIndicesMap;
      var nameOrIds = keys(selectedDataIndicesMap);
      var dataIndices = [];
      for (var i = 0; i < nameOrIds.length; i++) {
        var dataIndex = selectedDataIndicesMap[nameOrIds[i]];
        if (dataIndex >= 0) {
          dataIndices.push(dataIndex);
        }
      }
      return dataIndices;
    };
    SeriesModel2.prototype.isSelected = function(dataIndex, dataType) {
      var selectedMap = this.option.selectedMap;
      if (!selectedMap) {
        return false;
      }
      var data = this.getData(dataType);
      return (selectedMap === "all" || selectedMap[getSelectionKey(data, dataIndex)]) && !data.getItemModel(dataIndex).get(["select", "disabled"]);
    };
    SeriesModel2.prototype.isUniversalTransitionEnabled = function() {
      if (this[SERIES_UNIVERSAL_TRANSITION_PROP]) {
        return true;
      }
      var universalTransitionOpt = this.option.universalTransition;
      if (!universalTransitionOpt) {
        return false;
      }
      if (universalTransitionOpt === true) {
        return true;
      }
      return universalTransitionOpt && universalTransitionOpt.enabled;
    };
    SeriesModel2.prototype._innerSelect = function(data, innerDataIndices) {
      var _a2, _b2;
      var option = this.option;
      var selectedMode = option.selectedMode;
      var len2 = innerDataIndices.length;
      if (!selectedMode || !len2) {
        return;
      }
      if (selectedMode === "series") {
        option.selectedMap = "all";
      } else if (selectedMode === "multiple") {
        if (!isObject(option.selectedMap)) {
          option.selectedMap = {};
        }
        var selectedMap = option.selectedMap;
        for (var i = 0; i < len2; i++) {
          var dataIndex = innerDataIndices[i];
          var nameOrId = getSelectionKey(data, dataIndex);
          selectedMap[nameOrId] = true;
          this._selectedDataIndicesMap[nameOrId] = data.getRawIndex(dataIndex);
        }
      } else if (selectedMode === "single" || selectedMode === true) {
        var lastDataIndex = innerDataIndices[len2 - 1];
        var nameOrId = getSelectionKey(data, lastDataIndex);
        option.selectedMap = (_a2 = {}, _a2[nameOrId] = true, _a2);
        this._selectedDataIndicesMap = (_b2 = {}, _b2[nameOrId] = data.getRawIndex(lastDataIndex), _b2);
      }
    };
    SeriesModel2.prototype._initSelectedMapFromData = function(data) {
      if (this.option.selectedMap) {
        return;
      }
      var dataIndices = [];
      if (data.hasItemOption) {
        data.each(function(idx) {
          var rawItem = data.getRawDataItem(idx);
          if (rawItem && rawItem.selected) {
            dataIndices.push(idx);
          }
        });
      }
      if (dataIndices.length > 0) {
        this._innerSelect(data, dataIndices);
      }
    };
    SeriesModel2.registerClass = function(clz) {
      return Component_default.registerClass(clz);
    };
    SeriesModel2.protoInitialize = function() {
      var proto2 = SeriesModel2.prototype;
      proto2.type = "series.__base__";
      proto2.seriesIndex = 0;
      proto2.ignoreStyleOnData = false;
      proto2.hasSymbolVisual = false;
      proto2.defaultSymbol = "circle";
      proto2.visualStyleAccessPath = "itemStyle";
      proto2.visualDrawType = "fill";
    }();
    return SeriesModel2;
  }(Component_default);
  mixin(SeriesModel, DataFormatMixin);
  mixin(SeriesModel, PaletteMixin);
  mountExtend(SeriesModel, Component_default);
  function autoSeriesName(seriesModel) {
    var name = seriesModel.name;
    if (!isNameSpecified(seriesModel)) {
      seriesModel.name = getSeriesAutoName(seriesModel) || name;
    }
  }
  function getSeriesAutoName(seriesModel) {
    var data = seriesModel.getRawData();
    var dataDims = data.mapDimensionsAll("seriesName");
    var nameArr = [];
    each(dataDims, function(dataDim) {
      var dimInfo = data.getDimensionInfo(dataDim);
      dimInfo.displayName && nameArr.push(dimInfo.displayName);
    });
    return nameArr.join(" ");
  }
  function dataTaskCount(context) {
    return context.model.getRawData().count();
  }
  function dataTaskReset(context) {
    var seriesModel = context.model;
    seriesModel.setData(seriesModel.getRawData().cloneShallow());
    return dataTaskProgress;
  }
  function dataTaskProgress(param, context) {
    if (context.outputData && param.end > context.outputData.count()) {
      context.model.getRawData().cloneShallow(context.outputData);
    }
  }
  function wrapData(data, seriesModel) {
    each(concatArray(data.CHANGABLE_METHODS, data.DOWNSAMPLE_METHODS), function(methodName) {
      data.wrapMethod(methodName, curry(onDataChange, seriesModel));
    });
  }
  function onDataChange(seriesModel, newList) {
    var task = getCurrentTask(seriesModel);
    if (task) {
      task.setOutputEnd((newList || this).count());
    }
    return newList;
  }
  function getCurrentTask(seriesModel) {
    var scheduler = (seriesModel.ecModel || {}).scheduler;
    var pipeline = scheduler && scheduler.getPipeline(seriesModel.uid);
    if (pipeline) {
      var task = pipeline.currentTask;
      if (task) {
        var agentStubMap = task.agentStubMap;
        if (agentStubMap) {
          task = agentStubMap.get(seriesModel.uid);
        }
      }
      return task;
    }
  }
  var Series_default = SeriesModel;

  // node_modules/echarts/lib/view/Component.js
  var ComponentView = function() {
    function ComponentView2() {
      this.group = new Group_default();
      this.uid = getUID("viewComponent");
    }
    ComponentView2.prototype.init = function(ecModel, api) {
    };
    ComponentView2.prototype.render = function(model, ecModel, api, payload) {
    };
    ComponentView2.prototype.dispose = function(ecModel, api) {
    };
    ComponentView2.prototype.updateView = function(model, ecModel, api, payload) {
    };
    ComponentView2.prototype.updateLayout = function(model, ecModel, api, payload) {
    };
    ComponentView2.prototype.updateVisual = function(model, ecModel, api, payload) {
    };
    ComponentView2.prototype.toggleBlurSeries = function(seriesModels, isBlur, ecModel) {
    };
    ComponentView2.prototype.eachRendered = function(cb) {
      var group = this.group;
      if (group) {
        group.traverse(cb);
      }
    };
    return ComponentView2;
  }();
  enableClassExtend(ComponentView);
  enableClassManagement(ComponentView);
  var Component_default2 = ComponentView;

  // node_modules/echarts/lib/chart/helper/createRenderPlanner.js
  function createRenderPlanner() {
    var inner23 = makeInner();
    return function(seriesModel) {
      var fields = inner23(seriesModel);
      var pipelineContext = seriesModel.pipelineContext;
      var originalLarge = !!fields.large;
      var originalProgressive = !!fields.progressiveRender;
      var large = fields.large = !!(pipelineContext && pipelineContext.large);
      var progressive = fields.progressiveRender = !!(pipelineContext && pipelineContext.progressiveRender);
      return !!(originalLarge !== large || originalProgressive !== progressive) && "reset";
    };
  }

  // node_modules/echarts/lib/view/Chart.js
  var inner3 = makeInner();
  var renderPlanner = createRenderPlanner();
  var ChartView = function() {
    function ChartView2() {
      this.group = new Group_default();
      this.uid = getUID("viewChart");
      this.renderTask = createTask({
        plan: renderTaskPlan,
        reset: renderTaskReset
      });
      this.renderTask.context = {
        view: this
      };
    }
    ChartView2.prototype.init = function(ecModel, api) {
    };
    ChartView2.prototype.render = function(seriesModel, ecModel, api, payload) {
      if (true) {
        throw new Error("render method must been implemented");
      }
    };
    ChartView2.prototype.highlight = function(seriesModel, ecModel, api, payload) {
      var data = seriesModel.getData(payload && payload.dataType);
      if (!data) {
        if (true) {
          error("Unknown dataType " + payload.dataType);
        }
        return;
      }
      toggleHighlight(data, payload, "emphasis");
    };
    ChartView2.prototype.downplay = function(seriesModel, ecModel, api, payload) {
      var data = seriesModel.getData(payload && payload.dataType);
      if (!data) {
        if (true) {
          error("Unknown dataType " + payload.dataType);
        }
        return;
      }
      toggleHighlight(data, payload, "normal");
    };
    ChartView2.prototype.remove = function(ecModel, api) {
      this.group.removeAll();
    };
    ChartView2.prototype.dispose = function(ecModel, api) {
    };
    ChartView2.prototype.updateView = function(seriesModel, ecModel, api, payload) {
      this.render(seriesModel, ecModel, api, payload);
    };
    ChartView2.prototype.updateLayout = function(seriesModel, ecModel, api, payload) {
      this.render(seriesModel, ecModel, api, payload);
    };
    ChartView2.prototype.updateVisual = function(seriesModel, ecModel, api, payload) {
      this.render(seriesModel, ecModel, api, payload);
    };
    ChartView2.prototype.eachRendered = function(cb) {
      traverseElements(this.group, cb);
    };
    ChartView2.markUpdateMethod = function(payload, methodName) {
      inner3(payload).updateMethod = methodName;
    };
    ChartView2.protoInitialize = function() {
      var proto2 = ChartView2.prototype;
      proto2.type = "chart";
    }();
    return ChartView2;
  }();
  function elSetState(el, state, highlightDigit) {
    if (el && isHighDownDispatcher(el)) {
      (state === "emphasis" ? enterEmphasis : leaveEmphasis)(el, highlightDigit);
    }
  }
  function toggleHighlight(data, payload, state) {
    var dataIndex = queryDataIndex(data, payload);
    var highlightDigit = payload && payload.highlightKey != null ? getHighlightDigit(payload.highlightKey) : null;
    if (dataIndex != null) {
      each(normalizeToArray(dataIndex), function(dataIdx) {
        elSetState(data.getItemGraphicEl(dataIdx), state, highlightDigit);
      });
    } else {
      data.eachItemGraphicEl(function(el) {
        elSetState(el, state, highlightDigit);
      });
    }
  }
  enableClassExtend(ChartView, ["dispose"]);
  enableClassManagement(ChartView);
  function renderTaskPlan(context) {
    return renderPlanner(context.model);
  }
  function renderTaskReset(context) {
    var seriesModel = context.model;
    var ecModel = context.ecModel;
    var api = context.api;
    var payload = context.payload;
    var progressiveRender = seriesModel.pipelineContext.progressiveRender;
    var view = context.view;
    var updateMethod = payload && inner3(payload).updateMethod;
    var methodName = progressiveRender ? "incrementalPrepareRender" : updateMethod && view[updateMethod] ? updateMethod : "render";
    if (methodName !== "render") {
      view[methodName](seriesModel, ecModel, api, payload);
    }
    return progressMethodMap[methodName];
  }
  var progressMethodMap = {
    incrementalPrepareRender: {
      progress: function(params, context) {
        context.view.incrementalRender(params, context.model, context.ecModel, context.api, context.payload);
      }
    },
    render: {
      forceFirstProgress: true,
      progress: function(params, context) {
        context.view.render(context.model, context.ecModel, context.api, context.payload);
      }
    }
  };
  var Chart_default = ChartView;

  // node_modules/echarts/lib/util/throttle.js
  var ORIGIN_METHOD = "\0__throttleOriginMethod";
  var RATE = "\0__throttleRate";
  var THROTTLE_TYPE = "\0__throttleType";
  function throttle(fn, delay, debounce) {
    var currCall;
    var lastCall = 0;
    var lastExec = 0;
    var timer = null;
    var diff;
    var scope;
    var args;
    var debounceNextCall;
    delay = delay || 0;
    function exec() {
      lastExec = new Date().getTime();
      timer = null;
      fn.apply(scope, args || []);
    }
    var cb = function() {
      var cbArgs = [];
      for (var _i = 0; _i < arguments.length; _i++) {
        cbArgs[_i] = arguments[_i];
      }
      currCall = new Date().getTime();
      scope = this;
      args = cbArgs;
      var thisDelay = debounceNextCall || delay;
      var thisDebounce = debounceNextCall || debounce;
      debounceNextCall = null;
      diff = currCall - (thisDebounce ? lastCall : lastExec) - thisDelay;
      clearTimeout(timer);
      if (thisDebounce) {
        timer = setTimeout(exec, thisDelay);
      } else {
        if (diff >= 0) {
          exec();
        } else {
          timer = setTimeout(exec, -diff);
        }
      }
      lastCall = currCall;
    };
    cb.clear = function() {
      if (timer) {
        clearTimeout(timer);
        timer = null;
      }
    };
    cb.debounceNextCall = function(debounceDelay) {
      debounceNextCall = debounceDelay;
    };
    return cb;
  }
  function createOrUpdate(obj, fnAttr, rate, throttleType) {
    var fn = obj[fnAttr];
    if (!fn) {
      return;
    }
    var originFn = fn[ORIGIN_METHOD] || fn;
    var lastThrottleType = fn[THROTTLE_TYPE];
    var lastRate = fn[RATE];
    if (lastRate !== rate || lastThrottleType !== throttleType) {
      if (rate == null || !throttleType) {
        return obj[fnAttr] = originFn;
      }
      fn = obj[fnAttr] = throttle(originFn, rate, throttleType === "debounce");
      fn[ORIGIN_METHOD] = originFn;
      fn[THROTTLE_TYPE] = throttleType;
      fn[RATE] = rate;
    }
    return fn;
  }
  function clear(obj, fnAttr) {
    var fn = obj[fnAttr];
    if (fn && fn[ORIGIN_METHOD]) {
      fn.clear && fn.clear();
      obj[fnAttr] = fn[ORIGIN_METHOD];
    }
  }

  // node_modules/echarts/lib/visual/style.js
  var inner4 = makeInner();
  var defaultStyleMappers = {
    itemStyle: makeStyleMapper(ITEM_STYLE_KEY_MAP, true),
    lineStyle: makeStyleMapper(LINE_STYLE_KEY_MAP, true)
  };
  var defaultColorKey = {
    lineStyle: "stroke",
    itemStyle: "fill"
  };
  function getStyleMapper(seriesModel, stylePath) {
    var styleMapper = seriesModel.visualStyleMapper || defaultStyleMappers[stylePath];
    if (!styleMapper) {
      console.warn("Unkown style type '" + stylePath + "'.");
      return defaultStyleMappers.itemStyle;
    }
    return styleMapper;
  }
  function getDefaultColorKey(seriesModel, stylePath) {
    var colorKey = seriesModel.visualDrawType || defaultColorKey[stylePath];
    if (!colorKey) {
      console.warn("Unkown style type '" + stylePath + "'.");
      return "fill";
    }
    return colorKey;
  }
  var seriesStyleTask = {
    createOnAllSeries: true,
    performRawSeries: true,
    reset: function(seriesModel, ecModel) {
      var data = seriesModel.getData();
      var stylePath = seriesModel.visualStyleAccessPath || "itemStyle";
      var styleModel = seriesModel.getModel(stylePath);
      var getStyle2 = getStyleMapper(seriesModel, stylePath);
      var globalStyle = getStyle2(styleModel);
      var decalOption = styleModel.getShallow("decal");
      if (decalOption) {
        data.setVisual("decal", decalOption);
        decalOption.dirty = true;
      }
      var colorKey = getDefaultColorKey(seriesModel, stylePath);
      var color = globalStyle[colorKey];
      var colorCallback = isFunction(color) ? color : null;
      var hasAutoColor = globalStyle.fill === "auto" || globalStyle.stroke === "auto";
      if (!globalStyle[colorKey] || colorCallback || hasAutoColor) {
        var colorPalette2 = seriesModel.getColorFromPalette(seriesModel.name, null, ecModel.getSeriesCount());
        if (!globalStyle[colorKey]) {
          globalStyle[colorKey] = colorPalette2;
          data.setVisual("colorFromPalette", true);
        }
        globalStyle.fill = globalStyle.fill === "auto" || isFunction(globalStyle.fill) ? colorPalette2 : globalStyle.fill;
        globalStyle.stroke = globalStyle.stroke === "auto" || isFunction(globalStyle.stroke) ? colorPalette2 : globalStyle.stroke;
      }
      data.setVisual("style", globalStyle);
      data.setVisual("drawType", colorKey);
      if (!ecModel.isSeriesFiltered(seriesModel) && colorCallback) {
        data.setVisual("colorFromPalette", false);
        return {
          dataEach: function(data2, idx) {
            var dataParams = seriesModel.getDataParams(idx);
            var itemStyle = extend({}, globalStyle);
            itemStyle[colorKey] = colorCallback(dataParams);
            data2.setItemVisual(idx, "style", itemStyle);
          }
        };
      }
    }
  };
  var sharedModel = new Model_default();
  var dataStyleTask = {
    createOnAllSeries: true,
    performRawSeries: true,
    reset: function(seriesModel, ecModel) {
      if (seriesModel.ignoreStyleOnData || ecModel.isSeriesFiltered(seriesModel)) {
        return;
      }
      var data = seriesModel.getData();
      var stylePath = seriesModel.visualStyleAccessPath || "itemStyle";
      var getStyle2 = getStyleMapper(seriesModel, stylePath);
      var colorKey = data.getVisual("drawType");
      return {
        dataEach: data.hasItemOption ? function(data2, idx) {
          var rawItem = data2.getRawDataItem(idx);
          if (rawItem && rawItem[stylePath]) {
            sharedModel.option = rawItem[stylePath];
            var style = getStyle2(sharedModel);
            var existsStyle = data2.ensureUniqueItemVisual(idx, "style");
            extend(existsStyle, style);
            if (sharedModel.option.decal) {
              data2.setItemVisual(idx, "decal", sharedModel.option.decal);
              sharedModel.option.decal.dirty = true;
            }
            if (colorKey in style) {
              data2.setItemVisual(idx, "colorFromPalette", false);
            }
          }
        } : null
      };
    }
  };
  var dataColorPaletteTask = {
    performRawSeries: true,
    overallReset: function(ecModel) {
      var paletteScopeGroupByType = createHashMap();
      ecModel.eachSeries(function(seriesModel) {
        var colorBy = seriesModel.getColorBy();
        if (seriesModel.isColorBySeries()) {
          return;
        }
        var key = seriesModel.type + "-" + colorBy;
        var colorScope = paletteScopeGroupByType.get(key);
        if (!colorScope) {
          colorScope = {};
          paletteScopeGroupByType.set(key, colorScope);
        }
        inner4(seriesModel).scope = colorScope;
      });
      ecModel.eachSeries(function(seriesModel) {
        if (seriesModel.isColorBySeries() || ecModel.isSeriesFiltered(seriesModel)) {
          return;
        }
        var dataAll = seriesModel.getRawData();
        var idxMap = {};
        var data = seriesModel.getData();
        var colorScope = inner4(seriesModel).scope;
        var stylePath = seriesModel.visualStyleAccessPath || "itemStyle";
        var colorKey = getDefaultColorKey(seriesModel, stylePath);
        data.each(function(idx) {
          var rawIdx = data.getRawIndex(idx);
          idxMap[rawIdx] = idx;
        });
        dataAll.each(function(rawIdx) {
          var idx = idxMap[rawIdx];
          var fromPalette = data.getItemVisual(idx, "colorFromPalette");
          if (fromPalette) {
            var itemStyle = data.ensureUniqueItemVisual(idx, "style");
            var name_1 = dataAll.getName(rawIdx) || rawIdx + "";
            var dataCount = dataAll.count();
            itemStyle[colorKey] = seriesModel.getColorFromPalette(name_1, colorScope, dataCount);
          }
        });
      });
    }
  };

  // node_modules/echarts/lib/loading/default.js
  var PI5 = Math.PI;
  function defaultLoading(api, opts) {
    opts = opts || {};
    defaults(opts, {
      text: "loading",
      textColor: "#000",
      fontSize: 12,
      fontWeight: "normal",
      fontStyle: "normal",
      fontFamily: "sans-serif",
      maskColor: "rgba(255, 255, 255, 0.8)",
      showSpinner: true,
      color: "#5470c6",
      spinnerRadius: 10,
      lineWidth: 5,
      zlevel: 0
    });
    var group = new Group_default();
    var mask = new Rect_default({
      style: {
        fill: opts.maskColor
      },
      zlevel: opts.zlevel,
      z: 1e4
    });
    group.add(mask);
    var textContent = new Text_default({
      style: {
        text: opts.text,
        fill: opts.textColor,
        fontSize: opts.fontSize,
        fontWeight: opts.fontWeight,
        fontStyle: opts.fontStyle,
        fontFamily: opts.fontFamily
      },
      zlevel: opts.zlevel,
      z: 10001
    });
    var labelRect = new Rect_default({
      style: {
        fill: "none"
      },
      textContent,
      textConfig: {
        position: "right",
        distance: 10
      },
      zlevel: opts.zlevel,
      z: 10001
    });
    group.add(labelRect);
    var arc;
    if (opts.showSpinner) {
      arc = new Arc_default({
        shape: {
          startAngle: -PI5 / 2,
          endAngle: -PI5 / 2 + 0.1,
          r: opts.spinnerRadius
        },
        style: {
          stroke: opts.color,
          lineCap: "round",
          lineWidth: opts.lineWidth
        },
        zlevel: opts.zlevel,
        z: 10001
      });
      arc.animateShape(true).when(1e3, {
        endAngle: PI5 * 3 / 2
      }).start("circularInOut");
      arc.animateShape(true).when(1e3, {
        startAngle: PI5 * 3 / 2
      }).delay(300).start("circularInOut");
      group.add(arc);
    }
    group.resize = function() {
      var textWidth = textContent.getBoundingRect().width;
      var r = opts.showSpinner ? opts.spinnerRadius : 0;
      var cx = (api.getWidth() - r * 2 - (opts.showSpinner && textWidth ? 10 : 0) - textWidth) / 2 - (opts.showSpinner && textWidth ? 0 : 5 + textWidth / 2) + (opts.showSpinner ? 0 : textWidth / 2) + (textWidth ? 0 : r);
      var cy = api.getHeight() / 2;
      opts.showSpinner && arc.setShape({
        cx,
        cy
      });
      labelRect.setShape({
        x: cx - r,
        y: cy - r,
        width: r * 2,
        height: r * 2
      });
      mask.setShape({
        x: 0,
        y: 0,
        width: api.getWidth(),
        height: api.getHeight()
      });
    };
    group.resize();
    return group;
  }

  // node_modules/echarts/lib/core/Scheduler.js
  var Scheduler = function() {
    function Scheduler2(ecInstance, api, dataProcessorHandlers, visualHandlers) {
      this._stageTaskMap = createHashMap();
      this.ecInstance = ecInstance;
      this.api = api;
      dataProcessorHandlers = this._dataProcessorHandlers = dataProcessorHandlers.slice();
      visualHandlers = this._visualHandlers = visualHandlers.slice();
      this._allHandlers = dataProcessorHandlers.concat(visualHandlers);
    }
    Scheduler2.prototype.restoreData = function(ecModel, payload) {
      ecModel.restoreData(payload);
      this._stageTaskMap.each(function(taskRecord) {
        var overallTask = taskRecord.overallTask;
        overallTask && overallTask.dirty();
      });
    };
    Scheduler2.prototype.getPerformArgs = function(task, isBlock) {
      if (!task.__pipeline) {
        return;
      }
      var pipeline = this._pipelineMap.get(task.__pipeline.id);
      var pCtx = pipeline.context;
      var incremental = !isBlock && pipeline.progressiveEnabled && (!pCtx || pCtx.progressiveRender) && task.__idxInPipeline > pipeline.blockIndex;
      var step = incremental ? pipeline.step : null;
      var modDataCount = pCtx && pCtx.modDataCount;
      var modBy = modDataCount != null ? Math.ceil(modDataCount / step) : null;
      return {
        step,
        modBy,
        modDataCount
      };
    };
    Scheduler2.prototype.getPipeline = function(pipelineId) {
      return this._pipelineMap.get(pipelineId);
    };
    Scheduler2.prototype.updateStreamModes = function(seriesModel, view) {
      var pipeline = this._pipelineMap.get(seriesModel.uid);
      var data = seriesModel.getData();
      var dataLen = data.count();
      var progressiveRender = pipeline.progressiveEnabled && view.incrementalPrepareRender && dataLen >= pipeline.threshold;
      var large = seriesModel.get("large") && dataLen >= seriesModel.get("largeThreshold");
      var modDataCount = seriesModel.get("progressiveChunkMode") === "mod" ? dataLen : null;
      seriesModel.pipelineContext = pipeline.context = {
        progressiveRender,
        modDataCount,
        large
      };
    };
    Scheduler2.prototype.restorePipelines = function(ecModel) {
      var scheduler = this;
      var pipelineMap = scheduler._pipelineMap = createHashMap();
      ecModel.eachSeries(function(seriesModel) {
        var progressive = seriesModel.getProgressive();
        var pipelineId = seriesModel.uid;
        pipelineMap.set(pipelineId, {
          id: pipelineId,
          head: null,
          tail: null,
          threshold: seriesModel.getProgressiveThreshold(),
          progressiveEnabled: progressive && !(seriesModel.preventIncremental && seriesModel.preventIncremental()),
          blockIndex: -1,
          step: Math.round(progressive || 700),
          count: 0
        });
        scheduler._pipe(seriesModel, seriesModel.dataTask);
      });
    };
    Scheduler2.prototype.prepareStageTasks = function() {
      var stageTaskMap = this._stageTaskMap;
      var ecModel = this.api.getModel();
      var api = this.api;
      each(this._allHandlers, function(handler) {
        var record = stageTaskMap.get(handler.uid) || stageTaskMap.set(handler.uid, {});
        var errMsg = "";
        if (true) {
          errMsg = '"reset" and "overallReset" must not be both specified.';
        }
        assert(!(handler.reset && handler.overallReset), errMsg);
        handler.reset && this._createSeriesStageTask(handler, record, ecModel, api);
        handler.overallReset && this._createOverallStageTask(handler, record, ecModel, api);
      }, this);
    };
    Scheduler2.prototype.prepareView = function(view, model, ecModel, api) {
      var renderTask = view.renderTask;
      var context = renderTask.context;
      context.model = model;
      context.ecModel = ecModel;
      context.api = api;
      renderTask.__block = !view.incrementalPrepareRender;
      this._pipe(model, renderTask);
    };
    Scheduler2.prototype.performDataProcessorTasks = function(ecModel, payload) {
      this._performStageTasks(this._dataProcessorHandlers, ecModel, payload, {
        block: true
      });
    };
    Scheduler2.prototype.performVisualTasks = function(ecModel, payload, opt) {
      this._performStageTasks(this._visualHandlers, ecModel, payload, opt);
    };
    Scheduler2.prototype._performStageTasks = function(stageHandlers, ecModel, payload, opt) {
      opt = opt || {};
      var unfinished = false;
      var scheduler = this;
      each(stageHandlers, function(stageHandler, idx) {
        if (opt.visualType && opt.visualType !== stageHandler.visualType) {
          return;
        }
        var stageHandlerRecord = scheduler._stageTaskMap.get(stageHandler.uid);
        var seriesTaskMap = stageHandlerRecord.seriesTaskMap;
        var overallTask = stageHandlerRecord.overallTask;
        if (overallTask) {
          var overallNeedDirty_1;
          var agentStubMap = overallTask.agentStubMap;
          agentStubMap.each(function(stub) {
            if (needSetDirty(opt, stub)) {
              stub.dirty();
              overallNeedDirty_1 = true;
            }
          });
          overallNeedDirty_1 && overallTask.dirty();
          scheduler.updatePayload(overallTask, payload);
          var performArgs_1 = scheduler.getPerformArgs(overallTask, opt.block);
          agentStubMap.each(function(stub) {
            stub.perform(performArgs_1);
          });
          if (overallTask.perform(performArgs_1)) {
            unfinished = true;
          }
        } else if (seriesTaskMap) {
          seriesTaskMap.each(function(task, pipelineId) {
            if (needSetDirty(opt, task)) {
              task.dirty();
            }
            var performArgs = scheduler.getPerformArgs(task, opt.block);
            performArgs.skip = !stageHandler.performRawSeries && ecModel.isSeriesFiltered(task.context.model);
            scheduler.updatePayload(task, payload);
            if (task.perform(performArgs)) {
              unfinished = true;
            }
          });
        }
      });
      function needSetDirty(opt2, task) {
        return opt2.setDirty && (!opt2.dirtyMap || opt2.dirtyMap.get(task.__pipeline.id));
      }
      this.unfinished = unfinished || this.unfinished;
    };
    Scheduler2.prototype.performSeriesTasks = function(ecModel) {
      var unfinished;
      ecModel.eachSeries(function(seriesModel) {
        unfinished = seriesModel.dataTask.perform() || unfinished;
      });
      this.unfinished = unfinished || this.unfinished;
    };
    Scheduler2.prototype.plan = function() {
      this._pipelineMap.each(function(pipeline) {
        var task = pipeline.tail;
        do {
          if (task.__block) {
            pipeline.blockIndex = task.__idxInPipeline;
            break;
          }
          task = task.getUpstream();
        } while (task);
      });
    };
    Scheduler2.prototype.updatePayload = function(task, payload) {
      payload !== "remain" && (task.context.payload = payload);
    };
    Scheduler2.prototype._createSeriesStageTask = function(stageHandler, stageHandlerRecord, ecModel, api) {
      var scheduler = this;
      var oldSeriesTaskMap = stageHandlerRecord.seriesTaskMap;
      var newSeriesTaskMap = stageHandlerRecord.seriesTaskMap = createHashMap();
      var seriesType2 = stageHandler.seriesType;
      var getTargetSeries = stageHandler.getTargetSeries;
      if (stageHandler.createOnAllSeries) {
        ecModel.eachRawSeries(create4);
      } else if (seriesType2) {
        ecModel.eachRawSeriesByType(seriesType2, create4);
      } else if (getTargetSeries) {
        getTargetSeries(ecModel, api).each(create4);
      }
      function create4(seriesModel) {
        var pipelineId = seriesModel.uid;
        var task = newSeriesTaskMap.set(pipelineId, oldSeriesTaskMap && oldSeriesTaskMap.get(pipelineId) || createTask({
          plan: seriesTaskPlan,
          reset: seriesTaskReset,
          count: seriesTaskCount
        }));
        task.context = {
          model: seriesModel,
          ecModel,
          api,
          useClearVisual: stageHandler.isVisual && !stageHandler.isLayout,
          plan: stageHandler.plan,
          reset: stageHandler.reset,
          scheduler
        };
        scheduler._pipe(seriesModel, task);
      }
    };
    Scheduler2.prototype._createOverallStageTask = function(stageHandler, stageHandlerRecord, ecModel, api) {
      var scheduler = this;
      var overallTask = stageHandlerRecord.overallTask = stageHandlerRecord.overallTask || createTask({
        reset: overallTaskReset
      });
      overallTask.context = {
        ecModel,
        api,
        overallReset: stageHandler.overallReset,
        scheduler
      };
      var oldAgentStubMap = overallTask.agentStubMap;
      var newAgentStubMap = overallTask.agentStubMap = createHashMap();
      var seriesType2 = stageHandler.seriesType;
      var getTargetSeries = stageHandler.getTargetSeries;
      var overallProgress = true;
      var shouldOverallTaskDirty = false;
      var errMsg = "";
      if (true) {
        errMsg = '"createOnAllSeries" do not supported for "overallReset", becuase it will block all streams.';
      }
      assert(!stageHandler.createOnAllSeries, errMsg);
      if (seriesType2) {
        ecModel.eachRawSeriesByType(seriesType2, createStub);
      } else if (getTargetSeries) {
        getTargetSeries(ecModel, api).each(createStub);
      } else {
        overallProgress = false;
        each(ecModel.getSeries(), createStub);
      }
      function createStub(seriesModel) {
        var pipelineId = seriesModel.uid;
        var stub = newAgentStubMap.set(pipelineId, oldAgentStubMap && oldAgentStubMap.get(pipelineId) || (shouldOverallTaskDirty = true, createTask({
          reset: stubReset,
          onDirty: stubOnDirty
        })));
        stub.context = {
          model: seriesModel,
          overallProgress
        };
        stub.agent = overallTask;
        stub.__block = overallProgress;
        scheduler._pipe(seriesModel, stub);
      }
      if (shouldOverallTaskDirty) {
        overallTask.dirty();
      }
    };
    Scheduler2.prototype._pipe = function(seriesModel, task) {
      var pipelineId = seriesModel.uid;
      var pipeline = this._pipelineMap.get(pipelineId);
      !pipeline.head && (pipeline.head = task);
      pipeline.tail && pipeline.tail.pipe(task);
      pipeline.tail = task;
      task.__idxInPipeline = pipeline.count++;
      task.__pipeline = pipeline;
    };
    Scheduler2.wrapStageHandler = function(stageHandler, visualType) {
      if (isFunction(stageHandler)) {
        stageHandler = {
          overallReset: stageHandler,
          seriesType: detectSeriseType(stageHandler)
        };
      }
      stageHandler.uid = getUID("stageHandler");
      visualType && (stageHandler.visualType = visualType);
      return stageHandler;
    };
    ;
    return Scheduler2;
  }();
  function overallTaskReset(context) {
    context.overallReset(context.ecModel, context.api, context.payload);
  }
  function stubReset(context) {
    return context.overallProgress && stubProgress;
  }
  function stubProgress() {
    this.agent.dirty();
    this.getDownstream().dirty();
  }
  function stubOnDirty() {
    this.agent && this.agent.dirty();
  }
  function seriesTaskPlan(context) {
    return context.plan ? context.plan(context.model, context.ecModel, context.api, context.payload) : null;
  }
  function seriesTaskReset(context) {
    if (context.useClearVisual) {
      context.data.clearAllVisual();
    }
    var resetDefines = context.resetDefines = normalizeToArray(context.reset(context.model, context.ecModel, context.api, context.payload));
    return resetDefines.length > 1 ? map(resetDefines, function(v, idx) {
      return makeSeriesTaskProgress(idx);
    }) : singleSeriesTaskProgress;
  }
  var singleSeriesTaskProgress = makeSeriesTaskProgress(0);
  function makeSeriesTaskProgress(resetDefineIdx) {
    return function(params, context) {
      var data = context.data;
      var resetDefine = context.resetDefines[resetDefineIdx];
      if (resetDefine && resetDefine.dataEach) {
        for (var i = params.start; i < params.end; i++) {
          resetDefine.dataEach(data, i);
        }
      } else if (resetDefine && resetDefine.progress) {
        resetDefine.progress(params, data);
      }
    };
  }
  function seriesTaskCount(context) {
    return context.data.count();
  }
  function detectSeriseType(legacyFunc) {
    seriesType = null;
    try {
      legacyFunc(ecModelMock, apiMock);
    } catch (e2) {
    }
    return seriesType;
  }
  var ecModelMock = {};
  var apiMock = {};
  var seriesType;
  mockMethods(ecModelMock, Global_default);
  mockMethods(apiMock, ExtensionAPI_default);
  ecModelMock.eachSeriesByType = ecModelMock.eachRawSeriesByType = function(type) {
    seriesType = type;
  };
  ecModelMock.eachComponent = function(cond) {
    if (cond.mainType === "series" && cond.subType) {
      seriesType = cond.subType;
    }
  };
  function mockMethods(target, Clz) {
    for (var name_1 in Clz.prototype) {
      target[name_1] = noop;
    }
  }
  var Scheduler_default = Scheduler;

  // node_modules/echarts/lib/theme/light.js
  var colorAll = ["#37A2DA", "#32C5E9", "#67E0E3", "#9FE6B8", "#FFDB5C", "#ff9f7f", "#fb7293", "#E062AE", "#E690D1", "#e7bcf3", "#9d96f5", "#8378EA", "#96BFFF"];
  var light_default = {
    color: colorAll,
    colorLayer: [["#37A2DA", "#ffd85c", "#fd7b5f"], ["#37A2DA", "#67E0E3", "#FFDB5C", "#ff9f7f", "#E062AE", "#9d96f5"], ["#37A2DA", "#32C5E9", "#9FE6B8", "#FFDB5C", "#ff9f7f", "#fb7293", "#e7bcf3", "#8378EA", "#96BFFF"], colorAll]
  };

  // node_modules/echarts/lib/theme/dark.js
  var contrastColor = "#B9B8CE";
  var backgroundColor = "#100C2A";
  var axisCommon = function() {
    return {
      axisLine: {
        lineStyle: {
          color: contrastColor
        }
      },
      splitLine: {
        lineStyle: {
          color: "#484753"
        }
      },
      splitArea: {
        areaStyle: {
          color: ["rgba(255,255,255,0.02)", "rgba(255,255,255,0.05)"]
        }
      },
      minorSplitLine: {
        lineStyle: {
          color: "#20203B"
        }
      }
    };
  };
  var colorPalette = ["#4992ff", "#7cffb2", "#fddd60", "#ff6e76", "#58d9f9", "#05c091", "#ff8a45", "#8d48e3", "#dd79ff"];
  var theme = {
    darkMode: true,
    color: colorPalette,
    backgroundColor,
    axisPointer: {
      lineStyle: {
        color: "#817f91"
      },
      crossStyle: {
        color: "#817f91"
      },
      label: {
        color: "#fff"
      }
    },
    legend: {
      textStyle: {
        color: contrastColor
      }
    },
    textStyle: {
      color: contrastColor
    },
    title: {
      textStyle: {
        color: "#EEF1FA"
      },
      subtextStyle: {
        color: "#B9B8CE"
      }
    },
    toolbox: {
      iconStyle: {
        borderColor: contrastColor
      }
    },
    dataZoom: {
      borderColor: "#71708A",
      textStyle: {
        color: contrastColor
      },
      brushStyle: {
        color: "rgba(135,163,206,0.3)"
      },
      handleStyle: {
        color: "#353450",
        borderColor: "#C5CBE3"
      },
      moveHandleStyle: {
        color: "#B0B6C3",
        opacity: 0.3
      },
      fillerColor: "rgba(135,163,206,0.2)",
      emphasis: {
        handleStyle: {
          borderColor: "#91B7F2",
          color: "#4D587D"
        },
        moveHandleStyle: {
          color: "#636D9A",
          opacity: 0.7
        }
      },
      dataBackground: {
        lineStyle: {
          color: "#71708A",
          width: 1
        },
        areaStyle: {
          color: "#71708A"
        }
      },
      selectedDataBackground: {
        lineStyle: {
          color: "#87A3CE"
        },
        areaStyle: {
          color: "#87A3CE"
        }
      }
    },
    visualMap: {
      textStyle: {
        color: contrastColor
      }
    },
    timeline: {
      lineStyle: {
        color: contrastColor
      },
      label: {
        color: contrastColor
      },
      controlStyle: {
        color: contrastColor,
        borderColor: contrastColor
      }
    },
    calendar: {
      itemStyle: {
        color: backgroundColor
      },
      dayLabel: {
        color: contrastColor
      },
      monthLabel: {
        color: contrastColor
      },
      yearLabel: {
        color: contrastColor
      }
    },
    timeAxis: axisCommon(),
    logAxis: axisCommon(),
    valueAxis: axisCommon(),
    categoryAxis: axisCommon(),
    line: {
      symbol: "circle"
    },
    graph: {
      color: colorPalette
    },
    gauge: {
      title: {
        color: contrastColor
      },
      axisLine: {
        lineStyle: {
          color: [[1, "rgba(207,212,219,0.2)"]]
        }
      },
      axisLabel: {
        color: contrastColor
      },
      detail: {
        color: "#EEF1FA"
      }
    },
    candlestick: {
      itemStyle: {
        color: "#f64e56",
        color0: "#54ea92",
        borderColor: "#f64e56",
        borderColor0: "#54ea92"
      }
    }
  };
  theme.categoryAxis.splitLine.show = false;
  var dark_default = theme;

  // node_modules/echarts/lib/util/ECEventProcessor.js
  var ECEventProcessor = function() {
    function ECEventProcessor2() {
    }
    ECEventProcessor2.prototype.normalizeQuery = function(query) {
      var cptQuery = {};
      var dataQuery = {};
      var otherQuery = {};
      if (isString(query)) {
        var condCptType = parseClassType(query);
        cptQuery.mainType = condCptType.main || null;
        cptQuery.subType = condCptType.sub || null;
      } else {
        var suffixes_1 = ["Index", "Name", "Id"];
        var dataKeys_1 = {
          name: 1,
          dataIndex: 1,
          dataType: 1
        };
        each(query, function(val, key) {
          var reserved = false;
          for (var i = 0; i < suffixes_1.length; i++) {
            var propSuffix = suffixes_1[i];
            var suffixPos = key.lastIndexOf(propSuffix);
            if (suffixPos > 0 && suffixPos === key.length - propSuffix.length) {
              var mainType = key.slice(0, suffixPos);
              if (mainType !== "data") {
                cptQuery.mainType = mainType;
                cptQuery[propSuffix.toLowerCase()] = val;
                reserved = true;
              }
            }
          }
          if (dataKeys_1.hasOwnProperty(key)) {
            dataQuery[key] = val;
            reserved = true;
          }
          if (!reserved) {
            otherQuery[key] = val;
          }
        });
      }
      return {
        cptQuery,
        dataQuery,
        otherQuery
      };
    };
    ECEventProcessor2.prototype.filter = function(eventType, query) {
      var eventInfo = this.eventInfo;
      if (!eventInfo) {
        return true;
      }
      var targetEl = eventInfo.targetEl;
      var packedEvent = eventInfo.packedEvent;
      var model = eventInfo.model;
      var view = eventInfo.view;
      if (!model || !view) {
        return true;
      }
      var cptQuery = query.cptQuery;
      var dataQuery = query.dataQuery;
      return check(cptQuery, model, "mainType") && check(cptQuery, model, "subType") && check(cptQuery, model, "index", "componentIndex") && check(cptQuery, model, "name") && check(cptQuery, model, "id") && check(dataQuery, packedEvent, "name") && check(dataQuery, packedEvent, "dataIndex") && check(dataQuery, packedEvent, "dataType") && (!view.filterForExposedEvent || view.filterForExposedEvent(eventType, query.otherQuery, targetEl, packedEvent));
      function check(query2, host, prop, propOnHost) {
        return query2[prop] == null || host[propOnHost || prop] === query2[prop];
      }
    };
    ECEventProcessor2.prototype.afterTrigger = function() {
      this.eventInfo = null;
    };
    return ECEventProcessor2;
  }();

  // node_modules/echarts/lib/visual/symbol.js
  var SYMBOL_PROPS_WITH_CB = ["symbol", "symbolSize", "symbolRotate", "symbolOffset"];
  var SYMBOL_PROPS = SYMBOL_PROPS_WITH_CB.concat(["symbolKeepAspect"]);
  var seriesSymbolTask = {
    createOnAllSeries: true,
    performRawSeries: true,
    reset: function(seriesModel, ecModel) {
      var data = seriesModel.getData();
      if (seriesModel.legendIcon) {
        data.setVisual("legendIcon", seriesModel.legendIcon);
      }
      if (!seriesModel.hasSymbolVisual) {
        return;
      }
      var symbolOptions = {};
      var symbolOptionsCb = {};
      var hasCallback = false;
      for (var i = 0; i < SYMBOL_PROPS_WITH_CB.length; i++) {
        var symbolPropName = SYMBOL_PROPS_WITH_CB[i];
        var val = seriesModel.get(symbolPropName);
        if (isFunction(val)) {
          hasCallback = true;
          symbolOptionsCb[symbolPropName] = val;
        } else {
          symbolOptions[symbolPropName] = val;
        }
      }
      symbolOptions.symbol = symbolOptions.symbol || seriesModel.defaultSymbol;
      data.setVisual(extend({
        legendIcon: seriesModel.legendIcon || symbolOptions.symbol,
        symbolKeepAspect: seriesModel.get("symbolKeepAspect")
      }, symbolOptions));
      if (ecModel.isSeriesFiltered(seriesModel)) {
        return;
      }
      var symbolPropsCb = keys(symbolOptionsCb);
      function dataEach(data2, idx) {
        var rawValue = seriesModel.getRawValue(idx);
        var params = seriesModel.getDataParams(idx);
        for (var i2 = 0; i2 < symbolPropsCb.length; i2++) {
          var symbolPropName2 = symbolPropsCb[i2];
          data2.setItemVisual(idx, symbolPropName2, symbolOptionsCb[symbolPropName2](rawValue, params));
        }
      }
      return {
        dataEach: hasCallback ? dataEach : null
      };
    }
  };
  var dataSymbolTask = {
    createOnAllSeries: true,
    performRawSeries: true,
    reset: function(seriesModel, ecModel) {
      if (!seriesModel.hasSymbolVisual) {
        return;
      }
      if (ecModel.isSeriesFiltered(seriesModel)) {
        return;
      }
      var data = seriesModel.getData();
      function dataEach(data2, idx) {
        var itemModel = data2.getItemModel(idx);
        for (var i = 0; i < SYMBOL_PROPS.length; i++) {
          var symbolPropName = SYMBOL_PROPS[i];
          var val = itemModel.getShallow(symbolPropName, true);
          if (val != null) {
            data2.setItemVisual(idx, symbolPropName, val);
          }
        }
      }
      return {
        dataEach: data.hasItemOption ? dataEach : null
      };
    }
  };

  // node_modules/echarts/lib/visual/helper.js
  function getItemVisualFromData(data, dataIndex, key) {
    switch (key) {
      case "color":
        var style = data.getItemVisual(dataIndex, "style");
        return style[data.getVisual("drawType")];
      case "opacity":
        return data.getItemVisual(dataIndex, "style").opacity;
      case "symbol":
      case "symbolSize":
      case "liftZ":
        return data.getItemVisual(dataIndex, key);
      default:
        if (true) {
          console.warn("Unknown visual type " + key);
        }
    }
  }
  function getVisualFromData(data, key) {
    switch (key) {
      case "color":
        var style = data.getVisual("style");
        return style[data.getVisual("drawType")];
      case "opacity":
        return data.getVisual("style").opacity;
      case "symbol":
      case "symbolSize":
      case "liftZ":
        return data.getVisual(key);
      default:
        if (true) {
          console.warn("Unknown visual type " + key);
        }
    }
  }
  function setItemVisualFromData(data, dataIndex, key, value) {
    switch (key) {
      case "color":
        var style = data.ensureUniqueItemVisual(dataIndex, "style");
        style[data.getVisual("drawType")] = value;
        data.setItemVisual(dataIndex, "colorFromPalette", false);
        break;
      case "opacity":
        data.ensureUniqueItemVisual(dataIndex, "style").opacity = value;
        break;
      case "symbol":
      case "symbolSize":
      case "liftZ":
        data.setItemVisual(dataIndex, key, value);
        break;
      default:
        if (true) {
          console.warn("Unknown visual type " + key);
        }
    }
  }

  // node_modules/echarts/lib/legacy/dataSelectAction.js
  function createLegacyDataSelectAction(seriesType2, ecRegisterAction) {
    function getSeriesIndices(ecModel, payload) {
      var seriesIndices = [];
      ecModel.eachComponent({
        mainType: "series",
        subType: seriesType2,
        query: payload
      }, function(seriesModel) {
        seriesIndices.push(seriesModel.seriesIndex);
      });
      return seriesIndices;
    }
    each([[seriesType2 + "ToggleSelect", "toggleSelect"], [seriesType2 + "Select", "select"], [seriesType2 + "UnSelect", "unselect"]], function(eventsMap) {
      ecRegisterAction(eventsMap[0], function(payload, ecModel, api) {
        payload = extend({}, payload);
        if (true) {
          deprecateReplaceLog(payload.type, eventsMap[1]);
        }
        api.dispatchAction(extend(payload, {
          type: eventsMap[1],
          seriesIndex: getSeriesIndices(ecModel, payload)
        }));
      });
    });
  }
  function handleSeriesLegacySelectEvents(type, eventPostfix, ecIns, ecModel, payload) {
    var legacyEventName = type + eventPostfix;
    if (!ecIns.isSilent(legacyEventName)) {
      if (true) {
        deprecateLog("event " + legacyEventName + " is deprecated.");
      }
      ecModel.eachComponent({
        mainType: "series",
        subType: "pie"
      }, function(seriesModel) {
        var seriesIndex = seriesModel.seriesIndex;
        var selectedMap = seriesModel.option.selectedMap;
        var selected = payload.selected;
        for (var i = 0; i < selected.length; i++) {
          if (selected[i].seriesIndex === seriesIndex) {
            var data = seriesModel.getData();
            var dataIndex = queryDataIndex(data, payload.fromActionPayload);
            ecIns.trigger(legacyEventName, {
              type: legacyEventName,
              seriesId: seriesModel.id,
              name: isArray(dataIndex) ? data.getName(dataIndex[0]) : data.getName(dataIndex),
              selected: isString(selectedMap) ? selectedMap : extend({}, selectedMap)
            });
          }
        }
      });
    }
  }
  function handleLegacySelectEvents(messageCenter, ecIns, api) {
    messageCenter.on("selectchanged", function(params) {
      var ecModel = api.getModel();
      if (params.isFromClick) {
        handleSeriesLegacySelectEvents("map", "selectchanged", ecIns, ecModel, params);
        handleSeriesLegacySelectEvents("pie", "selectchanged", ecIns, ecModel, params);
      } else if (params.fromAction === "select") {
        handleSeriesLegacySelectEvents("map", "selected", ecIns, ecModel, params);
        handleSeriesLegacySelectEvents("pie", "selected", ecIns, ecModel, params);
      } else if (params.fromAction === "unselect") {
        handleSeriesLegacySelectEvents("map", "unselected", ecIns, ecModel, params);
        handleSeriesLegacySelectEvents("pie", "unselected", ecIns, ecModel, params);
      }
    });
  }

  // node_modules/echarts/lib/util/event.js
  function findEventDispatcher(target, det, returnFirstMatch) {
    var found;
    while (target) {
      if (det(target)) {
        found = target;
        if (returnFirstMatch) {
          break;
        }
      }
      target = target.__hostTarget || target.parent;
    }
    return found;
  }

  // node_modules/zrender/lib/core/WeakMap.js
  var wmUniqueIndex = Math.round(Math.random() * 9);
  var supportDefineProperty = typeof Object.defineProperty === "function";
  var WeakMap = function() {
    function WeakMap2() {
      this._id = "__ec_inner_" + wmUniqueIndex++;
    }
    WeakMap2.prototype.get = function(key) {
      return this._guard(key)[this._id];
    };
    WeakMap2.prototype.set = function(key, value) {
      var target = this._guard(key);
      if (supportDefineProperty) {
        Object.defineProperty(target, this._id, {
          value,
          enumerable: false,
          configurable: true
        });
      } else {
        target[this._id] = value;
      }
      return this;
    };
    WeakMap2.prototype["delete"] = function(key) {
      if (this.has(key)) {
        delete this._guard(key)[this._id];
        return true;
      }
      return false;
    };
    WeakMap2.prototype.has = function(key) {
      return !!this._guard(key)[this._id];
    };
    WeakMap2.prototype._guard = function(key) {
      if (key !== Object(key)) {
        throw TypeError("Value of WeakMap is not a non-null object.");
      }
      return key;
    };
    return WeakMap2;
  }();
  var WeakMap_default = WeakMap;

  // node_modules/echarts/lib/util/symbol.js
  var Triangle = Path_default.extend({
    type: "triangle",
    shape: {
      cx: 0,
      cy: 0,
      width: 0,
      height: 0
    },
    buildPath: function(path, shape) {
      var cx = shape.cx;
      var cy = shape.cy;
      var width = shape.width / 2;
      var height = shape.height / 2;
      path.moveTo(cx, cy - height);
      path.lineTo(cx + width, cy + height);
      path.lineTo(cx - width, cy + height);
      path.closePath();
    }
  });
  var Diamond = Path_default.extend({
    type: "diamond",
    shape: {
      cx: 0,
      cy: 0,
      width: 0,
      height: 0
    },
    buildPath: function(path, shape) {
      var cx = shape.cx;
      var cy = shape.cy;
      var width = shape.width / 2;
      var height = shape.height / 2;
      path.moveTo(cx, cy - height);
      path.lineTo(cx + width, cy);
      path.lineTo(cx, cy + height);
      path.lineTo(cx - width, cy);
      path.closePath();
    }
  });
  var Pin = Path_default.extend({
    type: "pin",
    shape: {
      x: 0,
      y: 0,
      width: 0,
      height: 0
    },
    buildPath: function(path, shape) {
      var x = shape.x;
      var y = shape.y;
      var w = shape.width / 5 * 3;
      var h = Math.max(w, shape.height);
      var r = w / 2;
      var dy = r * r / (h - r);
      var cy = y - h + r + dy;
      var angle = Math.asin(dy / r);
      var dx = Math.cos(angle) * r;
      var tanX = Math.sin(angle);
      var tanY = Math.cos(angle);
      var cpLen = r * 0.6;
      var cpLen2 = r * 0.7;
      path.moveTo(x - dx, cy + dy);
      path.arc(x, cy, r, Math.PI - angle, Math.PI * 2 + angle);
      path.bezierCurveTo(x + dx - tanX * cpLen, cy + dy + tanY * cpLen, x, y - cpLen2, x, y);
      path.bezierCurveTo(x, y - cpLen2, x - dx + tanX * cpLen, cy + dy + tanY * cpLen, x - dx, cy + dy);
      path.closePath();
    }
  });
  var Arrow = Path_default.extend({
    type: "arrow",
    shape: {
      x: 0,
      y: 0,
      width: 0,
      height: 0
    },
    buildPath: function(ctx, shape) {
      var height = shape.height;
      var width = shape.width;
      var x = shape.x;
      var y = shape.y;
      var dx = width / 3 * 2;
      ctx.moveTo(x, y);
      ctx.lineTo(x + dx, y + height);
      ctx.lineTo(x, y + height / 4 * 3);
      ctx.lineTo(x - dx, y + height);
      ctx.lineTo(x, y);
      ctx.closePath();
    }
  });
  var symbolCtors = {
    line: Line_default,
    rect: Rect_default,
    roundRect: Rect_default,
    square: Rect_default,
    circle: Circle_default,
    diamond: Diamond,
    pin: Pin,
    arrow: Arrow,
    triangle: Triangle
  };
  var symbolShapeMakers = {
    line: function(x, y, w, h, shape) {
      shape.x1 = x;
      shape.y1 = y + h / 2;
      shape.x2 = x + w;
      shape.y2 = y + h / 2;
    },
    rect: function(x, y, w, h, shape) {
      shape.x = x;
      shape.y = y;
      shape.width = w;
      shape.height = h;
    },
    roundRect: function(x, y, w, h, shape) {
      shape.x = x;
      shape.y = y;
      shape.width = w;
      shape.height = h;
      shape.r = Math.min(w, h) / 4;
    },
    square: function(x, y, w, h, shape) {
      var size = Math.min(w, h);
      shape.x = x;
      shape.y = y;
      shape.width = size;
      shape.height = size;
    },
    circle: function(x, y, w, h, shape) {
      shape.cx = x + w / 2;
      shape.cy = y + h / 2;
      shape.r = Math.min(w, h) / 2;
    },
    diamond: function(x, y, w, h, shape) {
      shape.cx = x + w / 2;
      shape.cy = y + h / 2;
      shape.width = w;
      shape.height = h;
    },
    pin: function(x, y, w, h, shape) {
      shape.x = x + w / 2;
      shape.y = y + h / 2;
      shape.width = w;
      shape.height = h;
    },
    arrow: function(x, y, w, h, shape) {
      shape.x = x + w / 2;
      shape.y = y + h / 2;
      shape.width = w;
      shape.height = h;
    },
    triangle: function(x, y, w, h, shape) {
      shape.cx = x + w / 2;
      shape.cy = y + h / 2;
      shape.width = w;
      shape.height = h;
    }
  };
  var symbolBuildProxies = {};
  each(symbolCtors, function(Ctor, name) {
    symbolBuildProxies[name] = new Ctor();
  });
  var SymbolClz = Path_default.extend({
    type: "symbol",
    shape: {
      symbolType: "",
      x: 0,
      y: 0,
      width: 0,
      height: 0
    },
    calculateTextPosition: function(out2, config, rect) {
      var res = calculateTextPosition(out2, config, rect);
      var shape = this.shape;
      if (shape && shape.symbolType === "pin" && config.position === "inside") {
        res.y = rect.y + rect.height * 0.4;
      }
      return res;
    },
    buildPath: function(ctx, shape, inBundle) {
      var symbolType = shape.symbolType;
      if (symbolType !== "none") {
        var proxySymbol = symbolBuildProxies[symbolType];
        if (!proxySymbol) {
          symbolType = "rect";
          proxySymbol = symbolBuildProxies[symbolType];
        }
        symbolShapeMakers[symbolType](shape.x, shape.y, shape.width, shape.height, proxySymbol.shape);
        proxySymbol.buildPath(ctx, proxySymbol.shape, inBundle);
      }
    }
  });
  function symbolPathSetColor(color, innerColor2) {
    if (this.type !== "image") {
      var symbolStyle = this.style;
      if (this.__isEmptyBrush) {
        symbolStyle.stroke = color;
        symbolStyle.fill = innerColor2 || "#fff";
        symbolStyle.lineWidth = 2;
      } else if (this.shape.symbolType === "line") {
        symbolStyle.stroke = color;
      } else {
        symbolStyle.fill = color;
      }
      this.markRedraw();
    }
  }
  function createSymbol(symbolType, x, y, w, h, color, keepAspect) {
    var isEmpty = symbolType.indexOf("empty") === 0;
    if (isEmpty) {
      symbolType = symbolType.substr(5, 1).toLowerCase() + symbolType.substr(6);
    }
    var symbolPath;
    if (symbolType.indexOf("image://") === 0) {
      symbolPath = makeImage(symbolType.slice(8), new BoundingRect_default(x, y, w, h), keepAspect ? "center" : "cover");
    } else if (symbolType.indexOf("path://") === 0) {
      symbolPath = makePath(symbolType.slice(7), {}, new BoundingRect_default(x, y, w, h), keepAspect ? "center" : "cover");
    } else {
      symbolPath = new SymbolClz({
        shape: {
          symbolType,
          x,
          y,
          width: w,
          height: h
        }
      });
    }
    symbolPath.__isEmptyBrush = isEmpty;
    symbolPath.setColor = symbolPathSetColor;
    if (color) {
      symbolPath.setColor(color);
    }
    return symbolPath;
  }
  function normalizeSymbolSize(symbolSize) {
    if (!isArray(symbolSize)) {
      symbolSize = [+symbolSize, +symbolSize];
    }
    return [symbolSize[0] || 0, symbolSize[1] || 0];
  }
  function normalizeSymbolOffset(symbolOffset, symbolSize) {
    if (symbolOffset == null) {
      return;
    }
    if (!isArray(symbolOffset)) {
      symbolOffset = [symbolOffset, symbolOffset];
    }
    return [parsePercent2(symbolOffset[0], symbolSize[0]) || 0, parsePercent2(retrieve2(symbolOffset[1], symbolOffset[0]), symbolSize[1]) || 0];
  }

  // node_modules/zrender/lib/canvas/helper.js
  function isSafeNum(num) {
    return isFinite(num);
  }
  function createLinearGradient(ctx, obj, rect) {
    var x = obj.x == null ? 0 : obj.x;
    var x2 = obj.x2 == null ? 1 : obj.x2;
    var y = obj.y == null ? 0 : obj.y;
    var y2 = obj.y2 == null ? 0 : obj.y2;
    if (!obj.global) {
      x = x * rect.width + rect.x;
      x2 = x2 * rect.width + rect.x;
      y = y * rect.height + rect.y;
      y2 = y2 * rect.height + rect.y;
    }
    x = isSafeNum(x) ? x : 0;
    x2 = isSafeNum(x2) ? x2 : 1;
    y = isSafeNum(y) ? y : 0;
    y2 = isSafeNum(y2) ? y2 : 0;
    var canvasGradient = ctx.createLinearGradient(x, y, x2, y2);
    return canvasGradient;
  }
  function createRadialGradient(ctx, obj, rect) {
    var width = rect.width;
    var height = rect.height;
    var min3 = Math.min(width, height);
    var x = obj.x == null ? 0.5 : obj.x;
    var y = obj.y == null ? 0.5 : obj.y;
    var r = obj.r == null ? 0.5 : obj.r;
    if (!obj.global) {
      x = x * width + rect.x;
      y = y * height + rect.y;
      r = r * min3;
    }
    x = isSafeNum(x) ? x : 0.5;
    y = isSafeNum(y) ? y : 0.5;
    r = r >= 0 && isSafeNum(r) ? r : 0.5;
    var canvasGradient = ctx.createRadialGradient(x, y, 0, x, y, r);
    return canvasGradient;
  }
  function getCanvasGradient(ctx, obj, rect) {
    var canvasGradient = obj.type === "radial" ? createRadialGradient(ctx, obj, rect) : createLinearGradient(ctx, obj, rect);
    var colorStops = obj.colorStops;
    for (var i = 0; i < colorStops.length; i++) {
      canvasGradient.addColorStop(colorStops[i].offset, colorStops[i].color);
    }
    return canvasGradient;
  }
  function isClipPathChanged(clipPaths, prevClipPaths) {
    if (clipPaths === prevClipPaths || !clipPaths && !prevClipPaths) {
      return false;
    }
    if (!clipPaths || !prevClipPaths || clipPaths.length !== prevClipPaths.length) {
      return true;
    }
    for (var i = 0; i < clipPaths.length; i++) {
      if (clipPaths[i] !== prevClipPaths[i]) {
        return true;
      }
    }
    return false;
  }
  function parseInt10(val) {
    return parseInt(val, 10);
  }
  function getSize(root, whIdx, opts) {
    var wh = ["width", "height"][whIdx];
    var cwh = ["clientWidth", "clientHeight"][whIdx];
    var plt = ["paddingLeft", "paddingTop"][whIdx];
    var prb = ["paddingRight", "paddingBottom"][whIdx];
    if (opts[wh] != null && opts[wh] !== "auto") {
      return parseFloat(opts[wh]);
    }
    var stl = document.defaultView.getComputedStyle(root);
    return (root[cwh] || parseInt10(stl[wh]) || parseInt10(root.style[wh])) - (parseInt10(stl[plt]) || 0) - (parseInt10(stl[prb]) || 0) | 0;
  }

  // node_modules/zrender/lib/canvas/dashStyle.js
  function normalizeLineDash(lineType, lineWidth) {
    if (!lineType || lineType === "solid" || !(lineWidth > 0)) {
      return null;
    }
    return lineType === "dashed" ? [4 * lineWidth, 2 * lineWidth] : lineType === "dotted" ? [lineWidth] : isNumber(lineType) ? [lineType] : isArray(lineType) ? lineType : null;
  }
  function getLineDash(el) {
    var style = el.style;
    var lineDash = style.lineDash && style.lineWidth > 0 && normalizeLineDash(style.lineDash, style.lineWidth);
    var lineDashOffset = style.lineDashOffset;
    if (lineDash) {
      var lineScale_1 = style.strokeNoScale && el.getLineScale ? el.getLineScale() : 1;
      if (lineScale_1 && lineScale_1 !== 1) {
        lineDash = map(lineDash, function(rawVal) {
          return rawVal / lineScale_1;
        });
        lineDashOffset /= lineScale_1;
      }
    }
    return [lineDash, lineDashOffset];
  }

  // node_modules/zrender/lib/canvas/graphic.js
  var pathProxyForDraw = new PathProxy_default(true);
  function styleHasStroke(style) {
    var stroke = style.stroke;
    return !(stroke == null || stroke === "none" || !(style.lineWidth > 0));
  }
  function isValidStrokeFillStyle(strokeOrFill) {
    return typeof strokeOrFill === "string" && strokeOrFill !== "none";
  }
  function styleHasFill(style) {
    var fill = style.fill;
    return fill != null && fill !== "none";
  }
  function doFillPath(ctx, style) {
    if (style.fillOpacity != null && style.fillOpacity !== 1) {
      var originalGlobalAlpha = ctx.globalAlpha;
      ctx.globalAlpha = style.fillOpacity * style.opacity;
      ctx.fill();
      ctx.globalAlpha = originalGlobalAlpha;
    } else {
      ctx.fill();
    }
  }
  function doStrokePath(ctx, style) {
    if (style.strokeOpacity != null && style.strokeOpacity !== 1) {
      var originalGlobalAlpha = ctx.globalAlpha;
      ctx.globalAlpha = style.strokeOpacity * style.opacity;
      ctx.stroke();
      ctx.globalAlpha = originalGlobalAlpha;
    } else {
      ctx.stroke();
    }
  }
  function createCanvasPattern(ctx, pattern, el) {
    var image = createOrUpdateImage(pattern.image, pattern.__image, el);
    if (isImageReady(image)) {
      var canvasPattern = ctx.createPattern(image, pattern.repeat || "repeat");
      if (typeof DOMMatrix === "function" && canvasPattern && canvasPattern.setTransform) {
        var matrix = new DOMMatrix();
        matrix.translateSelf(pattern.x || 0, pattern.y || 0);
        matrix.rotateSelf(0, 0, (pattern.rotation || 0) * RADIAN_TO_DEGREE);
        matrix.scaleSelf(pattern.scaleX || 1, pattern.scaleY || 1);
        canvasPattern.setTransform(matrix);
      }
      return canvasPattern;
    }
  }
  function brushPath(ctx, el, style, inBatch) {
    var _a2;
    var hasStroke = styleHasStroke(style);
    var hasFill = styleHasFill(style);
    var strokePercent = style.strokePercent;
    var strokePart = strokePercent < 1;
    var firstDraw = !el.path;
    if ((!el.silent || strokePart) && firstDraw) {
      el.createPathProxy();
    }
    var path = el.path || pathProxyForDraw;
    var dirtyFlag = el.__dirty;
    if (!inBatch) {
      var fill = style.fill;
      var stroke = style.stroke;
      var hasFillGradient = hasFill && !!fill.colorStops;
      var hasStrokeGradient = hasStroke && !!stroke.colorStops;
      var hasFillPattern = hasFill && !!fill.image;
      var hasStrokePattern = hasStroke && !!stroke.image;
      var fillGradient = void 0;
      var strokeGradient = void 0;
      var fillPattern = void 0;
      var strokePattern = void 0;
      var rect = void 0;
      if (hasFillGradient || hasStrokeGradient) {
        rect = el.getBoundingRect();
      }
      if (hasFillGradient) {
        fillGradient = dirtyFlag ? getCanvasGradient(ctx, fill, rect) : el.__canvasFillGradient;
        el.__canvasFillGradient = fillGradient;
      }
      if (hasStrokeGradient) {
        strokeGradient = dirtyFlag ? getCanvasGradient(ctx, stroke, rect) : el.__canvasStrokeGradient;
        el.__canvasStrokeGradient = strokeGradient;
      }
      if (hasFillPattern) {
        fillPattern = dirtyFlag || !el.__canvasFillPattern ? createCanvasPattern(ctx, fill, el) : el.__canvasFillPattern;
        el.__canvasFillPattern = fillPattern;
      }
      if (hasStrokePattern) {
        strokePattern = dirtyFlag || !el.__canvasStrokePattern ? createCanvasPattern(ctx, stroke, el) : el.__canvasStrokePattern;
        el.__canvasStrokePattern = fillPattern;
      }
      if (hasFillGradient) {
        ctx.fillStyle = fillGradient;
      } else if (hasFillPattern) {
        if (fillPattern) {
          ctx.fillStyle = fillPattern;
        } else {
          hasFill = false;
        }
      }
      if (hasStrokeGradient) {
        ctx.strokeStyle = strokeGradient;
      } else if (hasStrokePattern) {
        if (strokePattern) {
          ctx.strokeStyle = strokePattern;
        } else {
          hasStroke = false;
        }
      }
    }
    var scale4 = el.getGlobalScale();
    path.setScale(scale4[0], scale4[1], el.segmentIgnoreThreshold);
    var lineDash;
    var lineDashOffset;
    if (ctx.setLineDash && style.lineDash) {
      _a2 = getLineDash(el), lineDash = _a2[0], lineDashOffset = _a2[1];
    }
    var needsRebuild = true;
    if (firstDraw || dirtyFlag & SHAPE_CHANGED_BIT) {
      path.setDPR(ctx.dpr);
      if (strokePart) {
        path.setContext(null);
      } else {
        path.setContext(ctx);
        needsRebuild = false;
      }
      path.reset();
      el.buildPath(path, el.shape, inBatch);
      path.toStatic();
      el.pathUpdated();
    }
    if (needsRebuild) {
      path.rebuildPath(ctx, strokePart ? strokePercent : 1);
    }
    if (lineDash) {
      ctx.setLineDash(lineDash);
      ctx.lineDashOffset = lineDashOffset;
    }
    if (!inBatch) {
      if (style.strokeFirst) {
        if (hasStroke) {
          doStrokePath(ctx, style);
        }
        if (hasFill) {
          doFillPath(ctx, style);
        }
      } else {
        if (hasFill) {
          doFillPath(ctx, style);
        }
        if (hasStroke) {
          doStrokePath(ctx, style);
        }
      }
    }
    if (lineDash) {
      ctx.setLineDash([]);
    }
  }
  function brushImage(ctx, el, style) {
    var image = el.__image = createOrUpdateImage(style.image, el.__image, el, el.onload);
    if (!image || !isImageReady(image)) {
      return;
    }
    var x = style.x || 0;
    var y = style.y || 0;
    var width = el.getWidth();
    var height = el.getHeight();
    var aspect = image.width / image.height;
    if (width == null && height != null) {
      width = height * aspect;
    } else if (height == null && width != null) {
      height = width / aspect;
    } else if (width == null && height == null) {
      width = image.width;
      height = image.height;
    }
    if (style.sWidth && style.sHeight) {
      var sx = style.sx || 0;
      var sy = style.sy || 0;
      ctx.drawImage(image, sx, sy, style.sWidth, style.sHeight, x, y, width, height);
    } else if (style.sx && style.sy) {
      var sx = style.sx;
      var sy = style.sy;
      var sWidth = width - sx;
      var sHeight = height - sy;
      ctx.drawImage(image, sx, sy, sWidth, sHeight, x, y, width, height);
    } else {
      ctx.drawImage(image, x, y, width, height);
    }
  }
  function brushText(ctx, el, style) {
    var _a2;
    var text = style.text;
    text != null && (text += "");
    if (text) {
      ctx.font = style.font || DEFAULT_FONT;
      ctx.textAlign = style.textAlign;
      ctx.textBaseline = style.textBaseline;
      var lineDash = void 0;
      var lineDashOffset = void 0;
      if (ctx.setLineDash && style.lineDash) {
        _a2 = getLineDash(el), lineDash = _a2[0], lineDashOffset = _a2[1];
      }
      if (lineDash) {
        ctx.setLineDash(lineDash);
        ctx.lineDashOffset = lineDashOffset;
      }
      if (style.strokeFirst) {
        if (styleHasStroke(style)) {
          ctx.strokeText(text, style.x, style.y);
        }
        if (styleHasFill(style)) {
          ctx.fillText(text, style.x, style.y);
        }
      } else {
        if (styleHasFill(style)) {
          ctx.fillText(text, style.x, style.y);
        }
        if (styleHasStroke(style)) {
          ctx.strokeText(text, style.x, style.y);
        }
      }
      if (lineDash) {
        ctx.setLineDash([]);
      }
    }
  }
  var SHADOW_NUMBER_PROPS = ["shadowBlur", "shadowOffsetX", "shadowOffsetY"];
  var STROKE_PROPS = [
    ["lineCap", "butt"],
    ["lineJoin", "miter"],
    ["miterLimit", 10]
  ];
  function bindCommonProps(ctx, style, prevStyle, forceSetAll, scope) {
    var styleChanged = false;
    if (!forceSetAll) {
      prevStyle = prevStyle || {};
      if (style === prevStyle) {
        return false;
      }
    }
    if (forceSetAll || style.opacity !== prevStyle.opacity) {
      flushPathDrawn(ctx, scope);
      styleChanged = true;
      var opacity = Math.max(Math.min(style.opacity, 1), 0);
      ctx.globalAlpha = isNaN(opacity) ? DEFAULT_COMMON_STYLE.opacity : opacity;
    }
    if (forceSetAll || style.blend !== prevStyle.blend) {
      if (!styleChanged) {
        flushPathDrawn(ctx, scope);
        styleChanged = true;
      }
      ctx.globalCompositeOperation = style.blend || DEFAULT_COMMON_STYLE.blend;
    }
    for (var i = 0; i < SHADOW_NUMBER_PROPS.length; i++) {
      var propName = SHADOW_NUMBER_PROPS[i];
      if (forceSetAll || style[propName] !== prevStyle[propName]) {
        if (!styleChanged) {
          flushPathDrawn(ctx, scope);
          styleChanged = true;
        }
        ctx[propName] = ctx.dpr * (style[propName] || 0);
      }
    }
    if (forceSetAll || style.shadowColor !== prevStyle.shadowColor) {
      if (!styleChanged) {
        flushPathDrawn(ctx, scope);
        styleChanged = true;
      }
      ctx.shadowColor = style.shadowColor || DEFAULT_COMMON_STYLE.shadowColor;
    }
    return styleChanged;
  }
  function bindPathAndTextCommonStyle(ctx, el, prevEl, forceSetAll, scope) {
    var style = getStyle(el, scope.inHover);
    var prevStyle = forceSetAll ? null : prevEl && getStyle(prevEl, scope.inHover) || {};
    if (style === prevStyle) {
      return false;
    }
    var styleChanged = bindCommonProps(ctx, style, prevStyle, forceSetAll, scope);
    if (forceSetAll || style.fill !== prevStyle.fill) {
      if (!styleChanged) {
        flushPathDrawn(ctx, scope);
        styleChanged = true;
      }
      isValidStrokeFillStyle(style.fill) && (ctx.fillStyle = style.fill);
    }
    if (forceSetAll || style.stroke !== prevStyle.stroke) {
      if (!styleChanged) {
        flushPathDrawn(ctx, scope);
        styleChanged = true;
      }
      isValidStrokeFillStyle(style.stroke) && (ctx.strokeStyle = style.stroke);
    }
    if (forceSetAll || style.opacity !== prevStyle.opacity) {
      if (!styleChanged) {
        flushPathDrawn(ctx, scope);
        styleChanged = true;
      }
      ctx.globalAlpha = style.opacity == null ? 1 : style.opacity;
    }
    if (el.hasStroke()) {
      var lineWidth = style.lineWidth;
      var newLineWidth = lineWidth / (style.strokeNoScale && el.getLineScale ? el.getLineScale() : 1);
      if (ctx.lineWidth !== newLineWidth) {
        if (!styleChanged) {
          flushPathDrawn(ctx, scope);
          styleChanged = true;
        }
        ctx.lineWidth = newLineWidth;
      }
    }
    for (var i = 0; i < STROKE_PROPS.length; i++) {
      var prop = STROKE_PROPS[i];
      var propName = prop[0];
      if (forceSetAll || style[propName] !== prevStyle[propName]) {
        if (!styleChanged) {
          flushPathDrawn(ctx, scope);
          styleChanged = true;
        }
        ctx[propName] = style[propName] || prop[1];
      }
    }
    return styleChanged;
  }
  function bindImageStyle(ctx, el, prevEl, forceSetAll, scope) {
    return bindCommonProps(ctx, getStyle(el, scope.inHover), prevEl && getStyle(prevEl, scope.inHover), forceSetAll, scope);
  }
  function setContextTransform(ctx, el) {
    var m2 = el.transform;
    var dpr2 = ctx.dpr || 1;
    if (m2) {
      ctx.setTransform(dpr2 * m2[0], dpr2 * m2[1], dpr2 * m2[2], dpr2 * m2[3], dpr2 * m2[4], dpr2 * m2[5]);
    } else {
      ctx.setTransform(dpr2, 0, 0, dpr2, 0, 0);
    }
  }
  function updateClipStatus(clipPaths, ctx, scope) {
    var allClipped = false;
    for (var i = 0; i < clipPaths.length; i++) {
      var clipPath = clipPaths[i];
      allClipped = allClipped || clipPath.isZeroArea();
      setContextTransform(ctx, clipPath);
      ctx.beginPath();
      clipPath.buildPath(ctx, clipPath.shape);
      ctx.clip();
    }
    scope.allClipped = allClipped;
  }
  function isTransformChanged(m0, m1) {
    if (m0 && m1) {
      return m0[0] !== m1[0] || m0[1] !== m1[1] || m0[2] !== m1[2] || m0[3] !== m1[3] || m0[4] !== m1[4] || m0[5] !== m1[5];
    } else if (!m0 && !m1) {
      return false;
    }
    return true;
  }
  var DRAW_TYPE_PATH = 1;
  var DRAW_TYPE_IMAGE = 2;
  var DRAW_TYPE_TEXT = 3;
  var DRAW_TYPE_INCREMENTAL = 4;
  function canPathBatch(style) {
    var hasFill = styleHasFill(style);
    var hasStroke = styleHasStroke(style);
    return !(style.lineDash || !(+hasFill ^ +hasStroke) || hasFill && typeof style.fill !== "string" || hasStroke && typeof style.stroke !== "string" || style.strokePercent < 1 || style.strokeOpacity < 1 || style.fillOpacity < 1);
  }
  function flushPathDrawn(ctx, scope) {
    scope.batchFill && ctx.fill();
    scope.batchStroke && ctx.stroke();
    scope.batchFill = "";
    scope.batchStroke = "";
  }
  function getStyle(el, inHover) {
    return inHover ? el.__hoverStyle || el.style : el.style;
  }
  function brushSingle(ctx, el) {
    brush(ctx, el, { inHover: false, viewWidth: 0, viewHeight: 0 }, true);
  }
  function brush(ctx, el, scope, isLast) {
    var m2 = el.transform;
    if (!el.shouldBePainted(scope.viewWidth, scope.viewHeight, false, false)) {
      el.__dirty &= ~REDRAW_BIT;
      el.__isRendered = false;
      return;
    }
    var clipPaths = el.__clipPaths;
    var prevElClipPaths = scope.prevElClipPaths;
    var forceSetTransform = false;
    var forceSetStyle = false;
    if (!prevElClipPaths || isClipPathChanged(clipPaths, prevElClipPaths)) {
      if (prevElClipPaths && prevElClipPaths.length) {
        flushPathDrawn(ctx, scope);
        ctx.restore();
        forceSetStyle = forceSetTransform = true;
        scope.prevElClipPaths = null;
        scope.allClipped = false;
        scope.prevEl = null;
      }
      if (clipPaths && clipPaths.length) {
        flushPathDrawn(ctx, scope);
        ctx.save();
        updateClipStatus(clipPaths, ctx, scope);
        forceSetTransform = true;
      }
      scope.prevElClipPaths = clipPaths;
    }
    if (scope.allClipped) {
      el.__isRendered = false;
      return;
    }
    el.beforeBrush && el.beforeBrush();
    el.innerBeforeBrush();
    var prevEl = scope.prevEl;
    if (!prevEl) {
      forceSetStyle = forceSetTransform = true;
    }
    var canBatchPath = el instanceof Path_default && el.autoBatch && canPathBatch(el.style);
    if (forceSetTransform || isTransformChanged(m2, prevEl.transform)) {
      flushPathDrawn(ctx, scope);
      setContextTransform(ctx, el);
    } else if (!canBatchPath) {
      flushPathDrawn(ctx, scope);
    }
    var style = getStyle(el, scope.inHover);
    if (el instanceof Path_default) {
      if (scope.lastDrawType !== DRAW_TYPE_PATH) {
        forceSetStyle = true;
        scope.lastDrawType = DRAW_TYPE_PATH;
      }
      bindPathAndTextCommonStyle(ctx, el, prevEl, forceSetStyle, scope);
      if (!canBatchPath || !scope.batchFill && !scope.batchStroke) {
        ctx.beginPath();
      }
      brushPath(ctx, el, style, canBatchPath);
      if (canBatchPath) {
        scope.batchFill = style.fill || "";
        scope.batchStroke = style.stroke || "";
      }
    } else {
      if (el instanceof TSpan_default) {
        if (scope.lastDrawType !== DRAW_TYPE_TEXT) {
          forceSetStyle = true;
          scope.lastDrawType = DRAW_TYPE_TEXT;
        }
        bindPathAndTextCommonStyle(ctx, el, prevEl, forceSetStyle, scope);
        brushText(ctx, el, style);
      } else if (el instanceof Image_default) {
        if (scope.lastDrawType !== DRAW_TYPE_IMAGE) {
          forceSetStyle = true;
          scope.lastDrawType = DRAW_TYPE_IMAGE;
        }
        bindImageStyle(ctx, el, prevEl, forceSetStyle, scope);
        brushImage(ctx, el, style);
      } else if (el.getTemporalDisplayables) {
        if (scope.lastDrawType !== DRAW_TYPE_INCREMENTAL) {
          forceSetStyle = true;
          scope.lastDrawType = DRAW_TYPE_INCREMENTAL;
        }
        brushIncremental(ctx, el, scope);
      }
    }
    if (canBatchPath && isLast) {
      flushPathDrawn(ctx, scope);
    }
    el.innerAfterBrush();
    el.afterBrush && el.afterBrush();
    scope.prevEl = el;
    el.__dirty = 0;
    el.__isRendered = true;
  }
  function brushIncremental(ctx, el, scope) {
    var displayables = el.getDisplayables();
    var temporalDisplayables = el.getTemporalDisplayables();
    ctx.save();
    var innerScope = {
      prevElClipPaths: null,
      prevEl: null,
      allClipped: false,
      viewWidth: scope.viewWidth,
      viewHeight: scope.viewHeight,
      inHover: scope.inHover
    };
    var i;
    var len2;
    for (i = el.getCursor(), len2 = displayables.length; i < len2; i++) {
      var displayable = displayables[i];
      displayable.beforeBrush && displayable.beforeBrush();
      displayable.innerBeforeBrush();
      brush(ctx, displayable, innerScope, i === len2 - 1);
      displayable.innerAfterBrush();
      displayable.afterBrush && displayable.afterBrush();
      innerScope.prevEl = displayable;
    }
    for (var i_1 = 0, len_1 = temporalDisplayables.length; i_1 < len_1; i_1++) {
      var displayable = temporalDisplayables[i_1];
      displayable.beforeBrush && displayable.beforeBrush();
      displayable.innerBeforeBrush();
      brush(ctx, displayable, innerScope, i_1 === len_1 - 1);
      displayable.innerAfterBrush();
      displayable.afterBrush && displayable.afterBrush();
      innerScope.prevEl = displayable;
    }
    el.clearTemporalDisplayables();
    el.notClear = true;
    ctx.restore();
  }

  // node_modules/echarts/lib/util/decal.js
  var decalMap = new WeakMap_default();
  var decalCache = new LRU_default(100);
  var decalKeys = ["symbol", "symbolSize", "symbolKeepAspect", "color", "backgroundColor", "dashArrayX", "dashArrayY", "maxTileWidth", "maxTileHeight"];
  function createOrUpdatePatternFromDecal(decalObject, api) {
    if (decalObject === "none") {
      return null;
    }
    var dpr2 = api.getDevicePixelRatio();
    var zr = api.getZr();
    var isSVG = zr.painter.type === "svg";
    if (decalObject.dirty) {
      decalMap["delete"](decalObject);
    }
    var oldPattern = decalMap.get(decalObject);
    if (oldPattern) {
      return oldPattern;
    }
    var decalOpt = defaults(decalObject, {
      symbol: "rect",
      symbolSize: 1,
      symbolKeepAspect: true,
      color: "rgba(0, 0, 0, 0.2)",
      backgroundColor: null,
      dashArrayX: 5,
      dashArrayY: 5,
      rotation: 0,
      maxTileWidth: 512,
      maxTileHeight: 512
    });
    if (decalOpt.backgroundColor === "none") {
      decalOpt.backgroundColor = null;
    }
    var pattern = {
      repeat: "repeat"
    };
    setPatternnSource(pattern);
    pattern.rotation = decalOpt.rotation;
    pattern.scaleX = pattern.scaleY = isSVG ? 1 : 1 / dpr2;
    decalMap.set(decalObject, pattern);
    decalObject.dirty = false;
    return pattern;
    function setPatternnSource(pattern2) {
      var keys2 = [dpr2];
      var isValidKey = true;
      for (var i = 0; i < decalKeys.length; ++i) {
        var value = decalOpt[decalKeys[i]];
        if (value != null && !isArray(value) && !isString(value) && !isNumber(value) && typeof value !== "boolean") {
          isValidKey = false;
          break;
        }
        keys2.push(value);
      }
      var cacheKey;
      if (isValidKey) {
        cacheKey = keys2.join(",") + (isSVG ? "-svg" : "");
        var cache = decalCache.get(cacheKey);
        if (cache) {
          isSVG ? pattern2.svgElement = cache : pattern2.image = cache;
        }
      }
      var dashArrayX = normalizeDashArrayX(decalOpt.dashArrayX);
      var dashArrayY = normalizeDashArrayY(decalOpt.dashArrayY);
      var symbolArray = normalizeSymbolArray(decalOpt.symbol);
      var lineBlockLengthsX = getLineBlockLengthX(dashArrayX);
      var lineBlockLengthY = getLineBlockLengthY(dashArrayY);
      var canvas = !isSVG && platformApi.createCanvas();
      var svgRoot = isSVG && {
        tag: "g",
        attrs: {},
        key: "dcl",
        children: []
      };
      var pSize = getPatternSize();
      var ctx;
      if (canvas) {
        canvas.width = pSize.width * dpr2;
        canvas.height = pSize.height * dpr2;
        ctx = canvas.getContext("2d");
      }
      brushDecal();
      if (isValidKey) {
        decalCache.put(cacheKey, canvas || svgRoot);
      }
      pattern2.image = canvas;
      pattern2.svgElement = svgRoot;
      pattern2.svgWidth = pSize.width;
      pattern2.svgHeight = pSize.height;
      function getPatternSize() {
        var width = 1;
        for (var i2 = 0, xlen = lineBlockLengthsX.length; i2 < xlen; ++i2) {
          width = getLeastCommonMultiple(width, lineBlockLengthsX[i2]);
        }
        var symbolRepeats = 1;
        for (var i2 = 0, xlen = symbolArray.length; i2 < xlen; ++i2) {
          symbolRepeats = getLeastCommonMultiple(symbolRepeats, symbolArray[i2].length);
        }
        width *= symbolRepeats;
        var height = lineBlockLengthY * lineBlockLengthsX.length * symbolArray.length;
        if (true) {
          var warn2 = function(attrName) {
            console.warn("Calculated decal size is greater than " + attrName + " due to decal option settings so " + attrName + " is used for the decal size. Please consider changing the decal option to make a smaller decal or set " + attrName + " to be larger to avoid incontinuity.");
          };
          if (width > decalOpt.maxTileWidth) {
            warn2("maxTileWidth");
          }
          if (height > decalOpt.maxTileHeight) {
            warn2("maxTileHeight");
          }
        }
        return {
          width: Math.max(1, Math.min(width, decalOpt.maxTileWidth)),
          height: Math.max(1, Math.min(height, decalOpt.maxTileHeight))
        };
      }
      function brushDecal() {
        if (ctx) {
          ctx.clearRect(0, 0, canvas.width, canvas.height);
          if (decalOpt.backgroundColor) {
            ctx.fillStyle = decalOpt.backgroundColor;
            ctx.fillRect(0, 0, canvas.width, canvas.height);
          }
        }
        var ySum = 0;
        for (var i2 = 0; i2 < dashArrayY.length; ++i2) {
          ySum += dashArrayY[i2];
        }
        if (ySum <= 0) {
          return;
        }
        var y = -lineBlockLengthY;
        var yId = 0;
        var yIdTotal = 0;
        var xId0 = 0;
        while (y < pSize.height) {
          if (yId % 2 === 0) {
            var symbolYId = yIdTotal / 2 % symbolArray.length;
            var x = 0;
            var xId1 = 0;
            var xId1Total = 0;
            while (x < pSize.width * 2) {
              var xSum = 0;
              for (var i2 = 0; i2 < dashArrayX[xId0].length; ++i2) {
                xSum += dashArrayX[xId0][i2];
              }
              if (xSum <= 0) {
                break;
              }
              if (xId1 % 2 === 0) {
                var size = (1 - decalOpt.symbolSize) * 0.5;
                var left = x + dashArrayX[xId0][xId1] * size;
                var top_1 = y + dashArrayY[yId] * size;
                var width = dashArrayX[xId0][xId1] * decalOpt.symbolSize;
                var height = dashArrayY[yId] * decalOpt.symbolSize;
                var symbolXId = xId1Total / 2 % symbolArray[symbolYId].length;
                brushSymbol(left, top_1, width, height, symbolArray[symbolYId][symbolXId]);
              }
              x += dashArrayX[xId0][xId1];
              ++xId1Total;
              ++xId1;
              if (xId1 === dashArrayX[xId0].length) {
                xId1 = 0;
              }
            }
            ++xId0;
            if (xId0 === dashArrayX.length) {
              xId0 = 0;
            }
          }
          y += dashArrayY[yId];
          ++yIdTotal;
          ++yId;
          if (yId === dashArrayY.length) {
            yId = 0;
          }
        }
        function brushSymbol(x2, y2, width2, height2, symbolType) {
          var scale4 = isSVG ? 1 : dpr2;
          var symbol = createSymbol(symbolType, x2 * scale4, y2 * scale4, width2 * scale4, height2 * scale4, decalOpt.color, decalOpt.symbolKeepAspect);
          if (isSVG) {
            var symbolVNode = zr.painter.renderOneToVNode(symbol);
            if (symbolVNode) {
              svgRoot.children.push(symbolVNode);
            }
          } else {
            brushSingle(ctx, symbol);
          }
        }
      }
    }
  }
  function normalizeSymbolArray(symbol) {
    if (!symbol || symbol.length === 0) {
      return [["rect"]];
    }
    if (isString(symbol)) {
      return [[symbol]];
    }
    var isAllString = true;
    for (var i = 0; i < symbol.length; ++i) {
      if (!isString(symbol[i])) {
        isAllString = false;
        break;
      }
    }
    if (isAllString) {
      return normalizeSymbolArray([symbol]);
    }
    var result = [];
    for (var i = 0; i < symbol.length; ++i) {
      if (isString(symbol[i])) {
        result.push([symbol[i]]);
      } else {
        result.push(symbol[i]);
      }
    }
    return result;
  }
  function normalizeDashArrayX(dash) {
    if (!dash || dash.length === 0) {
      return [[0, 0]];
    }
    if (isNumber(dash)) {
      var dashValue = Math.ceil(dash);
      return [[dashValue, dashValue]];
    }
    var isAllNumber = true;
    for (var i = 0; i < dash.length; ++i) {
      if (!isNumber(dash[i])) {
        isAllNumber = false;
        break;
      }
    }
    if (isAllNumber) {
      return normalizeDashArrayX([dash]);
    }
    var result = [];
    for (var i = 0; i < dash.length; ++i) {
      if (isNumber(dash[i])) {
        var dashValue = Math.ceil(dash[i]);
        result.push([dashValue, dashValue]);
      } else {
        var dashValue = map(dash[i], function(n) {
          return Math.ceil(n);
        });
        if (dashValue.length % 2 === 1) {
          result.push(dashValue.concat(dashValue));
        } else {
          result.push(dashValue);
        }
      }
    }
    return result;
  }
  function normalizeDashArrayY(dash) {
    if (!dash || typeof dash === "object" && dash.length === 0) {
      return [0, 0];
    }
    if (isNumber(dash)) {
      var dashValue_1 = Math.ceil(dash);
      return [dashValue_1, dashValue_1];
    }
    var dashValue = map(dash, function(n) {
      return Math.ceil(n);
    });
    return dash.length % 2 ? dashValue.concat(dashValue) : dashValue;
  }
  function getLineBlockLengthX(dash) {
    return map(dash, function(line) {
      return getLineBlockLengthY(line);
    });
  }
  function getLineBlockLengthY(dash) {
    var blockLength = 0;
    for (var i = 0; i < dash.length; ++i) {
      blockLength += dash[i];
    }
    if (dash.length % 2 === 1) {
      return blockLength * 2;
    }
    return blockLength;
  }

  // node_modules/echarts/lib/visual/decal.js
  function decalVisual(ecModel, api) {
    ecModel.eachRawSeries(function(seriesModel) {
      if (ecModel.isSeriesFiltered(seriesModel)) {
        return;
      }
      var data = seriesModel.getData();
      if (data.hasItemVisual()) {
        data.each(function(idx) {
          var decal2 = data.getItemVisual(idx, "decal");
          if (decal2) {
            var itemStyle = data.ensureUniqueItemVisual(idx, "style");
            itemStyle.decal = createOrUpdatePatternFromDecal(decal2, api);
          }
        });
      }
      var decal = data.getVisual("decal");
      if (decal) {
        var style = data.getVisual("style");
        style.decal = createOrUpdatePatternFromDecal(decal, api);
      }
    });
  }

  // node_modules/echarts/lib/core/lifecycle.js
  var lifecycle = new Eventful_default();
  var lifecycle_default = lifecycle;

  // node_modules/echarts/lib/core/impl.js
  var implsStore = {};
  function registerImpl(name, impl) {
    if (true) {
      if (implsStore[name]) {
        error("Already has an implementation of " + name + ".");
      }
    }
    implsStore[name] = impl;
  }
  function getImpl(name) {
    if (true) {
      if (!implsStore[name]) {
        error("Implementation of " + name + " doesn't exists.");
      }
    }
    return implsStore[name];
  }

  // node_modules/echarts/lib/core/echarts.js
  var hasWindow = typeof window !== "undefined";
  var version2 = "5.3.3";
  var dependencies = {
    zrender: "5.3.2"
  };
  var TEST_FRAME_REMAIN_TIME = 1;
  var PRIORITY_PROCESSOR_SERIES_FILTER = 800;
  var PRIORITY_PROCESSOR_DATASTACK = 900;
  var PRIORITY_PROCESSOR_FILTER = 1e3;
  var PRIORITY_PROCESSOR_DEFAULT = 2e3;
  var PRIORITY_PROCESSOR_STATISTIC = 5e3;
  var PRIORITY_VISUAL_LAYOUT = 1e3;
  var PRIORITY_VISUAL_PROGRESSIVE_LAYOUT = 1100;
  var PRIORITY_VISUAL_GLOBAL = 2e3;
  var PRIORITY_VISUAL_CHART = 3e3;
  var PRIORITY_VISUAL_COMPONENT = 4e3;
  var PRIORITY_VISUAL_CHART_DATA_CUSTOM = 4500;
  var PRIORITY_VISUAL_POST_CHART_LAYOUT = 4600;
  var PRIORITY_VISUAL_BRUSH = 5e3;
  var PRIORITY_VISUAL_ARIA = 6e3;
  var PRIORITY_VISUAL_DECAL = 7e3;
  var PRIORITY = {
    PROCESSOR: {
      FILTER: PRIORITY_PROCESSOR_FILTER,
      SERIES_FILTER: PRIORITY_PROCESSOR_SERIES_FILTER,
      STATISTIC: PRIORITY_PROCESSOR_STATISTIC
    },
    VISUAL: {
      LAYOUT: PRIORITY_VISUAL_LAYOUT,
      PROGRESSIVE_LAYOUT: PRIORITY_VISUAL_PROGRESSIVE_LAYOUT,
      GLOBAL: PRIORITY_VISUAL_GLOBAL,
      CHART: PRIORITY_VISUAL_CHART,
      POST_CHART_LAYOUT: PRIORITY_VISUAL_POST_CHART_LAYOUT,
      COMPONENT: PRIORITY_VISUAL_COMPONENT,
      BRUSH: PRIORITY_VISUAL_BRUSH,
      CHART_ITEM: PRIORITY_VISUAL_CHART_DATA_CUSTOM,
      ARIA: PRIORITY_VISUAL_ARIA,
      DECAL: PRIORITY_VISUAL_DECAL
    }
  };
  var IN_MAIN_PROCESS_KEY = "__flagInMainProcess";
  var PENDING_UPDATE = "__pendingUpdate";
  var STATUS_NEEDS_UPDATE_KEY = "__needsUpdateStatus";
  var ACTION_REG = /^[a-zA-Z0-9_]+$/;
  var CONNECT_STATUS_KEY = "__connectUpdateStatus";
  var CONNECT_STATUS_PENDING = 0;
  var CONNECT_STATUS_UPDATING = 1;
  var CONNECT_STATUS_UPDATED = 2;
  function createRegisterEventWithLowercaseECharts(method) {
    return function() {
      var args = [];
      for (var _i = 0; _i < arguments.length; _i++) {
        args[_i] = arguments[_i];
      }
      if (this.isDisposed()) {
        disposedWarning(this.id);
        return;
      }
      return toLowercaseNameAndCallEventful(this, method, args);
    };
  }
  function createRegisterEventWithLowercaseMessageCenter(method) {
    return function() {
      var args = [];
      for (var _i = 0; _i < arguments.length; _i++) {
        args[_i] = arguments[_i];
      }
      return toLowercaseNameAndCallEventful(this, method, args);
    };
  }
  function toLowercaseNameAndCallEventful(host, method, args) {
    args[0] = args[0] && args[0].toLowerCase();
    return Eventful_default.prototype[method].apply(host, args);
  }
  var MessageCenter = function(_super) {
    __extends(MessageCenter2, _super);
    function MessageCenter2() {
      return _super !== null && _super.apply(this, arguments) || this;
    }
    return MessageCenter2;
  }(Eventful_default);
  var messageCenterProto = MessageCenter.prototype;
  messageCenterProto.on = createRegisterEventWithLowercaseMessageCenter("on");
  messageCenterProto.off = createRegisterEventWithLowercaseMessageCenter("off");
  var prepare;
  var prepareView;
  var updateDirectly;
  var updateMethods;
  var doConvertPixel;
  var updateStreamModes;
  var doDispatchAction;
  var flushPendingActions;
  var triggerUpdatedEvent;
  var bindRenderedEvent;
  var bindMouseEvent;
  var render;
  var renderComponents;
  var renderSeries;
  var createExtensionAPI;
  var enableConnect;
  var markStatusToUpdate;
  var applyChangedStates;
  var ECharts = function(_super) {
    __extends(ECharts2, _super);
    function ECharts2(dom, theme2, opts) {
      var _this = _super.call(this, new ECEventProcessor()) || this;
      _this._chartsViews = [];
      _this._chartsMap = {};
      _this._componentsViews = [];
      _this._componentsMap = {};
      _this._pendingActions = [];
      opts = opts || {};
      if (isString(theme2)) {
        theme2 = themeStorage[theme2];
      }
      _this._dom = dom;
      var defaultRenderer = "canvas";
      var defaultUseDirtyRect = false;
      if (true) {
        var root = hasWindow ? window : global;
        defaultRenderer = root.__ECHARTS__DEFAULT__RENDERER__ || defaultRenderer;
        var devUseDirtyRect = root.__ECHARTS__DEFAULT__USE_DIRTY_RECT__;
        defaultUseDirtyRect = devUseDirtyRect == null ? defaultUseDirtyRect : devUseDirtyRect;
      }
      var zr = _this._zr = init(dom, {
        renderer: opts.renderer || defaultRenderer,
        devicePixelRatio: opts.devicePixelRatio,
        width: opts.width,
        height: opts.height,
        ssr: opts.ssr,
        useDirtyRect: opts.useDirtyRect == null ? defaultUseDirtyRect : opts.useDirtyRect
      });
      _this._ssr = opts.ssr;
      _this._throttledZrFlush = throttle(bind(zr.flush, zr), 17);
      theme2 = clone(theme2);
      theme2 && globalBackwardCompat(theme2, true);
      _this._theme = theme2;
      _this._locale = createLocaleObject(opts.locale || SYSTEM_LANG);
      _this._coordSysMgr = new CoordinateSystem_default();
      var api = _this._api = createExtensionAPI(_this);
      function prioritySortFunc(a, b) {
        return a.__prio - b.__prio;
      }
      sort(visualFuncs, prioritySortFunc);
      sort(dataProcessorFuncs, prioritySortFunc);
      _this._scheduler = new Scheduler_default(_this, api, dataProcessorFuncs, visualFuncs);
      _this._messageCenter = new MessageCenter();
      _this._initEvents();
      _this.resize = bind(_this.resize, _this);
      zr.animation.on("frame", _this._onframe, _this);
      bindRenderedEvent(zr, _this);
      bindMouseEvent(zr, _this);
      setAsPrimitive(_this);
      return _this;
    }
    ECharts2.prototype._onframe = function() {
      if (this._disposed) {
        return;
      }
      applyChangedStates(this);
      var scheduler = this._scheduler;
      if (this[PENDING_UPDATE]) {
        var silent = this[PENDING_UPDATE].silent;
        this[IN_MAIN_PROCESS_KEY] = true;
        try {
          prepare(this);
          updateMethods.update.call(this, null, this[PENDING_UPDATE].updateParams);
        } catch (e2) {
          this[IN_MAIN_PROCESS_KEY] = false;
          this[PENDING_UPDATE] = null;
          throw e2;
        }
        this._zr.flush();
        this[IN_MAIN_PROCESS_KEY] = false;
        this[PENDING_UPDATE] = null;
        flushPendingActions.call(this, silent);
        triggerUpdatedEvent.call(this, silent);
      } else if (scheduler.unfinished) {
        var remainTime = TEST_FRAME_REMAIN_TIME;
        var ecModel = this._model;
        var api = this._api;
        scheduler.unfinished = false;
        do {
          var startTime = +new Date();
          scheduler.performSeriesTasks(ecModel);
          scheduler.performDataProcessorTasks(ecModel);
          updateStreamModes(this, ecModel);
          scheduler.performVisualTasks(ecModel);
          renderSeries(this, this._model, api, "remain", {});
          remainTime -= +new Date() - startTime;
        } while (remainTime > 0 && scheduler.unfinished);
        if (!scheduler.unfinished) {
          this._zr.flush();
        }
      }
    };
    ECharts2.prototype.getDom = function() {
      return this._dom;
    };
    ECharts2.prototype.getId = function() {
      return this.id;
    };
    ECharts2.prototype.getZr = function() {
      return this._zr;
    };
    ECharts2.prototype.isSSR = function() {
      return this._ssr;
    };
    ECharts2.prototype.setOption = function(option, notMerge, lazyUpdate) {
      if (this[IN_MAIN_PROCESS_KEY]) {
        if (true) {
          error("`setOption` should not be called during main process.");
        }
        return;
      }
      if (this._disposed) {
        disposedWarning(this.id);
        return;
      }
      var silent;
      var replaceMerge;
      var transitionOpt;
      if (isObject(notMerge)) {
        lazyUpdate = notMerge.lazyUpdate;
        silent = notMerge.silent;
        replaceMerge = notMerge.replaceMerge;
        transitionOpt = notMerge.transition;
        notMerge = notMerge.notMerge;
      }
      this[IN_MAIN_PROCESS_KEY] = true;
      if (!this._model || notMerge) {
        var optionManager = new OptionManager_default(this._api);
        var theme2 = this._theme;
        var ecModel = this._model = new Global_default();
        ecModel.scheduler = this._scheduler;
        ecModel.ssr = this._ssr;
        ecModel.init(null, null, null, theme2, this._locale, optionManager);
      }
      this._model.setOption(option, {
        replaceMerge
      }, optionPreprocessorFuncs);
      var updateParams = {
        seriesTransition: transitionOpt,
        optionChanged: true
      };
      if (lazyUpdate) {
        this[PENDING_UPDATE] = {
          silent,
          updateParams
        };
        this[IN_MAIN_PROCESS_KEY] = false;
        this.getZr().wakeUp();
      } else {
        try {
          prepare(this);
          updateMethods.update.call(this, null, updateParams);
        } catch (e2) {
          this[PENDING_UPDATE] = null;
          this[IN_MAIN_PROCESS_KEY] = false;
          throw e2;
        }
        if (!this._ssr) {
          this._zr.flush();
        }
        this[PENDING_UPDATE] = null;
        this[IN_MAIN_PROCESS_KEY] = false;
        flushPendingActions.call(this, silent);
        triggerUpdatedEvent.call(this, silent);
      }
    };
    ECharts2.prototype.setTheme = function() {
      deprecateLog("ECharts#setTheme() is DEPRECATED in ECharts 3.0");
    };
    ECharts2.prototype.getModel = function() {
      return this._model;
    };
    ECharts2.prototype.getOption = function() {
      return this._model && this._model.getOption();
    };
    ECharts2.prototype.getWidth = function() {
      return this._zr.getWidth();
    };
    ECharts2.prototype.getHeight = function() {
      return this._zr.getHeight();
    };
    ECharts2.prototype.getDevicePixelRatio = function() {
      return this._zr.painter.dpr || hasWindow && window.devicePixelRatio || 1;
    };
    ECharts2.prototype.getRenderedCanvas = function(opts) {
      if (true) {
        deprecateReplaceLog("getRenderedCanvas", "renderToCanvas");
      }
      return this.renderToCanvas(opts);
    };
    ECharts2.prototype.renderToCanvas = function(opts) {
      opts = opts || {};
      var painter = this._zr.painter;
      if (true) {
        if (painter.type !== "canvas") {
          throw new Error("renderToCanvas can only be used in the canvas renderer.");
        }
      }
      return painter.getRenderedCanvas({
        backgroundColor: opts.backgroundColor || this._model.get("backgroundColor"),
        pixelRatio: opts.pixelRatio || this.getDevicePixelRatio()
      });
    };
    ECharts2.prototype.renderToSVGString = function(opts) {
      opts = opts || {};
      var painter = this._zr.painter;
      if (true) {
        if (painter.type !== "svg") {
          throw new Error("renderToSVGString can only be used in the svg renderer.");
        }
      }
      return painter.renderToString({
        useViewBox: opts.useViewBox
      });
    };
    ECharts2.prototype.getSvgDataURL = function() {
      if (!env_default.svgSupported) {
        return;
      }
      var zr = this._zr;
      var list = zr.storage.getDisplayList();
      each(list, function(el) {
        el.stopAnimation(null, true);
      });
      return zr.painter.toDataURL();
    };
    ECharts2.prototype.getDataURL = function(opts) {
      if (this._disposed) {
        disposedWarning(this.id);
        return;
      }
      opts = opts || {};
      var excludeComponents = opts.excludeComponents;
      var ecModel = this._model;
      var excludesComponentViews = [];
      var self2 = this;
      each(excludeComponents, function(componentType) {
        ecModel.eachComponent({
          mainType: componentType
        }, function(component) {
          var view = self2._componentsMap[component.__viewId];
          if (!view.group.ignore) {
            excludesComponentViews.push(view);
            view.group.ignore = true;
          }
        });
      });
      var url = this._zr.painter.getType() === "svg" ? this.getSvgDataURL() : this.renderToCanvas(opts).toDataURL("image/" + (opts && opts.type || "png"));
      each(excludesComponentViews, function(view) {
        view.group.ignore = false;
      });
      return url;
    };
    ECharts2.prototype.getConnectedDataURL = function(opts) {
      if (this._disposed) {
        disposedWarning(this.id);
        return;
      }
      var isSvg = opts.type === "svg";
      var groupId = this.group;
      var mathMin12 = Math.min;
      var mathMax12 = Math.max;
      var MAX_NUMBER = Infinity;
      if (connectedGroups[groupId]) {
        var left_1 = MAX_NUMBER;
        var top_1 = MAX_NUMBER;
        var right_1 = -MAX_NUMBER;
        var bottom_1 = -MAX_NUMBER;
        var canvasList_1 = [];
        var dpr_1 = opts && opts.pixelRatio || this.getDevicePixelRatio();
        each(instances2, function(chart, id) {
          if (chart.group === groupId) {
            var canvas = isSvg ? chart.getZr().painter.getSvgDom().innerHTML : chart.renderToCanvas(clone(opts));
            var boundingRect = chart.getDom().getBoundingClientRect();
            left_1 = mathMin12(boundingRect.left, left_1);
            top_1 = mathMin12(boundingRect.top, top_1);
            right_1 = mathMax12(boundingRect.right, right_1);
            bottom_1 = mathMax12(boundingRect.bottom, bottom_1);
            canvasList_1.push({
              dom: canvas,
              left: boundingRect.left,
              top: boundingRect.top
            });
          }
        });
        left_1 *= dpr_1;
        top_1 *= dpr_1;
        right_1 *= dpr_1;
        bottom_1 *= dpr_1;
        var width = right_1 - left_1;
        var height = bottom_1 - top_1;
        var targetCanvas = platformApi.createCanvas();
        var zr_1 = init(targetCanvas, {
          renderer: isSvg ? "svg" : "canvas"
        });
        zr_1.resize({
          width,
          height
        });
        if (isSvg) {
          var content_1 = "";
          each(canvasList_1, function(item) {
            var x = item.left - left_1;
            var y = item.top - top_1;
            content_1 += '<g transform="translate(' + x + "," + y + ')">' + item.dom + "</g>";
          });
          zr_1.painter.getSvgRoot().innerHTML = content_1;
          if (opts.connectedBackgroundColor) {
            zr_1.painter.setBackgroundColor(opts.connectedBackgroundColor);
          }
          zr_1.refreshImmediately();
          return zr_1.painter.toDataURL();
        } else {
          if (opts.connectedBackgroundColor) {
            zr_1.add(new Rect_default({
              shape: {
                x: 0,
                y: 0,
                width,
                height
              },
              style: {
                fill: opts.connectedBackgroundColor
              }
            }));
          }
          each(canvasList_1, function(item) {
            var img = new Image_default({
              style: {
                x: item.left * dpr_1 - left_1,
                y: item.top * dpr_1 - top_1,
                image: item.dom
              }
            });
            zr_1.add(img);
          });
          zr_1.refreshImmediately();
          return targetCanvas.toDataURL("image/" + (opts && opts.type || "png"));
        }
      } else {
        return this.getDataURL(opts);
      }
    };
    ECharts2.prototype.convertToPixel = function(finder, value) {
      return doConvertPixel(this, "convertToPixel", finder, value);
    };
    ECharts2.prototype.convertFromPixel = function(finder, value) {
      return doConvertPixel(this, "convertFromPixel", finder, value);
    };
    ECharts2.prototype.containPixel = function(finder, value) {
      if (this._disposed) {
        disposedWarning(this.id);
        return;
      }
      var ecModel = this._model;
      var result;
      var findResult = parseFinder(ecModel, finder);
      each(findResult, function(models, key) {
        key.indexOf("Models") >= 0 && each(models, function(model) {
          var coordSys = model.coordinateSystem;
          if (coordSys && coordSys.containPoint) {
            result = result || !!coordSys.containPoint(value);
          } else if (key === "seriesModels") {
            var view = this._chartsMap[model.__viewId];
            if (view && view.containPoint) {
              result = result || view.containPoint(value, model);
            } else {
              if (true) {
                console.warn(key + ": " + (view ? "The found component do not support containPoint." : "No view mapping to the found component."));
              }
            }
          } else {
            if (true) {
              console.warn(key + ": containPoint is not supported");
            }
          }
        }, this);
      }, this);
      return !!result;
    };
    ECharts2.prototype.getVisual = function(finder, visualType) {
      var ecModel = this._model;
      var parsedFinder = parseFinder(ecModel, finder, {
        defaultMainType: "series"
      });
      var seriesModel = parsedFinder.seriesModel;
      if (true) {
        if (!seriesModel) {
          console.warn("There is no specified seires model");
        }
      }
      var data = seriesModel.getData();
      var dataIndexInside = parsedFinder.hasOwnProperty("dataIndexInside") ? parsedFinder.dataIndexInside : parsedFinder.hasOwnProperty("dataIndex") ? data.indexOfRawIndex(parsedFinder.dataIndex) : null;
      return dataIndexInside != null ? getItemVisualFromData(data, dataIndexInside, visualType) : getVisualFromData(data, visualType);
    };
    ECharts2.prototype.getViewOfComponentModel = function(componentModel) {
      return this._componentsMap[componentModel.__viewId];
    };
    ECharts2.prototype.getViewOfSeriesModel = function(seriesModel) {
      return this._chartsMap[seriesModel.__viewId];
    };
    ECharts2.prototype._initEvents = function() {
      var _this = this;
      each(MOUSE_EVENT_NAMES, function(eveName) {
        var handler = function(e2) {
          var ecModel = _this.getModel();
          var el = e2.target;
          var params;
          var isGlobalOut = eveName === "globalout";
          if (isGlobalOut) {
            params = {};
          } else {
            el && findEventDispatcher(el, function(parent) {
              var ecData = getECData(parent);
              if (ecData && ecData.dataIndex != null) {
                var dataModel = ecData.dataModel || ecModel.getSeriesByIndex(ecData.seriesIndex);
                params = dataModel && dataModel.getDataParams(ecData.dataIndex, ecData.dataType) || {};
                return true;
              } else if (ecData.eventData) {
                params = extend({}, ecData.eventData);
                return true;
              }
            }, true);
          }
          if (params) {
            var componentType = params.componentType;
            var componentIndex = params.componentIndex;
            if (componentType === "markLine" || componentType === "markPoint" || componentType === "markArea") {
              componentType = "series";
              componentIndex = params.seriesIndex;
            }
            var model = componentType && componentIndex != null && ecModel.getComponent(componentType, componentIndex);
            var view = model && _this[model.mainType === "series" ? "_chartsMap" : "_componentsMap"][model.__viewId];
            if (true) {
              if (!isGlobalOut && !(model && view)) {
                console.warn("model or view can not be found by params");
              }
            }
            params.event = e2;
            params.type = eveName;
            _this._$eventProcessor.eventInfo = {
              targetEl: el,
              packedEvent: params,
              model,
              view
            };
            _this.trigger(eveName, params);
          }
        };
        handler.zrEventfulCallAtLast = true;
        _this._zr.on(eveName, handler, _this);
      });
      each(eventActionMap, function(actionType, eventType) {
        _this._messageCenter.on(eventType, function(event) {
          this.trigger(eventType, event);
        }, _this);
      });
      each(["selectchanged"], function(eventType) {
        _this._messageCenter.on(eventType, function(event) {
          this.trigger(eventType, event);
        }, _this);
      });
      handleLegacySelectEvents(this._messageCenter, this, this._api);
    };
    ECharts2.prototype.isDisposed = function() {
      return this._disposed;
    };
    ECharts2.prototype.clear = function() {
      if (this._disposed) {
        disposedWarning(this.id);
        return;
      }
      this.setOption({
        series: []
      }, true);
    };
    ECharts2.prototype.dispose = function() {
      if (this._disposed) {
        disposedWarning(this.id);
        return;
      }
      this._disposed = true;
      var dom = this.getDom();
      if (dom) {
        setAttribute(this.getDom(), DOM_ATTRIBUTE_KEY, "");
      }
      var chart = this;
      var api = chart._api;
      var ecModel = chart._model;
      each(chart._componentsViews, function(component) {
        component.dispose(ecModel, api);
      });
      each(chart._chartsViews, function(chart2) {
        chart2.dispose(ecModel, api);
      });
      chart._zr.dispose();
      chart._dom = chart._model = chart._chartsMap = chart._componentsMap = chart._chartsViews = chart._componentsViews = chart._scheduler = chart._api = chart._zr = chart._throttledZrFlush = chart._theme = chart._coordSysMgr = chart._messageCenter = null;
      delete instances2[chart.id];
    };
    ECharts2.prototype.resize = function(opts) {
      if (this[IN_MAIN_PROCESS_KEY]) {
        if (true) {
          error("`resize` should not be called during main process.");
        }
        return;
      }
      if (this._disposed) {
        disposedWarning(this.id);
        return;
      }
      this._zr.resize(opts);
      var ecModel = this._model;
      this._loadingFX && this._loadingFX.resize();
      if (!ecModel) {
        return;
      }
      var needPrepare = ecModel.resetOption("media");
      var silent = opts && opts.silent;
      if (this[PENDING_UPDATE]) {
        if (silent == null) {
          silent = this[PENDING_UPDATE].silent;
        }
        needPrepare = true;
        this[PENDING_UPDATE] = null;
      }
      this[IN_MAIN_PROCESS_KEY] = true;
      try {
        needPrepare && prepare(this);
        updateMethods.update.call(this, {
          type: "resize",
          animation: extend({
            duration: 0
          }, opts && opts.animation)
        });
      } catch (e2) {
        this[IN_MAIN_PROCESS_KEY] = false;
        throw e2;
      }
      this[IN_MAIN_PROCESS_KEY] = false;
      flushPendingActions.call(this, silent);
      triggerUpdatedEvent.call(this, silent);
    };
    ECharts2.prototype.showLoading = function(name, cfg) {
      if (this._disposed) {
        disposedWarning(this.id);
        return;
      }
      if (isObject(name)) {
        cfg = name;
        name = "";
      }
      name = name || "default";
      this.hideLoading();
      if (!loadingEffects[name]) {
        if (true) {
          console.warn("Loading effects " + name + " not exists.");
        }
        return;
      }
      var el = loadingEffects[name](this._api, cfg);
      var zr = this._zr;
      this._loadingFX = el;
      zr.add(el);
    };
    ECharts2.prototype.hideLoading = function() {
      if (this._disposed) {
        disposedWarning(this.id);
        return;
      }
      this._loadingFX && this._zr.remove(this._loadingFX);
      this._loadingFX = null;
    };
    ECharts2.prototype.makeActionFromEvent = function(eventObj) {
      var payload = extend({}, eventObj);
      payload.type = eventActionMap[eventObj.type];
      return payload;
    };
    ECharts2.prototype.dispatchAction = function(payload, opt) {
      if (this._disposed) {
        disposedWarning(this.id);
        return;
      }
      if (!isObject(opt)) {
        opt = {
          silent: !!opt
        };
      }
      if (!actions[payload.type]) {
        return;
      }
      if (!this._model) {
        return;
      }
      if (this[IN_MAIN_PROCESS_KEY]) {
        this._pendingActions.push(payload);
        return;
      }
      var silent = opt.silent;
      doDispatchAction.call(this, payload, silent);
      var flush = opt.flush;
      if (flush) {
        this._zr.flush();
      } else if (flush !== false && env_default.browser.weChat) {
        this._throttledZrFlush();
      }
      flushPendingActions.call(this, silent);
      triggerUpdatedEvent.call(this, silent);
    };
    ECharts2.prototype.updateLabelLayout = function() {
      lifecycle_default.trigger("series:layoutlabels", this._model, this._api, {
        updatedSeries: []
      });
    };
    ECharts2.prototype.appendData = function(params) {
      if (this._disposed) {
        disposedWarning(this.id);
        return;
      }
      var seriesIndex = params.seriesIndex;
      var ecModel = this.getModel();
      var seriesModel = ecModel.getSeriesByIndex(seriesIndex);
      if (true) {
        assert(params.data && seriesModel);
      }
      seriesModel.appendData(params);
      this._scheduler.unfinished = true;
      this.getZr().wakeUp();
    };
    ECharts2.internalField = function() {
      prepare = function(ecIns) {
        var scheduler = ecIns._scheduler;
        scheduler.restorePipelines(ecIns._model);
        scheduler.prepareStageTasks();
        prepareView(ecIns, true);
        prepareView(ecIns, false);
        scheduler.plan();
      };
      prepareView = function(ecIns, isComponent) {
        var ecModel = ecIns._model;
        var scheduler = ecIns._scheduler;
        var viewList = isComponent ? ecIns._componentsViews : ecIns._chartsViews;
        var viewMap = isComponent ? ecIns._componentsMap : ecIns._chartsMap;
        var zr = ecIns._zr;
        var api = ecIns._api;
        for (var i = 0; i < viewList.length; i++) {
          viewList[i].__alive = false;
        }
        isComponent ? ecModel.eachComponent(function(componentType, model) {
          componentType !== "series" && doPrepare(model);
        }) : ecModel.eachSeries(doPrepare);
        function doPrepare(model) {
          var requireNewView = model.__requireNewView;
          model.__requireNewView = false;
          var viewId = "_ec_" + model.id + "_" + model.type;
          var view2 = !requireNewView && viewMap[viewId];
          if (!view2) {
            var classType = parseClassType(model.type);
            var Clazz = isComponent ? Component_default2.getClass(classType.main, classType.sub) : Chart_default.getClass(classType.sub);
            if (true) {
              assert(Clazz, classType.sub + " does not exist.");
            }
            view2 = new Clazz();
            view2.init(ecModel, api);
            viewMap[viewId] = view2;
            viewList.push(view2);
            zr.add(view2.group);
          }
          model.__viewId = view2.__id = viewId;
          view2.__alive = true;
          view2.__model = model;
          view2.group.__ecComponentInfo = {
            mainType: model.mainType,
            index: model.componentIndex
          };
          !isComponent && scheduler.prepareView(view2, model, ecModel, api);
        }
        for (var i = 0; i < viewList.length; ) {
          var view = viewList[i];
          if (!view.__alive) {
            !isComponent && view.renderTask.dispose();
            zr.remove(view.group);
            view.dispose(ecModel, api);
            viewList.splice(i, 1);
            if (viewMap[view.__id] === view) {
              delete viewMap[view.__id];
            }
            view.__id = view.group.__ecComponentInfo = null;
          } else {
            i++;
          }
        }
      };
      updateDirectly = function(ecIns, method, payload, mainType, subType) {
        var ecModel = ecIns._model;
        ecModel.setUpdatePayload(payload);
        if (!mainType) {
          each([].concat(ecIns._componentsViews).concat(ecIns._chartsViews), callView);
          return;
        }
        var query = {};
        query[mainType + "Id"] = payload[mainType + "Id"];
        query[mainType + "Index"] = payload[mainType + "Index"];
        query[mainType + "Name"] = payload[mainType + "Name"];
        var condition = {
          mainType,
          query
        };
        subType && (condition.subType = subType);
        var excludeSeriesId = payload.excludeSeriesId;
        var excludeSeriesIdMap;
        if (excludeSeriesId != null) {
          excludeSeriesIdMap = createHashMap();
          each(normalizeToArray(excludeSeriesId), function(id) {
            var modelId = convertOptionIdName(id, null);
            if (modelId != null) {
              excludeSeriesIdMap.set(modelId, true);
            }
          });
        }
        ecModel && ecModel.eachComponent(condition, function(model) {
          var isExcluded = excludeSeriesIdMap && excludeSeriesIdMap.get(model.id) !== null;
          if (isExcluded) {
            return;
          }
          ;
          if (isHighDownPayload(payload)) {
            if (model instanceof Series_default) {
              if (payload.type === HIGHLIGHT_ACTION_TYPE && !payload.notBlur && !model.get(["emphasis", "disabled"])) {
                blurSeriesFromHighlightPayload(model, payload, ecIns._api);
              }
            } else {
              var _a2 = findComponentHighDownDispatchers(model.mainType, model.componentIndex, payload.name, ecIns._api), focusSelf = _a2.focusSelf, dispatchers = _a2.dispatchers;
              if (payload.type === HIGHLIGHT_ACTION_TYPE && focusSelf && !payload.notBlur) {
                blurComponent(model.mainType, model.componentIndex, ecIns._api);
              }
              if (dispatchers) {
                each(dispatchers, function(dispatcher) {
                  payload.type === HIGHLIGHT_ACTION_TYPE ? enterEmphasis(dispatcher) : leaveEmphasis(dispatcher);
                });
              }
            }
          } else if (isSelectChangePayload(payload)) {
            if (model instanceof Series_default) {
              toggleSelectionFromPayload(model, payload, ecIns._api);
              updateSeriesElementSelection(model);
              markStatusToUpdate(ecIns);
            }
          }
        }, ecIns);
        ecModel && ecModel.eachComponent(condition, function(model) {
          var isExcluded = excludeSeriesIdMap && excludeSeriesIdMap.get(model.id) !== null;
          if (isExcluded) {
            return;
          }
          ;
          callView(ecIns[mainType === "series" ? "_chartsMap" : "_componentsMap"][model.__viewId]);
        }, ecIns);
        function callView(view) {
          view && view.__alive && view[method] && view[method](view.__model, ecModel, ecIns._api, payload);
        }
      };
      updateMethods = {
        prepareAndUpdate: function(payload) {
          prepare(this);
          updateMethods.update.call(this, payload, {
            optionChanged: payload.newOption != null
          });
        },
        update: function(payload, updateParams) {
          var ecModel = this._model;
          var api = this._api;
          var zr = this._zr;
          var coordSysMgr = this._coordSysMgr;
          var scheduler = this._scheduler;
          if (!ecModel) {
            return;
          }
          ecModel.setUpdatePayload(payload);
          scheduler.restoreData(ecModel, payload);
          scheduler.performSeriesTasks(ecModel);
          coordSysMgr.create(ecModel, api);
          scheduler.performDataProcessorTasks(ecModel, payload);
          updateStreamModes(this, ecModel);
          coordSysMgr.update(ecModel, api);
          clearColorPalette(ecModel);
          scheduler.performVisualTasks(ecModel, payload);
          render(this, ecModel, api, payload, updateParams);
          var backgroundColor2 = ecModel.get("backgroundColor") || "transparent";
          var darkMode = ecModel.get("darkMode");
          zr.setBackgroundColor(backgroundColor2);
          if (darkMode != null && darkMode !== "auto") {
            zr.setDarkMode(darkMode);
          }
          lifecycle_default.trigger("afterupdate", ecModel, api);
        },
        updateTransform: function(payload) {
          var _this = this;
          var ecModel = this._model;
          var api = this._api;
          if (!ecModel) {
            return;
          }
          ecModel.setUpdatePayload(payload);
          var componentDirtyList = [];
          ecModel.eachComponent(function(componentType, componentModel) {
            if (componentType === "series") {
              return;
            }
            var componentView = _this.getViewOfComponentModel(componentModel);
            if (componentView && componentView.__alive) {
              if (componentView.updateTransform) {
                var result = componentView.updateTransform(componentModel, ecModel, api, payload);
                result && result.update && componentDirtyList.push(componentView);
              } else {
                componentDirtyList.push(componentView);
              }
            }
          });
          var seriesDirtyMap = createHashMap();
          ecModel.eachSeries(function(seriesModel) {
            var chartView = _this._chartsMap[seriesModel.__viewId];
            if (chartView.updateTransform) {
              var result = chartView.updateTransform(seriesModel, ecModel, api, payload);
              result && result.update && seriesDirtyMap.set(seriesModel.uid, 1);
            } else {
              seriesDirtyMap.set(seriesModel.uid, 1);
            }
          });
          clearColorPalette(ecModel);
          this._scheduler.performVisualTasks(ecModel, payload, {
            setDirty: true,
            dirtyMap: seriesDirtyMap
          });
          renderSeries(this, ecModel, api, payload, {}, seriesDirtyMap);
          lifecycle_default.trigger("afterupdate", ecModel, api);
        },
        updateView: function(payload) {
          var ecModel = this._model;
          if (!ecModel) {
            return;
          }
          ecModel.setUpdatePayload(payload);
          Chart_default.markUpdateMethod(payload, "updateView");
          clearColorPalette(ecModel);
          this._scheduler.performVisualTasks(ecModel, payload, {
            setDirty: true
          });
          render(this, ecModel, this._api, payload, {});
          lifecycle_default.trigger("afterupdate", ecModel, this._api);
        },
        updateVisual: function(payload) {
          var _this = this;
          var ecModel = this._model;
          if (!ecModel) {
            return;
          }
          ecModel.setUpdatePayload(payload);
          ecModel.eachSeries(function(seriesModel) {
            seriesModel.getData().clearAllVisual();
          });
          Chart_default.markUpdateMethod(payload, "updateVisual");
          clearColorPalette(ecModel);
          this._scheduler.performVisualTasks(ecModel, payload, {
            visualType: "visual",
            setDirty: true
          });
          ecModel.eachComponent(function(componentType, componentModel) {
            if (componentType !== "series") {
              var componentView = _this.getViewOfComponentModel(componentModel);
              componentView && componentView.__alive && componentView.updateVisual(componentModel, ecModel, _this._api, payload);
            }
          });
          ecModel.eachSeries(function(seriesModel) {
            var chartView = _this._chartsMap[seriesModel.__viewId];
            chartView.updateVisual(seriesModel, ecModel, _this._api, payload);
          });
          lifecycle_default.trigger("afterupdate", ecModel, this._api);
        },
        updateLayout: function(payload) {
          updateMethods.update.call(this, payload);
        }
      };
      doConvertPixel = function(ecIns, methodName, finder, value) {
        if (ecIns._disposed) {
          disposedWarning(ecIns.id);
          return;
        }
        var ecModel = ecIns._model;
        var coordSysList = ecIns._coordSysMgr.getCoordinateSystems();
        var result;
        var parsedFinder = parseFinder(ecModel, finder);
        for (var i = 0; i < coordSysList.length; i++) {
          var coordSys = coordSysList[i];
          if (coordSys[methodName] && (result = coordSys[methodName](ecModel, parsedFinder, value)) != null) {
            return result;
          }
        }
        if (true) {
          console.warn("No coordinate system that supports " + methodName + " found by the given finder.");
        }
      };
      updateStreamModes = function(ecIns, ecModel) {
        var chartsMap = ecIns._chartsMap;
        var scheduler = ecIns._scheduler;
        ecModel.eachSeries(function(seriesModel) {
          scheduler.updateStreamModes(seriesModel, chartsMap[seriesModel.__viewId]);
        });
      };
      doDispatchAction = function(payload, silent) {
        var _this = this;
        var ecModel = this.getModel();
        var payloadType = payload.type;
        var escapeConnect = payload.escapeConnect;
        var actionWrap = actions[payloadType];
        var actionInfo3 = actionWrap.actionInfo;
        var cptTypeTmp = (actionInfo3.update || "update").split(":");
        var updateMethod = cptTypeTmp.pop();
        var cptType = cptTypeTmp[0] != null && parseClassType(cptTypeTmp[0]);
        this[IN_MAIN_PROCESS_KEY] = true;
        var payloads = [payload];
        var batched = false;
        if (payload.batch) {
          batched = true;
          payloads = map(payload.batch, function(item) {
            item = defaults(extend({}, item), payload);
            item.batch = null;
            return item;
          });
        }
        var eventObjBatch = [];
        var eventObj;
        var isSelectChange = isSelectChangePayload(payload);
        var isHighDown = isHighDownPayload(payload);
        if (isHighDown) {
          allLeaveBlur(this._api);
        }
        each(payloads, function(batchItem) {
          eventObj = actionWrap.action(batchItem, _this._model, _this._api);
          eventObj = eventObj || extend({}, batchItem);
          eventObj.type = actionInfo3.event || eventObj.type;
          eventObjBatch.push(eventObj);
          if (isHighDown) {
            var _a2 = preParseFinder(payload), queryOptionMap = _a2.queryOptionMap, mainTypeSpecified = _a2.mainTypeSpecified;
            var componentMainType = mainTypeSpecified ? queryOptionMap.keys()[0] : "series";
            updateDirectly(_this, updateMethod, batchItem, componentMainType);
            markStatusToUpdate(_this);
          } else if (isSelectChange) {
            updateDirectly(_this, updateMethod, batchItem, "series");
            markStatusToUpdate(_this);
          } else if (cptType) {
            updateDirectly(_this, updateMethod, batchItem, cptType.main, cptType.sub);
          }
        });
        if (updateMethod !== "none" && !isHighDown && !isSelectChange && !cptType) {
          try {
            if (this[PENDING_UPDATE]) {
              prepare(this);
              updateMethods.update.call(this, payload);
              this[PENDING_UPDATE] = null;
            } else {
              updateMethods[updateMethod].call(this, payload);
            }
          } catch (e2) {
            this[IN_MAIN_PROCESS_KEY] = false;
            throw e2;
          }
        }
        if (batched) {
          eventObj = {
            type: actionInfo3.event || payloadType,
            escapeConnect,
            batch: eventObjBatch
          };
        } else {
          eventObj = eventObjBatch[0];
        }
        this[IN_MAIN_PROCESS_KEY] = false;
        if (!silent) {
          var messageCenter = this._messageCenter;
          messageCenter.trigger(eventObj.type, eventObj);
          if (isSelectChange) {
            var newObj = {
              type: "selectchanged",
              escapeConnect,
              selected: getAllSelectedIndices(ecModel),
              isFromClick: payload.isFromClick || false,
              fromAction: payload.type,
              fromActionPayload: payload
            };
            messageCenter.trigger(newObj.type, newObj);
          }
        }
      };
      flushPendingActions = function(silent) {
        var pendingActions = this._pendingActions;
        while (pendingActions.length) {
          var payload = pendingActions.shift();
          doDispatchAction.call(this, payload, silent);
        }
      };
      triggerUpdatedEvent = function(silent) {
        !silent && this.trigger("updated");
      };
      bindRenderedEvent = function(zr, ecIns) {
        zr.on("rendered", function(params) {
          ecIns.trigger("rendered", params);
          if (zr.animation.isFinished() && !ecIns[PENDING_UPDATE] && !ecIns._scheduler.unfinished && !ecIns._pendingActions.length) {
            ecIns.trigger("finished");
          }
        });
      };
      bindMouseEvent = function(zr, ecIns) {
        zr.on("mouseover", function(e2) {
          var el = e2.target;
          var dispatcher = findEventDispatcher(el, isHighDownDispatcher);
          if (dispatcher) {
            handleGlobalMouseOverForHighDown(dispatcher, e2, ecIns._api);
            markStatusToUpdate(ecIns);
          }
        }).on("mouseout", function(e2) {
          var el = e2.target;
          var dispatcher = findEventDispatcher(el, isHighDownDispatcher);
          if (dispatcher) {
            handleGlobalMouseOutForHighDown(dispatcher, e2, ecIns._api);
            markStatusToUpdate(ecIns);
          }
        }).on("click", function(e2) {
          var el = e2.target;
          var dispatcher = findEventDispatcher(el, function(target) {
            return getECData(target).dataIndex != null;
          }, true);
          if (dispatcher) {
            var actionType = dispatcher.selected ? "unselect" : "select";
            var ecData = getECData(dispatcher);
            ecIns._api.dispatchAction({
              type: actionType,
              dataType: ecData.dataType,
              dataIndexInside: ecData.dataIndex,
              seriesIndex: ecData.seriesIndex,
              isFromClick: true
            });
          }
        });
      };
      function clearColorPalette(ecModel) {
        ecModel.clearColorPalette();
        ecModel.eachSeries(function(seriesModel) {
          seriesModel.clearColorPalette();
        });
      }
      ;
      function allocateZlevels(ecModel) {
        ;
        var componentZLevels = [];
        var seriesZLevels = [];
        var hasSeperateZLevel = false;
        ecModel.eachComponent(function(componentType, componentModel) {
          var zlevel = componentModel.get("zlevel") || 0;
          var z = componentModel.get("z") || 0;
          var zlevelKey = componentModel.getZLevelKey();
          hasSeperateZLevel = hasSeperateZLevel || !!zlevelKey;
          (componentType === "series" ? seriesZLevels : componentZLevels).push({
            zlevel,
            z,
            idx: componentModel.componentIndex,
            type: componentType,
            key: zlevelKey
          });
        });
        if (hasSeperateZLevel) {
          var zLevels = componentZLevels.concat(seriesZLevels);
          var lastSeriesZLevel_1;
          var lastSeriesKey_1;
          sort(zLevels, function(a, b) {
            if (a.zlevel === b.zlevel) {
              return a.z - b.z;
            }
            return a.zlevel - b.zlevel;
          });
          each(zLevels, function(item) {
            var componentModel = ecModel.getComponent(item.type, item.idx);
            var zlevel = item.zlevel;
            var key = item.key;
            if (lastSeriesZLevel_1 != null) {
              zlevel = Math.max(lastSeriesZLevel_1, zlevel);
            }
            if (key) {
              if (zlevel === lastSeriesZLevel_1 && key !== lastSeriesKey_1) {
                zlevel++;
              }
              lastSeriesKey_1 = key;
            } else if (lastSeriesKey_1) {
              if (zlevel === lastSeriesZLevel_1) {
                zlevel++;
              }
              lastSeriesKey_1 = "";
            }
            lastSeriesZLevel_1 = zlevel;
            componentModel.setZLevel(zlevel);
          });
        }
      }
      render = function(ecIns, ecModel, api, payload, updateParams) {
        allocateZlevels(ecModel);
        renderComponents(ecIns, ecModel, api, payload, updateParams);
        each(ecIns._chartsViews, function(chart) {
          chart.__alive = false;
        });
        renderSeries(ecIns, ecModel, api, payload, updateParams);
        each(ecIns._chartsViews, function(chart) {
          if (!chart.__alive) {
            chart.remove(ecModel, api);
          }
        });
      };
      renderComponents = function(ecIns, ecModel, api, payload, updateParams, dirtyList) {
        each(dirtyList || ecIns._componentsViews, function(componentView) {
          var componentModel = componentView.__model;
          clearStates(componentModel, componentView);
          componentView.render(componentModel, ecModel, api, payload);
          updateZ3(componentModel, componentView);
          updateStates(componentModel, componentView);
        });
      };
      renderSeries = function(ecIns, ecModel, api, payload, updateParams, dirtyMap) {
        var scheduler = ecIns._scheduler;
        updateParams = extend(updateParams || {}, {
          updatedSeries: ecModel.getSeries()
        });
        lifecycle_default.trigger("series:beforeupdate", ecModel, api, updateParams);
        var unfinished = false;
        ecModel.eachSeries(function(seriesModel) {
          var chartView = ecIns._chartsMap[seriesModel.__viewId];
          chartView.__alive = true;
          var renderTask = chartView.renderTask;
          scheduler.updatePayload(renderTask, payload);
          clearStates(seriesModel, chartView);
          if (dirtyMap && dirtyMap.get(seriesModel.uid)) {
            renderTask.dirty();
          }
          if (renderTask.perform(scheduler.getPerformArgs(renderTask))) {
            unfinished = true;
          }
          chartView.group.silent = !!seriesModel.get("silent");
          updateBlend(seriesModel, chartView);
          updateSeriesElementSelection(seriesModel);
        });
        scheduler.unfinished = unfinished || scheduler.unfinished;
        lifecycle_default.trigger("series:layoutlabels", ecModel, api, updateParams);
        lifecycle_default.trigger("series:transition", ecModel, api, updateParams);
        ecModel.eachSeries(function(seriesModel) {
          var chartView = ecIns._chartsMap[seriesModel.__viewId];
          updateZ3(seriesModel, chartView);
          updateStates(seriesModel, chartView);
        });
        updateHoverLayerStatus(ecIns, ecModel);
        lifecycle_default.trigger("series:afterupdate", ecModel, api, updateParams);
      };
      markStatusToUpdate = function(ecIns) {
        ecIns[STATUS_NEEDS_UPDATE_KEY] = true;
        ecIns.getZr().wakeUp();
      };
      applyChangedStates = function(ecIns) {
        if (!ecIns[STATUS_NEEDS_UPDATE_KEY]) {
          return;
        }
        ecIns.getZr().storage.traverse(function(el) {
          if (isElementRemoved(el)) {
            return;
          }
          applyElementStates(el);
        });
        ecIns[STATUS_NEEDS_UPDATE_KEY] = false;
      };
      function applyElementStates(el) {
        var newStates = [];
        var oldStates = el.currentStates;
        for (var i = 0; i < oldStates.length; i++) {
          var stateName = oldStates[i];
          if (!(stateName === "emphasis" || stateName === "blur" || stateName === "select")) {
            newStates.push(stateName);
          }
        }
        if (el.selected && el.states.select) {
          newStates.push("select");
        }
        if (el.hoverState === HOVER_STATE_EMPHASIS && el.states.emphasis) {
          newStates.push("emphasis");
        } else if (el.hoverState === HOVER_STATE_BLUR && el.states.blur) {
          newStates.push("blur");
        }
        el.useStates(newStates);
      }
      function updateHoverLayerStatus(ecIns, ecModel) {
        var zr = ecIns._zr;
        var storage2 = zr.storage;
        var elCount = 0;
        storage2.traverse(function(el) {
          if (!el.isGroup) {
            elCount++;
          }
        });
        if (elCount > ecModel.get("hoverLayerThreshold") && !env_default.node && !env_default.worker) {
          ecModel.eachSeries(function(seriesModel) {
            if (seriesModel.preventUsingHoverLayer) {
              return;
            }
            var chartView = ecIns._chartsMap[seriesModel.__viewId];
            if (chartView.__alive) {
              chartView.eachRendered(function(el) {
                if (el.states.emphasis) {
                  el.states.emphasis.hoverLayer = true;
                }
              });
            }
          });
        }
      }
      ;
      function updateBlend(seriesModel, chartView) {
        var blendMode = seriesModel.get("blendMode") || null;
        chartView.eachRendered(function(el) {
          if (!el.isGroup) {
            el.style.blend = blendMode;
          }
        });
      }
      ;
      function updateZ3(model, view) {
        if (model.preventAutoZ) {
          return;
        }
        var z = model.get("z") || 0;
        var zlevel = model.get("zlevel") || 0;
        view.eachRendered(function(el) {
          doUpdateZ(el, z, zlevel, -Infinity);
          return true;
        });
      }
      ;
      function doUpdateZ(el, z, zlevel, maxZ2) {
        var label = el.getTextContent();
        var labelLine = el.getTextGuideLine();
        var isGroup = el.isGroup;
        if (isGroup) {
          var children = el.childrenRef();
          for (var i = 0; i < children.length; i++) {
            maxZ2 = Math.max(doUpdateZ(children[i], z, zlevel, maxZ2), maxZ2);
          }
        } else {
          el.z = z;
          el.zlevel = zlevel;
          maxZ2 = Math.max(el.z2, maxZ2);
        }
        if (label) {
          label.z = z;
          label.zlevel = zlevel;
          isFinite(maxZ2) && (label.z2 = maxZ2 + 2);
        }
        if (labelLine) {
          var textGuideLineConfig = el.textGuideLineConfig;
          labelLine.z = z;
          labelLine.zlevel = zlevel;
          isFinite(maxZ2) && (labelLine.z2 = maxZ2 + (textGuideLineConfig && textGuideLineConfig.showAbove ? 1 : -1));
        }
        return maxZ2;
      }
      function clearStates(model, view) {
        view.eachRendered(function(el) {
          if (isElementRemoved(el)) {
            return;
          }
          var textContent = el.getTextContent();
          var textGuide = el.getTextGuideLine();
          if (el.stateTransition) {
            el.stateTransition = null;
          }
          if (textContent && textContent.stateTransition) {
            textContent.stateTransition = null;
          }
          if (textGuide && textGuide.stateTransition) {
            textGuide.stateTransition = null;
          }
          if (el.hasState()) {
            el.prevStates = el.currentStates;
            el.clearStates();
          } else if (el.prevStates) {
            el.prevStates = null;
          }
        });
      }
      function updateStates(model, view) {
        var stateAnimationModel = model.getModel("stateAnimation");
        var enableAnimation = model.isAnimationEnabled();
        var duration = stateAnimationModel.get("duration");
        var stateTransition = duration > 0 ? {
          duration,
          delay: stateAnimationModel.get("delay"),
          easing: stateAnimationModel.get("easing")
        } : null;
        view.eachRendered(function(el) {
          if (el.states && el.states.emphasis) {
            if (isElementRemoved(el)) {
              return;
            }
            if (el instanceof Path_default) {
              savePathStates(el);
            }
            if (el.__dirty) {
              var prevStates = el.prevStates;
              if (prevStates) {
                el.useStates(prevStates);
              }
            }
            if (enableAnimation) {
              el.stateTransition = stateTransition;
              var textContent = el.getTextContent();
              var textGuide = el.getTextGuideLine();
              if (textContent) {
                textContent.stateTransition = stateTransition;
              }
              if (textGuide) {
                textGuide.stateTransition = stateTransition;
              }
            }
            if (el.__dirty) {
              applyElementStates(el);
            }
          }
        });
      }
      ;
      createExtensionAPI = function(ecIns) {
        return new (function(_super2) {
          __extends(class_1, _super2);
          function class_1() {
            return _super2 !== null && _super2.apply(this, arguments) || this;
          }
          class_1.prototype.getCoordinateSystems = function() {
            return ecIns._coordSysMgr.getCoordinateSystems();
          };
          class_1.prototype.getComponentByElement = function(el) {
            while (el) {
              var modelInfo = el.__ecComponentInfo;
              if (modelInfo != null) {
                return ecIns._model.getComponent(modelInfo.mainType, modelInfo.index);
              }
              el = el.parent;
            }
          };
          class_1.prototype.enterEmphasis = function(el, highlightDigit) {
            enterEmphasis(el, highlightDigit);
            markStatusToUpdate(ecIns);
          };
          class_1.prototype.leaveEmphasis = function(el, highlightDigit) {
            leaveEmphasis(el, highlightDigit);
            markStatusToUpdate(ecIns);
          };
          class_1.prototype.enterBlur = function(el) {
            enterBlur(el);
            markStatusToUpdate(ecIns);
          };
          class_1.prototype.leaveBlur = function(el) {
            leaveBlur(el);
            markStatusToUpdate(ecIns);
          };
          class_1.prototype.enterSelect = function(el) {
            enterSelect(el);
            markStatusToUpdate(ecIns);
          };
          class_1.prototype.leaveSelect = function(el) {
            leaveSelect(el);
            markStatusToUpdate(ecIns);
          };
          class_1.prototype.getModel = function() {
            return ecIns.getModel();
          };
          class_1.prototype.getViewOfComponentModel = function(componentModel) {
            return ecIns.getViewOfComponentModel(componentModel);
          };
          class_1.prototype.getViewOfSeriesModel = function(seriesModel) {
            return ecIns.getViewOfSeriesModel(seriesModel);
          };
          return class_1;
        }(ExtensionAPI_default))(ecIns);
      };
      enableConnect = function(chart) {
        function updateConnectedChartsStatus(charts, status) {
          for (var i = 0; i < charts.length; i++) {
            var otherChart = charts[i];
            otherChart[CONNECT_STATUS_KEY] = status;
          }
        }
        each(eventActionMap, function(actionType, eventType) {
          chart._messageCenter.on(eventType, function(event) {
            if (connectedGroups[chart.group] && chart[CONNECT_STATUS_KEY] !== CONNECT_STATUS_PENDING) {
              if (event && event.escapeConnect) {
                return;
              }
              var action_1 = chart.makeActionFromEvent(event);
              var otherCharts_1 = [];
              each(instances2, function(otherChart) {
                if (otherChart !== chart && otherChart.group === chart.group) {
                  otherCharts_1.push(otherChart);
                }
              });
              updateConnectedChartsStatus(otherCharts_1, CONNECT_STATUS_PENDING);
              each(otherCharts_1, function(otherChart) {
                if (otherChart[CONNECT_STATUS_KEY] !== CONNECT_STATUS_UPDATING) {
                  otherChart.dispatchAction(action_1);
                }
              });
              updateConnectedChartsStatus(otherCharts_1, CONNECT_STATUS_UPDATED);
            }
          });
        });
      };
    }();
    return ECharts2;
  }(Eventful_default);
  var echartsProto = ECharts.prototype;
  echartsProto.on = createRegisterEventWithLowercaseECharts("on");
  echartsProto.off = createRegisterEventWithLowercaseECharts("off");
  echartsProto.one = function(eventName, cb, ctx) {
    var self2 = this;
    deprecateLog("ECharts#one is deprecated.");
    function wrapped() {
      var args2 = [];
      for (var _i = 0; _i < arguments.length; _i++) {
        args2[_i] = arguments[_i];
      }
      cb && cb.apply && cb.apply(this, args2);
      self2.off(eventName, wrapped);
    }
    ;
    this.on.call(this, eventName, wrapped, ctx);
  };
  var MOUSE_EVENT_NAMES = ["click", "dblclick", "mouseover", "mouseout", "mousemove", "mousedown", "mouseup", "globalout", "contextmenu"];
  function disposedWarning(id) {
    if (true) {
      console.warn("Instance " + id + " has been disposed");
    }
  }
  var actions = {};
  var eventActionMap = {};
  var dataProcessorFuncs = [];
  var optionPreprocessorFuncs = [];
  var visualFuncs = [];
  var themeStorage = {};
  var loadingEffects = {};
  var instances2 = {};
  var connectedGroups = {};
  var idBase = +new Date() - 0;
  var groupIdBase = +new Date() - 0;
  var DOM_ATTRIBUTE_KEY = "_echarts_instance_";
  function init2(dom, theme2, opts) {
    var isClient = !(opts && opts.ssr);
    if (isClient) {
      if (true) {
        if (!dom) {
          throw new Error("Initialize failed: invalid dom.");
        }
      }
      var existInstance = getInstanceByDom(dom);
      if (existInstance) {
        if (true) {
          console.warn("There is a chart instance already initialized on the dom.");
        }
        return existInstance;
      }
      if (true) {
        if (isDom(dom) && dom.nodeName.toUpperCase() !== "CANVAS" && (!dom.clientWidth && (!opts || opts.width == null) || !dom.clientHeight && (!opts || opts.height == null))) {
          console.warn("Can't get DOM width or height. Please check dom.clientWidth and dom.clientHeight. They should not be 0.For example, you may need to call this in the callback of window.onload.");
        }
      }
    }
    var chart = new ECharts(dom, theme2, opts);
    chart.id = "ec_" + idBase++;
    instances2[chart.id] = chart;
    isClient && setAttribute(dom, DOM_ATTRIBUTE_KEY, chart.id);
    enableConnect(chart);
    lifecycle_default.trigger("afterinit", chart);
    return chart;
  }
  function connect(groupId) {
    if (isArray(groupId)) {
      var charts = groupId;
      groupId = null;
      each(charts, function(chart) {
        if (chart.group != null) {
          groupId = chart.group;
        }
      });
      groupId = groupId || "g_" + groupIdBase++;
      each(charts, function(chart) {
        chart.group = groupId;
      });
    }
    connectedGroups[groupId] = true;
    return groupId;
  }
  function disConnect(groupId) {
    connectedGroups[groupId] = false;
  }
  var disconnect = disConnect;
  function dispose2(chart) {
    if (isString(chart)) {
      chart = instances2[chart];
    } else if (!(chart instanceof ECharts)) {
      chart = getInstanceByDom(chart);
    }
    if (chart instanceof ECharts && !chart.isDisposed()) {
      chart.dispose();
    }
  }
  function getInstanceByDom(dom) {
    return instances2[getAttribute(dom, DOM_ATTRIBUTE_KEY)];
  }
  function getInstanceById(key) {
    return instances2[key];
  }
  function registerTheme(name, theme2) {
    themeStorage[name] = theme2;
  }
  function registerPreprocessor(preprocessorFunc) {
    if (indexOf(optionPreprocessorFuncs, preprocessorFunc) < 0) {
      optionPreprocessorFuncs.push(preprocessorFunc);
    }
  }
  function registerProcessor(priority, processor) {
    normalizeRegister(dataProcessorFuncs, priority, processor, PRIORITY_PROCESSOR_DEFAULT);
  }
  function registerPostInit(postInitFunc) {
    registerUpdateLifecycle("afterinit", postInitFunc);
  }
  function registerPostUpdate(postUpdateFunc) {
    registerUpdateLifecycle("afterupdate", postUpdateFunc);
  }
  function registerUpdateLifecycle(name, cb) {
    lifecycle_default.on(name, cb);
  }
  function registerAction(actionInfo3, eventName, action) {
    if (isFunction(eventName)) {
      action = eventName;
      eventName = "";
    }
    var actionType = isObject(actionInfo3) ? actionInfo3.type : [actionInfo3, actionInfo3 = {
      event: eventName
    }][0];
    actionInfo3.event = (actionInfo3.event || actionType).toLowerCase();
    eventName = actionInfo3.event;
    if (eventActionMap[eventName]) {
      return;
    }
    assert(ACTION_REG.test(actionType) && ACTION_REG.test(eventName));
    if (!actions[actionType]) {
      actions[actionType] = {
        action,
        actionInfo: actionInfo3
      };
    }
    eventActionMap[eventName] = actionType;
  }
  function registerCoordinateSystem(type, coordSysCreator) {
    CoordinateSystem_default.register(type, coordSysCreator);
  }
  function getCoordinateSystemDimensions(type) {
    var coordSysCreator = CoordinateSystem_default.get(type);
    if (coordSysCreator) {
      return coordSysCreator.getDimensionsInfo ? coordSysCreator.getDimensionsInfo() : coordSysCreator.dimensions.slice();
    }
  }
  function registerLayout(priority, layoutTask) {
    normalizeRegister(visualFuncs, priority, layoutTask, PRIORITY_VISUAL_LAYOUT, "layout");
  }
  function registerVisual(priority, visualTask) {
    normalizeRegister(visualFuncs, priority, visualTask, PRIORITY_VISUAL_CHART, "visual");
  }
  var registeredTasks = [];
  function normalizeRegister(targetList, priority, fn, defaultPriority, visualType) {
    if (isFunction(priority) || isObject(priority)) {
      fn = priority;
      priority = defaultPriority;
    }
    if (true) {
      if (isNaN(priority) || priority == null) {
        throw new Error("Illegal priority");
      }
      each(targetList, function(wrap) {
        assert(wrap.__raw !== fn);
      });
    }
    if (indexOf(registeredTasks, fn) >= 0) {
      return;
    }
    registeredTasks.push(fn);
    var stageHandler = Scheduler_default.wrapStageHandler(fn, visualType);
    stageHandler.__prio = priority;
    stageHandler.__raw = fn;
    targetList.push(stageHandler);
  }
  function registerLoading(name, loadingFx) {
    loadingEffects[name] = loadingFx;
  }
  function setCanvasCreator(creator) {
    if (true) {
      deprecateLog("setCanvasCreator is deprecated. Use setPlatformAPI({ createCanvas }) instead.");
    }
    setPlatformAPI({
      createCanvas: creator
    });
  }
  function registerMap(mapName, geoJson, specialAreas) {
    var registerMap3 = getImpl("registerMap");
    registerMap3 && registerMap3(mapName, geoJson, specialAreas);
  }
  function getMap(mapName) {
    var getMap2 = getImpl("getMap");
    return getMap2 && getMap2(mapName);
  }
  var registerTransform = registerExternalTransform;
  registerVisual(PRIORITY_VISUAL_GLOBAL, seriesStyleTask);
  registerVisual(PRIORITY_VISUAL_CHART_DATA_CUSTOM, dataStyleTask);
  registerVisual(PRIORITY_VISUAL_CHART_DATA_CUSTOM, dataColorPaletteTask);
  registerVisual(PRIORITY_VISUAL_GLOBAL, seriesSymbolTask);
  registerVisual(PRIORITY_VISUAL_CHART_DATA_CUSTOM, dataSymbolTask);
  registerVisual(PRIORITY_VISUAL_DECAL, decalVisual);
  registerPreprocessor(globalBackwardCompat);
  registerProcessor(PRIORITY_PROCESSOR_DATASTACK, dataStack);
  registerLoading("default", defaultLoading);
  registerAction({
    type: HIGHLIGHT_ACTION_TYPE,
    event: HIGHLIGHT_ACTION_TYPE,
    update: HIGHLIGHT_ACTION_TYPE
  }, noop);
  registerAction({
    type: DOWNPLAY_ACTION_TYPE,
    event: DOWNPLAY_ACTION_TYPE,
    update: DOWNPLAY_ACTION_TYPE
  }, noop);
  registerAction({
    type: SELECT_ACTION_TYPE,
    event: SELECT_ACTION_TYPE,
    update: SELECT_ACTION_TYPE
  }, noop);
  registerAction({
    type: UNSELECT_ACTION_TYPE,
    event: UNSELECT_ACTION_TYPE,
    update: UNSELECT_ACTION_TYPE
  }, noop);
  registerAction({
    type: TOGGLE_SELECT_ACTION_TYPE,
    event: TOGGLE_SELECT_ACTION_TYPE,
    update: TOGGLE_SELECT_ACTION_TYPE
  }, noop);
  registerTheme("light", light_default);
  registerTheme("dark", dark_default);
  var dataTool = {};

  // node_modules/echarts/lib/extension.js
  var extensions = [];
  var extensionRegisters = {
    registerPreprocessor,
    registerProcessor,
    registerPostInit,
    registerPostUpdate,
    registerUpdateLifecycle,
    registerAction,
    registerCoordinateSystem,
    registerLayout,
    registerVisual,
    registerTransform,
    registerLoading,
    registerMap,
    registerImpl,
    PRIORITY,
    ComponentModel: Component_default,
    ComponentView: Component_default2,
    SeriesModel: Series_default,
    ChartView: Chart_default,
    registerComponentModel: function(ComponentModelClass) {
      Component_default.registerClass(ComponentModelClass);
    },
    registerComponentView: function(ComponentViewClass) {
      Component_default2.registerClass(ComponentViewClass);
    },
    registerSeriesModel: function(SeriesModelClass) {
      Series_default.registerClass(SeriesModelClass);
    },
    registerChartView: function(ChartViewClass) {
      Chart_default.registerClass(ChartViewClass);
    },
    registerSubTypeDefaulter: function(componentType, defaulter) {
      Component_default.registerSubTypeDefaulter(componentType, defaulter);
    },
    registerPainter: function(painterType, PainterCtor) {
      registerPainter(painterType, PainterCtor);
    }
  };
  function use(ext) {
    if (isArray(ext)) {
      each(ext, function(singleExt) {
        use(singleExt);
      });
      return;
    }
    if (indexOf(extensions, ext) >= 0) {
      return;
    }
    extensions.push(ext);
    if (isFunction(ext)) {
      ext = {
        install: ext
      };
    }
    ext.install(extensionRegisters);
  }

  // node_modules/echarts/lib/data/DataDiffer.js
  function dataIndexMapValueLength(valNumOrArrLengthMoreThan2) {
    return valNumOrArrLengthMoreThan2 == null ? 0 : valNumOrArrLengthMoreThan2.length || 1;
  }
  function defaultKeyGetter(item) {
    return item;
  }
  var DataDiffer = function() {
    function DataDiffer2(oldArr, newArr, oldKeyGetter, newKeyGetter, context, diffMode) {
      this._old = oldArr;
      this._new = newArr;
      this._oldKeyGetter = oldKeyGetter || defaultKeyGetter;
      this._newKeyGetter = newKeyGetter || defaultKeyGetter;
      this.context = context;
      this._diffModeMultiple = diffMode === "multiple";
    }
    DataDiffer2.prototype.add = function(func) {
      this._add = func;
      return this;
    };
    DataDiffer2.prototype.update = function(func) {
      this._update = func;
      return this;
    };
    DataDiffer2.prototype.updateManyToOne = function(func) {
      this._updateManyToOne = func;
      return this;
    };
    DataDiffer2.prototype.updateOneToMany = function(func) {
      this._updateOneToMany = func;
      return this;
    };
    DataDiffer2.prototype.updateManyToMany = function(func) {
      this._updateManyToMany = func;
      return this;
    };
    DataDiffer2.prototype.remove = function(func) {
      this._remove = func;
      return this;
    };
    DataDiffer2.prototype.execute = function() {
      this[this._diffModeMultiple ? "_executeMultiple" : "_executeOneToOne"]();
    };
    DataDiffer2.prototype._executeOneToOne = function() {
      var oldArr = this._old;
      var newArr = this._new;
      var newDataIndexMap = {};
      var oldDataKeyArr = new Array(oldArr.length);
      var newDataKeyArr = new Array(newArr.length);
      this._initIndexMap(oldArr, null, oldDataKeyArr, "_oldKeyGetter");
      this._initIndexMap(newArr, newDataIndexMap, newDataKeyArr, "_newKeyGetter");
      for (var i = 0; i < oldArr.length; i++) {
        var oldKey = oldDataKeyArr[i];
        var newIdxMapVal = newDataIndexMap[oldKey];
        var newIdxMapValLen = dataIndexMapValueLength(newIdxMapVal);
        if (newIdxMapValLen > 1) {
          var newIdx = newIdxMapVal.shift();
          if (newIdxMapVal.length === 1) {
            newDataIndexMap[oldKey] = newIdxMapVal[0];
          }
          this._update && this._update(newIdx, i);
        } else if (newIdxMapValLen === 1) {
          newDataIndexMap[oldKey] = null;
          this._update && this._update(newIdxMapVal, i);
        } else {
          this._remove && this._remove(i);
        }
      }
      this._performRestAdd(newDataKeyArr, newDataIndexMap);
    };
    DataDiffer2.prototype._executeMultiple = function() {
      var oldArr = this._old;
      var newArr = this._new;
      var oldDataIndexMap = {};
      var newDataIndexMap = {};
      var oldDataKeyArr = [];
      var newDataKeyArr = [];
      this._initIndexMap(oldArr, oldDataIndexMap, oldDataKeyArr, "_oldKeyGetter");
      this._initIndexMap(newArr, newDataIndexMap, newDataKeyArr, "_newKeyGetter");
      for (var i = 0; i < oldDataKeyArr.length; i++) {
        var oldKey = oldDataKeyArr[i];
        var oldIdxMapVal = oldDataIndexMap[oldKey];
        var newIdxMapVal = newDataIndexMap[oldKey];
        var oldIdxMapValLen = dataIndexMapValueLength(oldIdxMapVal);
        var newIdxMapValLen = dataIndexMapValueLength(newIdxMapVal);
        if (oldIdxMapValLen > 1 && newIdxMapValLen === 1) {
          this._updateManyToOne && this._updateManyToOne(newIdxMapVal, oldIdxMapVal);
          newDataIndexMap[oldKey] = null;
        } else if (oldIdxMapValLen === 1 && newIdxMapValLen > 1) {
          this._updateOneToMany && this._updateOneToMany(newIdxMapVal, oldIdxMapVal);
          newDataIndexMap[oldKey] = null;
        } else if (oldIdxMapValLen === 1 && newIdxMapValLen === 1) {
          this._update && this._update(newIdxMapVal, oldIdxMapVal);
          newDataIndexMap[oldKey] = null;
        } else if (oldIdxMapValLen > 1 && newIdxMapValLen > 1) {
          this._updateManyToMany && this._updateManyToMany(newIdxMapVal, oldIdxMapVal);
          newDataIndexMap[oldKey] = null;
        } else if (oldIdxMapValLen > 1) {
          for (var i_1 = 0; i_1 < oldIdxMapValLen; i_1++) {
            this._remove && this._remove(oldIdxMapVal[i_1]);
          }
        } else {
          this._remove && this._remove(oldIdxMapVal);
        }
      }
      this._performRestAdd(newDataKeyArr, newDataIndexMap);
    };
    DataDiffer2.prototype._performRestAdd = function(newDataKeyArr, newDataIndexMap) {
      for (var i = 0; i < newDataKeyArr.length; i++) {
        var newKey = newDataKeyArr[i];
        var newIdxMapVal = newDataIndexMap[newKey];
        var idxMapValLen = dataIndexMapValueLength(newIdxMapVal);
        if (idxMapValLen > 1) {
          for (var j = 0; j < idxMapValLen; j++) {
            this._add && this._add(newIdxMapVal[j]);
          }
        } else if (idxMapValLen === 1) {
          this._add && this._add(newIdxMapVal);
        }
        newDataIndexMap[newKey] = null;
      }
    };
    DataDiffer2.prototype._initIndexMap = function(arr, map3, keyArr, keyGetterName) {
      var cbModeMultiple = this._diffModeMultiple;
      for (var i = 0; i < arr.length; i++) {
        var key = "_ec_" + this[keyGetterName](arr[i], i);
        if (!cbModeMultiple) {
          keyArr[i] = key;
        }
        if (!map3) {
          continue;
        }
        var idxMapVal = map3[key];
        var idxMapValLen = dataIndexMapValueLength(idxMapVal);
        if (idxMapValLen === 0) {
          map3[key] = i;
          if (cbModeMultiple) {
            keyArr.push(key);
          }
        } else if (idxMapValLen === 1) {
          map3[key] = [idxMapVal, i];
        } else {
          idxMapVal.push(i);
        }
      }
    };
    return DataDiffer2;
  }();
  var DataDiffer_default = DataDiffer;

  // node_modules/echarts/lib/data/helper/dimensionHelper.js
  var DimensionUserOuput = function() {
    function DimensionUserOuput2(encode, dimRequest) {
      this._encode = encode;
      this._schema = dimRequest;
    }
    DimensionUserOuput2.prototype.get = function() {
      return {
        fullDimensions: this._getFullDimensionNames(),
        encode: this._encode
      };
    };
    DimensionUserOuput2.prototype._getFullDimensionNames = function() {
      if (!this._cachedDimNames) {
        this._cachedDimNames = this._schema ? this._schema.makeOutputDimensionNames() : [];
      }
      return this._cachedDimNames;
    };
    return DimensionUserOuput2;
  }();
  function summarizeDimensions(data, schema) {
    var summary = {};
    var encode = summary.encode = {};
    var notExtraCoordDimMap = createHashMap();
    var defaultedLabel = [];
    var defaultedTooltip = [];
    var userOutputEncode = {};
    each(data.dimensions, function(dimName) {
      var dimItem = data.getDimensionInfo(dimName);
      var coordDim = dimItem.coordDim;
      if (coordDim) {
        if (true) {
          assert(VISUAL_DIMENSIONS.get(coordDim) == null);
        }
        var coordDimIndex = dimItem.coordDimIndex;
        getOrCreateEncodeArr(encode, coordDim)[coordDimIndex] = dimName;
        if (!dimItem.isExtraCoord) {
          notExtraCoordDimMap.set(coordDim, 1);
          if (mayLabelDimType(dimItem.type)) {
            defaultedLabel[0] = dimName;
          }
          getOrCreateEncodeArr(userOutputEncode, coordDim)[coordDimIndex] = data.getDimensionIndex(dimItem.name);
        }
        if (dimItem.defaultTooltip) {
          defaultedTooltip.push(dimName);
        }
      }
      VISUAL_DIMENSIONS.each(function(v, otherDim) {
        var encodeArr = getOrCreateEncodeArr(encode, otherDim);
        var dimIndex = dimItem.otherDims[otherDim];
        if (dimIndex != null && dimIndex !== false) {
          encodeArr[dimIndex] = dimItem.name;
        }
      });
    });
    var dataDimsOnCoord = [];
    var encodeFirstDimNotExtra = {};
    notExtraCoordDimMap.each(function(v, coordDim) {
      var dimArr = encode[coordDim];
      encodeFirstDimNotExtra[coordDim] = dimArr[0];
      dataDimsOnCoord = dataDimsOnCoord.concat(dimArr);
    });
    summary.dataDimsOnCoord = dataDimsOnCoord;
    summary.dataDimIndicesOnCoord = map(dataDimsOnCoord, function(dimName) {
      return data.getDimensionInfo(dimName).storeDimIndex;
    });
    summary.encodeFirstDimNotExtra = encodeFirstDimNotExtra;
    var encodeLabel = encode.label;
    if (encodeLabel && encodeLabel.length) {
      defaultedLabel = encodeLabel.slice();
    }
    var encodeTooltip = encode.tooltip;
    if (encodeTooltip && encodeTooltip.length) {
      defaultedTooltip = encodeTooltip.slice();
    } else if (!defaultedTooltip.length) {
      defaultedTooltip = defaultedLabel.slice();
    }
    encode.defaultedLabel = defaultedLabel;
    encode.defaultedTooltip = defaultedTooltip;
    summary.userOutput = new DimensionUserOuput(userOutputEncode, schema);
    return summary;
  }
  function getOrCreateEncodeArr(encode, dim) {
    if (!encode.hasOwnProperty(dim)) {
      encode[dim] = [];
    }
    return encode[dim];
  }
  function getDimensionTypeByAxis(axisType) {
    return axisType === "category" ? "ordinal" : axisType === "time" ? "time" : "float";
  }
  function mayLabelDimType(dimType) {
    return !(dimType === "ordinal" || dimType === "time");
  }

  // node_modules/echarts/lib/data/SeriesDimensionDefine.js
  var SeriesDimensionDefine = function() {
    function SeriesDimensionDefine2(opt) {
      this.otherDims = {};
      if (opt != null) {
        extend(this, opt);
      }
    }
    return SeriesDimensionDefine2;
  }();
  var SeriesDimensionDefine_default = SeriesDimensionDefine;

  // node_modules/echarts/lib/data/helper/SeriesDataSchema.js
  var inner5 = makeInner();
  var dimTypeShort = {
    float: "f",
    int: "i",
    ordinal: "o",
    number: "n",
    time: "t"
  };
  var SeriesDataSchema = function() {
    function SeriesDataSchema2(opt) {
      this.dimensions = opt.dimensions;
      this._dimOmitted = opt.dimensionOmitted;
      this.source = opt.source;
      this._fullDimCount = opt.fullDimensionCount;
      this._updateDimOmitted(opt.dimensionOmitted);
    }
    SeriesDataSchema2.prototype.isDimensionOmitted = function() {
      return this._dimOmitted;
    };
    SeriesDataSchema2.prototype._updateDimOmitted = function(dimensionOmitted) {
      this._dimOmitted = dimensionOmitted;
      if (!dimensionOmitted) {
        return;
      }
      if (!this._dimNameMap) {
        this._dimNameMap = ensureSourceDimNameMap(this.source);
      }
    };
    SeriesDataSchema2.prototype.getSourceDimensionIndex = function(dimName) {
      return retrieve2(this._dimNameMap.get(dimName), -1);
    };
    SeriesDataSchema2.prototype.getSourceDimension = function(dimIndex) {
      var dimensionsDefine = this.source.dimensionsDefine;
      if (dimensionsDefine) {
        return dimensionsDefine[dimIndex];
      }
    };
    SeriesDataSchema2.prototype.makeStoreSchema = function() {
      var dimCount = this._fullDimCount;
      var willRetrieveDataByName = shouldRetrieveDataByName(this.source);
      var makeHashStrict = !shouldOmitUnusedDimensions(dimCount);
      var dimHash = "";
      var dims = [];
      for (var fullDimIdx = 0, seriesDimIdx = 0; fullDimIdx < dimCount; fullDimIdx++) {
        var property = void 0;
        var type = void 0;
        var ordinalMeta = void 0;
        var seriesDimDef = this.dimensions[seriesDimIdx];
        if (seriesDimDef && seriesDimDef.storeDimIndex === fullDimIdx) {
          property = willRetrieveDataByName ? seriesDimDef.name : null;
          type = seriesDimDef.type;
          ordinalMeta = seriesDimDef.ordinalMeta;
          seriesDimIdx++;
        } else {
          var sourceDimDef = this.getSourceDimension(fullDimIdx);
          if (sourceDimDef) {
            property = willRetrieveDataByName ? sourceDimDef.name : null;
            type = sourceDimDef.type;
          }
        }
        dims.push({
          property,
          type,
          ordinalMeta
        });
        if (willRetrieveDataByName && property != null && (!seriesDimDef || !seriesDimDef.isCalculationCoord)) {
          dimHash += makeHashStrict ? property.replace(/\`/g, "`1").replace(/\$/g, "`2") : property;
        }
        dimHash += "$";
        dimHash += dimTypeShort[type] || "f";
        if (ordinalMeta) {
          dimHash += ordinalMeta.uid;
        }
        dimHash += "$";
      }
      var source = this.source;
      var hash = [source.seriesLayoutBy, source.startIndex, dimHash].join("$$");
      return {
        dimensions: dims,
        hash
      };
    };
    SeriesDataSchema2.prototype.makeOutputDimensionNames = function() {
      var result = [];
      for (var fullDimIdx = 0, seriesDimIdx = 0; fullDimIdx < this._fullDimCount; fullDimIdx++) {
        var name_1 = void 0;
        var seriesDimDef = this.dimensions[seriesDimIdx];
        if (seriesDimDef && seriesDimDef.storeDimIndex === fullDimIdx) {
          if (!seriesDimDef.isCalculationCoord) {
            name_1 = seriesDimDef.name;
          }
          seriesDimIdx++;
        } else {
          var sourceDimDef = this.getSourceDimension(fullDimIdx);
          if (sourceDimDef) {
            name_1 = sourceDimDef.name;
          }
        }
        result.push(name_1);
      }
      return result;
    };
    SeriesDataSchema2.prototype.appendCalculationDimension = function(dimDef) {
      this.dimensions.push(dimDef);
      dimDef.isCalculationCoord = true;
      this._fullDimCount++;
      this._updateDimOmitted(true);
    };
    return SeriesDataSchema2;
  }();
  function isSeriesDataSchema(schema) {
    return schema instanceof SeriesDataSchema;
  }
  function createDimNameMap(dimsDef) {
    var dataDimNameMap = createHashMap();
    for (var i = 0; i < (dimsDef || []).length; i++) {
      var dimDefItemRaw = dimsDef[i];
      var userDimName = isObject(dimDefItemRaw) ? dimDefItemRaw.name : dimDefItemRaw;
      if (userDimName != null && dataDimNameMap.get(userDimName) == null) {
        dataDimNameMap.set(userDimName, i);
      }
    }
    return dataDimNameMap;
  }
  function ensureSourceDimNameMap(source) {
    var innerSource = inner5(source);
    return innerSource.dimNameMap || (innerSource.dimNameMap = createDimNameMap(source.dimensionsDefine));
  }
  function shouldOmitUnusedDimensions(dimCount) {
    return dimCount > 30;
  }

  // node_modules/echarts/lib/data/SeriesData.js
  var isObject3 = isObject;
  var map2 = map;
  var CtorInt32Array2 = typeof Int32Array === "undefined" ? Array : Int32Array;
  var ID_PREFIX = "e\0\0";
  var INDEX_NOT_FOUND = -1;
  var TRANSFERABLE_PROPERTIES = ["hasItemOption", "_nameList", "_idList", "_invertedIndicesMap", "_dimSummary", "userOutput", "_rawData", "_dimValueGetter", "_nameDimIdx", "_idDimIdx", "_nameRepeatCount"];
  var CLONE_PROPERTIES = ["_approximateExtent"];
  var prepareInvertedIndex;
  var getId;
  var getIdNameFromStore;
  var normalizeDimensions;
  var transferProperties;
  var cloneListForMapAndSample;
  var makeIdFromName;
  var SeriesData = function() {
    function SeriesData2(dimensionsInput, hostModel) {
      this.type = "list";
      this._dimOmitted = false;
      this._nameList = [];
      this._idList = [];
      this._visual = {};
      this._layout = {};
      this._itemVisuals = [];
      this._itemLayouts = [];
      this._graphicEls = [];
      this._approximateExtent = {};
      this._calculationInfo = {};
      this.hasItemOption = false;
      this.TRANSFERABLE_METHODS = ["cloneShallow", "downSample", "lttbDownSample", "map"];
      this.CHANGABLE_METHODS = ["filterSelf", "selectRange"];
      this.DOWNSAMPLE_METHODS = ["downSample", "lttbDownSample"];
      var dimensions;
      var assignStoreDimIdx = false;
      if (isSeriesDataSchema(dimensionsInput)) {
        dimensions = dimensionsInput.dimensions;
        this._dimOmitted = dimensionsInput.isDimensionOmitted();
        this._schema = dimensionsInput;
      } else {
        assignStoreDimIdx = true;
        dimensions = dimensionsInput;
      }
      dimensions = dimensions || ["x", "y"];
      var dimensionInfos = {};
      var dimensionNames = [];
      var invertedIndicesMap = {};
      var needsHasOwn = false;
      var emptyObj = {};
      for (var i = 0; i < dimensions.length; i++) {
        var dimInfoInput = dimensions[i];
        var dimensionInfo = isString(dimInfoInput) ? new SeriesDimensionDefine_default({
          name: dimInfoInput
        }) : !(dimInfoInput instanceof SeriesDimensionDefine_default) ? new SeriesDimensionDefine_default(dimInfoInput) : dimInfoInput;
        var dimensionName = dimensionInfo.name;
        dimensionInfo.type = dimensionInfo.type || "float";
        if (!dimensionInfo.coordDim) {
          dimensionInfo.coordDim = dimensionName;
          dimensionInfo.coordDimIndex = 0;
        }
        var otherDims = dimensionInfo.otherDims = dimensionInfo.otherDims || {};
        dimensionNames.push(dimensionName);
        dimensionInfos[dimensionName] = dimensionInfo;
        if (emptyObj[dimensionName] != null) {
          needsHasOwn = true;
        }
        if (dimensionInfo.createInvertedIndices) {
          invertedIndicesMap[dimensionName] = [];
        }
        if (otherDims.itemName === 0) {
          this._nameDimIdx = i;
        }
        if (otherDims.itemId === 0) {
          this._idDimIdx = i;
        }
        if (true) {
          assert(assignStoreDimIdx || dimensionInfo.storeDimIndex >= 0);
        }
        if (assignStoreDimIdx) {
          dimensionInfo.storeDimIndex = i;
        }
      }
      this.dimensions = dimensionNames;
      this._dimInfos = dimensionInfos;
      this._initGetDimensionInfo(needsHasOwn);
      this.hostModel = hostModel;
      this._invertedIndicesMap = invertedIndicesMap;
      if (this._dimOmitted) {
        var dimIdxToName_1 = this._dimIdxToName = createHashMap();
        each(dimensionNames, function(dimName) {
          dimIdxToName_1.set(dimensionInfos[dimName].storeDimIndex, dimName);
        });
      }
    }
    SeriesData2.prototype.getDimension = function(dim) {
      var dimIdx = this._recognizeDimIndex(dim);
      if (dimIdx == null) {
        return dim;
      }
      dimIdx = dim;
      if (!this._dimOmitted) {
        return this.dimensions[dimIdx];
      }
      var dimName = this._dimIdxToName.get(dimIdx);
      if (dimName != null) {
        return dimName;
      }
      var sourceDimDef = this._schema.getSourceDimension(dimIdx);
      if (sourceDimDef) {
        return sourceDimDef.name;
      }
    };
    SeriesData2.prototype.getDimensionIndex = function(dim) {
      var dimIdx = this._recognizeDimIndex(dim);
      if (dimIdx != null) {
        return dimIdx;
      }
      if (dim == null) {
        return -1;
      }
      var dimInfo = this._getDimInfo(dim);
      return dimInfo ? dimInfo.storeDimIndex : this._dimOmitted ? this._schema.getSourceDimensionIndex(dim) : -1;
    };
    SeriesData2.prototype._recognizeDimIndex = function(dim) {
      if (isNumber(dim) || dim != null && !isNaN(dim) && !this._getDimInfo(dim) && (!this._dimOmitted || this._schema.getSourceDimensionIndex(dim) < 0)) {
        return +dim;
      }
    };
    SeriesData2.prototype._getStoreDimIndex = function(dim) {
      var dimIdx = this.getDimensionIndex(dim);
      if (true) {
        if (dimIdx == null) {
          throw new Error("Unkown dimension " + dim);
        }
      }
      return dimIdx;
    };
    SeriesData2.prototype.getDimensionInfo = function(dim) {
      return this._getDimInfo(this.getDimension(dim));
    };
    SeriesData2.prototype._initGetDimensionInfo = function(needsHasOwn) {
      var dimensionInfos = this._dimInfos;
      this._getDimInfo = needsHasOwn ? function(dimName) {
        return dimensionInfos.hasOwnProperty(dimName) ? dimensionInfos[dimName] : void 0;
      } : function(dimName) {
        return dimensionInfos[dimName];
      };
    };
    SeriesData2.prototype.getDimensionsOnCoord = function() {
      return this._dimSummary.dataDimsOnCoord.slice();
    };
    SeriesData2.prototype.mapDimension = function(coordDim, idx) {
      var dimensionsSummary = this._dimSummary;
      if (idx == null) {
        return dimensionsSummary.encodeFirstDimNotExtra[coordDim];
      }
      var dims = dimensionsSummary.encode[coordDim];
      return dims ? dims[idx] : null;
    };
    SeriesData2.prototype.mapDimensionsAll = function(coordDim) {
      var dimensionsSummary = this._dimSummary;
      var dims = dimensionsSummary.encode[coordDim];
      return (dims || []).slice();
    };
    SeriesData2.prototype.getStore = function() {
      return this._store;
    };
    SeriesData2.prototype.initData = function(data, nameList, dimValueGetter) {
      var _this = this;
      var store;
      if (data instanceof DataStore_default) {
        store = data;
      }
      if (!store) {
        var dimensions = this.dimensions;
        var provider = isSourceInstance(data) || isArrayLike(data) ? new DefaultDataProvider(data, dimensions.length) : data;
        store = new DataStore_default();
        var dimensionInfos = map2(dimensions, function(dimName) {
          return {
            type: _this._dimInfos[dimName].type,
            property: dimName
          };
        });
        store.initData(provider, dimensionInfos, dimValueGetter);
      }
      this._store = store;
      this._nameList = (nameList || []).slice();
      this._idList = [];
      this._nameRepeatCount = {};
      this._doInit(0, store.count());
      this._dimSummary = summarizeDimensions(this, this._schema);
      this.userOutput = this._dimSummary.userOutput;
    };
    SeriesData2.prototype.appendData = function(data) {
      var range = this._store.appendData(data);
      this._doInit(range[0], range[1]);
    };
    SeriesData2.prototype.appendValues = function(values, names) {
      var _a2 = this._store.appendValues(values, names.length), start2 = _a2.start, end2 = _a2.end;
      var shouldMakeIdFromName = this._shouldMakeIdFromName();
      this._updateOrdinalMeta();
      if (names) {
        for (var idx = start2; idx < end2; idx++) {
          var sourceIdx = idx - start2;
          this._nameList[idx] = names[sourceIdx];
          if (shouldMakeIdFromName) {
            makeIdFromName(this, idx);
          }
        }
      }
    };
    SeriesData2.prototype._updateOrdinalMeta = function() {
      var store = this._store;
      var dimensions = this.dimensions;
      for (var i = 0; i < dimensions.length; i++) {
        var dimInfo = this._dimInfos[dimensions[i]];
        if (dimInfo.ordinalMeta) {
          store.collectOrdinalMeta(dimInfo.storeDimIndex, dimInfo.ordinalMeta);
        }
      }
    };
    SeriesData2.prototype._shouldMakeIdFromName = function() {
      var provider = this._store.getProvider();
      return this._idDimIdx == null && provider.getSource().sourceFormat !== SOURCE_FORMAT_TYPED_ARRAY && !provider.fillStorage;
    };
    SeriesData2.prototype._doInit = function(start2, end2) {
      if (start2 >= end2) {
        return;
      }
      var store = this._store;
      var provider = store.getProvider();
      this._updateOrdinalMeta();
      var nameList = this._nameList;
      var idList = this._idList;
      var sourceFormat = provider.getSource().sourceFormat;
      var isFormatOriginal = sourceFormat === SOURCE_FORMAT_ORIGINAL;
      if (isFormatOriginal && !provider.pure) {
        var sharedDataItem = [];
        for (var idx = start2; idx < end2; idx++) {
          var dataItem = provider.getItem(idx, sharedDataItem);
          if (!this.hasItemOption && isDataItemOption(dataItem)) {
            this.hasItemOption = true;
          }
          if (dataItem) {
            var itemName = dataItem.name;
            if (nameList[idx] == null && itemName != null) {
              nameList[idx] = convertOptionIdName(itemName, null);
            }
            var itemId = dataItem.id;
            if (idList[idx] == null && itemId != null) {
              idList[idx] = convertOptionIdName(itemId, null);
            }
          }
        }
      }
      if (this._shouldMakeIdFromName()) {
        for (var idx = start2; idx < end2; idx++) {
          makeIdFromName(this, idx);
        }
      }
      prepareInvertedIndex(this);
    };
    SeriesData2.prototype.getApproximateExtent = function(dim) {
      return this._approximateExtent[dim] || this._store.getDataExtent(this._getStoreDimIndex(dim));
    };
    SeriesData2.prototype.setApproximateExtent = function(extent3, dim) {
      dim = this.getDimension(dim);
      this._approximateExtent[dim] = extent3.slice();
    };
    SeriesData2.prototype.getCalculationInfo = function(key) {
      return this._calculationInfo[key];
    };
    SeriesData2.prototype.setCalculationInfo = function(key, value) {
      isObject3(key) ? extend(this._calculationInfo, key) : this._calculationInfo[key] = value;
    };
    SeriesData2.prototype.getName = function(idx) {
      var rawIndex = this.getRawIndex(idx);
      var name = this._nameList[rawIndex];
      if (name == null && this._nameDimIdx != null) {
        name = getIdNameFromStore(this, this._nameDimIdx, rawIndex);
      }
      if (name == null) {
        name = "";
      }
      return name;
    };
    SeriesData2.prototype._getCategory = function(dimIdx, idx) {
      var ordinal = this._store.get(dimIdx, idx);
      var ordinalMeta = this._store.getOrdinalMeta(dimIdx);
      if (ordinalMeta) {
        return ordinalMeta.categories[ordinal];
      }
      return ordinal;
    };
    SeriesData2.prototype.getId = function(idx) {
      return getId(this, this.getRawIndex(idx));
    };
    SeriesData2.prototype.count = function() {
      return this._store.count();
    };
    SeriesData2.prototype.get = function(dim, idx) {
      var store = this._store;
      var dimInfo = this._dimInfos[dim];
      if (dimInfo) {
        return store.get(dimInfo.storeDimIndex, idx);
      }
    };
    SeriesData2.prototype.getByRawIndex = function(dim, rawIdx) {
      var store = this._store;
      var dimInfo = this._dimInfos[dim];
      if (dimInfo) {
        return store.getByRawIndex(dimInfo.storeDimIndex, rawIdx);
      }
    };
    SeriesData2.prototype.getIndices = function() {
      return this._store.getIndices();
    };
    SeriesData2.prototype.getDataExtent = function(dim) {
      return this._store.getDataExtent(this._getStoreDimIndex(dim));
    };
    SeriesData2.prototype.getSum = function(dim) {
      return this._store.getSum(this._getStoreDimIndex(dim));
    };
    SeriesData2.prototype.getMedian = function(dim) {
      return this._store.getMedian(this._getStoreDimIndex(dim));
    };
    SeriesData2.prototype.getValues = function(dimensions, idx) {
      var _this = this;
      var store = this._store;
      return isArray(dimensions) ? store.getValues(map2(dimensions, function(dim) {
        return _this._getStoreDimIndex(dim);
      }), idx) : store.getValues(dimensions);
    };
    SeriesData2.prototype.hasValue = function(idx) {
      var dataDimIndicesOnCoord = this._dimSummary.dataDimIndicesOnCoord;
      for (var i = 0, len2 = dataDimIndicesOnCoord.length; i < len2; i++) {
        if (isNaN(this._store.get(dataDimIndicesOnCoord[i], idx))) {
          return false;
        }
      }
      return true;
    };
    SeriesData2.prototype.indexOfName = function(name) {
      for (var i = 0, len2 = this._store.count(); i < len2; i++) {
        if (this.getName(i) === name) {
          return i;
        }
      }
      return -1;
    };
    SeriesData2.prototype.getRawIndex = function(idx) {
      return this._store.getRawIndex(idx);
    };
    SeriesData2.prototype.indexOfRawIndex = function(rawIndex) {
      return this._store.indexOfRawIndex(rawIndex);
    };
    SeriesData2.prototype.rawIndexOf = function(dim, value) {
      var invertedIndices = dim && this._invertedIndicesMap[dim];
      if (true) {
        if (!invertedIndices) {
          throw new Error("Do not supported yet");
        }
      }
      var rawIndex = invertedIndices[value];
      if (rawIndex == null || isNaN(rawIndex)) {
        return INDEX_NOT_FOUND;
      }
      return rawIndex;
    };
    SeriesData2.prototype.indicesOfNearest = function(dim, value, maxDistance) {
      return this._store.indicesOfNearest(this._getStoreDimIndex(dim), value, maxDistance);
    };
    SeriesData2.prototype.each = function(dims, cb, ctx) {
      "use strict";
      if (isFunction(dims)) {
        ctx = cb;
        cb = dims;
        dims = [];
      }
      var fCtx = ctx || this;
      var dimIndices = map2(normalizeDimensions(dims), this._getStoreDimIndex, this);
      this._store.each(dimIndices, fCtx ? bind(cb, fCtx) : cb);
    };
    SeriesData2.prototype.filterSelf = function(dims, cb, ctx) {
      "use strict";
      if (isFunction(dims)) {
        ctx = cb;
        cb = dims;
        dims = [];
      }
      var fCtx = ctx || this;
      var dimIndices = map2(normalizeDimensions(dims), this._getStoreDimIndex, this);
      this._store = this._store.filter(dimIndices, fCtx ? bind(cb, fCtx) : cb);
      return this;
    };
    SeriesData2.prototype.selectRange = function(range) {
      "use strict";
      var _this = this;
      var innerRange = {};
      var dims = keys(range);
      var dimIndices = [];
      each(dims, function(dim) {
        var dimIdx = _this._getStoreDimIndex(dim);
        innerRange[dimIdx] = range[dim];
        dimIndices.push(dimIdx);
      });
      this._store = this._store.selectRange(innerRange);
      return this;
    };
    SeriesData2.prototype.mapArray = function(dims, cb, ctx) {
      "use strict";
      if (isFunction(dims)) {
        ctx = cb;
        cb = dims;
        dims = [];
      }
      ctx = ctx || this;
      var result = [];
      this.each(dims, function() {
        result.push(cb && cb.apply(this, arguments));
      }, ctx);
      return result;
    };
    SeriesData2.prototype.map = function(dims, cb, ctx, ctxCompat) {
      "use strict";
      var fCtx = ctx || ctxCompat || this;
      var dimIndices = map2(normalizeDimensions(dims), this._getStoreDimIndex, this);
      var list = cloneListForMapAndSample(this);
      list._store = this._store.map(dimIndices, fCtx ? bind(cb, fCtx) : cb);
      return list;
    };
    SeriesData2.prototype.modify = function(dims, cb, ctx, ctxCompat) {
      var _this = this;
      var fCtx = ctx || ctxCompat || this;
      if (true) {
        each(normalizeDimensions(dims), function(dim) {
          var dimInfo = _this.getDimensionInfo(dim);
          if (!dimInfo.isCalculationCoord) {
            console.error("Danger: only stack dimension can be modified");
          }
        });
      }
      var dimIndices = map2(normalizeDimensions(dims), this._getStoreDimIndex, this);
      this._store.modify(dimIndices, fCtx ? bind(cb, fCtx) : cb);
    };
    SeriesData2.prototype.downSample = function(dimension, rate, sampleValue, sampleIndex) {
      var list = cloneListForMapAndSample(this);
      list._store = this._store.downSample(this._getStoreDimIndex(dimension), rate, sampleValue, sampleIndex);
      return list;
    };
    SeriesData2.prototype.lttbDownSample = function(valueDimension, rate) {
      var list = cloneListForMapAndSample(this);
      list._store = this._store.lttbDownSample(this._getStoreDimIndex(valueDimension), rate);
      return list;
    };
    SeriesData2.prototype.getRawDataItem = function(idx) {
      return this._store.getRawDataItem(idx);
    };
    SeriesData2.prototype.getItemModel = function(idx) {
      var hostModel = this.hostModel;
      var dataItem = this.getRawDataItem(idx);
      return new Model_default(dataItem, hostModel, hostModel && hostModel.ecModel);
    };
    SeriesData2.prototype.diff = function(otherList) {
      var thisList = this;
      return new DataDiffer_default(otherList ? otherList.getStore().getIndices() : [], this.getStore().getIndices(), function(idx) {
        return getId(otherList, idx);
      }, function(idx) {
        return getId(thisList, idx);
      });
    };
    SeriesData2.prototype.getVisual = function(key) {
      var visual = this._visual;
      return visual && visual[key];
    };
    SeriesData2.prototype.setVisual = function(kvObj, val) {
      this._visual = this._visual || {};
      if (isObject3(kvObj)) {
        extend(this._visual, kvObj);
      } else {
        this._visual[kvObj] = val;
      }
    };
    SeriesData2.prototype.getItemVisual = function(idx, key) {
      var itemVisual = this._itemVisuals[idx];
      var val = itemVisual && itemVisual[key];
      if (val == null) {
        return this.getVisual(key);
      }
      return val;
    };
    SeriesData2.prototype.hasItemVisual = function() {
      return this._itemVisuals.length > 0;
    };
    SeriesData2.prototype.ensureUniqueItemVisual = function(idx, key) {
      var itemVisuals = this._itemVisuals;
      var itemVisual = itemVisuals[idx];
      if (!itemVisual) {
        itemVisual = itemVisuals[idx] = {};
      }
      var val = itemVisual[key];
      if (val == null) {
        val = this.getVisual(key);
        if (isArray(val)) {
          val = val.slice();
        } else if (isObject3(val)) {
          val = extend({}, val);
        }
        itemVisual[key] = val;
      }
      return val;
    };
    SeriesData2.prototype.setItemVisual = function(idx, key, value) {
      var itemVisual = this._itemVisuals[idx] || {};
      this._itemVisuals[idx] = itemVisual;
      if (isObject3(key)) {
        extend(itemVisual, key);
      } else {
        itemVisual[key] = value;
      }
    };
    SeriesData2.prototype.clearAllVisual = function() {
      this._visual = {};
      this._itemVisuals = [];
    };
    SeriesData2.prototype.setLayout = function(key, val) {
      isObject3(key) ? extend(this._layout, key) : this._layout[key] = val;
    };
    SeriesData2.prototype.getLayout = function(key) {
      return this._layout[key];
    };
    SeriesData2.prototype.getItemLayout = function(idx) {
      return this._itemLayouts[idx];
    };
    SeriesData2.prototype.setItemLayout = function(idx, layout5, merge2) {
      this._itemLayouts[idx] = merge2 ? extend(this._itemLayouts[idx] || {}, layout5) : layout5;
    };
    SeriesData2.prototype.clearItemLayouts = function() {
      this._itemLayouts.length = 0;
    };
    SeriesData2.prototype.setItemGraphicEl = function(idx, el) {
      var seriesIndex = this.hostModel && this.hostModel.seriesIndex;
      setCommonECData(seriesIndex, this.dataType, idx, el);
      this._graphicEls[idx] = el;
    };
    SeriesData2.prototype.getItemGraphicEl = function(idx) {
      return this._graphicEls[idx];
    };
    SeriesData2.prototype.eachItemGraphicEl = function(cb, context) {
      each(this._graphicEls, function(el, idx) {
        if (el) {
          cb && cb.call(context, el, idx);
        }
      });
    };
    SeriesData2.prototype.cloneShallow = function(list) {
      if (!list) {
        list = new SeriesData2(this._schema ? this._schema : map2(this.dimensions, this._getDimInfo, this), this.hostModel);
      }
      transferProperties(list, this);
      list._store = this._store;
      return list;
    };
    SeriesData2.prototype.wrapMethod = function(methodName, injectFunction) {
      var originalMethod = this[methodName];
      if (!isFunction(originalMethod)) {
        return;
      }
      this.__wrappedMethods = this.__wrappedMethods || [];
      this.__wrappedMethods.push(methodName);
      this[methodName] = function() {
        var res = originalMethod.apply(this, arguments);
        return injectFunction.apply(this, [res].concat(slice(arguments)));
      };
    };
    SeriesData2.internalField = function() {
      prepareInvertedIndex = function(data) {
        var invertedIndicesMap = data._invertedIndicesMap;
        each(invertedIndicesMap, function(invertedIndices, dim) {
          var dimInfo = data._dimInfos[dim];
          var ordinalMeta = dimInfo.ordinalMeta;
          var store = data._store;
          if (ordinalMeta) {
            invertedIndices = invertedIndicesMap[dim] = new CtorInt32Array2(ordinalMeta.categories.length);
            for (var i = 0; i < invertedIndices.length; i++) {
              invertedIndices[i] = INDEX_NOT_FOUND;
            }
            for (var i = 0; i < store.count(); i++) {
              invertedIndices[store.get(dimInfo.storeDimIndex, i)] = i;
            }
          }
        });
      };
      getIdNameFromStore = function(data, dimIdx, idx) {
        return convertOptionIdName(data._getCategory(dimIdx, idx), null);
      };
      getId = function(data, rawIndex) {
        var id = data._idList[rawIndex];
        if (id == null && data._idDimIdx != null) {
          id = getIdNameFromStore(data, data._idDimIdx, rawIndex);
        }
        if (id == null) {
          id = ID_PREFIX + rawIndex;
        }
        return id;
      };
      normalizeDimensions = function(dimensions) {
        if (!isArray(dimensions)) {
          dimensions = dimensions != null ? [dimensions] : [];
        }
        return dimensions;
      };
      cloneListForMapAndSample = function(original) {
        var list = new SeriesData2(original._schema ? original._schema : map2(original.dimensions, original._getDimInfo, original), original.hostModel);
        transferProperties(list, original);
        return list;
      };
      transferProperties = function(target, source) {
        each(TRANSFERABLE_PROPERTIES.concat(source.__wrappedMethods || []), function(propName) {
          if (source.hasOwnProperty(propName)) {
            target[propName] = source[propName];
          }
        });
        target.__wrappedMethods = source.__wrappedMethods;
        each(CLONE_PROPERTIES, function(propName) {
          target[propName] = clone(source[propName]);
        });
        target._calculationInfo = extend({}, source._calculationInfo);
      };
      makeIdFromName = function(data, idx) {
        var nameList = data._nameList;
        var idList = data._idList;
        var nameDimIdx = data._nameDimIdx;
        var idDimIdx = data._idDimIdx;
        var name = nameList[idx];
        var id = idList[idx];
        if (name == null && nameDimIdx != null) {
          nameList[idx] = name = getIdNameFromStore(data, nameDimIdx, idx);
        }
        if (id == null && idDimIdx != null) {
          idList[idx] = id = getIdNameFromStore(data, idDimIdx, idx);
        }
        if (id == null && name != null) {
          var nameRepeatCount = data._nameRepeatCount;
          var nmCnt = nameRepeatCount[name] = (nameRepeatCount[name] || 0) + 1;
          id = name;
          if (nmCnt > 1) {
            id += "__ec__" + nmCnt;
          }
          idList[idx] = id;
        }
      };
    }();
    return SeriesData2;
  }();
  var SeriesData_default = SeriesData;

  // node_modules/echarts/lib/export/api/helper.js
  var helper_exports2 = {};
  __export(helper_exports2, {
    createDimensions: () => createDimensions,
    createList: () => createList,
    createScale: () => createScale,
    createSymbol: () => createSymbol,
    createTextStyle: () => createTextStyle2,
    dataStack: () => dataStack2,
    enableHoverEmphasis: () => enableHoverEmphasis,
    getECData: () => getECData,
    getLayoutRect: () => getLayoutRect,
    mixinAxisModelCommonMethods: () => mixinAxisModelCommonMethods
  });

  // node_modules/echarts/lib/data/helper/createDimensions.js
  function createDimensions(source, opt) {
    return prepareSeriesDataSchema(source, opt).dimensions;
  }
  function prepareSeriesDataSchema(source, opt) {
    if (!isSourceInstance(source)) {
      source = createSourceFromSeriesDataOption(source);
    }
    opt = opt || {};
    var sysDims = opt.coordDimensions || [];
    var dimsDef = opt.dimensionsDefine || source.dimensionsDefine || [];
    var coordDimNameMap = createHashMap();
    var resultList = [];
    var dimCount = getDimCount(source, sysDims, dimsDef, opt.dimensionsCount);
    var omitUnusedDimensions = opt.canOmitUnusedDimensions && shouldOmitUnusedDimensions(dimCount);
    var isUsingSourceDimensionsDef = dimsDef === source.dimensionsDefine;
    var dataDimNameMap = isUsingSourceDimensionsDef ? ensureSourceDimNameMap(source) : createDimNameMap(dimsDef);
    var encodeDef = opt.encodeDefine;
    if (!encodeDef && opt.encodeDefaulter) {
      encodeDef = opt.encodeDefaulter(source, dimCount);
    }
    var encodeDefMap = createHashMap(encodeDef);
    var indicesMap = new CtorInt32Array(dimCount);
    for (var i = 0; i < indicesMap.length; i++) {
      indicesMap[i] = -1;
    }
    function getResultItem(dimIdx) {
      var idx = indicesMap[dimIdx];
      if (idx < 0) {
        var dimDefItemRaw = dimsDef[dimIdx];
        var dimDefItem = isObject(dimDefItemRaw) ? dimDefItemRaw : {
          name: dimDefItemRaw
        };
        var resultItem2 = new SeriesDimensionDefine_default();
        var userDimName = dimDefItem.name;
        if (userDimName != null && dataDimNameMap.get(userDimName) != null) {
          resultItem2.name = resultItem2.displayName = userDimName;
        }
        dimDefItem.type != null && (resultItem2.type = dimDefItem.type);
        dimDefItem.displayName != null && (resultItem2.displayName = dimDefItem.displayName);
        var newIdx = resultList.length;
        indicesMap[dimIdx] = newIdx;
        resultItem2.storeDimIndex = dimIdx;
        resultList.push(resultItem2);
        return resultItem2;
      }
      return resultList[idx];
    }
    if (!omitUnusedDimensions) {
      for (var i = 0; i < dimCount; i++) {
        getResultItem(i);
      }
    }
    encodeDefMap.each(function(dataDimsRaw, coordDim2) {
      var dataDims = normalizeToArray(dataDimsRaw).slice();
      if (dataDims.length === 1 && !isString(dataDims[0]) && dataDims[0] < 0) {
        encodeDefMap.set(coordDim2, false);
        return;
      }
      var validDataDims = encodeDefMap.set(coordDim2, []);
      each(dataDims, function(resultDimIdxOrName, idx) {
        var resultDimIdx2 = isString(resultDimIdxOrName) ? dataDimNameMap.get(resultDimIdxOrName) : resultDimIdxOrName;
        if (resultDimIdx2 != null && resultDimIdx2 < dimCount) {
          validDataDims[idx] = resultDimIdx2;
          applyDim(getResultItem(resultDimIdx2), coordDim2, idx);
        }
      });
    });
    var availDimIdx = 0;
    each(sysDims, function(sysDimItemRaw) {
      var coordDim2;
      var sysDimItemDimsDef;
      var sysDimItemOtherDims;
      var sysDimItem;
      if (isString(sysDimItemRaw)) {
        coordDim2 = sysDimItemRaw;
        sysDimItem = {};
      } else {
        sysDimItem = sysDimItemRaw;
        coordDim2 = sysDimItem.name;
        var ordinalMeta = sysDimItem.ordinalMeta;
        sysDimItem.ordinalMeta = null;
        sysDimItem = extend({}, sysDimItem);
        sysDimItem.ordinalMeta = ordinalMeta;
        sysDimItemDimsDef = sysDimItem.dimsDef;
        sysDimItemOtherDims = sysDimItem.otherDims;
        sysDimItem.name = sysDimItem.coordDim = sysDimItem.coordDimIndex = sysDimItem.dimsDef = sysDimItem.otherDims = null;
      }
      var dataDims = encodeDefMap.get(coordDim2);
      if (dataDims === false) {
        return;
      }
      dataDims = normalizeToArray(dataDims);
      if (!dataDims.length) {
        for (var i2 = 0; i2 < (sysDimItemDimsDef && sysDimItemDimsDef.length || 1); i2++) {
          while (availDimIdx < dimCount && getResultItem(availDimIdx).coordDim != null) {
            availDimIdx++;
          }
          availDimIdx < dimCount && dataDims.push(availDimIdx++);
        }
      }
      each(dataDims, function(resultDimIdx2, coordDimIndex) {
        var resultItem2 = getResultItem(resultDimIdx2);
        if (isUsingSourceDimensionsDef && sysDimItem.type != null) {
          resultItem2.type = sysDimItem.type;
        }
        applyDim(defaults(resultItem2, sysDimItem), coordDim2, coordDimIndex);
        if (resultItem2.name == null && sysDimItemDimsDef) {
          var sysDimItemDimsDefItem = sysDimItemDimsDef[coordDimIndex];
          !isObject(sysDimItemDimsDefItem) && (sysDimItemDimsDefItem = {
            name: sysDimItemDimsDefItem
          });
          resultItem2.name = resultItem2.displayName = sysDimItemDimsDefItem.name;
          resultItem2.defaultTooltip = sysDimItemDimsDefItem.defaultTooltip;
        }
        sysDimItemOtherDims && defaults(resultItem2.otherDims, sysDimItemOtherDims);
      });
    });
    function applyDim(resultItem2, coordDim2, coordDimIndex) {
      if (VISUAL_DIMENSIONS.get(coordDim2) != null) {
        resultItem2.otherDims[coordDim2] = coordDimIndex;
      } else {
        resultItem2.coordDim = coordDim2;
        resultItem2.coordDimIndex = coordDimIndex;
        coordDimNameMap.set(coordDim2, true);
      }
    }
    var generateCoord = opt.generateCoord;
    var generateCoordCount = opt.generateCoordCount;
    var fromZero = generateCoordCount != null;
    generateCoordCount = generateCoord ? generateCoordCount || 1 : 0;
    var extra = generateCoord || "value";
    function ifNoNameFillWithCoordName(resultItem2) {
      if (resultItem2.name == null) {
        resultItem2.name = resultItem2.coordDim;
      }
    }
    if (!omitUnusedDimensions) {
      for (var resultDimIdx = 0; resultDimIdx < dimCount; resultDimIdx++) {
        var resultItem = getResultItem(resultDimIdx);
        var coordDim = resultItem.coordDim;
        if (coordDim == null) {
          resultItem.coordDim = genCoordDimName(extra, coordDimNameMap, fromZero);
          resultItem.coordDimIndex = 0;
          if (!generateCoord || generateCoordCount <= 0) {
            resultItem.isExtraCoord = true;
          }
          generateCoordCount--;
        }
        ifNoNameFillWithCoordName(resultItem);
        if (resultItem.type == null && (guessOrdinal(source, resultDimIdx) === BE_ORDINAL.Must || resultItem.isExtraCoord && (resultItem.otherDims.itemName != null || resultItem.otherDims.seriesName != null))) {
          resultItem.type = "ordinal";
        }
      }
    } else {
      each(resultList, function(resultItem2) {
        ifNoNameFillWithCoordName(resultItem2);
      });
      resultList.sort(function(item0, item1) {
        return item0.storeDimIndex - item1.storeDimIndex;
      });
    }
    removeDuplication(resultList);
    return new SeriesDataSchema({
      source,
      dimensions: resultList,
      fullDimensionCount: dimCount,
      dimensionOmitted: omitUnusedDimensions
    });
  }
  function removeDuplication(result) {
    var duplicationMap = createHashMap();
    for (var i = 0; i < result.length; i++) {
      var dim = result[i];
      var dimOriginalName = dim.name;
      var count2 = duplicationMap.get(dimOriginalName) || 0;
      if (count2 > 0) {
        dim.name = dimOriginalName + (count2 - 1);
      }
      count2++;
      duplicationMap.set(dimOriginalName, count2);
    }
  }
  function getDimCount(source, sysDims, dimsDef, optDimCount) {
    var dimCount = Math.max(source.dimensionsDetectedCount || 1, sysDims.length, dimsDef.length, optDimCount || 0);
    each(sysDims, function(sysDimItem) {
      var sysDimItemDimsDef;
      if (isObject(sysDimItem) && (sysDimItemDimsDef = sysDimItem.dimsDef)) {
        dimCount = Math.max(dimCount, sysDimItemDimsDef.length);
      }
    });
    return dimCount;
  }
  function genCoordDimName(name, map3, fromZero) {
    var mapData = map3.data;
    if (fromZero || mapData.hasOwnProperty(name)) {
      var i = 0;
      while (mapData.hasOwnProperty(name + i)) {
        i++;
      }
      name += i;
    }
    map3.set(name, true);
    return name;
  }

  // node_modules/echarts/lib/model/referHelper.js
  var CoordSysInfo = function() {
    function CoordSysInfo2(coordSysName) {
      this.coordSysDims = [];
      this.axisMap = createHashMap();
      this.categoryAxisMap = createHashMap();
      this.coordSysName = coordSysName;
    }
    return CoordSysInfo2;
  }();
  function getCoordSysInfoBySeries(seriesModel) {
    var coordSysName = seriesModel.get("coordinateSystem");
    var result = new CoordSysInfo(coordSysName);
    var fetch = fetchers[coordSysName];
    if (fetch) {
      fetch(seriesModel, result, result.axisMap, result.categoryAxisMap);
      return result;
    }
  }
  var fetchers = {
    cartesian2d: function(seriesModel, result, axisMap, categoryAxisMap) {
      var xAxisModel = seriesModel.getReferringComponents("xAxis", SINGLE_REFERRING).models[0];
      var yAxisModel = seriesModel.getReferringComponents("yAxis", SINGLE_REFERRING).models[0];
      if (true) {
        if (!xAxisModel) {
          throw new Error('xAxis "' + retrieve(seriesModel.get("xAxisIndex"), seriesModel.get("xAxisId"), 0) + '" not found');
        }
        if (!yAxisModel) {
          throw new Error('yAxis "' + retrieve(seriesModel.get("xAxisIndex"), seriesModel.get("yAxisId"), 0) + '" not found');
        }
      }
      result.coordSysDims = ["x", "y"];
      axisMap.set("x", xAxisModel);
      axisMap.set("y", yAxisModel);
      if (isCategory(xAxisModel)) {
        categoryAxisMap.set("x", xAxisModel);
        result.firstCategoryDimIndex = 0;
      }
      if (isCategory(yAxisModel)) {
        categoryAxisMap.set("y", yAxisModel);
        result.firstCategoryDimIndex == null && (result.firstCategoryDimIndex = 1);
      }
    },
    singleAxis: function(seriesModel, result, axisMap, categoryAxisMap) {
      var singleAxisModel = seriesModel.getReferringComponents("singleAxis", SINGLE_REFERRING).models[0];
      if (true) {
        if (!singleAxisModel) {
          throw new Error("singleAxis should be specified.");
        }
      }
      result.coordSysDims = ["single"];
      axisMap.set("single", singleAxisModel);
      if (isCategory(singleAxisModel)) {
        categoryAxisMap.set("single", singleAxisModel);
        result.firstCategoryDimIndex = 0;
      }
    },
    polar: function(seriesModel, result, axisMap, categoryAxisMap) {
      var polarModel = seriesModel.getReferringComponents("polar", SINGLE_REFERRING).models[0];
      var radiusAxisModel = polarModel.findAxisModel("radiusAxis");
      var angleAxisModel = polarModel.findAxisModel("angleAxis");
      if (true) {
        if (!angleAxisModel) {
          throw new Error("angleAxis option not found");
        }
        if (!radiusAxisModel) {
          throw new Error("radiusAxis option not found");
        }
      }
      result.coordSysDims = ["radius", "angle"];
      axisMap.set("radius", radiusAxisModel);
      axisMap.set("angle", angleAxisModel);
      if (isCategory(radiusAxisModel)) {
        categoryAxisMap.set("radius", radiusAxisModel);
        result.firstCategoryDimIndex = 0;
      }
      if (isCategory(angleAxisModel)) {
        categoryAxisMap.set("angle", angleAxisModel);
        result.firstCategoryDimIndex == null && (result.firstCategoryDimIndex = 1);
      }
    },
    geo: function(seriesModel, result, axisMap, categoryAxisMap) {
      result.coordSysDims = ["lng", "lat"];
    },
    parallel: function(seriesModel, result, axisMap, categoryAxisMap) {
      var ecModel = seriesModel.ecModel;
      var parallelModel = ecModel.getComponent("parallel", seriesModel.get("parallelIndex"));
      var coordSysDims = result.coordSysDims = parallelModel.dimensions.slice();
      each(parallelModel.parallelAxisIndex, function(axisIndex, index) {
        var axisModel = ecModel.getComponent("parallelAxis", axisIndex);
        var axisDim = coordSysDims[index];
        axisMap.set(axisDim, axisModel);
        if (isCategory(axisModel)) {
          categoryAxisMap.set(axisDim, axisModel);
          if (result.firstCategoryDimIndex == null) {
            result.firstCategoryDimIndex = index;
          }
        }
      });
    }
  };
  function isCategory(axisModel) {
    return axisModel.get("type") === "category";
  }

  // node_modules/echarts/lib/data/helper/dataStackHelper.js
  function enableDataStack(seriesModel, dimensionsInput, opt) {
    opt = opt || {};
    var byIndex = opt.byIndex;
    var stackedCoordDimension = opt.stackedCoordDimension;
    var dimensionDefineList;
    var schema;
    var store;
    if (isLegacyDimensionsInput(dimensionsInput)) {
      dimensionDefineList = dimensionsInput;
    } else {
      schema = dimensionsInput.schema;
      dimensionDefineList = schema.dimensions;
      store = dimensionsInput.store;
    }
    var mayStack = !!(seriesModel && seriesModel.get("stack"));
    var stackedByDimInfo;
    var stackedDimInfo;
    var stackResultDimension;
    var stackedOverDimension;
    each(dimensionDefineList, function(dimensionInfo, index) {
      if (isString(dimensionInfo)) {
        dimensionDefineList[index] = dimensionInfo = {
          name: dimensionInfo
        };
      }
      if (mayStack && !dimensionInfo.isExtraCoord) {
        if (!byIndex && !stackedByDimInfo && dimensionInfo.ordinalMeta) {
          stackedByDimInfo = dimensionInfo;
        }
        if (!stackedDimInfo && dimensionInfo.type !== "ordinal" && dimensionInfo.type !== "time" && (!stackedCoordDimension || stackedCoordDimension === dimensionInfo.coordDim)) {
          stackedDimInfo = dimensionInfo;
        }
      }
    });
    if (stackedDimInfo && !byIndex && !stackedByDimInfo) {
      byIndex = true;
    }
    if (stackedDimInfo) {
      stackResultDimension = "__\0ecstackresult_" + seriesModel.id;
      stackedOverDimension = "__\0ecstackedover_" + seriesModel.id;
      if (stackedByDimInfo) {
        stackedByDimInfo.createInvertedIndices = true;
      }
      var stackedDimCoordDim_1 = stackedDimInfo.coordDim;
      var stackedDimType = stackedDimInfo.type;
      var stackedDimCoordIndex_1 = 0;
      each(dimensionDefineList, function(dimensionInfo) {
        if (dimensionInfo.coordDim === stackedDimCoordDim_1) {
          stackedDimCoordIndex_1++;
        }
      });
      var stackedOverDimensionDefine = {
        name: stackResultDimension,
        coordDim: stackedDimCoordDim_1,
        coordDimIndex: stackedDimCoordIndex_1,
        type: stackedDimType,
        isExtraCoord: true,
        isCalculationCoord: true,
        storeDimIndex: dimensionDefineList.length
      };
      var stackResultDimensionDefine = {
        name: stackedOverDimension,
        coordDim: stackedOverDimension,
        coordDimIndex: stackedDimCoordIndex_1 + 1,
        type: stackedDimType,
        isExtraCoord: true,
        isCalculationCoord: true,
        storeDimIndex: dimensionDefineList.length + 1
      };
      if (schema) {
        if (store) {
          stackedOverDimensionDefine.storeDimIndex = store.ensureCalculationDimension(stackedOverDimension, stackedDimType);
          stackResultDimensionDefine.storeDimIndex = store.ensureCalculationDimension(stackResultDimension, stackedDimType);
        }
        schema.appendCalculationDimension(stackedOverDimensionDefine);
        schema.appendCalculationDimension(stackResultDimensionDefine);
      } else {
        dimensionDefineList.push(stackedOverDimensionDefine);
        dimensionDefineList.push(stackResultDimensionDefine);
      }
    }
    return {
      stackedDimension: stackedDimInfo && stackedDimInfo.name,
      stackedByDimension: stackedByDimInfo && stackedByDimInfo.name,
      isStackedByIndex: byIndex,
      stackedOverDimension,
      stackResultDimension
    };
  }
  function isLegacyDimensionsInput(dimensionsInput) {
    return !isSeriesDataSchema(dimensionsInput.schema);
  }
  function isDimensionStacked(data, stackedDim) {
    return !!stackedDim && stackedDim === data.getCalculationInfo("stackedDimension");
  }
  function getStackedDimension(data, targetDim) {
    return isDimensionStacked(data, targetDim) ? data.getCalculationInfo("stackResultDimension") : targetDim;
  }

  // node_modules/echarts/lib/chart/helper/createSeriesData.js
  function getCoordSysDimDefs(seriesModel, coordSysInfo) {
    var coordSysName = seriesModel.get("coordinateSystem");
    var registeredCoordSys = CoordinateSystem_default.get(coordSysName);
    var coordSysDimDefs;
    if (coordSysInfo && coordSysInfo.coordSysDims) {
      coordSysDimDefs = map(coordSysInfo.coordSysDims, function(dim) {
        var dimInfo = {
          name: dim
        };
        var axisModel = coordSysInfo.axisMap.get(dim);
        if (axisModel) {
          var axisType = axisModel.get("type");
          dimInfo.type = getDimensionTypeByAxis(axisType);
        }
        return dimInfo;
      });
    }
    if (!coordSysDimDefs) {
      coordSysDimDefs = registeredCoordSys && (registeredCoordSys.getDimensionsInfo ? registeredCoordSys.getDimensionsInfo() : registeredCoordSys.dimensions.slice()) || ["x", "y"];
    }
    return coordSysDimDefs;
  }
  function injectOrdinalMeta(dimInfoList, createInvertedIndices, coordSysInfo) {
    var firstCategoryDimIndex;
    var hasNameEncode;
    coordSysInfo && each(dimInfoList, function(dimInfo, dimIndex) {
      var coordDim = dimInfo.coordDim;
      var categoryAxisModel = coordSysInfo.categoryAxisMap.get(coordDim);
      if (categoryAxisModel) {
        if (firstCategoryDimIndex == null) {
          firstCategoryDimIndex = dimIndex;
        }
        dimInfo.ordinalMeta = categoryAxisModel.getOrdinalMeta();
        if (createInvertedIndices) {
          dimInfo.createInvertedIndices = true;
        }
      }
      if (dimInfo.otherDims.itemName != null) {
        hasNameEncode = true;
      }
    });
    if (!hasNameEncode && firstCategoryDimIndex != null) {
      dimInfoList[firstCategoryDimIndex].otherDims.itemName = 0;
    }
    return firstCategoryDimIndex;
  }
  function createSeriesData(sourceRaw, seriesModel, opt) {
    opt = opt || {};
    var sourceManager = seriesModel.getSourceManager();
    var source;
    var isOriginalSource = false;
    if (sourceRaw) {
      isOriginalSource = true;
      source = createSourceFromSeriesDataOption(sourceRaw);
    } else {
      source = sourceManager.getSource();
      isOriginalSource = source.sourceFormat === SOURCE_FORMAT_ORIGINAL;
    }
    var coordSysInfo = getCoordSysInfoBySeries(seriesModel);
    var coordSysDimDefs = getCoordSysDimDefs(seriesModel, coordSysInfo);
    var useEncodeDefaulter = opt.useEncodeDefaulter;
    var encodeDefaulter = isFunction(useEncodeDefaulter) ? useEncodeDefaulter : useEncodeDefaulter ? curry(makeSeriesEncodeForAxisCoordSys, coordSysDimDefs, seriesModel) : null;
    var createDimensionOptions = {
      coordDimensions: coordSysDimDefs,
      generateCoord: opt.generateCoord,
      encodeDefine: seriesModel.getEncode(),
      encodeDefaulter,
      canOmitUnusedDimensions: !isOriginalSource
    };
    var schema = prepareSeriesDataSchema(source, createDimensionOptions);
    var firstCategoryDimIndex = injectOrdinalMeta(schema.dimensions, opt.createInvertedIndices, coordSysInfo);
    var store = !isOriginalSource ? sourceManager.getSharedDataStore(schema) : null;
    var stackCalculationInfo = enableDataStack(seriesModel, {
      schema,
      store
    });
    var data = new SeriesData_default(schema, seriesModel);
    data.setCalculationInfo(stackCalculationInfo);
    var dimValueGetter = firstCategoryDimIndex != null && isNeedCompleteOrdinalData(source) ? function(itemOpt, dimName, dataIndex, dimIndex) {
      return dimIndex === firstCategoryDimIndex ? dataIndex : this.defaultDimValueGetter(itemOpt, dimName, dataIndex, dimIndex);
    } : null;
    data.hasItemOption = false;
    data.initData(isOriginalSource ? source : store, null, dimValueGetter);
    return data;
  }
  function isNeedCompleteOrdinalData(source) {
    if (source.sourceFormat === SOURCE_FORMAT_ORIGINAL) {
      var sampleItem = firstDataNotNull(source.data || []);
      return !isArray(getDataItemValue(sampleItem));
    }
  }
  function firstDataNotNull(arr) {
    var i = 0;
    while (i < arr.length && arr[i] == null) {
      i++;
    }
    return arr[i];
  }
  var createSeriesData_default = createSeriesData;

  // node_modules/echarts/lib/scale/Scale.js
  var Scale = function() {
    function Scale2(setting) {
      this._setting = setting || {};
      this._extent = [Infinity, -Infinity];
    }
    Scale2.prototype.getSetting = function(name) {
      return this._setting[name];
    };
    Scale2.prototype.unionExtent = function(other) {
      var extent3 = this._extent;
      other[0] < extent3[0] && (extent3[0] = other[0]);
      other[1] > extent3[1] && (extent3[1] = other[1]);
    };
    Scale2.prototype.unionExtentFromData = function(data, dim) {
      this.unionExtent(data.getApproximateExtent(dim));
    };
    Scale2.prototype.getExtent = function() {
      return this._extent.slice();
    };
    Scale2.prototype.setExtent = function(start2, end2) {
      var thisExtent = this._extent;
      if (!isNaN(start2)) {
        thisExtent[0] = start2;
      }
      if (!isNaN(end2)) {
        thisExtent[1] = end2;
      }
    };
    Scale2.prototype.isInExtentRange = function(value) {
      return this._extent[0] <= value && this._extent[1] >= value;
    };
    Scale2.prototype.isBlank = function() {
      return this._isBlank;
    };
    Scale2.prototype.setBlank = function(isBlank) {
      this._isBlank = isBlank;
    };
    return Scale2;
  }();
  enableClassManagement(Scale);
  var Scale_default = Scale;

  // node_modules/echarts/lib/data/OrdinalMeta.js
  var uidBase = 0;
  var OrdinalMeta = function() {
    function OrdinalMeta2(opt) {
      this.categories = opt.categories || [];
      this._needCollect = opt.needCollect;
      this._deduplication = opt.deduplication;
      this.uid = ++uidBase;
    }
    OrdinalMeta2.createByAxisModel = function(axisModel) {
      var option = axisModel.option;
      var data = option.data;
      var categories = data && map(data, getName);
      return new OrdinalMeta2({
        categories,
        needCollect: !categories,
        deduplication: option.dedplication !== false
      });
    };
    ;
    OrdinalMeta2.prototype.getOrdinal = function(category) {
      return this._getOrCreateMap().get(category);
    };
    OrdinalMeta2.prototype.parseAndCollect = function(category) {
      var index;
      var needCollect = this._needCollect;
      if (!isString(category) && !needCollect) {
        return category;
      }
      if (needCollect && !this._deduplication) {
        index = this.categories.length;
        this.categories[index] = category;
        return index;
      }
      var map3 = this._getOrCreateMap();
      index = map3.get(category);
      if (index == null) {
        if (needCollect) {
          index = this.categories.length;
          this.categories[index] = category;
          map3.set(category, index);
        } else {
          index = NaN;
        }
      }
      return index;
    };
    OrdinalMeta2.prototype._getOrCreateMap = function() {
      return this._map || (this._map = createHashMap(this.categories));
    };
    return OrdinalMeta2;
  }();
  function getName(obj) {
    if (isObject(obj) && obj.value != null) {
      return obj.value;
    } else {
      return obj + "";
    }
  }
  var OrdinalMeta_default = OrdinalMeta;

  // node_modules/echarts/lib/scale/helper.js
  function isValueNice(val) {
    var exp10 = Math.pow(10, quantityExponent(Math.abs(val)));
    var f = Math.abs(val / exp10);
    return f === 0 || f === 1 || f === 2 || f === 3 || f === 5;
  }
  function isIntervalOrLogScale(scale4) {
    return scale4.type === "interval" || scale4.type === "log";
  }
  function intervalScaleNiceTicks(extent3, splitNumber, minInterval, maxInterval) {
    var result = {};
    var span = extent3[1] - extent3[0];
    var interval = result.interval = nice(span / splitNumber, true);
    if (minInterval != null && interval < minInterval) {
      interval = result.interval = minInterval;
    }
    if (maxInterval != null && interval > maxInterval) {
      interval = result.interval = maxInterval;
    }
    var precision = result.intervalPrecision = getIntervalPrecision(interval);
    var niceTickExtent = result.niceTickExtent = [round(Math.ceil(extent3[0] / interval) * interval, precision), round(Math.floor(extent3[1] / interval) * interval, precision)];
    fixExtent(niceTickExtent, extent3);
    return result;
  }
  function increaseInterval(interval) {
    var exp10 = Math.pow(10, quantityExponent(interval));
    var f = interval / exp10;
    if (!f) {
      f = 1;
    } else if (f === 2) {
      f = 3;
    } else if (f === 3) {
      f = 5;
    } else {
      f *= 2;
    }
    return round(f * exp10);
  }
  function getIntervalPrecision(interval) {
    return getPrecision(interval) + 2;
  }
  function clamp(niceTickExtent, idx, extent3) {
    niceTickExtent[idx] = Math.max(Math.min(niceTickExtent[idx], extent3[1]), extent3[0]);
  }
  function fixExtent(niceTickExtent, extent3) {
    !isFinite(niceTickExtent[0]) && (niceTickExtent[0] = extent3[0]);
    !isFinite(niceTickExtent[1]) && (niceTickExtent[1] = extent3[1]);
    clamp(niceTickExtent, 0, extent3);
    clamp(niceTickExtent, 1, extent3);
    if (niceTickExtent[0] > niceTickExtent[1]) {
      niceTickExtent[0] = niceTickExtent[1];
    }
  }
  function contain2(val, extent3) {
    return val >= extent3[0] && val <= extent3[1];
  }
  function normalize2(val, extent3) {
    if (extent3[1] === extent3[0]) {
      return 0.5;
    }
    return (val - extent3[0]) / (extent3[1] - extent3[0]);
  }
  function scale3(val, extent3) {
    return val * (extent3[1] - extent3[0]) + extent3[0];
  }

  // node_modules/echarts/lib/scale/Ordinal.js
  var OrdinalScale = function(_super) {
    __extends(OrdinalScale2, _super);
    function OrdinalScale2(setting) {
      var _this = _super.call(this, setting) || this;
      _this.type = "ordinal";
      var ordinalMeta = _this.getSetting("ordinalMeta");
      if (!ordinalMeta) {
        ordinalMeta = new OrdinalMeta_default({});
      }
      if (isArray(ordinalMeta)) {
        ordinalMeta = new OrdinalMeta_default({
          categories: map(ordinalMeta, function(item) {
            return isObject(item) ? item.value : item;
          })
        });
      }
      _this._ordinalMeta = ordinalMeta;
      _this._extent = _this.getSetting("extent") || [0, ordinalMeta.categories.length - 1];
      return _this;
    }
    OrdinalScale2.prototype.parse = function(val) {
      if (val == null) {
        return NaN;
      }
      return isString(val) ? this._ordinalMeta.getOrdinal(val) : Math.round(val);
    };
    OrdinalScale2.prototype.contain = function(rank) {
      rank = this.parse(rank);
      return contain2(rank, this._extent) && this._ordinalMeta.categories[rank] != null;
    };
    OrdinalScale2.prototype.normalize = function(val) {
      val = this._getTickNumber(this.parse(val));
      return normalize2(val, this._extent);
    };
    OrdinalScale2.prototype.scale = function(val) {
      val = Math.round(scale3(val, this._extent));
      return this.getRawOrdinalNumber(val);
    };
    OrdinalScale2.prototype.getTicks = function() {
      var ticks = [];
      var extent3 = this._extent;
      var rank = extent3[0];
      while (rank <= extent3[1]) {
        ticks.push({
          value: rank
        });
        rank++;
      }
      return ticks;
    };
    OrdinalScale2.prototype.getMinorTicks = function(splitNumber) {
      return;
    };
    OrdinalScale2.prototype.setSortInfo = function(info) {
      if (info == null) {
        this._ordinalNumbersByTick = this._ticksByOrdinalNumber = null;
        return;
      }
      var infoOrdinalNumbers = info.ordinalNumbers;
      var ordinalsByTick = this._ordinalNumbersByTick = [];
      var ticksByOrdinal = this._ticksByOrdinalNumber = [];
      var tickNum = 0;
      var allCategoryLen = this._ordinalMeta.categories.length;
      for (var len2 = Math.min(allCategoryLen, infoOrdinalNumbers.length); tickNum < len2; ++tickNum) {
        var ordinalNumber = infoOrdinalNumbers[tickNum];
        ordinalsByTick[tickNum] = ordinalNumber;
        ticksByOrdinal[ordinalNumber] = tickNum;
      }
      var unusedOrdinal = 0;
      for (; tickNum < allCategoryLen; ++tickNum) {
        while (ticksByOrdinal[unusedOrdinal] != null) {
          unusedOrdinal++;
        }
        ;
        ordinalsByTick.push(unusedOrdinal);
        ticksByOrdinal[unusedOrdinal] = tickNum;
      }
    };
    OrdinalScale2.prototype._getTickNumber = function(ordinal) {
      var ticksByOrdinalNumber = this._ticksByOrdinalNumber;
      return ticksByOrdinalNumber && ordinal >= 0 && ordinal < ticksByOrdinalNumber.length ? ticksByOrdinalNumber[ordinal] : ordinal;
    };
    OrdinalScale2.prototype.getRawOrdinalNumber = function(tickNumber) {
      var ordinalNumbersByTick = this._ordinalNumbersByTick;
      return ordinalNumbersByTick && tickNumber >= 0 && tickNumber < ordinalNumbersByTick.length ? ordinalNumbersByTick[tickNumber] : tickNumber;
    };
    OrdinalScale2.prototype.getLabel = function(tick) {
      if (!this.isBlank()) {
        var ordinalNumber = this.getRawOrdinalNumber(tick.value);
        var cateogry = this._ordinalMeta.categories[ordinalNumber];
        return cateogry == null ? "" : cateogry + "";
      }
    };
    OrdinalScale2.prototype.count = function() {
      return this._extent[1] - this._extent[0] + 1;
    };
    OrdinalScale2.prototype.unionExtentFromData = function(data, dim) {
      this.unionExtent(data.getApproximateExtent(dim));
    };
    OrdinalScale2.prototype.isInExtentRange = function(value) {
      value = this._getTickNumber(value);
      return this._extent[0] <= value && this._extent[1] >= value;
    };
    OrdinalScale2.prototype.getOrdinalMeta = function() {
      return this._ordinalMeta;
    };
    OrdinalScale2.prototype.calcNiceTicks = function() {
    };
    OrdinalScale2.prototype.calcNiceExtent = function() {
    };
    OrdinalScale2.type = "ordinal";
    return OrdinalScale2;
  }(Scale_default);
  Scale_default.registerClass(OrdinalScale);
  var Ordinal_default = OrdinalScale;

  // node_modules/echarts/lib/scale/Interval.js
  var roundNumber = round;
  var IntervalScale = function(_super) {
    __extends(IntervalScale2, _super);
    function IntervalScale2() {
      var _this = _super !== null && _super.apply(this, arguments) || this;
      _this.type = "interval";
      _this._interval = 0;
      _this._intervalPrecision = 2;
      return _this;
    }
    IntervalScale2.prototype.parse = function(val) {
      return val;
    };
    IntervalScale2.prototype.contain = function(val) {
      return contain2(val, this._extent);
    };
    IntervalScale2.prototype.normalize = function(val) {
      return normalize2(val, this._extent);
    };
    IntervalScale2.prototype.scale = function(val) {
      return scale3(val, this._extent);
    };
    IntervalScale2.prototype.setExtent = function(start2, end2) {
      var thisExtent = this._extent;
      if (!isNaN(start2)) {
        thisExtent[0] = parseFloat(start2);
      }
      if (!isNaN(end2)) {
        thisExtent[1] = parseFloat(end2);
      }
    };
    IntervalScale2.prototype.unionExtent = function(other) {
      var extent3 = this._extent;
      other[0] < extent3[0] && (extent3[0] = other[0]);
      other[1] > extent3[1] && (extent3[1] = other[1]);
      this.setExtent(extent3[0], extent3[1]);
    };
    IntervalScale2.prototype.getInterval = function() {
      return this._interval;
    };
    IntervalScale2.prototype.setInterval = function(interval) {
      this._interval = interval;
      this._niceExtent = this._extent.slice();
      this._intervalPrecision = getIntervalPrecision(interval);
    };
    IntervalScale2.prototype.getTicks = function(expandToNicedExtent) {
      var interval = this._interval;
      var extent3 = this._extent;
      var niceTickExtent = this._niceExtent;
      var intervalPrecision = this._intervalPrecision;
      var ticks = [];
      if (!interval) {
        return ticks;
      }
      var safeLimit = 1e4;
      if (extent3[0] < niceTickExtent[0]) {
        if (expandToNicedExtent) {
          ticks.push({
            value: roundNumber(niceTickExtent[0] - interval, intervalPrecision)
          });
        } else {
          ticks.push({
            value: extent3[0]
          });
        }
      }
      var tick = niceTickExtent[0];
      while (tick <= niceTickExtent[1]) {
        ticks.push({
          value: tick
        });
        tick = roundNumber(tick + interval, intervalPrecision);
        if (tick === ticks[ticks.length - 1].value) {
          break;
        }
        if (ticks.length > safeLimit) {
          return [];
        }
      }
      var lastNiceTick = ticks.length ? ticks[ticks.length - 1].value : niceTickExtent[1];
      if (extent3[1] > lastNiceTick) {
        if (expandToNicedExtent) {
          ticks.push({
            value: roundNumber(lastNiceTick + interval, intervalPrecision)
          });
        } else {
          ticks.push({
            value: extent3[1]
          });
        }
      }
      return ticks;
    };
    IntervalScale2.prototype.getMinorTicks = function(splitNumber) {
      var ticks = this.getTicks(true);
      var minorTicks = [];
      var extent3 = this.getExtent();
      for (var i = 1; i < ticks.length; i++) {
        var nextTick = ticks[i];
        var prevTick = ticks[i - 1];
        var count2 = 0;
        var minorTicksGroup = [];
        var interval = nextTick.value - prevTick.value;
        var minorInterval = interval / splitNumber;
        while (count2 < splitNumber - 1) {
          var minorTick = roundNumber(prevTick.value + (count2 + 1) * minorInterval);
          if (minorTick > extent3[0] && minorTick < extent3[1]) {
            minorTicksGroup.push(minorTick);
          }
          count2++;
        }
        minorTicks.push(minorTicksGroup);
      }
      return minorTicks;
    };
    IntervalScale2.prototype.getLabel = function(data, opt) {
      if (data == null) {
        return "";
      }
      var precision = opt && opt.precision;
      if (precision == null) {
        precision = getPrecision(data.value) || 0;
      } else if (precision === "auto") {
        precision = this._intervalPrecision;
      }
      var dataNum = roundNumber(data.value, precision, true);
      return addCommas(dataNum);
    };
    IntervalScale2.prototype.calcNiceTicks = function(splitNumber, minInterval, maxInterval) {
      splitNumber = splitNumber || 5;
      var extent3 = this._extent;
      var span = extent3[1] - extent3[0];
      if (!isFinite(span)) {
        return;
      }
      if (span < 0) {
        span = -span;
        extent3.reverse();
      }
      var result = intervalScaleNiceTicks(extent3, splitNumber, minInterval, maxInterval);
      this._intervalPrecision = result.intervalPrecision;
      this._interval = result.interval;
      this._niceExtent = result.niceTickExtent;
    };
    IntervalScale2.prototype.calcNiceExtent = function(opt) {
      var extent3 = this._extent;
      if (extent3[0] === extent3[1]) {
        if (extent3[0] !== 0) {
          var expandSize = extent3[0];
          if (!opt.fixMax) {
            extent3[1] += expandSize / 2;
            extent3[0] -= expandSize / 2;
          } else {
            extent3[0] -= expandSize / 2;
          }
        } else {
          extent3[1] = 1;
        }
      }
      var span = extent3[1] - extent3[0];
      if (!isFinite(span)) {
        extent3[0] = 0;
        extent3[1] = 1;
      }
      this.calcNiceTicks(opt.splitNumber, opt.minInterval, opt.maxInterval);
      var interval = this._interval;
      if (!opt.fixMin) {
        extent3[0] = roundNumber(Math.floor(extent3[0] / interval) * interval);
      }
      if (!opt.fixMax) {
        extent3[1] = roundNumber(Math.ceil(extent3[1] / interval) * interval);
      }
    };
    IntervalScale2.prototype.setNiceExtent = function(min3, max3) {
      this._niceExtent = [min3, max3];
    };
    IntervalScale2.type = "interval";
    return IntervalScale2;
  }(Scale_default);
  Scale_default.registerClass(IntervalScale);
  var Interval_default = IntervalScale;

  // node_modules/echarts/lib/util/vendor.js
  var supportFloat32Array = typeof Float32Array !== "undefined";
  var Float32ArrayCtor = !supportFloat32Array ? Array : Float32Array;
  function createFloat32Array(arg) {
    if (isArray(arg)) {
      return supportFloat32Array ? new Float32Array(arg) : arg;
    }
    return new Float32ArrayCtor(arg);
  }

  // node_modules/echarts/lib/layout/barGrid.js
  var STACK_PREFIX = "__ec_stack_";
  function getSeriesStackId(seriesModel) {
    return seriesModel.get("stack") || STACK_PREFIX + seriesModel.seriesIndex;
  }
  function getAxisKey(axis) {
    return axis.dim + axis.index;
  }
  function getLayoutOnAxis(opt) {
    var params = [];
    var baseAxis = opt.axis;
    var axisKey = "axis0";
    if (baseAxis.type !== "category") {
      return;
    }
    var bandWidth = baseAxis.getBandWidth();
    for (var i = 0; i < opt.count || 0; i++) {
      params.push(defaults({
        bandWidth,
        axisKey,
        stackId: STACK_PREFIX + i
      }, opt));
    }
    var widthAndOffsets = doCalBarWidthAndOffset(params);
    var result = [];
    for (var i = 0; i < opt.count; i++) {
      var item = widthAndOffsets[axisKey][STACK_PREFIX + i];
      item.offsetCenter = item.offset + item.width / 2;
      result.push(item);
    }
    return result;
  }
  function prepareLayoutBarSeries(seriesType2, ecModel) {
    var seriesModels = [];
    ecModel.eachSeriesByType(seriesType2, function(seriesModel) {
      if (isOnCartesian(seriesModel)) {
        seriesModels.push(seriesModel);
      }
    });
    return seriesModels;
  }
  function getValueAxesMinGaps(barSeries) {
    var axisValues = {};
    each(barSeries, function(seriesModel) {
      var cartesian = seriesModel.coordinateSystem;
      var baseAxis = cartesian.getBaseAxis();
      if (baseAxis.type !== "time" && baseAxis.type !== "value") {
        return;
      }
      var data = seriesModel.getData();
      var key2 = baseAxis.dim + "_" + baseAxis.index;
      var dimIdx = data.getDimensionIndex(data.mapDimension(baseAxis.dim));
      var store = data.getStore();
      for (var i = 0, cnt = store.count(); i < cnt; ++i) {
        var value = store.get(dimIdx, i);
        if (!axisValues[key2]) {
          axisValues[key2] = [value];
        } else {
          axisValues[key2].push(value);
        }
      }
    });
    var axisMinGaps = {};
    for (var key in axisValues) {
      if (axisValues.hasOwnProperty(key)) {
        var valuesInAxis = axisValues[key];
        if (valuesInAxis) {
          valuesInAxis.sort(function(a, b) {
            return a - b;
          });
          var min3 = null;
          for (var j = 1; j < valuesInAxis.length; ++j) {
            var delta = valuesInAxis[j] - valuesInAxis[j - 1];
            if (delta > 0) {
              min3 = min3 === null ? delta : Math.min(min3, delta);
            }
          }
          axisMinGaps[key] = min3;
        }
      }
    }
    return axisMinGaps;
  }
  function makeColumnLayout(barSeries) {
    var axisMinGaps = getValueAxesMinGaps(barSeries);
    var seriesInfoList = [];
    each(barSeries, function(seriesModel) {
      var cartesian = seriesModel.coordinateSystem;
      var baseAxis = cartesian.getBaseAxis();
      var axisExtent = baseAxis.getExtent();
      var bandWidth;
      if (baseAxis.type === "category") {
        bandWidth = baseAxis.getBandWidth();
      } else if (baseAxis.type === "value" || baseAxis.type === "time") {
        var key = baseAxis.dim + "_" + baseAxis.index;
        var minGap = axisMinGaps[key];
        var extentSpan = Math.abs(axisExtent[1] - axisExtent[0]);
        var scale4 = baseAxis.scale.getExtent();
        var scaleSpan = Math.abs(scale4[1] - scale4[0]);
        bandWidth = minGap ? extentSpan / scaleSpan * minGap : extentSpan;
      } else {
        var data = seriesModel.getData();
        bandWidth = Math.abs(axisExtent[1] - axisExtent[0]) / data.count();
      }
      var barWidth = parsePercent2(seriesModel.get("barWidth"), bandWidth);
      var barMaxWidth = parsePercent2(seriesModel.get("barMaxWidth"), bandWidth);
      var barMinWidth = parsePercent2(seriesModel.get("barMinWidth") || (isInLargeMode(seriesModel) ? 0.5 : 1), bandWidth);
      var barGap = seriesModel.get("barGap");
      var barCategoryGap = seriesModel.get("barCategoryGap");
      seriesInfoList.push({
        bandWidth,
        barWidth,
        barMaxWidth,
        barMinWidth,
        barGap,
        barCategoryGap,
        axisKey: getAxisKey(baseAxis),
        stackId: getSeriesStackId(seriesModel)
      });
    });
    return doCalBarWidthAndOffset(seriesInfoList);
  }
  function doCalBarWidthAndOffset(seriesInfoList) {
    var columnsMap = {};
    each(seriesInfoList, function(seriesInfo, idx) {
      var axisKey = seriesInfo.axisKey;
      var bandWidth = seriesInfo.bandWidth;
      var columnsOnAxis = columnsMap[axisKey] || {
        bandWidth,
        remainedWidth: bandWidth,
        autoWidthCount: 0,
        categoryGap: null,
        gap: "20%",
        stacks: {}
      };
      var stacks = columnsOnAxis.stacks;
      columnsMap[axisKey] = columnsOnAxis;
      var stackId = seriesInfo.stackId;
      if (!stacks[stackId]) {
        columnsOnAxis.autoWidthCount++;
      }
      stacks[stackId] = stacks[stackId] || {
        width: 0,
        maxWidth: 0
      };
      var barWidth = seriesInfo.barWidth;
      if (barWidth && !stacks[stackId].width) {
        stacks[stackId].width = barWidth;
        barWidth = Math.min(columnsOnAxis.remainedWidth, barWidth);
        columnsOnAxis.remainedWidth -= barWidth;
      }
      var barMaxWidth = seriesInfo.barMaxWidth;
      barMaxWidth && (stacks[stackId].maxWidth = barMaxWidth);
      var barMinWidth = seriesInfo.barMinWidth;
      barMinWidth && (stacks[stackId].minWidth = barMinWidth);
      var barGap = seriesInfo.barGap;
      barGap != null && (columnsOnAxis.gap = barGap);
      var barCategoryGap = seriesInfo.barCategoryGap;
      barCategoryGap != null && (columnsOnAxis.categoryGap = barCategoryGap);
    });
    var result = {};
    each(columnsMap, function(columnsOnAxis, coordSysName) {
      result[coordSysName] = {};
      var stacks = columnsOnAxis.stacks;
      var bandWidth = columnsOnAxis.bandWidth;
      var categoryGapPercent = columnsOnAxis.categoryGap;
      if (categoryGapPercent == null) {
        var columnCount = keys(stacks).length;
        categoryGapPercent = Math.max(35 - columnCount * 4, 15) + "%";
      }
      var categoryGap = parsePercent2(categoryGapPercent, bandWidth);
      var barGapPercent = parsePercent2(columnsOnAxis.gap, 1);
      var remainedWidth = columnsOnAxis.remainedWidth;
      var autoWidthCount = columnsOnAxis.autoWidthCount;
      var autoWidth = (remainedWidth - categoryGap) / (autoWidthCount + (autoWidthCount - 1) * barGapPercent);
      autoWidth = Math.max(autoWidth, 0);
      each(stacks, function(column) {
        var maxWidth = column.maxWidth;
        var minWidth = column.minWidth;
        if (!column.width) {
          var finalWidth = autoWidth;
          if (maxWidth && maxWidth < finalWidth) {
            finalWidth = Math.min(maxWidth, remainedWidth);
          }
          if (minWidth && minWidth > finalWidth) {
            finalWidth = minWidth;
          }
          if (finalWidth !== autoWidth) {
            column.width = finalWidth;
            remainedWidth -= finalWidth + barGapPercent * finalWidth;
            autoWidthCount--;
          }
        } else {
          var finalWidth = column.width;
          if (maxWidth) {
            finalWidth = Math.min(finalWidth, maxWidth);
          }
          if (minWidth) {
            finalWidth = Math.max(finalWidth, minWidth);
          }
          column.width = finalWidth;
          remainedWidth -= finalWidth + barGapPercent * finalWidth;
          autoWidthCount--;
        }
      });
      autoWidth = (remainedWidth - categoryGap) / (autoWidthCount + (autoWidthCount - 1) * barGapPercent);
      autoWidth = Math.max(autoWidth, 0);
      var widthSum = 0;
      var lastColumn;
      each(stacks, function(column, idx) {
        if (!column.width) {
          column.width = autoWidth;
        }
        lastColumn = column;
        widthSum += column.width * (1 + barGapPercent);
      });
      if (lastColumn) {
        widthSum -= lastColumn.width * barGapPercent;
      }
      var offset = -widthSum / 2;
      each(stacks, function(column, stackId) {
        result[coordSysName][stackId] = result[coordSysName][stackId] || {
          bandWidth,
          offset,
          width: column.width
        };
        offset += column.width * (1 + barGapPercent);
      });
    });
    return result;
  }
  function retrieveColumnLayout(barWidthAndOffset, axis, seriesModel) {
    if (barWidthAndOffset && axis) {
      var result = barWidthAndOffset[getAxisKey(axis)];
      if (result != null && seriesModel != null) {
        return result[getSeriesStackId(seriesModel)];
      }
      return result;
    }
  }
  function layout(seriesType2, ecModel) {
    var seriesModels = prepareLayoutBarSeries(seriesType2, ecModel);
    var barWidthAndOffset = makeColumnLayout(seriesModels);
    each(seriesModels, function(seriesModel) {
      var data = seriesModel.getData();
      var cartesian = seriesModel.coordinateSystem;
      var baseAxis = cartesian.getBaseAxis();
      var stackId = getSeriesStackId(seriesModel);
      var columnLayoutInfo = barWidthAndOffset[getAxisKey(baseAxis)][stackId];
      var columnOffset = columnLayoutInfo.offset;
      var columnWidth = columnLayoutInfo.width;
      data.setLayout({
        bandWidth: columnLayoutInfo.bandWidth,
        offset: columnOffset,
        size: columnWidth
      });
    });
  }
  function createProgressiveLayout(seriesType2) {
    return {
      seriesType: seriesType2,
      plan: createRenderPlanner(),
      reset: function(seriesModel) {
        if (!isOnCartesian(seriesModel)) {
          return;
        }
        var data = seriesModel.getData();
        var cartesian = seriesModel.coordinateSystem;
        var baseAxis = cartesian.getBaseAxis();
        var valueAxis2 = cartesian.getOtherAxis(baseAxis);
        var valueDimIdx = data.getDimensionIndex(data.mapDimension(valueAxis2.dim));
        var baseDimIdx = data.getDimensionIndex(data.mapDimension(baseAxis.dim));
        var drawBackground = seriesModel.get("showBackground", true);
        var valueDim = data.mapDimension(valueAxis2.dim);
        var stackResultDim = data.getCalculationInfo("stackResultDimension");
        var stacked = isDimensionStacked(data, valueDim) && !!data.getCalculationInfo("stackedOnSeries");
        var isValueAxisH = valueAxis2.isHorizontal();
        var valueAxisStart = getValueAxisStart(baseAxis, valueAxis2);
        var isLarge = isInLargeMode(seriesModel);
        var barMinHeight = seriesModel.get("barMinHeight") || 0;
        var stackedDimIdx = stackResultDim && data.getDimensionIndex(stackResultDim);
        var columnWidth = data.getLayout("size");
        var columnOffset = data.getLayout("offset");
        return {
          progress: function(params, data2) {
            var count2 = params.count;
            var largePoints = isLarge && createFloat32Array(count2 * 3);
            var largeBackgroundPoints = isLarge && drawBackground && createFloat32Array(count2 * 3);
            var largeDataIndices = isLarge && createFloat32Array(count2);
            var coordLayout = cartesian.master.getRect();
            var bgSize = isValueAxisH ? coordLayout.width : coordLayout.height;
            var dataIndex;
            var store = data2.getStore();
            var idxOffset = 0;
            while ((dataIndex = params.next()) != null) {
              var value = store.get(stacked ? stackedDimIdx : valueDimIdx, dataIndex);
              var baseValue = store.get(baseDimIdx, dataIndex);
              var baseCoord = valueAxisStart;
              var startValue = void 0;
              if (stacked) {
                startValue = +value - store.get(valueDimIdx, dataIndex);
              }
              var x = void 0;
              var y = void 0;
              var width = void 0;
              var height = void 0;
              if (isValueAxisH) {
                var coord = cartesian.dataToPoint([value, baseValue]);
                if (stacked) {
                  var startCoord = cartesian.dataToPoint([startValue, baseValue]);
                  baseCoord = startCoord[0];
                }
                x = baseCoord;
                y = coord[1] + columnOffset;
                width = coord[0] - baseCoord;
                height = columnWidth;
                if (Math.abs(width) < barMinHeight) {
                  width = (width < 0 ? -1 : 1) * barMinHeight;
                }
              } else {
                var coord = cartesian.dataToPoint([baseValue, value]);
                if (stacked) {
                  var startCoord = cartesian.dataToPoint([baseValue, startValue]);
                  baseCoord = startCoord[1];
                }
                x = coord[0] + columnOffset;
                y = baseCoord;
                width = columnWidth;
                height = coord[1] - baseCoord;
                if (Math.abs(height) < barMinHeight) {
                  height = (height <= 0 ? -1 : 1) * barMinHeight;
                }
              }
              if (!isLarge) {
                data2.setItemLayout(dataIndex, {
                  x,
                  y,
                  width,
                  height
                });
              } else {
                largePoints[idxOffset] = x;
                largePoints[idxOffset + 1] = y;
                largePoints[idxOffset + 2] = isValueAxisH ? width : height;
                if (largeBackgroundPoints) {
                  largeBackgroundPoints[idxOffset] = isValueAxisH ? coordLayout.x : x;
                  largeBackgroundPoints[idxOffset + 1] = isValueAxisH ? y : coordLayout.y;
                  largeBackgroundPoints[idxOffset + 2] = bgSize;
                }
                largeDataIndices[dataIndex] = dataIndex;
              }
              idxOffset += 3;
            }
            if (isLarge) {
              data2.setLayout({
                largePoints,
                largeDataIndices,
                largeBackgroundPoints,
                valueAxisHorizontal: isValueAxisH
              });
            }
          }
        };
      }
    };
  }
  function isOnCartesian(seriesModel) {
    return seriesModel.coordinateSystem && seriesModel.coordinateSystem.type === "cartesian2d";
  }
  function isInLargeMode(seriesModel) {
    return seriesModel.pipelineContext && seriesModel.pipelineContext.large;
  }
  function getValueAxisStart(baseAxis, valueAxis2) {
    return valueAxis2.toGlobalCoord(valueAxis2.dataToCoord(valueAxis2.type === "log" ? 1 : 0));
  }

  // node_modules/echarts/lib/scale/Time.js
  var bisect = function(a, x, lo, hi) {
    while (lo < hi) {
      var mid = lo + hi >>> 1;
      if (a[mid][1] < x) {
        lo = mid + 1;
      } else {
        hi = mid;
      }
    }
    return lo;
  };
  var TimeScale = function(_super) {
    __extends(TimeScale2, _super);
    function TimeScale2(settings) {
      var _this = _super.call(this, settings) || this;
      _this.type = "time";
      return _this;
    }
    TimeScale2.prototype.getLabel = function(tick) {
      var useUTC = this.getSetting("useUTC");
      return format(tick.value, fullLeveledFormatter[getDefaultFormatPrecisionOfInterval(getPrimaryTimeUnit(this._minLevelUnit))] || fullLeveledFormatter.second, useUTC, this.getSetting("locale"));
    };
    TimeScale2.prototype.getFormattedLabel = function(tick, idx, labelFormatter) {
      var isUTC = this.getSetting("useUTC");
      var lang = this.getSetting("locale");
      return leveledFormat(tick, idx, labelFormatter, lang, isUTC);
    };
    TimeScale2.prototype.getTicks = function() {
      var interval = this._interval;
      var extent3 = this._extent;
      var ticks = [];
      if (!interval) {
        return ticks;
      }
      ticks.push({
        value: extent3[0],
        level: 0
      });
      var useUTC = this.getSetting("useUTC");
      var innerTicks = getIntervalTicks(this._minLevelUnit, this._approxInterval, useUTC, extent3);
      ticks = ticks.concat(innerTicks);
      ticks.push({
        value: extent3[1],
        level: 0
      });
      return ticks;
    };
    TimeScale2.prototype.calcNiceExtent = function(opt) {
      var extent3 = this._extent;
      if (extent3[0] === extent3[1]) {
        extent3[0] -= ONE_DAY;
        extent3[1] += ONE_DAY;
      }
      if (extent3[1] === -Infinity && extent3[0] === Infinity) {
        var d = new Date();
        extent3[1] = +new Date(d.getFullYear(), d.getMonth(), d.getDate());
        extent3[0] = extent3[1] - ONE_DAY;
      }
      this.calcNiceTicks(opt.splitNumber, opt.minInterval, opt.maxInterval);
    };
    TimeScale2.prototype.calcNiceTicks = function(approxTickNum, minInterval, maxInterval) {
      approxTickNum = approxTickNum || 10;
      var extent3 = this._extent;
      var span = extent3[1] - extent3[0];
      this._approxInterval = span / approxTickNum;
      if (minInterval != null && this._approxInterval < minInterval) {
        this._approxInterval = minInterval;
      }
      if (maxInterval != null && this._approxInterval > maxInterval) {
        this._approxInterval = maxInterval;
      }
      var scaleIntervalsLen = scaleIntervals.length;
      var idx = Math.min(bisect(scaleIntervals, this._approxInterval, 0, scaleIntervalsLen), scaleIntervalsLen - 1);
      this._interval = scaleIntervals[idx][1];
      this._minLevelUnit = scaleIntervals[Math.max(idx - 1, 0)][0];
    };
    TimeScale2.prototype.parse = function(val) {
      return isNumber(val) ? val : +parseDate(val);
    };
    TimeScale2.prototype.contain = function(val) {
      return contain2(this.parse(val), this._extent);
    };
    TimeScale2.prototype.normalize = function(val) {
      return normalize2(this.parse(val), this._extent);
    };
    TimeScale2.prototype.scale = function(val) {
      return scale3(val, this._extent);
    };
    TimeScale2.type = "time";
    return TimeScale2;
  }(Interval_default);
  var scaleIntervals = [
    ["second", ONE_SECOND],
    ["minute", ONE_MINUTE],
    ["hour", ONE_HOUR],
    ["quarter-day", ONE_HOUR * 6],
    ["half-day", ONE_HOUR * 12],
    ["day", ONE_DAY * 1.2],
    ["half-week", ONE_DAY * 3.5],
    ["week", ONE_DAY * 7],
    ["month", ONE_DAY * 31],
    ["quarter", ONE_DAY * 95],
    ["half-year", ONE_YEAR / 2],
    ["year", ONE_YEAR]
  ];
  function isUnitValueSame(unit, valueA, valueB, isUTC) {
    var dateA = parseDate(valueA);
    var dateB = parseDate(valueB);
    var isSame = function(unit2) {
      return getUnitValue(dateA, unit2, isUTC) === getUnitValue(dateB, unit2, isUTC);
    };
    var isSameYear = function() {
      return isSame("year");
    };
    var isSameMonth = function() {
      return isSameYear() && isSame("month");
    };
    var isSameDay = function() {
      return isSameMonth() && isSame("day");
    };
    var isSameHour = function() {
      return isSameDay() && isSame("hour");
    };
    var isSameMinute = function() {
      return isSameHour() && isSame("minute");
    };
    var isSameSecond = function() {
      return isSameMinute() && isSame("second");
    };
    var isSameMilliSecond = function() {
      return isSameSecond() && isSame("millisecond");
    };
    switch (unit) {
      case "year":
        return isSameYear();
      case "month":
        return isSameMonth();
      case "day":
        return isSameDay();
      case "hour":
        return isSameHour();
      case "minute":
        return isSameMinute();
      case "second":
        return isSameSecond();
      case "millisecond":
        return isSameMilliSecond();
    }
  }
  function getDateInterval(approxInterval, daysInMonth) {
    approxInterval /= ONE_DAY;
    return approxInterval > 16 ? 16 : approxInterval > 7.5 ? 7 : approxInterval > 3.5 ? 4 : approxInterval > 1.5 ? 2 : 1;
  }
  function getMonthInterval(approxInterval) {
    var APPROX_ONE_MONTH = 30 * ONE_DAY;
    approxInterval /= APPROX_ONE_MONTH;
    return approxInterval > 6 ? 6 : approxInterval > 3 ? 3 : approxInterval > 2 ? 2 : 1;
  }
  function getHourInterval(approxInterval) {
    approxInterval /= ONE_HOUR;
    return approxInterval > 12 ? 12 : approxInterval > 6 ? 6 : approxInterval > 3.5 ? 4 : approxInterval > 2 ? 2 : 1;
  }
  function getMinutesAndSecondsInterval(approxInterval, isMinutes) {
    approxInterval /= isMinutes ? ONE_MINUTE : ONE_SECOND;
    return approxInterval > 30 ? 30 : approxInterval > 20 ? 20 : approxInterval > 15 ? 15 : approxInterval > 10 ? 10 : approxInterval > 5 ? 5 : approxInterval > 2 ? 2 : 1;
  }
  function getMillisecondsInterval(approxInterval) {
    return nice(approxInterval, true);
  }
  function getFirstTimestampOfUnit(date, unitName, isUTC) {
    var outDate = new Date(date);
    switch (getPrimaryTimeUnit(unitName)) {
      case "year":
      case "month":
        outDate[monthSetterName(isUTC)](0);
      case "day":
        outDate[dateSetterName(isUTC)](1);
      case "hour":
        outDate[hoursSetterName(isUTC)](0);
      case "minute":
        outDate[minutesSetterName(isUTC)](0);
      case "second":
        outDate[secondsSetterName(isUTC)](0);
        outDate[millisecondsSetterName(isUTC)](0);
    }
    return outDate.getTime();
  }
  function getIntervalTicks(bottomUnitName, approxInterval, isUTC, extent3) {
    var safeLimit = 1e4;
    var unitNames = timeUnits;
    var iter = 0;
    function addTicksInSpan(interval, minTimestamp, maxTimestamp, getMethodName, setMethodName, isDate, out2) {
      var date = new Date(minTimestamp);
      var dateTime = minTimestamp;
      var d = date[getMethodName]();
      while (dateTime < maxTimestamp && dateTime <= extent3[1]) {
        out2.push({
          value: dateTime
        });
        d += interval;
        date[setMethodName](d);
        dateTime = date.getTime();
      }
      out2.push({
        value: dateTime,
        notAdd: true
      });
    }
    function addLevelTicks(unitName, lastLevelTicks, levelTicks2) {
      var newAddedTicks = [];
      var isFirstLevel = !lastLevelTicks.length;
      if (isUnitValueSame(getPrimaryTimeUnit(unitName), extent3[0], extent3[1], isUTC)) {
        return;
      }
      if (isFirstLevel) {
        lastLevelTicks = [{
          value: getFirstTimestampOfUnit(new Date(extent3[0]), unitName, isUTC)
        }, {
          value: extent3[1]
        }];
      }
      for (var i2 = 0; i2 < lastLevelTicks.length - 1; i2++) {
        var startTick = lastLevelTicks[i2].value;
        var endTick = lastLevelTicks[i2 + 1].value;
        if (startTick === endTick) {
          continue;
        }
        var interval = void 0;
        var getterName = void 0;
        var setterName = void 0;
        var isDate = false;
        switch (unitName) {
          case "year":
            interval = Math.max(1, Math.round(approxInterval / ONE_DAY / 365));
            getterName = fullYearGetterName(isUTC);
            setterName = fullYearSetterName(isUTC);
            break;
          case "half-year":
          case "quarter":
          case "month":
            interval = getMonthInterval(approxInterval);
            getterName = monthGetterName(isUTC);
            setterName = monthSetterName(isUTC);
            break;
          case "week":
          case "half-week":
          case "day":
            interval = getDateInterval(approxInterval, 31);
            getterName = dateGetterName(isUTC);
            setterName = dateSetterName(isUTC);
            isDate = true;
            break;
          case "half-day":
          case "quarter-day":
          case "hour":
            interval = getHourInterval(approxInterval);
            getterName = hoursGetterName(isUTC);
            setterName = hoursSetterName(isUTC);
            break;
          case "minute":
            interval = getMinutesAndSecondsInterval(approxInterval, true);
            getterName = minutesGetterName(isUTC);
            setterName = minutesSetterName(isUTC);
            break;
          case "second":
            interval = getMinutesAndSecondsInterval(approxInterval, false);
            getterName = secondsGetterName(isUTC);
            setterName = secondsSetterName(isUTC);
            break;
          case "millisecond":
            interval = getMillisecondsInterval(approxInterval);
            getterName = millisecondsGetterName(isUTC);
            setterName = millisecondsSetterName(isUTC);
            break;
        }
        addTicksInSpan(interval, startTick, endTick, getterName, setterName, isDate, newAddedTicks);
        if (unitName === "year" && levelTicks2.length > 1 && i2 === 0) {
          levelTicks2.unshift({
            value: levelTicks2[0].value - interval
          });
        }
      }
      for (var i2 = 0; i2 < newAddedTicks.length; i2++) {
        levelTicks2.push(newAddedTicks[i2]);
      }
      return newAddedTicks;
    }
    var levelsTicks = [];
    var currentLevelTicks = [];
    var tickCount = 0;
    var lastLevelTickCount = 0;
    for (var i = 0; i < unitNames.length && iter++ < safeLimit; ++i) {
      var primaryTimeUnit = getPrimaryTimeUnit(unitNames[i]);
      if (!isPrimaryTimeUnit(unitNames[i])) {
        continue;
      }
      addLevelTicks(unitNames[i], levelsTicks[levelsTicks.length - 1] || [], currentLevelTicks);
      var nextPrimaryTimeUnit = unitNames[i + 1] ? getPrimaryTimeUnit(unitNames[i + 1]) : null;
      if (primaryTimeUnit !== nextPrimaryTimeUnit) {
        if (currentLevelTicks.length) {
          lastLevelTickCount = tickCount;
          currentLevelTicks.sort(function(a, b) {
            return a.value - b.value;
          });
          var levelTicksRemoveDuplicated = [];
          for (var i_1 = 0; i_1 < currentLevelTicks.length; ++i_1) {
            var tickValue = currentLevelTicks[i_1].value;
            if (i_1 === 0 || currentLevelTicks[i_1 - 1].value !== tickValue) {
              levelTicksRemoveDuplicated.push(currentLevelTicks[i_1]);
              if (tickValue >= extent3[0] && tickValue <= extent3[1]) {
                tickCount++;
              }
            }
          }
          var targetTickNum = (extent3[1] - extent3[0]) / approxInterval;
          if (tickCount > targetTickNum * 1.5 && lastLevelTickCount > targetTickNum / 1.5) {
            break;
          }
          levelsTicks.push(levelTicksRemoveDuplicated);
          if (tickCount > targetTickNum || bottomUnitName === unitNames[i]) {
            break;
          }
        }
        currentLevelTicks = [];
      }
    }
    if (true) {
      if (iter >= safeLimit) {
        warn("Exceed safe limit.");
      }
    }
    var levelsTicksInExtent = filter(map(levelsTicks, function(levelTicks2) {
      return filter(levelTicks2, function(tick) {
        return tick.value >= extent3[0] && tick.value <= extent3[1] && !tick.notAdd;
      });
    }), function(levelTicks2) {
      return levelTicks2.length > 0;
    });
    var ticks = [];
    var maxLevel = levelsTicksInExtent.length - 1;
    for (var i = 0; i < levelsTicksInExtent.length; ++i) {
      var levelTicks = levelsTicksInExtent[i];
      for (var k = 0; k < levelTicks.length; ++k) {
        ticks.push({
          value: levelTicks[k].value,
          level: maxLevel - i
        });
      }
    }
    ticks.sort(function(a, b) {
      return a.value - b.value;
    });
    var result = [];
    for (var i = 0; i < ticks.length; ++i) {
      if (i === 0 || ticks[i].value !== ticks[i - 1].value) {
        result.push(ticks[i]);
      }
    }
    return result;
  }
  Scale_default.registerClass(TimeScale);
  var Time_default = TimeScale;

  // node_modules/echarts/lib/scale/Log.js
  var scaleProto = Scale_default.prototype;
  var intervalScaleProto = Interval_default.prototype;
  var roundingErrorFix = round;
  var mathFloor = Math.floor;
  var mathCeil = Math.ceil;
  var mathPow2 = Math.pow;
  var mathLog = Math.log;
  var LogScale = function(_super) {
    __extends(LogScale2, _super);
    function LogScale2() {
      var _this = _super !== null && _super.apply(this, arguments) || this;
      _this.type = "log";
      _this.base = 10;
      _this._originalScale = new Interval_default();
      _this._interval = 0;
      return _this;
    }
    LogScale2.prototype.getTicks = function(expandToNicedExtent) {
      var originalScale = this._originalScale;
      var extent3 = this._extent;
      var originalExtent = originalScale.getExtent();
      var ticks = intervalScaleProto.getTicks.call(this, expandToNicedExtent);
      return map(ticks, function(tick) {
        var val = tick.value;
        var powVal = round(mathPow2(this.base, val));
        powVal = val === extent3[0] && this._fixMin ? fixRoundingError(powVal, originalExtent[0]) : powVal;
        powVal = val === extent3[1] && this._fixMax ? fixRoundingError(powVal, originalExtent[1]) : powVal;
        return {
          value: powVal
        };
      }, this);
    };
    LogScale2.prototype.setExtent = function(start2, end2) {
      var base2 = this.base;
      start2 = mathLog(start2) / mathLog(base2);
      end2 = mathLog(end2) / mathLog(base2);
      intervalScaleProto.setExtent.call(this, start2, end2);
    };
    LogScale2.prototype.getExtent = function() {
      var base2 = this.base;
      var extent3 = scaleProto.getExtent.call(this);
      extent3[0] = mathPow2(base2, extent3[0]);
      extent3[1] = mathPow2(base2, extent3[1]);
      var originalScale = this._originalScale;
      var originalExtent = originalScale.getExtent();
      this._fixMin && (extent3[0] = fixRoundingError(extent3[0], originalExtent[0]));
      this._fixMax && (extent3[1] = fixRoundingError(extent3[1], originalExtent[1]));
      return extent3;
    };
    LogScale2.prototype.unionExtent = function(extent3) {
      this._originalScale.unionExtent(extent3);
      var base2 = this.base;
      extent3[0] = mathLog(extent3[0]) / mathLog(base2);
      extent3[1] = mathLog(extent3[1]) / mathLog(base2);
      scaleProto.unionExtent.call(this, extent3);
    };
    LogScale2.prototype.unionExtentFromData = function(data, dim) {
      this.unionExtent(data.getApproximateExtent(dim));
    };
    LogScale2.prototype.calcNiceTicks = function(approxTickNum) {
      approxTickNum = approxTickNum || 10;
      var extent3 = this._extent;
      var span = extent3[1] - extent3[0];
      if (span === Infinity || span <= 0) {
        return;
      }
      var interval = quantity(span);
      var err = approxTickNum / span * interval;
      if (err <= 0.5) {
        interval *= 10;
      }
      while (!isNaN(interval) && Math.abs(interval) < 1 && Math.abs(interval) > 0) {
        interval *= 10;
      }
      var niceExtent = [round(mathCeil(extent3[0] / interval) * interval), round(mathFloor(extent3[1] / interval) * interval)];
      this._interval = interval;
      this._niceExtent = niceExtent;
    };
    LogScale2.prototype.calcNiceExtent = function(opt) {
      intervalScaleProto.calcNiceExtent.call(this, opt);
      this._fixMin = opt.fixMin;
      this._fixMax = opt.fixMax;
    };
    LogScale2.prototype.parse = function(val) {
      return val;
    };
    LogScale2.prototype.contain = function(val) {
      val = mathLog(val) / mathLog(this.base);
      return contain2(val, this._extent);
    };
    LogScale2.prototype.normalize = function(val) {
      val = mathLog(val) / mathLog(this.base);
      return normalize2(val, this._extent);
    };
    LogScale2.prototype.scale = function(val) {
      val = scale3(val, this._extent);
      return mathPow2(this.base, val);
    };
    LogScale2.type = "log";
    return LogScale2;
  }(Scale_default);
  var proto = LogScale.prototype;
  proto.getMinorTicks = intervalScaleProto.getMinorTicks;
  proto.getLabel = intervalScaleProto.getLabel;
  function fixRoundingError(val, originalVal) {
    return roundingErrorFix(val, getPrecision(originalVal));
  }
  Scale_default.registerClass(LogScale);
  var Log_default = LogScale;

  // node_modules/echarts/lib/coord/scaleRawExtentInfo.js
  var ScaleRawExtentInfo = function() {
    function ScaleRawExtentInfo2(scale4, model, originalExtent) {
      this._prepareParams(scale4, model, originalExtent);
    }
    ScaleRawExtentInfo2.prototype._prepareParams = function(scale4, model, dataExtent) {
      if (dataExtent[1] < dataExtent[0]) {
        dataExtent = [NaN, NaN];
      }
      this._dataMin = dataExtent[0];
      this._dataMax = dataExtent[1];
      var isOrdinal = this._isOrdinal = scale4.type === "ordinal";
      this._needCrossZero = scale4.type === "interval" && model.getNeedCrossZero && model.getNeedCrossZero();
      var modelMinRaw = this._modelMinRaw = model.get("min", true);
      if (isFunction(modelMinRaw)) {
        this._modelMinNum = parseAxisModelMinMax(scale4, modelMinRaw({
          min: dataExtent[0],
          max: dataExtent[1]
        }));
      } else if (modelMinRaw !== "dataMin") {
        this._modelMinNum = parseAxisModelMinMax(scale4, modelMinRaw);
      }
      var modelMaxRaw = this._modelMaxRaw = model.get("max", true);
      if (isFunction(modelMaxRaw)) {
        this._modelMaxNum = parseAxisModelMinMax(scale4, modelMaxRaw({
          min: dataExtent[0],
          max: dataExtent[1]
        }));
      } else if (modelMaxRaw !== "dataMax") {
        this._modelMaxNum = parseAxisModelMinMax(scale4, modelMaxRaw);
      }
      if (isOrdinal) {
        this._axisDataLen = model.getCategories().length;
      } else {
        var boundaryGap = model.get("boundaryGap");
        var boundaryGapArr = isArray(boundaryGap) ? boundaryGap : [boundaryGap || 0, boundaryGap || 0];
        if (typeof boundaryGapArr[0] === "boolean" || typeof boundaryGapArr[1] === "boolean") {
          if (true) {
            console.warn('Boolean type for boundaryGap is only allowed for ordinal axis. Please use string in percentage instead, e.g., "20%". Currently, boundaryGap is set to be 0.');
          }
          this._boundaryGapInner = [0, 0];
        } else {
          this._boundaryGapInner = [parsePercent(boundaryGapArr[0], 1), parsePercent(boundaryGapArr[1], 1)];
        }
      }
    };
    ScaleRawExtentInfo2.prototype.calculate = function() {
      var isOrdinal = this._isOrdinal;
      var dataMin = this._dataMin;
      var dataMax = this._dataMax;
      var axisDataLen = this._axisDataLen;
      var boundaryGapInner = this._boundaryGapInner;
      var span = !isOrdinal ? dataMax - dataMin || Math.abs(dataMin) : null;
      var min3 = this._modelMinRaw === "dataMin" ? dataMin : this._modelMinNum;
      var max3 = this._modelMaxRaw === "dataMax" ? dataMax : this._modelMaxNum;
      var minFixed = min3 != null;
      var maxFixed = max3 != null;
      if (min3 == null) {
        min3 = isOrdinal ? axisDataLen ? 0 : NaN : dataMin - boundaryGapInner[0] * span;
      }
      if (max3 == null) {
        max3 = isOrdinal ? axisDataLen ? axisDataLen - 1 : NaN : dataMax + boundaryGapInner[1] * span;
      }
      (min3 == null || !isFinite(min3)) && (min3 = NaN);
      (max3 == null || !isFinite(max3)) && (max3 = NaN);
      var isBlank = eqNaN(min3) || eqNaN(max3) || isOrdinal && !axisDataLen;
      if (this._needCrossZero) {
        if (min3 > 0 && max3 > 0 && !minFixed) {
          min3 = 0;
        }
        if (min3 < 0 && max3 < 0 && !maxFixed) {
          max3 = 0;
        }
      }
      var determinedMin = this._determinedMin;
      var determinedMax = this._determinedMax;
      if (determinedMin != null) {
        min3 = determinedMin;
        minFixed = true;
      }
      if (determinedMax != null) {
        max3 = determinedMax;
        maxFixed = true;
      }
      return {
        min: min3,
        max: max3,
        minFixed,
        maxFixed,
        isBlank
      };
    };
    ScaleRawExtentInfo2.prototype.modifyDataMinMax = function(minMaxName, val) {
      if (true) {
        assert(!this.frozen);
      }
      this[DATA_MIN_MAX_ATTR[minMaxName]] = val;
    };
    ScaleRawExtentInfo2.prototype.setDeterminedMinMax = function(minMaxName, val) {
      var attr = DETERMINED_MIN_MAX_ATTR[minMaxName];
      if (true) {
        assert(!this.frozen && this[attr] == null);
      }
      this[attr] = val;
    };
    ScaleRawExtentInfo2.prototype.freeze = function() {
      this.frozen = true;
    };
    return ScaleRawExtentInfo2;
  }();
  var DETERMINED_MIN_MAX_ATTR = {
    min: "_determinedMin",
    max: "_determinedMax"
  };
  var DATA_MIN_MAX_ATTR = {
    min: "_dataMin",
    max: "_dataMax"
  };
  function ensureScaleRawExtentInfo(scale4, model, originalExtent) {
    var rawExtentInfo = scale4.rawExtentInfo;
    if (rawExtentInfo) {
      return rawExtentInfo;
    }
    rawExtentInfo = new ScaleRawExtentInfo(scale4, model, originalExtent);
    scale4.rawExtentInfo = rawExtentInfo;
    return rawExtentInfo;
  }
  function parseAxisModelMinMax(scale4, minMax) {
    return minMax == null ? null : eqNaN(minMax) ? NaN : scale4.parse(minMax);
  }

  // node_modules/echarts/lib/coord/axisHelper.js
  function getScaleExtent(scale4, model) {
    var scaleType = scale4.type;
    var rawExtentResult = ensureScaleRawExtentInfo(scale4, model, scale4.getExtent()).calculate();
    scale4.setBlank(rawExtentResult.isBlank);
    var min3 = rawExtentResult.min;
    var max3 = rawExtentResult.max;
    var ecModel = model.ecModel;
    if (ecModel && scaleType === "time") {
      var barSeriesModels = prepareLayoutBarSeries("bar", ecModel);
      var isBaseAxisAndHasBarSeries_1 = false;
      each(barSeriesModels, function(seriesModel) {
        isBaseAxisAndHasBarSeries_1 = isBaseAxisAndHasBarSeries_1 || seriesModel.getBaseAxis() === model.axis;
      });
      if (isBaseAxisAndHasBarSeries_1) {
        var barWidthAndOffset = makeColumnLayout(barSeriesModels);
        var adjustedScale = adjustScaleForOverflow(min3, max3, model, barWidthAndOffset);
        min3 = adjustedScale.min;
        max3 = adjustedScale.max;
      }
    }
    return {
      extent: [min3, max3],
      fixMin: rawExtentResult.minFixed,
      fixMax: rawExtentResult.maxFixed
    };
  }
  function adjustScaleForOverflow(min3, max3, model, barWidthAndOffset) {
    var axisExtent = model.axis.getExtent();
    var axisLength = axisExtent[1] - axisExtent[0];
    var barsOnCurrentAxis = retrieveColumnLayout(barWidthAndOffset, model.axis);
    if (barsOnCurrentAxis === void 0) {
      return {
        min: min3,
        max: max3
      };
    }
    var minOverflow = Infinity;
    each(barsOnCurrentAxis, function(item) {
      minOverflow = Math.min(item.offset, minOverflow);
    });
    var maxOverflow = -Infinity;
    each(barsOnCurrentAxis, function(item) {
      maxOverflow = Math.max(item.offset + item.width, maxOverflow);
    });
    minOverflow = Math.abs(minOverflow);
    maxOverflow = Math.abs(maxOverflow);
    var totalOverFlow = minOverflow + maxOverflow;
    var oldRange = max3 - min3;
    var oldRangePercentOfNew = 1 - (minOverflow + maxOverflow) / axisLength;
    var overflowBuffer = oldRange / oldRangePercentOfNew - oldRange;
    max3 += overflowBuffer * (maxOverflow / totalOverFlow);
    min3 -= overflowBuffer * (minOverflow / totalOverFlow);
    return {
      min: min3,
      max: max3
    };
  }
  function niceScaleExtent(scale4, inModel) {
    var model = inModel;
    var extentInfo = getScaleExtent(scale4, model);
    var extent3 = extentInfo.extent;
    var splitNumber = model.get("splitNumber");
    if (scale4 instanceof Log_default) {
      scale4.base = model.get("logBase");
    }
    var scaleType = scale4.type;
    var interval = model.get("interval");
    var isIntervalOrTime = scaleType === "interval" || scaleType === "time";
    scale4.setExtent(extent3[0], extent3[1]);
    scale4.calcNiceExtent({
      splitNumber,
      fixMin: extentInfo.fixMin,
      fixMax: extentInfo.fixMax,
      minInterval: isIntervalOrTime ? model.get("minInterval") : null,
      maxInterval: isIntervalOrTime ? model.get("maxInterval") : null
    });
    if (interval != null) {
      scale4.setInterval && scale4.setInterval(interval);
    }
  }
  function createScaleByModel(model, axisType) {
    axisType = axisType || model.get("type");
    if (axisType) {
      switch (axisType) {
        case "category":
          return new Ordinal_default({
            ordinalMeta: model.getOrdinalMeta ? model.getOrdinalMeta() : model.getCategories(),
            extent: [Infinity, -Infinity]
          });
        case "time":
          return new Time_default({
            locale: model.ecModel.getLocaleModel(),
            useUTC: model.ecModel.get("useUTC")
          });
        default:
          return new (Scale_default.getClass(axisType) || Interval_default)();
      }
    }
  }
  function ifAxisCrossZero(axis) {
    var dataExtent = axis.scale.getExtent();
    var min3 = dataExtent[0];
    var max3 = dataExtent[1];
    return !(min3 > 0 && max3 > 0 || min3 < 0 && max3 < 0);
  }
  function makeLabelFormatter(axis) {
    var labelFormatter = axis.getLabelModel().get("formatter");
    var categoryTickStart = axis.type === "category" ? axis.scale.getExtent()[0] : null;
    if (axis.scale.type === "time") {
      return function(tpl) {
        return function(tick, idx) {
          return axis.scale.getFormattedLabel(tick, idx, tpl);
        };
      }(labelFormatter);
    } else if (isString(labelFormatter)) {
      return function(tpl) {
        return function(tick) {
          var label = axis.scale.getLabel(tick);
          var text = tpl.replace("{value}", label != null ? label : "");
          return text;
        };
      }(labelFormatter);
    } else if (isFunction(labelFormatter)) {
      return function(cb) {
        return function(tick, idx) {
          if (categoryTickStart != null) {
            idx = tick.value - categoryTickStart;
          }
          return cb(getAxisRawValue(axis, tick), idx, tick.level != null ? {
            level: tick.level
          } : null);
        };
      }(labelFormatter);
    } else {
      return function(tick) {
        return axis.scale.getLabel(tick);
      };
    }
  }
  function getAxisRawValue(axis, tick) {
    return axis.type === "category" ? axis.scale.getLabel(tick) : tick.value;
  }
  function estimateLabelUnionRect(axis) {
    var axisModel = axis.model;
    var scale4 = axis.scale;
    if (!axisModel.get(["axisLabel", "show"]) || scale4.isBlank()) {
      return;
    }
    var realNumberScaleTicks;
    var tickCount;
    var categoryScaleExtent = scale4.getExtent();
    if (scale4 instanceof Ordinal_default) {
      tickCount = scale4.count();
    } else {
      realNumberScaleTicks = scale4.getTicks();
      tickCount = realNumberScaleTicks.length;
    }
    var axisLabelModel = axis.getLabelModel();
    var labelFormatter = makeLabelFormatter(axis);
    var rect;
    var step = 1;
    if (tickCount > 40) {
      step = Math.ceil(tickCount / 40);
    }
    for (var i = 0; i < tickCount; i += step) {
      var tick = realNumberScaleTicks ? realNumberScaleTicks[i] : {
        value: categoryScaleExtent[0] + i
      };
      var label = labelFormatter(tick, i);
      var unrotatedSingleRect = axisLabelModel.getTextRect(label);
      var singleRect = rotateTextRect(unrotatedSingleRect, axisLabelModel.get("rotate") || 0);
      rect ? rect.union(singleRect) : rect = singleRect;
    }
    return rect;
  }
  function rotateTextRect(textRect, rotate2) {
    var rotateRadians = rotate2 * Math.PI / 180;
    var beforeWidth = textRect.width;
    var beforeHeight = textRect.height;
    var afterWidth = beforeWidth * Math.abs(Math.cos(rotateRadians)) + Math.abs(beforeHeight * Math.sin(rotateRadians));
    var afterHeight = beforeWidth * Math.abs(Math.sin(rotateRadians)) + Math.abs(beforeHeight * Math.cos(rotateRadians));
    var rotatedRect = new BoundingRect_default(textRect.x, textRect.y, afterWidth, afterHeight);
    return rotatedRect;
  }
  function getOptionCategoryInterval(model) {
    var interval = model.get("interval");
    return interval == null ? "auto" : interval;
  }
  function shouldShowAllLabels(axis) {
    return axis.type === "category" && getOptionCategoryInterval(axis.getLabelModel()) === 0;
  }
  function getDataDimensionsOnAxis(data, axisDim) {
    var dataDimMap = {};
    each(data.mapDimensionsAll(axisDim), function(dataDim) {
      dataDimMap[getStackedDimension(data, dataDim)] = true;
    });
    return keys(dataDimMap);
  }
  function unionAxisExtentFromData(dataExtent, data, axisDim) {
    if (data) {
      each(getDataDimensionsOnAxis(data, axisDim), function(dim) {
        var seriesExtent = data.getApproximateExtent(dim);
        seriesExtent[0] < dataExtent[0] && (dataExtent[0] = seriesExtent[0]);
        seriesExtent[1] > dataExtent[1] && (dataExtent[1] = seriesExtent[1]);
      });
    }
  }

  // node_modules/echarts/lib/coord/axisModelCommonMixin.js
  var AxisModelCommonMixin = function() {
    function AxisModelCommonMixin2() {
    }
    AxisModelCommonMixin2.prototype.getNeedCrossZero = function() {
      var option = this.option;
      return !option.scale;
    };
    AxisModelCommonMixin2.prototype.getCoordSysModel = function() {
      return;
    };
    return AxisModelCommonMixin2;
  }();

  // node_modules/echarts/lib/export/api/helper.js
  function createList(seriesModel) {
    return createSeriesData_default(null, seriesModel);
  }
  var dataStack2 = {
    isDimensionStacked,
    enableDataStack,
    getStackedDimension
  };
  function createScale(dataExtent, option) {
    var axisModel = option;
    if (!(option instanceof Model_default)) {
      axisModel = new Model_default(option);
    }
    var scale4 = createScaleByModel(axisModel);
    scale4.setExtent(dataExtent[0], dataExtent[1]);
    niceScaleExtent(scale4, axisModel);
    return scale4;
  }
  function mixinAxisModelCommonMethods(Model2) {
    mixin(Model2, AxisModelCommonMixin);
  }
  function createTextStyle2(textStyleModel, opts) {
    opts = opts || {};
    return createTextStyle(textStyleModel, null, null, opts.state !== "normal");
  }

  // node_modules/zrender/lib/contain/polygon.js
  var EPSILON5 = 1e-8;
  function isAroundEqual2(a, b) {
    return Math.abs(a - b) < EPSILON5;
  }
  function contain3(points4, x, y) {
    var w = 0;
    var p = points4[0];
    if (!p) {
      return false;
    }
    for (var i = 1; i < points4.length; i++) {
      var p2 = points4[i];
      w += windingLine(p[0], p[1], p2[0], p2[1], x, y);
      p = p2;
    }
    var p0 = points4[0];
    if (!isAroundEqual2(p[0], p0[0]) || !isAroundEqual2(p[1], p0[1])) {
      w += windingLine(p[0], p[1], p0[0], p0[1], x, y);
    }
    return w !== 0;
  }

  // node_modules/echarts/lib/coord/geo/Region.js
  var TMP_TRANSFORM = [];
  function transformPoints(points4, transform2) {
    for (var p = 0; p < points4.length; p++) {
      applyTransform(points4[p], points4[p], transform2);
    }
  }
  function updateBBoxFromPoints(points4, min3, max3, projection) {
    for (var i = 0; i < points4.length; i++) {
      var p = points4[i];
      if (projection) {
        p = projection.project(p);
      }
      if (p && isFinite(p[0]) && isFinite(p[1])) {
        min(min3, min3, p);
        max(max3, max3, p);
      }
    }
  }
  function centroid(points4) {
    var signedArea = 0;
    var cx = 0;
    var cy = 0;
    var len2 = points4.length;
    var x0 = points4[len2 - 1][0];
    var y0 = points4[len2 - 1][1];
    for (var i = 0; i < len2; i++) {
      var x1 = points4[i][0];
      var y1 = points4[i][1];
      var a = x0 * y1 - x1 * y0;
      signedArea += a;
      cx += (x0 + x1) * a;
      cy += (y0 + y1) * a;
      x0 = x1;
      y0 = y1;
    }
    return signedArea ? [cx / signedArea / 3, cy / signedArea / 3, signedArea] : [points4[0][0] || 0, points4[0][1] || 0];
  }
  var Region = function() {
    function Region2(name) {
      this.name = name;
    }
    Region2.prototype.setCenter = function(center3) {
      this._center = center3;
    };
    Region2.prototype.getCenter = function() {
      var center3 = this._center;
      if (!center3) {
        center3 = this._center = this.calcCenter();
      }
      return center3;
    };
    return Region2;
  }();
  var GeoJSONPolygonGeometry = function() {
    function GeoJSONPolygonGeometry2(exterior, interiors) {
      this.type = "polygon";
      this.exterior = exterior;
      this.interiors = interiors;
    }
    return GeoJSONPolygonGeometry2;
  }();
  var GeoJSONLineStringGeometry = function() {
    function GeoJSONLineStringGeometry2(points4) {
      this.type = "linestring";
      this.points = points4;
    }
    return GeoJSONLineStringGeometry2;
  }();
  var GeoJSONRegion = function(_super) {
    __extends(GeoJSONRegion2, _super);
    function GeoJSONRegion2(name, geometries, cp) {
      var _this = _super.call(this, name) || this;
      _this.type = "geoJSON";
      _this.geometries = geometries;
      _this._center = cp && [cp[0], cp[1]];
      return _this;
    }
    GeoJSONRegion2.prototype.calcCenter = function() {
      var geometries = this.geometries;
      var largestGeo;
      var largestGeoSize = 0;
      for (var i = 0; i < geometries.length; i++) {
        var geo = geometries[i];
        var exterior = geo.exterior;
        var size = exterior && exterior.length;
        if (size > largestGeoSize) {
          largestGeo = geo;
          largestGeoSize = size;
        }
      }
      if (largestGeo) {
        return centroid(largestGeo.exterior);
      }
      var rect = this.getBoundingRect();
      return [rect.x + rect.width / 2, rect.y + rect.height / 2];
    };
    GeoJSONRegion2.prototype.getBoundingRect = function(projection) {
      var rect = this._rect;
      if (rect && !projection) {
        return rect;
      }
      var min3 = [Infinity, Infinity];
      var max3 = [-Infinity, -Infinity];
      var geometries = this.geometries;
      each(geometries, function(geo) {
        if (geo.type === "polygon") {
          updateBBoxFromPoints(geo.exterior, min3, max3, projection);
        } else {
          each(geo.points, function(points4) {
            updateBBoxFromPoints(points4, min3, max3, projection);
          });
        }
      });
      if (!(isFinite(min3[0]) && isFinite(min3[1]) && isFinite(max3[0]) && isFinite(max3[1]))) {
        min3[0] = min3[1] = max3[0] = max3[1] = 0;
      }
      rect = new BoundingRect_default(min3[0], min3[1], max3[0] - min3[0], max3[1] - min3[1]);
      if (!projection) {
        this._rect = rect;
      }
      return rect;
    };
    GeoJSONRegion2.prototype.contain = function(coord) {
      var rect = this.getBoundingRect();
      var geometries = this.geometries;
      if (!rect.contain(coord[0], coord[1])) {
        return false;
      }
      loopGeo:
        for (var i = 0, len2 = geometries.length; i < len2; i++) {
          var geo = geometries[i];
          if (geo.type !== "polygon") {
            continue;
          }
          var exterior = geo.exterior;
          var interiors = geo.interiors;
          if (contain3(exterior, coord[0], coord[1])) {
            for (var k = 0; k < (interiors ? interiors.length : 0); k++) {
              if (contain3(interiors[k], coord[0], coord[1])) {
                continue loopGeo;
              }
            }
            return true;
          }
        }
      return false;
    };
    GeoJSONRegion2.prototype.transformTo = function(x, y, width, height) {
      var rect = this.getBoundingRect();
      var aspect = rect.width / rect.height;
      if (!width) {
        width = aspect * height;
      } else if (!height) {
        height = width / aspect;
      }
      var target = new BoundingRect_default(x, y, width, height);
      var transform2 = rect.calculateTransform(target);
      var geometries = this.geometries;
      for (var i = 0; i < geometries.length; i++) {
        var geo = geometries[i];
        if (geo.type === "polygon") {
          transformPoints(geo.exterior, transform2);
          each(geo.interiors, function(interior) {
            transformPoints(interior, transform2);
          });
        } else {
          each(geo.points, function(points4) {
            transformPoints(points4, transform2);
          });
        }
      }
      rect = this._rect;
      rect.copy(target);
      this._center = [rect.x + rect.width / 2, rect.y + rect.height / 2];
    };
    GeoJSONRegion2.prototype.cloneShallow = function(name) {
      name == null && (name = this.name);
      var newRegion = new GeoJSONRegion2(name, this.geometries, this._center);
      newRegion._rect = this._rect;
      newRegion.transformTo = null;
      return newRegion;
    };
    return GeoJSONRegion2;
  }(Region);
  var GeoSVGRegion = function(_super) {
    __extends(GeoSVGRegion2, _super);
    function GeoSVGRegion2(name, elOnlyForCalculate) {
      var _this = _super.call(this, name) || this;
      _this.type = "geoSVG";
      _this._elOnlyForCalculate = elOnlyForCalculate;
      return _this;
    }
    GeoSVGRegion2.prototype.calcCenter = function() {
      var el = this._elOnlyForCalculate;
      var rect = el.getBoundingRect();
      var center3 = [rect.x + rect.width / 2, rect.y + rect.height / 2];
      var mat = identity(TMP_TRANSFORM);
      var target = el;
      while (target && !target.isGeoSVGGraphicRoot) {
        mul2(mat, target.getLocalTransform(), mat);
        target = target.parent;
      }
      invert(mat, mat);
      applyTransform(center3, center3, mat);
      return center3;
    };
    return GeoSVGRegion2;
  }(Region);

  // node_modules/echarts/lib/coord/geo/parseGeoJson.js
  function decode(json) {
    if (!json.UTF8Encoding) {
      return json;
    }
    var jsonCompressed = json;
    var encodeScale = jsonCompressed.UTF8Scale;
    if (encodeScale == null) {
      encodeScale = 1024;
    }
    var features2 = jsonCompressed.features;
    each(features2, function(feature) {
      var geometry = feature.geometry;
      var encodeOffsets = geometry.encodeOffsets;
      var coordinates = geometry.coordinates;
      if (!encodeOffsets) {
        return;
      }
      switch (geometry.type) {
        case "LineString":
          geometry.coordinates = decodeRing(coordinates, encodeOffsets, encodeScale);
          break;
        case "Polygon":
          decodeRings(coordinates, encodeOffsets, encodeScale);
          break;
        case "MultiLineString":
          decodeRings(coordinates, encodeOffsets, encodeScale);
          break;
        case "MultiPolygon":
          each(coordinates, function(rings, idx) {
            return decodeRings(rings, encodeOffsets[idx], encodeScale);
          });
      }
    });
    jsonCompressed.UTF8Encoding = false;
    return jsonCompressed;
  }
  function decodeRings(rings, encodeOffsets, encodeScale) {
    for (var c = 0; c < rings.length; c++) {
      rings[c] = decodeRing(rings[c], encodeOffsets[c], encodeScale);
    }
  }
  function decodeRing(coordinate, encodeOffsets, encodeScale) {
    var result = [];
    var prevX = encodeOffsets[0];
    var prevY = encodeOffsets[1];
    for (var i = 0; i < coordinate.length; i += 2) {
      var x = coordinate.charCodeAt(i) - 64;
      var y = coordinate.charCodeAt(i + 1) - 64;
      x = x >> 1 ^ -(x & 1);
      y = y >> 1 ^ -(y & 1);
      x += prevX;
      y += prevY;
      prevX = x;
      prevY = y;
      result.push([x / encodeScale, y / encodeScale]);
    }
    return result;
  }
  function parseGeoJSON(geoJson, nameProperty) {
    geoJson = decode(geoJson);
    return map(filter(geoJson.features, function(featureObj) {
      return featureObj.geometry && featureObj.properties && featureObj.geometry.coordinates.length > 0;
    }), function(featureObj) {
      var properties = featureObj.properties;
      var geo = featureObj.geometry;
      var geometries = [];
      switch (geo.type) {
        case "Polygon":
          var coordinates = geo.coordinates;
          geometries.push(new GeoJSONPolygonGeometry(coordinates[0], coordinates.slice(1)));
          break;
        case "MultiPolygon":
          each(geo.coordinates, function(item) {
            if (item[0]) {
              geometries.push(new GeoJSONPolygonGeometry(item[0], item.slice(1)));
            }
          });
          break;
        case "LineString":
          geometries.push(new GeoJSONLineStringGeometry([geo.coordinates]));
          break;
        case "MultiLineString":
          geometries.push(new GeoJSONLineStringGeometry(geo.coordinates));
      }
      var region = new GeoJSONRegion(properties[nameProperty || "name"], geometries, properties.cp);
      region.properties = properties;
      return region;
    });
  }

  // node_modules/echarts/lib/export/api/number.js
  var number_exports2 = {};
  __export(number_exports2, {
    MAX_SAFE_INTEGER: () => MAX_SAFE_INTEGER,
    asc: () => asc,
    getPercentWithPrecision: () => getPercentWithPrecision,
    getPixelPrecision: () => getPixelPrecision,
    getPrecision: () => getPrecision,
    getPrecisionSafe: () => getPrecisionSafe,
    isNumeric: () => isNumeric,
    isRadianAroundZero: () => isRadianAroundZero,
    linearMap: () => linearMap,
    nice: () => nice,
    numericToNumber: () => numericToNumber,
    parseDate: () => parseDate,
    quantile: () => quantile,
    quantity: () => quantity,
    quantityExponent: () => quantityExponent,
    reformIntervals: () => reformIntervals,
    remRadian: () => remRadian,
    round: () => round
  });

  // node_modules/echarts/lib/export/api/time.js
  var time_exports = {};
  __export(time_exports, {
    format: () => format,
    parse: () => parseDate
  });

  // node_modules/echarts/lib/export/api/graphic.js
  var graphic_exports2 = {};
  __export(graphic_exports2, {
    Arc: () => Arc_default,
    BezierCurve: () => BezierCurve_default,
    BoundingRect: () => BoundingRect_default,
    Circle: () => Circle_default,
    CompoundPath: () => CompoundPath_default,
    Ellipse: () => Ellipse_default,
    Group: () => Group_default,
    Image: () => Image_default,
    IncrementalDisplayable: () => IncrementalDisplayable_default,
    Line: () => Line_default,
    LinearGradient: () => LinearGradient_default,
    Polygon: () => Polygon_default,
    Polyline: () => Polyline_default,
    RadialGradient: () => RadialGradient_default,
    Rect: () => Rect_default,
    Ring: () => Ring_default,
    Sector: () => Sector_default,
    Text: () => Text_default,
    clipPointsByRect: () => clipPointsByRect,
    clipRectByRect: () => clipRectByRect,
    createIcon: () => createIcon,
    extendPath: () => extendPath,
    extendShape: () => extendShape,
    getShapeClass: () => getShapeClass,
    getTransform: () => getTransform,
    initProps: () => initProps,
    makeImage: () => makeImage,
    makePath: () => makePath,
    mergePath: () => mergePath2,
    registerShape: () => registerShape,
    resizePath: () => resizePath,
    updateProps: () => updateProps
  });

  // node_modules/echarts/lib/export/api/format.js
  var format_exports2 = {};
  __export(format_exports2, {
    addCommas: () => addCommas,
    capitalFirst: () => capitalFirst,
    encodeHTML: () => encodeHTML,
    formatTime: () => formatTime,
    formatTpl: () => formatTpl,
    getTextRect: () => getTextRect,
    getTooltipMarker: () => getTooltipMarker,
    normalizeCssArray: () => normalizeCssArray2,
    toCamelCase: () => toCamelCase,
    truncateText: () => truncateText
  });

  // node_modules/echarts/lib/export/api/util.js
  var util_exports2 = {};
  __export(util_exports2, {
    bind: () => bind,
    clone: () => clone,
    curry: () => curry,
    defaults: () => defaults,
    each: () => each,
    extend: () => extend,
    filter: () => filter,
    indexOf: () => indexOf,
    inherits: () => inherits,
    isArray: () => isArray,
    isFunction: () => isFunction,
    isObject: () => isObject,
    isString: () => isString,
    map: () => map,
    merge: () => merge,
    reduce: () => reduce
  });

  // node_modules/echarts/lib/coord/axisTickLabelBuilder.js
  var inner6 = makeInner();
  function createAxisLabels(axis) {
    return axis.type === "category" ? makeCategoryLabels(axis) : makeRealNumberLabels(axis);
  }
  function createAxisTicks(axis, tickModel) {
    return axis.type === "category" ? makeCategoryTicks(axis, tickModel) : {
      ticks: map(axis.scale.getTicks(), function(tick) {
        return tick.value;
      })
    };
  }
  function makeCategoryLabels(axis) {
    var labelModel = axis.getLabelModel();
    var result = makeCategoryLabelsActually(axis, labelModel);
    return !labelModel.get("show") || axis.scale.isBlank() ? {
      labels: [],
      labelCategoryInterval: result.labelCategoryInterval
    } : result;
  }
  function makeCategoryLabelsActually(axis, labelModel) {
    var labelsCache = getListCache(axis, "labels");
    var optionLabelInterval = getOptionCategoryInterval(labelModel);
    var result = listCacheGet(labelsCache, optionLabelInterval);
    if (result) {
      return result;
    }
    var labels;
    var numericLabelInterval;
    if (isFunction(optionLabelInterval)) {
      labels = makeLabelsByCustomizedCategoryInterval(axis, optionLabelInterval);
    } else {
      numericLabelInterval = optionLabelInterval === "auto" ? makeAutoCategoryInterval(axis) : optionLabelInterval;
      labels = makeLabelsByNumericCategoryInterval(axis, numericLabelInterval);
    }
    return listCacheSet(labelsCache, optionLabelInterval, {
      labels,
      labelCategoryInterval: numericLabelInterval
    });
  }
  function makeCategoryTicks(axis, tickModel) {
    var ticksCache = getListCache(axis, "ticks");
    var optionTickInterval = getOptionCategoryInterval(tickModel);
    var result = listCacheGet(ticksCache, optionTickInterval);
    if (result) {
      return result;
    }
    var ticks;
    var tickCategoryInterval;
    if (!tickModel.get("show") || axis.scale.isBlank()) {
      ticks = [];
    }
    if (isFunction(optionTickInterval)) {
      ticks = makeLabelsByCustomizedCategoryInterval(axis, optionTickInterval, true);
    } else if (optionTickInterval === "auto") {
      var labelsResult = makeCategoryLabelsActually(axis, axis.getLabelModel());
      tickCategoryInterval = labelsResult.labelCategoryInterval;
      ticks = map(labelsResult.labels, function(labelItem) {
        return labelItem.tickValue;
      });
    } else {
      tickCategoryInterval = optionTickInterval;
      ticks = makeLabelsByNumericCategoryInterval(axis, tickCategoryInterval, true);
    }
    return listCacheSet(ticksCache, optionTickInterval, {
      ticks,
      tickCategoryInterval
    });
  }
  function makeRealNumberLabels(axis) {
    var ticks = axis.scale.getTicks();
    var labelFormatter = makeLabelFormatter(axis);
    return {
      labels: map(ticks, function(tick, idx) {
        return {
          level: tick.level,
          formattedLabel: labelFormatter(tick, idx),
          rawLabel: axis.scale.getLabel(tick),
          tickValue: tick.value
        };
      })
    };
  }
  function getListCache(axis, prop) {
    return inner6(axis)[prop] || (inner6(axis)[prop] = []);
  }
  function listCacheGet(cache, key) {
    for (var i = 0; i < cache.length; i++) {
      if (cache[i].key === key) {
        return cache[i].value;
      }
    }
  }
  function listCacheSet(cache, key, value) {
    cache.push({
      key,
      value
    });
    return value;
  }
  function makeAutoCategoryInterval(axis) {
    var result = inner6(axis).autoInterval;
    return result != null ? result : inner6(axis).autoInterval = axis.calculateCategoryInterval();
  }
  function calculateCategoryInterval(axis) {
    var params = fetchAutoCategoryIntervalCalculationParams(axis);
    var labelFormatter = makeLabelFormatter(axis);
    var rotation = (params.axisRotate - params.labelRotate) / 180 * Math.PI;
    var ordinalScale = axis.scale;
    var ordinalExtent = ordinalScale.getExtent();
    var tickCount = ordinalScale.count();
    if (ordinalExtent[1] - ordinalExtent[0] < 1) {
      return 0;
    }
    var step = 1;
    if (tickCount > 40) {
      step = Math.max(1, Math.floor(tickCount / 40));
    }
    var tickValue = ordinalExtent[0];
    var unitSpan = axis.dataToCoord(tickValue + 1) - axis.dataToCoord(tickValue);
    var unitW = Math.abs(unitSpan * Math.cos(rotation));
    var unitH = Math.abs(unitSpan * Math.sin(rotation));
    var maxW = 0;
    var maxH = 0;
    for (; tickValue <= ordinalExtent[1]; tickValue += step) {
      var width = 0;
      var height = 0;
      var rect = getBoundingRect(labelFormatter({
        value: tickValue
      }), params.font, "center", "top");
      width = rect.width * 1.3;
      height = rect.height * 1.3;
      maxW = Math.max(maxW, width, 7);
      maxH = Math.max(maxH, height, 7);
    }
    var dw = maxW / unitW;
    var dh = maxH / unitH;
    isNaN(dw) && (dw = Infinity);
    isNaN(dh) && (dh = Infinity);
    var interval = Math.max(0, Math.floor(Math.min(dw, dh)));
    var cache = inner6(axis.model);
    var axisExtent = axis.getExtent();
    var lastAutoInterval = cache.lastAutoInterval;
    var lastTickCount = cache.lastTickCount;
    if (lastAutoInterval != null && lastTickCount != null && Math.abs(lastAutoInterval - interval) <= 1 && Math.abs(lastTickCount - tickCount) <= 1 && lastAutoInterval > interval && cache.axisExtent0 === axisExtent[0] && cache.axisExtent1 === axisExtent[1]) {
      interval = lastAutoInterval;
    } else {
      cache.lastTickCount = tickCount;
      cache.lastAutoInterval = interval;
      cache.axisExtent0 = axisExtent[0];
      cache.axisExtent1 = axisExtent[1];
    }
    return interval;
  }
  function fetchAutoCategoryIntervalCalculationParams(axis) {
    var labelModel = axis.getLabelModel();
    return {
      axisRotate: axis.getRotate ? axis.getRotate() : axis.isHorizontal && !axis.isHorizontal() ? 90 : 0,
      labelRotate: labelModel.get("rotate") || 0,
      font: labelModel.getFont()
    };
  }
  function makeLabelsByNumericCategoryInterval(axis, categoryInterval, onlyTick) {
    var labelFormatter = makeLabelFormatter(axis);
    var ordinalScale = axis.scale;
    var ordinalExtent = ordinalScale.getExtent();
    var labelModel = axis.getLabelModel();
    var result = [];
    var step = Math.max((categoryInterval || 0) + 1, 1);
    var startTick = ordinalExtent[0];
    var tickCount = ordinalScale.count();
    if (startTick !== 0 && step > 1 && tickCount / step > 2) {
      startTick = Math.round(Math.ceil(startTick / step) * step);
    }
    var showAllLabel = shouldShowAllLabels(axis);
    var includeMinLabel = labelModel.get("showMinLabel") || showAllLabel;
    var includeMaxLabel = labelModel.get("showMaxLabel") || showAllLabel;
    if (includeMinLabel && startTick !== ordinalExtent[0]) {
      addItem(ordinalExtent[0]);
    }
    var tickValue = startTick;
    for (; tickValue <= ordinalExtent[1]; tickValue += step) {
      addItem(tickValue);
    }
    if (includeMaxLabel && tickValue - step !== ordinalExtent[1]) {
      addItem(ordinalExtent[1]);
    }
    function addItem(tickValue2) {
      var tickObj = {
        value: tickValue2
      };
      result.push(onlyTick ? tickValue2 : {
        formattedLabel: labelFormatter(tickObj),
        rawLabel: ordinalScale.getLabel(tickObj),
        tickValue: tickValue2
      });
    }
    return result;
  }
  function makeLabelsByCustomizedCategoryInterval(axis, categoryInterval, onlyTick) {
    var ordinalScale = axis.scale;
    var labelFormatter = makeLabelFormatter(axis);
    var result = [];
    each(ordinalScale.getTicks(), function(tick) {
      var rawLabel = ordinalScale.getLabel(tick);
      var tickValue = tick.value;
      if (categoryInterval(tick.value, rawLabel)) {
        result.push(onlyTick ? tickValue : {
          formattedLabel: labelFormatter(tick),
          rawLabel,
          tickValue
        });
      }
    });
    return result;
  }

  // node_modules/echarts/lib/coord/Axis.js
  var NORMALIZED_EXTENT = [0, 1];
  var Axis = function() {
    function Axis2(dim, scale4, extent3) {
      this.onBand = false;
      this.inverse = false;
      this.dim = dim;
      this.scale = scale4;
      this._extent = extent3 || [0, 0];
    }
    Axis2.prototype.contain = function(coord) {
      var extent3 = this._extent;
      var min3 = Math.min(extent3[0], extent3[1]);
      var max3 = Math.max(extent3[0], extent3[1]);
      return coord >= min3 && coord <= max3;
    };
    Axis2.prototype.containData = function(data) {
      return this.scale.contain(data);
    };
    Axis2.prototype.getExtent = function() {
      return this._extent.slice();
    };
    Axis2.prototype.getPixelPrecision = function(dataExtent) {
      return getPixelPrecision(dataExtent || this.scale.getExtent(), this._extent);
    };
    Axis2.prototype.setExtent = function(start2, end2) {
      var extent3 = this._extent;
      extent3[0] = start2;
      extent3[1] = end2;
    };
    Axis2.prototype.dataToCoord = function(data, clamp2) {
      var extent3 = this._extent;
      var scale4 = this.scale;
      data = scale4.normalize(data);
      if (this.onBand && scale4.type === "ordinal") {
        extent3 = extent3.slice();
        fixExtentWithBands(extent3, scale4.count());
      }
      return linearMap(data, NORMALIZED_EXTENT, extent3, clamp2);
    };
    Axis2.prototype.coordToData = function(coord, clamp2) {
      var extent3 = this._extent;
      var scale4 = this.scale;
      if (this.onBand && scale4.type === "ordinal") {
        extent3 = extent3.slice();
        fixExtentWithBands(extent3, scale4.count());
      }
      var t = linearMap(coord, extent3, NORMALIZED_EXTENT, clamp2);
      return this.scale.scale(t);
    };
    Axis2.prototype.pointToData = function(point, clamp2) {
      return;
    };
    Axis2.prototype.getTicksCoords = function(opt) {
      opt = opt || {};
      var tickModel = opt.tickModel || this.getTickModel();
      var result = createAxisTicks(this, tickModel);
      var ticks = result.ticks;
      var ticksCoords = map(ticks, function(tickVal) {
        return {
          coord: this.dataToCoord(this.scale.type === "ordinal" ? this.scale.getRawOrdinalNumber(tickVal) : tickVal),
          tickValue: tickVal
        };
      }, this);
      var alignWithLabel = tickModel.get("alignWithLabel");
      fixOnBandTicksCoords(this, ticksCoords, alignWithLabel, opt.clamp);
      return ticksCoords;
    };
    Axis2.prototype.getMinorTicksCoords = function() {
      if (this.scale.type === "ordinal") {
        return [];
      }
      var minorTickModel = this.model.getModel("minorTick");
      var splitNumber = minorTickModel.get("splitNumber");
      if (!(splitNumber > 0 && splitNumber < 100)) {
        splitNumber = 5;
      }
      var minorTicks = this.scale.getMinorTicks(splitNumber);
      var minorTicksCoords = map(minorTicks, function(minorTicksGroup) {
        return map(minorTicksGroup, function(minorTick) {
          return {
            coord: this.dataToCoord(minorTick),
            tickValue: minorTick
          };
        }, this);
      }, this);
      return minorTicksCoords;
    };
    Axis2.prototype.getViewLabels = function() {
      return createAxisLabels(this).labels;
    };
    Axis2.prototype.getLabelModel = function() {
      return this.model.getModel("axisLabel");
    };
    Axis2.prototype.getTickModel = function() {
      return this.model.getModel("axisTick");
    };
    Axis2.prototype.getBandWidth = function() {
      var axisExtent = this._extent;
      var dataExtent = this.scale.getExtent();
      var len2 = dataExtent[1] - dataExtent[0] + (this.onBand ? 1 : 0);
      len2 === 0 && (len2 = 1);
      var size = Math.abs(axisExtent[1] - axisExtent[0]);
      return Math.abs(size) / len2;
    };
    Axis2.prototype.calculateCategoryInterval = function() {
      return calculateCategoryInterval(this);
    };
    return Axis2;
  }();
  function fixExtentWithBands(extent3, nTick) {
    var size = extent3[1] - extent3[0];
    var len2 = nTick;
    var margin = size / len2 / 2;
    extent3[0] += margin;
    extent3[1] -= margin;
  }
  function fixOnBandTicksCoords(axis, ticksCoords, alignWithLabel, clamp2) {
    var ticksLen = ticksCoords.length;
    if (!axis.onBand || alignWithLabel || !ticksLen) {
      return;
    }
    var axisExtent = axis.getExtent();
    var last;
    var diffSize;
    if (ticksLen === 1) {
      ticksCoords[0].coord = axisExtent[0];
      last = ticksCoords[1] = {
        coord: axisExtent[0]
      };
    } else {
      var crossLen = ticksCoords[ticksLen - 1].tickValue - ticksCoords[0].tickValue;
      var shift_1 = (ticksCoords[ticksLen - 1].coord - ticksCoords[0].coord) / crossLen;
      each(ticksCoords, function(ticksItem) {
        ticksItem.coord -= shift_1 / 2;
      });
      var dataExtent = axis.scale.getExtent();
      diffSize = 1 + dataExtent[1] - ticksCoords[ticksLen - 1].tickValue;
      last = {
        coord: ticksCoords[ticksLen - 1].coord + shift_1 * diffSize
      };
      ticksCoords.push(last);
    }
    var inverse = axisExtent[0] > axisExtent[1];
    if (littleThan2(ticksCoords[0].coord, axisExtent[0])) {
      clamp2 ? ticksCoords[0].coord = axisExtent[0] : ticksCoords.shift();
    }
    if (clamp2 && littleThan2(axisExtent[0], ticksCoords[0].coord)) {
      ticksCoords.unshift({
        coord: axisExtent[0]
      });
    }
    if (littleThan2(axisExtent[1], last.coord)) {
      clamp2 ? last.coord = axisExtent[1] : ticksCoords.pop();
    }
    if (clamp2 && littleThan2(last.coord, axisExtent[1])) {
      ticksCoords.push({
        coord: axisExtent[1]
      });
    }
    function littleThan2(a, b) {
      a = round(a);
      b = round(b);
      return inverse ? a > b : a < b;
    }
  }
  var Axis_default = Axis;

  // node_modules/echarts/lib/export/api.js
  function extendComponentModel(proto2) {
    var Model2 = Component_default.extend(proto2);
    Component_default.registerClass(Model2);
    return Model2;
  }
  function extendComponentView(proto2) {
    var View2 = Component_default2.extend(proto2);
    Component_default2.registerClass(View2);
    return View2;
  }
  function extendSeriesModel(proto2) {
    var Model2 = Series_default.extend(proto2);
    Series_default.registerClass(Model2);
    return Model2;
  }
  function extendChartView(proto2) {
    var View2 = Chart_default.extend(proto2);
    Chart_default.registerClass(View2);
    return View2;
  }

  // node_modules/echarts/lib/label/labelGuideHelper.js
  var PI27 = Math.PI * 2;
  var CMD4 = PathProxy_default.CMD;
  var DEFAULT_SEARCH_SPACE = ["top", "right", "bottom", "left"];
  function getCandidateAnchor(pos, distance2, rect, outPt, outDir) {
    var width = rect.width;
    var height = rect.height;
    switch (pos) {
      case "top":
        outPt.set(rect.x + width / 2, rect.y - distance2);
        outDir.set(0, -1);
        break;
      case "bottom":
        outPt.set(rect.x + width / 2, rect.y + height + distance2);
        outDir.set(0, 1);
        break;
      case "left":
        outPt.set(rect.x - distance2, rect.y + height / 2);
        outDir.set(-1, 0);
        break;
      case "right":
        outPt.set(rect.x + width + distance2, rect.y + height / 2);
        outDir.set(1, 0);
        break;
    }
  }
  function projectPointToArc(cx, cy, r, startAngle, endAngle, anticlockwise, x, y, out2) {
    x -= cx;
    y -= cy;
    var d = Math.sqrt(x * x + y * y);
    x /= d;
    y /= d;
    var ox = x * r + cx;
    var oy = y * r + cy;
    if (Math.abs(startAngle - endAngle) % PI27 < 1e-4) {
      out2[0] = ox;
      out2[1] = oy;
      return d - r;
    }
    if (anticlockwise) {
      var tmp = startAngle;
      startAngle = normalizeRadian(endAngle);
      endAngle = normalizeRadian(tmp);
    } else {
      startAngle = normalizeRadian(startAngle);
      endAngle = normalizeRadian(endAngle);
    }
    if (startAngle > endAngle) {
      endAngle += PI27;
    }
    var angle = Math.atan2(y, x);
    if (angle < 0) {
      angle += PI27;
    }
    if (angle >= startAngle && angle <= endAngle || angle + PI27 >= startAngle && angle + PI27 <= endAngle) {
      out2[0] = ox;
      out2[1] = oy;
      return d - r;
    }
    var x1 = r * Math.cos(startAngle) + cx;
    var y1 = r * Math.sin(startAngle) + cy;
    var x2 = r * Math.cos(endAngle) + cx;
    var y2 = r * Math.sin(endAngle) + cy;
    var d1 = (x1 - x) * (x1 - x) + (y1 - y) * (y1 - y);
    var d2 = (x2 - x) * (x2 - x) + (y2 - y) * (y2 - y);
    if (d1 < d2) {
      out2[0] = x1;
      out2[1] = y1;
      return Math.sqrt(d1);
    } else {
      out2[0] = x2;
      out2[1] = y2;
      return Math.sqrt(d2);
    }
  }
  function projectPointToLine(x1, y1, x2, y2, x, y, out2, limitToEnds) {
    var dx = x - x1;
    var dy = y - y1;
    var dx1 = x2 - x1;
    var dy1 = y2 - y1;
    var lineLen = Math.sqrt(dx1 * dx1 + dy1 * dy1);
    dx1 /= lineLen;
    dy1 /= lineLen;
    var projectedLen = dx * dx1 + dy * dy1;
    var t = projectedLen / lineLen;
    if (limitToEnds) {
      t = Math.min(Math.max(t, 0), 1);
    }
    t *= lineLen;
    var ox = out2[0] = x1 + t * dx1;
    var oy = out2[1] = y1 + t * dy1;
    return Math.sqrt((ox - x) * (ox - x) + (oy - y) * (oy - y));
  }
  function projectPointToRect(x1, y1, width, height, x, y, out2) {
    if (width < 0) {
      x1 = x1 + width;
      width = -width;
    }
    if (height < 0) {
      y1 = y1 + height;
      height = -height;
    }
    var x2 = x1 + width;
    var y2 = y1 + height;
    var ox = out2[0] = Math.min(Math.max(x, x1), x2);
    var oy = out2[1] = Math.min(Math.max(y, y1), y2);
    return Math.sqrt((ox - x) * (ox - x) + (oy - y) * (oy - y));
  }
  var tmpPt = [];
  function nearestPointOnRect(pt, rect, out2) {
    var dist3 = projectPointToRect(rect.x, rect.y, rect.width, rect.height, pt.x, pt.y, tmpPt);
    out2.set(tmpPt[0], tmpPt[1]);
    return dist3;
  }
  function nearestPointOnPath(pt, path, out2) {
    var xi = 0;
    var yi = 0;
    var x0 = 0;
    var y0 = 0;
    var x1;
    var y1;
    var minDist = Infinity;
    var data = path.data;
    var x = pt.x;
    var y = pt.y;
    for (var i = 0; i < data.length; ) {
      var cmd = data[i++];
      if (i === 1) {
        xi = data[i];
        yi = data[i + 1];
        x0 = xi;
        y0 = yi;
      }
      var d = minDist;
      switch (cmd) {
        case CMD4.M:
          x0 = data[i++];
          y0 = data[i++];
          xi = x0;
          yi = y0;
          break;
        case CMD4.L:
          d = projectPointToLine(xi, yi, data[i], data[i + 1], x, y, tmpPt, true);
          xi = data[i++];
          yi = data[i++];
          break;
        case CMD4.C:
          d = cubicProjectPoint(xi, yi, data[i++], data[i++], data[i++], data[i++], data[i], data[i + 1], x, y, tmpPt);
          xi = data[i++];
          yi = data[i++];
          break;
        case CMD4.Q:
          d = quadraticProjectPoint(xi, yi, data[i++], data[i++], data[i], data[i + 1], x, y, tmpPt);
          xi = data[i++];
          yi = data[i++];
          break;
        case CMD4.A:
          var cx = data[i++];
          var cy = data[i++];
          var rx = data[i++];
          var ry = data[i++];
          var theta = data[i++];
          var dTheta = data[i++];
          i += 1;
          var anticlockwise = !!(1 - data[i++]);
          x1 = Math.cos(theta) * rx + cx;
          y1 = Math.sin(theta) * ry + cy;
          if (i <= 1) {
            x0 = x1;
            y0 = y1;
          }
          var _x = (x - cx) * ry / rx + cx;
          d = projectPointToArc(cx, cy, ry, theta, theta + dTheta, anticlockwise, _x, y, tmpPt);
          xi = Math.cos(theta + dTheta) * rx + cx;
          yi = Math.sin(theta + dTheta) * ry + cy;
          break;
        case CMD4.R:
          x0 = xi = data[i++];
          y0 = yi = data[i++];
          var width = data[i++];
          var height = data[i++];
          d = projectPointToRect(x0, y0, width, height, x, y, tmpPt);
          break;
        case CMD4.Z:
          d = projectPointToLine(xi, yi, x0, y0, x, y, tmpPt, true);
          xi = x0;
          yi = y0;
          break;
      }
      if (d < minDist) {
        minDist = d;
        out2.set(tmpPt[0], tmpPt[1]);
      }
    }
    return minDist;
  }
  var pt0 = new Point_default();
  var pt1 = new Point_default();
  var pt2 = new Point_default();
  var dir = new Point_default();
  var dir2 = new Point_default();
  function updateLabelLinePoints(target, labelLineModel) {
    if (!target) {
      return;
    }
    var labelLine = target.getTextGuideLine();
    var label = target.getTextContent();
    if (!(label && labelLine)) {
      return;
    }
    var labelGuideConfig = target.textGuideLineConfig || {};
    var points4 = [[0, 0], [0, 0], [0, 0]];
    var searchSpace = labelGuideConfig.candidates || DEFAULT_SEARCH_SPACE;
    var labelRect = label.getBoundingRect().clone();
    labelRect.applyTransform(label.getComputedTransform());
    var minDist = Infinity;
    var anchorPoint = labelGuideConfig.anchor;
    var targetTransform = target.getComputedTransform();
    var targetInversedTransform = targetTransform && invert([], targetTransform);
    var len2 = labelLineModel.get("length2") || 0;
    if (anchorPoint) {
      pt2.copy(anchorPoint);
    }
    for (var i = 0; i < searchSpace.length; i++) {
      var candidate = searchSpace[i];
      getCandidateAnchor(candidate, 0, labelRect, pt0, dir);
      Point_default.scaleAndAdd(pt1, pt0, dir, len2);
      pt1.transform(targetInversedTransform);
      var boundingRect = target.getBoundingRect();
      var dist3 = anchorPoint ? anchorPoint.distance(pt1) : target instanceof Path_default ? nearestPointOnPath(pt1, target.path, pt2) : nearestPointOnRect(pt1, boundingRect, pt2);
      if (dist3 < minDist) {
        minDist = dist3;
        pt1.transform(targetTransform);
        pt2.transform(targetTransform);
        pt2.toArray(points4[0]);
        pt1.toArray(points4[1]);
        pt0.toArray(points4[2]);
      }
    }
    limitTurnAngle(points4, labelLineModel.get("minTurnAngle"));
    labelLine.setShape({
      points: points4
    });
  }
  var tmpArr = [];
  var tmpProjPoint = new Point_default();
  function limitTurnAngle(linePoints, minTurnAngle) {
    if (!(minTurnAngle <= 180 && minTurnAngle > 0)) {
      return;
    }
    minTurnAngle = minTurnAngle / 180 * Math.PI;
    pt0.fromArray(linePoints[0]);
    pt1.fromArray(linePoints[1]);
    pt2.fromArray(linePoints[2]);
    Point_default.sub(dir, pt0, pt1);
    Point_default.sub(dir2, pt2, pt1);
    var len1 = dir.len();
    var len2 = dir2.len();
    if (len1 < 1e-3 || len2 < 1e-3) {
      return;
    }
    dir.scale(1 / len1);
    dir2.scale(1 / len2);
    var angleCos = dir.dot(dir2);
    var minTurnAngleCos = Math.cos(minTurnAngle);
    if (minTurnAngleCos < angleCos) {
      var d = projectPointToLine(pt1.x, pt1.y, pt2.x, pt2.y, pt0.x, pt0.y, tmpArr, false);
      tmpProjPoint.fromArray(tmpArr);
      tmpProjPoint.scaleAndAdd(dir2, d / Math.tan(Math.PI - minTurnAngle));
      var t = pt2.x !== pt1.x ? (tmpProjPoint.x - pt1.x) / (pt2.x - pt1.x) : (tmpProjPoint.y - pt1.y) / (pt2.y - pt1.y);
      if (isNaN(t)) {
        return;
      }
      if (t < 0) {
        Point_default.copy(tmpProjPoint, pt1);
      } else if (t > 1) {
        Point_default.copy(tmpProjPoint, pt2);
      }
      tmpProjPoint.toArray(linePoints[1]);
    }
  }
  function limitSurfaceAngle(linePoints, surfaceNormal, maxSurfaceAngle) {
    if (!(maxSurfaceAngle <= 180 && maxSurfaceAngle > 0)) {
      return;
    }
    maxSurfaceAngle = maxSurfaceAngle / 180 * Math.PI;
    pt0.fromArray(linePoints[0]);
    pt1.fromArray(linePoints[1]);
    pt2.fromArray(linePoints[2]);
    Point_default.sub(dir, pt1, pt0);
    Point_default.sub(dir2, pt2, pt1);
    var len1 = dir.len();
    var len2 = dir2.len();
    if (len1 < 1e-3 || len2 < 1e-3) {
      return;
    }
    dir.scale(1 / len1);
    dir2.scale(1 / len2);
    var angleCos = dir.dot(surfaceNormal);
    var maxSurfaceAngleCos = Math.cos(maxSurfaceAngle);
    if (angleCos < maxSurfaceAngleCos) {
      var d = projectPointToLine(pt1.x, pt1.y, pt2.x, pt2.y, pt0.x, pt0.y, tmpArr, false);
      tmpProjPoint.fromArray(tmpArr);
      var HALF_PI = Math.PI / 2;
      var angle2 = Math.acos(dir2.dot(surfaceNormal));
      var newAngle = HALF_PI + angle2 - maxSurfaceAngle;
      if (newAngle >= HALF_PI) {
        Point_default.copy(tmpProjPoint, pt2);
      } else {
        tmpProjPoint.scaleAndAdd(dir2, d / Math.tan(Math.PI / 2 - newAngle));
        var t = pt2.x !== pt1.x ? (tmpProjPoint.x - pt1.x) / (pt2.x - pt1.x) : (tmpProjPoint.y - pt1.y) / (pt2.y - pt1.y);
        if (isNaN(t)) {
          return;
        }
        if (t < 0) {
          Point_default.copy(tmpProjPoint, pt1);
        } else if (t > 1) {
          Point_default.copy(tmpProjPoint, pt2);
        }
      }
      tmpProjPoint.toArray(linePoints[1]);
    }
  }
  function setLabelLineState(labelLine, ignore, stateName, stateModel) {
    var isNormal = stateName === "normal";
    var stateObj = isNormal ? labelLine : labelLine.ensureState(stateName);
    stateObj.ignore = ignore;
    var smooth = stateModel.get("smooth");
    if (smooth && smooth === true) {
      smooth = 0.3;
    }
    stateObj.shape = stateObj.shape || {};
    if (smooth > 0) {
      stateObj.shape.smooth = smooth;
    }
    var styleObj = stateModel.getModel("lineStyle").getLineStyle();
    isNormal ? labelLine.useStyle(styleObj) : stateObj.style = styleObj;
  }
  function buildLabelLinePath(path, shape) {
    var smooth = shape.smooth;
    var points4 = shape.points;
    if (!points4) {
      return;
    }
    path.moveTo(points4[0][0], points4[0][1]);
    if (smooth > 0 && points4.length >= 3) {
      var len1 = dist(points4[0], points4[1]);
      var len2 = dist(points4[1], points4[2]);
      if (!len1 || !len2) {
        path.lineTo(points4[1][0], points4[1][1]);
        path.lineTo(points4[2][0], points4[2][1]);
        return;
      }
      var moveLen = Math.min(len1, len2) * smooth;
      var midPoint0 = lerp([], points4[1], points4[0], moveLen / len1);
      var midPoint2 = lerp([], points4[1], points4[2], moveLen / len2);
      var midPoint1 = lerp([], midPoint0, midPoint2, 0.5);
      path.bezierCurveTo(midPoint0[0], midPoint0[1], midPoint0[0], midPoint0[1], midPoint1[0], midPoint1[1]);
      path.bezierCurveTo(midPoint2[0], midPoint2[1], midPoint2[0], midPoint2[1], points4[2][0], points4[2][1]);
    } else {
      for (var i = 1; i < points4.length; i++) {
        path.lineTo(points4[i][0], points4[i][1]);
      }
    }
  }
  function setLabelLineStyle(targetEl, statesModels, defaultStyle) {
    var labelLine = targetEl.getTextGuideLine();
    var label = targetEl.getTextContent();
    if (!label) {
      if (labelLine) {
        targetEl.removeTextGuideLine();
      }
      return;
    }
    var normalModel = statesModels.normal;
    var showNormal = normalModel.get("show");
    var labelIgnoreNormal = label.ignore;
    for (var i = 0; i < DISPLAY_STATES.length; i++) {
      var stateName = DISPLAY_STATES[i];
      var stateModel = statesModels[stateName];
      var isNormal = stateName === "normal";
      if (stateModel) {
        var stateShow = stateModel.get("show");
        var isLabelIgnored = isNormal ? labelIgnoreNormal : retrieve2(label.states[stateName] && label.states[stateName].ignore, labelIgnoreNormal);
        if (isLabelIgnored || !retrieve2(stateShow, showNormal)) {
          var stateObj = isNormal ? labelLine : labelLine && labelLine.states[stateName];
          if (stateObj) {
            stateObj.ignore = true;
          }
          continue;
        }
        if (!labelLine) {
          labelLine = new Polyline_default();
          targetEl.setTextGuideLine(labelLine);
          if (!isNormal && (labelIgnoreNormal || !showNormal)) {
            setLabelLineState(labelLine, true, "normal", statesModels.normal);
          }
          if (targetEl.stateProxy) {
            labelLine.stateProxy = targetEl.stateProxy;
          }
        }
        setLabelLineState(labelLine, false, stateName, stateModel);
      }
    }
    if (labelLine) {
      defaults(labelLine.style, defaultStyle);
      labelLine.style.fill = null;
      var showAbove = normalModel.get("showAbove");
      var labelLineConfig = targetEl.textGuideLineConfig = targetEl.textGuideLineConfig || {};
      labelLineConfig.showAbove = showAbove || false;
      labelLine.buildPath = buildLabelLinePath;
    }
  }
  function getLabelLineStatesModels(itemModel, labelLineName) {
    labelLineName = labelLineName || "labelLine";
    var statesModels = {
      normal: itemModel.getModel(labelLineName)
    };
    for (var i = 0; i < SPECIAL_STATES.length; i++) {
      var stateName = SPECIAL_STATES[i];
      statesModels[stateName] = itemModel.getModel([stateName, labelLineName]);
    }
    return statesModels;
  }

  // node_modules/echarts/lib/label/labelLayoutHelper.js
  function prepareLayoutList(input) {
    var list = [];
    for (var i = 0; i < input.length; i++) {
      var rawItem = input[i];
      if (rawItem.defaultAttr.ignore) {
        continue;
      }
      var label = rawItem.label;
      var transform2 = label.getComputedTransform();
      var localRect = label.getBoundingRect();
      var isAxisAligned = !transform2 || transform2[1] < 1e-5 && transform2[2] < 1e-5;
      var minMargin = label.style.margin || 0;
      var globalRect = localRect.clone();
      globalRect.applyTransform(transform2);
      globalRect.x -= minMargin / 2;
      globalRect.y -= minMargin / 2;
      globalRect.width += minMargin;
      globalRect.height += minMargin;
      var obb = isAxisAligned ? new OrientedBoundingRect_default(localRect, transform2) : null;
      list.push({
        label,
        labelLine: rawItem.labelLine,
        rect: globalRect,
        localRect,
        obb,
        priority: rawItem.priority,
        defaultAttr: rawItem.defaultAttr,
        layoutOption: rawItem.computedLayoutOption,
        axisAligned: isAxisAligned,
        transform: transform2
      });
    }
    return list;
  }
  function shiftLayout(list, xyDim, sizeDim, minBound, maxBound, balanceShift) {
    var len2 = list.length;
    if (len2 < 2) {
      return;
    }
    list.sort(function(a, b) {
      return a.rect[xyDim] - b.rect[xyDim];
    });
    var lastPos = 0;
    var delta;
    var adjusted = false;
    var shifts = [];
    var totalShifts = 0;
    for (var i = 0; i < len2; i++) {
      var item = list[i];
      var rect = item.rect;
      delta = rect[xyDim] - lastPos;
      if (delta < 0) {
        rect[xyDim] -= delta;
        item.label[xyDim] -= delta;
        adjusted = true;
      }
      var shift = Math.max(-delta, 0);
      shifts.push(shift);
      totalShifts += shift;
      lastPos = rect[xyDim] + rect[sizeDim];
    }
    if (totalShifts > 0 && balanceShift) {
      shiftList(-totalShifts / len2, 0, len2);
    }
    var first = list[0];
    var last = list[len2 - 1];
    var minGap;
    var maxGap;
    updateMinMaxGap();
    minGap < 0 && squeezeGaps(-minGap, 0.8);
    maxGap < 0 && squeezeGaps(maxGap, 0.8);
    updateMinMaxGap();
    takeBoundsGap(minGap, maxGap, 1);
    takeBoundsGap(maxGap, minGap, -1);
    updateMinMaxGap();
    if (minGap < 0) {
      squeezeWhenBailout(-minGap);
    }
    if (maxGap < 0) {
      squeezeWhenBailout(maxGap);
    }
    function updateMinMaxGap() {
      minGap = first.rect[xyDim] - minBound;
      maxGap = maxBound - last.rect[xyDim] - last.rect[sizeDim];
    }
    function takeBoundsGap(gapThisBound, gapOtherBound, moveDir) {
      if (gapThisBound < 0) {
        var moveFromMaxGap = Math.min(gapOtherBound, -gapThisBound);
        if (moveFromMaxGap > 0) {
          shiftList(moveFromMaxGap * moveDir, 0, len2);
          var remained = moveFromMaxGap + gapThisBound;
          if (remained < 0) {
            squeezeGaps(-remained * moveDir, 1);
          }
        } else {
          squeezeGaps(-gapThisBound * moveDir, 1);
        }
      }
    }
    function shiftList(delta2, start2, end2) {
      if (delta2 !== 0) {
        adjusted = true;
      }
      for (var i2 = start2; i2 < end2; i2++) {
        var item2 = list[i2];
        var rect2 = item2.rect;
        rect2[xyDim] += delta2;
        item2.label[xyDim] += delta2;
      }
    }
    function squeezeGaps(delta2, maxSqeezePercent) {
      var gaps = [];
      var totalGaps = 0;
      for (var i2 = 1; i2 < len2; i2++) {
        var prevItemRect = list[i2 - 1].rect;
        var gap = Math.max(list[i2].rect[xyDim] - prevItemRect[xyDim] - prevItemRect[sizeDim], 0);
        gaps.push(gap);
        totalGaps += gap;
      }
      if (!totalGaps) {
        return;
      }
      var squeezePercent = Math.min(Math.abs(delta2) / totalGaps, maxSqeezePercent);
      if (delta2 > 0) {
        for (var i2 = 0; i2 < len2 - 1; i2++) {
          var movement = gaps[i2] * squeezePercent;
          shiftList(movement, 0, i2 + 1);
        }
      } else {
        for (var i2 = len2 - 1; i2 > 0; i2--) {
          var movement = gaps[i2 - 1] * squeezePercent;
          shiftList(-movement, i2, len2);
        }
      }
    }
    function squeezeWhenBailout(delta2) {
      var dir3 = delta2 < 0 ? -1 : 1;
      delta2 = Math.abs(delta2);
      var moveForEachLabel = Math.ceil(delta2 / (len2 - 1));
      for (var i2 = 0; i2 < len2 - 1; i2++) {
        if (dir3 > 0) {
          shiftList(moveForEachLabel, 0, i2 + 1);
        } else {
          shiftList(-moveForEachLabel, len2 - i2 - 1, len2);
        }
        delta2 -= moveForEachLabel;
        if (delta2 <= 0) {
          return;
        }
      }
    }
    return adjusted;
  }
  function shiftLayoutOnX(list, leftBound, rightBound, balanceShift) {
    return shiftLayout(list, "x", "width", leftBound, rightBound, balanceShift);
  }
  function shiftLayoutOnY(list, topBound, bottomBound, balanceShift) {
    return shiftLayout(list, "y", "height", topBound, bottomBound, balanceShift);
  }
  function hideOverlap(labelList) {
    var displayedLabels = [];
    labelList.sort(function(a, b) {
      return b.priority - a.priority;
    });
    var globalRect = new BoundingRect_default(0, 0, 0, 0);
    function hideEl(el) {
      if (!el.ignore) {
        var emphasisState = el.ensureState("emphasis");
        if (emphasisState.ignore == null) {
          emphasisState.ignore = false;
        }
      }
      el.ignore = true;
    }
    for (var i = 0; i < labelList.length; i++) {
      var labelItem = labelList[i];
      var isAxisAligned = labelItem.axisAligned;
      var localRect = labelItem.localRect;
      var transform2 = labelItem.transform;
      var label = labelItem.label;
      var labelLine = labelItem.labelLine;
      globalRect.copy(labelItem.rect);
      globalRect.width -= 0.1;
      globalRect.height -= 0.1;
      globalRect.x += 0.05;
      globalRect.y += 0.05;
      var obb = labelItem.obb;
      var overlapped = false;
      for (var j = 0; j < displayedLabels.length; j++) {
        var existsTextCfg = displayedLabels[j];
        if (!globalRect.intersect(existsTextCfg.rect)) {
          continue;
        }
        if (isAxisAligned && existsTextCfg.axisAligned) {
          overlapped = true;
          break;
        }
        if (!existsTextCfg.obb) {
          existsTextCfg.obb = new OrientedBoundingRect_default(existsTextCfg.localRect, existsTextCfg.transform);
        }
        if (!obb) {
          obb = new OrientedBoundingRect_default(localRect, transform2);
        }
        if (obb.intersect(existsTextCfg.obb)) {
          overlapped = true;
          break;
        }
      }
      if (overlapped) {
        hideEl(label);
        labelLine && hideEl(labelLine);
      } else {
        label.attr("ignore", labelItem.defaultAttr.ignore);
        labelLine && labelLine.attr("ignore", labelItem.defaultAttr.labelGuideIgnore);
        displayedLabels.push(labelItem);
      }
    }
  }

  // node_modules/echarts/lib/label/LabelManager.js
  function cloneArr(points4) {
    if (points4) {
      var newPoints = [];
      for (var i = 0; i < points4.length; i++) {
        newPoints.push(points4[i].slice());
      }
      return newPoints;
    }
  }
  function prepareLayoutCallbackParams(labelItem, hostEl) {
    var label = labelItem.label;
    var labelLine = hostEl && hostEl.getTextGuideLine();
    return {
      dataIndex: labelItem.dataIndex,
      dataType: labelItem.dataType,
      seriesIndex: labelItem.seriesModel.seriesIndex,
      text: labelItem.label.style.text,
      rect: labelItem.hostRect,
      labelRect: labelItem.rect,
      align: label.style.align,
      verticalAlign: label.style.verticalAlign,
      labelLinePoints: cloneArr(labelLine && labelLine.shape.points)
    };
  }
  var LABEL_OPTION_TO_STYLE_KEYS = ["align", "verticalAlign", "width", "height", "fontSize"];
  var dummyTransformable = new Transformable_default();
  var labelLayoutInnerStore = makeInner();
  var labelLineAnimationStore = makeInner();
  function extendWithKeys(target, source, keys2) {
    for (var i = 0; i < keys2.length; i++) {
      var key = keys2[i];
      if (source[key] != null) {
        target[key] = source[key];
      }
    }
  }
  var LABEL_LAYOUT_PROPS = ["x", "y", "rotation"];
  var LabelManager = function() {
    function LabelManager2() {
      this._labelList = [];
      this._chartViewList = [];
    }
    LabelManager2.prototype.clearLabels = function() {
      this._labelList = [];
      this._chartViewList = [];
    };
    LabelManager2.prototype._addLabel = function(dataIndex, dataType, seriesModel, label, layoutOption) {
      var labelStyle = label.style;
      var hostEl = label.__hostTarget;
      var textConfig = hostEl.textConfig || {};
      var labelTransform = label.getComputedTransform();
      var labelRect = label.getBoundingRect().plain();
      BoundingRect_default.applyTransform(labelRect, labelRect, labelTransform);
      if (labelTransform) {
        dummyTransformable.setLocalTransform(labelTransform);
      } else {
        dummyTransformable.x = dummyTransformable.y = dummyTransformable.rotation = dummyTransformable.originX = dummyTransformable.originY = 0;
        dummyTransformable.scaleX = dummyTransformable.scaleY = 1;
      }
      var host = label.__hostTarget;
      var hostRect;
      if (host) {
        hostRect = host.getBoundingRect().plain();
        var transform2 = host.getComputedTransform();
        BoundingRect_default.applyTransform(hostRect, hostRect, transform2);
      }
      var labelGuide = hostRect && host.getTextGuideLine();
      this._labelList.push({
        label,
        labelLine: labelGuide,
        seriesModel,
        dataIndex,
        dataType,
        layoutOption,
        computedLayoutOption: null,
        rect: labelRect,
        hostRect,
        priority: hostRect ? hostRect.width * hostRect.height : 0,
        defaultAttr: {
          ignore: label.ignore,
          labelGuideIgnore: labelGuide && labelGuide.ignore,
          x: dummyTransformable.x,
          y: dummyTransformable.y,
          scaleX: dummyTransformable.scaleX,
          scaleY: dummyTransformable.scaleY,
          rotation: dummyTransformable.rotation,
          style: {
            x: labelStyle.x,
            y: labelStyle.y,
            align: labelStyle.align,
            verticalAlign: labelStyle.verticalAlign,
            width: labelStyle.width,
            height: labelStyle.height,
            fontSize: labelStyle.fontSize
          },
          cursor: label.cursor,
          attachedPos: textConfig.position,
          attachedRot: textConfig.rotation
        }
      });
    };
    LabelManager2.prototype.addLabelsOfSeries = function(chartView) {
      var _this = this;
      this._chartViewList.push(chartView);
      var seriesModel = chartView.__model;
      var layoutOption = seriesModel.get("labelLayout");
      if (!(isFunction(layoutOption) || keys(layoutOption).length)) {
        return;
      }
      chartView.group.traverse(function(child) {
        if (child.ignore) {
          return true;
        }
        var textEl = child.getTextContent();
        var ecData = getECData(child);
        if (textEl && !textEl.disableLabelLayout) {
          _this._addLabel(ecData.dataIndex, ecData.dataType, seriesModel, textEl, layoutOption);
        }
      });
    };
    LabelManager2.prototype.updateLayoutConfig = function(api) {
      var width = api.getWidth();
      var height = api.getHeight();
      function createDragHandler(el, labelLineModel) {
        return function() {
          updateLabelLinePoints(el, labelLineModel);
        };
      }
      for (var i = 0; i < this._labelList.length; i++) {
        var labelItem = this._labelList[i];
        var label = labelItem.label;
        var hostEl = label.__hostTarget;
        var defaultLabelAttr = labelItem.defaultAttr;
        var layoutOption = void 0;
        if (isFunction(labelItem.layoutOption)) {
          layoutOption = labelItem.layoutOption(prepareLayoutCallbackParams(labelItem, hostEl));
        } else {
          layoutOption = labelItem.layoutOption;
        }
        layoutOption = layoutOption || {};
        labelItem.computedLayoutOption = layoutOption;
        var degreeToRadian = Math.PI / 180;
        if (hostEl) {
          hostEl.setTextConfig({
            local: false,
            position: layoutOption.x != null || layoutOption.y != null ? null : defaultLabelAttr.attachedPos,
            rotation: layoutOption.rotate != null ? layoutOption.rotate * degreeToRadian : defaultLabelAttr.attachedRot,
            offset: [layoutOption.dx || 0, layoutOption.dy || 0]
          });
        }
        var needsUpdateLabelLine = false;
        if (layoutOption.x != null) {
          label.x = parsePercent2(layoutOption.x, width);
          label.setStyle("x", 0);
          needsUpdateLabelLine = true;
        } else {
          label.x = defaultLabelAttr.x;
          label.setStyle("x", defaultLabelAttr.style.x);
        }
        if (layoutOption.y != null) {
          label.y = parsePercent2(layoutOption.y, height);
          label.setStyle("y", 0);
          needsUpdateLabelLine = true;
        } else {
          label.y = defaultLabelAttr.y;
          label.setStyle("y", defaultLabelAttr.style.y);
        }
        if (layoutOption.labelLinePoints) {
          var guideLine = hostEl.getTextGuideLine();
          if (guideLine) {
            guideLine.setShape({
              points: layoutOption.labelLinePoints
            });
            needsUpdateLabelLine = false;
          }
        }
        var labelLayoutStore = labelLayoutInnerStore(label);
        labelLayoutStore.needsUpdateLabelLine = needsUpdateLabelLine;
        label.rotation = layoutOption.rotate != null ? layoutOption.rotate * degreeToRadian : defaultLabelAttr.rotation;
        label.scaleX = defaultLabelAttr.scaleX;
        label.scaleY = defaultLabelAttr.scaleY;
        for (var k = 0; k < LABEL_OPTION_TO_STYLE_KEYS.length; k++) {
          var key = LABEL_OPTION_TO_STYLE_KEYS[k];
          label.setStyle(key, layoutOption[key] != null ? layoutOption[key] : defaultLabelAttr.style[key]);
        }
        if (layoutOption.draggable) {
          label.draggable = true;
          label.cursor = "move";
          if (hostEl) {
            var hostModel = labelItem.seriesModel;
            if (labelItem.dataIndex != null) {
              var data = labelItem.seriesModel.getData(labelItem.dataType);
              hostModel = data.getItemModel(labelItem.dataIndex);
            }
            label.on("drag", createDragHandler(hostEl, hostModel.getModel("labelLine")));
          }
        } else {
          label.off("drag");
          label.cursor = defaultLabelAttr.cursor;
        }
      }
    };
    LabelManager2.prototype.layout = function(api) {
      var width = api.getWidth();
      var height = api.getHeight();
      var labelList = prepareLayoutList(this._labelList);
      var labelsNeedsAdjustOnX = filter(labelList, function(item) {
        return item.layoutOption.moveOverlap === "shiftX";
      });
      var labelsNeedsAdjustOnY = filter(labelList, function(item) {
        return item.layoutOption.moveOverlap === "shiftY";
      });
      shiftLayoutOnX(labelsNeedsAdjustOnX, 0, width);
      shiftLayoutOnY(labelsNeedsAdjustOnY, 0, height);
      var labelsNeedsHideOverlap = filter(labelList, function(item) {
        return item.layoutOption.hideOverlap;
      });
      hideOverlap(labelsNeedsHideOverlap);
    };
    LabelManager2.prototype.processLabelsOverall = function() {
      var _this = this;
      each(this._chartViewList, function(chartView) {
        var seriesModel = chartView.__model;
        var ignoreLabelLineUpdate = chartView.ignoreLabelLineUpdate;
        var animationEnabled = seriesModel.isAnimationEnabled();
        chartView.group.traverse(function(child) {
          if (child.ignore && !child.forceLabelAnimation) {
            return true;
          }
          var needsUpdateLabelLine = !ignoreLabelLineUpdate;
          var label = child.getTextContent();
          if (!needsUpdateLabelLine && label) {
            needsUpdateLabelLine = labelLayoutInnerStore(label).needsUpdateLabelLine;
          }
          if (needsUpdateLabelLine) {
            _this._updateLabelLine(child, seriesModel);
          }
          if (animationEnabled) {
            _this._animateLabels(child, seriesModel);
          }
        });
      });
    };
    LabelManager2.prototype._updateLabelLine = function(el, seriesModel) {
      var textEl = el.getTextContent();
      var ecData = getECData(el);
      var dataIndex = ecData.dataIndex;
      if (textEl && dataIndex != null) {
        var data = seriesModel.getData(ecData.dataType);
        var itemModel = data.getItemModel(dataIndex);
        var defaultStyle = {};
        var visualStyle = data.getItemVisual(dataIndex, "style");
        var visualType = data.getVisual("drawType");
        defaultStyle.stroke = visualStyle[visualType];
        var labelLineModel = itemModel.getModel("labelLine");
        setLabelLineStyle(el, getLabelLineStatesModels(itemModel), defaultStyle);
        updateLabelLinePoints(el, labelLineModel);
      }
    };
    LabelManager2.prototype._animateLabels = function(el, seriesModel) {
      var textEl = el.getTextContent();
      var guideLine = el.getTextGuideLine();
      if (textEl && (el.forceLabelAnimation || !textEl.ignore && !textEl.invisible && !el.disableLabelAnimation && !isElementRemoved(el))) {
        var layoutStore = labelLayoutInnerStore(textEl);
        var oldLayout = layoutStore.oldLayout;
        var ecData = getECData(el);
        var dataIndex = ecData.dataIndex;
        var newProps = {
          x: textEl.x,
          y: textEl.y,
          rotation: textEl.rotation
        };
        var data = seriesModel.getData(ecData.dataType);
        if (!oldLayout) {
          textEl.attr(newProps);
          if (!labelInner(textEl).valueAnimation) {
            var oldOpacity = retrieve2(textEl.style.opacity, 1);
            textEl.style.opacity = 0;
            initProps(textEl, {
              style: {
                opacity: oldOpacity
              }
            }, seriesModel, dataIndex);
          }
        } else {
          textEl.attr(oldLayout);
          var prevStates = el.prevStates;
          if (prevStates) {
            if (indexOf(prevStates, "select") >= 0) {
              textEl.attr(layoutStore.oldLayoutSelect);
            }
            if (indexOf(prevStates, "emphasis") >= 0) {
              textEl.attr(layoutStore.oldLayoutEmphasis);
            }
          }
          updateProps(textEl, newProps, seriesModel, dataIndex);
        }
        layoutStore.oldLayout = newProps;
        if (textEl.states.select) {
          var layoutSelect = layoutStore.oldLayoutSelect = {};
          extendWithKeys(layoutSelect, newProps, LABEL_LAYOUT_PROPS);
          extendWithKeys(layoutSelect, textEl.states.select, LABEL_LAYOUT_PROPS);
        }
        if (textEl.states.emphasis) {
          var layoutEmphasis = layoutStore.oldLayoutEmphasis = {};
          extendWithKeys(layoutEmphasis, newProps, LABEL_LAYOUT_PROPS);
          extendWithKeys(layoutEmphasis, textEl.states.emphasis, LABEL_LAYOUT_PROPS);
        }
        animateLabelValue(textEl, dataIndex, data, seriesModel, seriesModel);
      }
      if (guideLine && !guideLine.ignore && !guideLine.invisible) {
        var layoutStore = labelLineAnimationStore(guideLine);
        var oldLayout = layoutStore.oldLayout;
        var newLayout = {
          points: guideLine.shape.points
        };
        if (!oldLayout) {
          guideLine.setShape(newLayout);
          guideLine.style.strokePercent = 0;
          initProps(guideLine, {
            style: {
              strokePercent: 1
            }
          }, seriesModel);
        } else {
          guideLine.attr({
            shape: oldLayout
          });
          updateProps(guideLine, {
            shape: newLayout
          }, seriesModel);
        }
        layoutStore.oldLayout = newLayout;
      }
    };
    return LabelManager2;
  }();
  var LabelManager_default = LabelManager;

  // node_modules/echarts/lib/label/installLabelLayout.js
  var getLabelManager = makeInner();
  function installLabelLayout(registers) {
    registers.registerUpdateLifecycle("series:beforeupdate", function(ecModel, api, params) {
      var labelManager = getLabelManager(api).labelManager;
      if (!labelManager) {
        labelManager = getLabelManager(api).labelManager = new LabelManager_default();
      }
      labelManager.clearLabels();
    });
    registers.registerUpdateLifecycle("series:layoutlabels", function(ecModel, api, params) {
      var labelManager = getLabelManager(api).labelManager;
      params.updatedSeries.forEach(function(series) {
        labelManager.addLabelsOfSeries(api.getViewOfSeriesModel(series));
      });
      labelManager.updateLayoutConfig(api);
      labelManager.layout(api);
      labelManager.processLabelsOverall();
    });
  }

  // node_modules/zrender/lib/svg/SVGPathRebuilder.js
  var mathSin5 = Math.sin;
  var mathCos5 = Math.cos;
  var PI6 = Math.PI;
  var PI28 = Math.PI * 2;
  var degree = 180 / PI6;
  var SVGPathRebuilder = function() {
    function SVGPathRebuilder2() {
    }
    SVGPathRebuilder2.prototype.reset = function(precision) {
      this._start = true;
      this._d = [];
      this._str = "";
      this._p = Math.pow(10, precision || 4);
    };
    SVGPathRebuilder2.prototype.moveTo = function(x, y) {
      this._add("M", x, y);
    };
    SVGPathRebuilder2.prototype.lineTo = function(x, y) {
      this._add("L", x, y);
    };
    SVGPathRebuilder2.prototype.bezierCurveTo = function(x, y, x2, y2, x3, y3) {
      this._add("C", x, y, x2, y2, x3, y3);
    };
    SVGPathRebuilder2.prototype.quadraticCurveTo = function(x, y, x2, y2) {
      this._add("Q", x, y, x2, y2);
    };
    SVGPathRebuilder2.prototype.arc = function(cx, cy, r, startAngle, endAngle, anticlockwise) {
      this.ellipse(cx, cy, r, r, 0, startAngle, endAngle, anticlockwise);
    };
    SVGPathRebuilder2.prototype.ellipse = function(cx, cy, rx, ry, psi, startAngle, endAngle, anticlockwise) {
      var dTheta = endAngle - startAngle;
      var clockwise = !anticlockwise;
      var dThetaPositive = Math.abs(dTheta);
      var isCircle = isAroundZero2(dThetaPositive - PI28) || (clockwise ? dTheta >= PI28 : -dTheta >= PI28);
      var unifiedTheta = dTheta > 0 ? dTheta % PI28 : dTheta % PI28 + PI28;
      var large = false;
      if (isCircle) {
        large = true;
      } else if (isAroundZero2(dThetaPositive)) {
        large = false;
      } else {
        large = unifiedTheta >= PI6 === !!clockwise;
      }
      var x0 = cx + rx * mathCos5(startAngle);
      var y0 = cy + ry * mathSin5(startAngle);
      if (this._start) {
        this._add("M", x0, y0);
      }
      var xRot = Math.round(psi * degree);
      if (isCircle) {
        var p = 1 / this._p;
        var dTheta_1 = (clockwise ? 1 : -1) * (PI28 - p);
        this._add("A", rx, ry, xRot, 1, +clockwise, cx + rx * mathCos5(startAngle + dTheta_1), cy + ry * mathSin5(startAngle + dTheta_1));
        if (p > 0.01) {
          this._add("A", rx, ry, xRot, 0, +clockwise, x0, y0);
        }
      } else {
        var x = cx + rx * mathCos5(endAngle);
        var y = cy + ry * mathSin5(endAngle);
        this._add("A", rx, ry, xRot, +large, +clockwise, x, y);
      }
    };
    SVGPathRebuilder2.prototype.rect = function(x, y, w, h) {
      this._add("M", x, y);
      this._add("l", w, 0);
      this._add("l", 0, h);
      this._add("l", -w, 0);
      this._add("Z");
    };
    SVGPathRebuilder2.prototype.closePath = function() {
      if (this._d.length > 0) {
        this._add("Z");
      }
    };
    SVGPathRebuilder2.prototype._add = function(cmd, a, b, c, d, e2, f, g, h) {
      var vals = [];
      var p = this._p;
      for (var i = 1; i < arguments.length; i++) {
        var val = arguments[i];
        if (isNaN(val)) {
          this._invalid = true;
          return;
        }
        vals.push(Math.round(val * p) / p);
      }
      this._d.push(cmd + vals.join(" "));
      this._start = cmd === "Z";
    };
    SVGPathRebuilder2.prototype.generateStr = function() {
      this._str = this._invalid ? "" : this._d.join("");
      this._d = [];
    };
    SVGPathRebuilder2.prototype.getStr = function() {
      return this._str;
    };
    return SVGPathRebuilder2;
  }();
  var SVGPathRebuilder_default = SVGPathRebuilder;

  // node_modules/zrender/lib/svg/mapStyleToAttrs.js
  var NONE = "none";
  var mathRound2 = Math.round;
  function pathHasFill(style) {
    var fill = style.fill;
    return fill != null && fill !== NONE;
  }
  function pathHasStroke(style) {
    var stroke = style.stroke;
    return stroke != null && stroke !== NONE;
  }
  var strokeProps = ["lineCap", "miterLimit", "lineJoin"];
  var svgStrokeProps = map(strokeProps, function(prop) {
    return "stroke-" + prop.toLowerCase();
  });
  function mapStyleToAttrs(updateAttr2, style, el, forceUpdate) {
    var opacity = style.opacity == null ? 1 : style.opacity;
    if (el instanceof Image_default) {
      updateAttr2("opacity", opacity);
      return;
    }
    if (pathHasFill(style)) {
      var fill = normalizeColor(style.fill);
      updateAttr2("fill", fill.color);
      var fillOpacity = style.fillOpacity != null ? style.fillOpacity * fill.opacity * opacity : fill.opacity * opacity;
      if (forceUpdate || fillOpacity < 1) {
        updateAttr2("fill-opacity", fillOpacity);
      }
    } else {
      updateAttr2("fill", NONE);
    }
    if (pathHasStroke(style)) {
      var stroke = normalizeColor(style.stroke);
      updateAttr2("stroke", stroke.color);
      var strokeScale = style.strokeNoScale ? el.getLineScale() : 1;
      var strokeWidth = strokeScale ? (style.lineWidth || 0) / strokeScale : 0;
      var strokeOpacity = style.strokeOpacity != null ? style.strokeOpacity * stroke.opacity * opacity : stroke.opacity * opacity;
      var strokeFirst = style.strokeFirst;
      if (forceUpdate || strokeWidth !== 1) {
        updateAttr2("stroke-width", strokeWidth);
      }
      if (forceUpdate || strokeFirst) {
        updateAttr2("paint-order", strokeFirst ? "stroke" : "fill");
      }
      if (forceUpdate || strokeOpacity < 1) {
        updateAttr2("stroke-opacity", strokeOpacity);
      }
      if (style.lineDash) {
        var _a2 = getLineDash(el), lineDash = _a2[0], lineDashOffset = _a2[1];
        if (lineDash) {
          lineDashOffset = mathRound2(lineDashOffset || 0);
          updateAttr2("stroke-dasharray", lineDash.join(","));
          if (lineDashOffset || forceUpdate) {
            updateAttr2("stroke-dashoffset", lineDashOffset);
          }
        }
      } else if (forceUpdate) {
        updateAttr2("stroke-dasharray", NONE);
      }
      for (var i = 0; i < strokeProps.length; i++) {
        var propName = strokeProps[i];
        if (forceUpdate || style[propName] !== DEFAULT_PATH_STYLE[propName]) {
          var val = style[propName] || DEFAULT_PATH_STYLE[propName];
          val && updateAttr2(svgStrokeProps[i], val);
        }
      }
    } else if (forceUpdate) {
      updateAttr2("stroke", NONE);
    }
  }

  // node_modules/zrender/lib/svg/core.js
  var SVGNS = "http://www.w3.org/2000/svg";
  var XLINKNS = "http://www.w3.org/1999/xlink";
  var XMLNS = "http://www.w3.org/2000/xmlns/";
  var XML_NAMESPACE = "http://www.w3.org/XML/1998/namespace";
  function createElement(name) {
    return document.createElementNS(SVGNS, name);
  }
  function createVNode(tag, key, attrs, children, text) {
    return {
      tag,
      attrs: attrs || {},
      children,
      text,
      key
    };
  }
  function createElementOpen(name, attrs) {
    var attrsStr = [];
    if (attrs) {
      for (var key in attrs) {
        var val = attrs[key];
        var part = key;
        if (val === false) {
          continue;
        } else if (val !== true && val != null) {
          part += '="' + val + '"';
        }
        attrsStr.push(part);
      }
    }
    return "<" + name + " " + attrsStr.join(" ") + ">";
  }
  function createElementClose(name) {
    return "</" + name + ">";
  }
  function vNodeToString(el, opts) {
    opts = opts || {};
    var S = opts.newline ? "\n" : "";
    function convertElToString(el2) {
      var children = el2.children, tag = el2.tag, attrs = el2.attrs;
      return createElementOpen(tag, attrs) + (el2.text || "") + (children ? "" + S + map(children, function(child) {
        return convertElToString(child);
      }).join(S) + S : "") + createElementClose(tag);
    }
    return convertElToString(el);
  }
  function getCssString(selectorNodes, animationNodes, opts) {
    opts = opts || {};
    var S = opts.newline ? "\n" : "";
    var bracketBegin = " {" + S;
    var bracketEnd = S + "}";
    var selectors = map(keys(selectorNodes), function(className) {
      return className + bracketBegin + map(keys(selectorNodes[className]), function(attrName) {
        return attrName + ":" + selectorNodes[className][attrName] + ";";
      }).join(S) + bracketEnd;
    }).join(S);
    var animations = map(keys(animationNodes), function(animationName) {
      return "@keyframes " + animationName + bracketBegin + map(keys(animationNodes[animationName]), function(percent) {
        return percent + bracketBegin + map(keys(animationNodes[animationName][percent]), function(attrName) {
          var val = animationNodes[animationName][percent][attrName];
          if (attrName === "d") {
            val = 'path("' + val + '")';
          }
          return attrName + ":" + val + ";";
        }).join(S) + bracketEnd;
      }).join(S) + bracketEnd;
    }).join(S);
    if (!selectors && !animations) {
      return "";
    }
    return ["<![CDATA[", selectors, animations, "]]>"].join(S);
  }
  function createBrushScope(zrId) {
    return {
      zrId,
      shadowCache: {},
      patternCache: {},
      gradientCache: {},
      clipPathCache: {},
      defs: {},
      cssNodes: {},
      cssAnims: {},
      cssClassIdx: 0,
      cssAnimIdx: 0,
      shadowIdx: 0,
      gradientIdx: 0,
      patternIdx: 0,
      clipPathIdx: 0
    };
  }
  function createSVGVNode(width, height, children, useViewBox) {
    return createVNode("svg", "root", {
      "width": width,
      "height": height,
      "xmlns": SVGNS,
      "xmlns:xlink": XLINKNS,
      "version": "1.1",
      "baseProfile": "full",
      "viewBox": useViewBox ? "0 0 " + width + " " + height : false
    }, children);
  }

  // node_modules/zrender/lib/svg/cssAnimation.js
  var EASING_MAP = {
    cubicIn: "0.32,0,0.67,0",
    cubicOut: "0.33,1,0.68,1",
    cubicInOut: "0.65,0,0.35,1",
    quadraticIn: "0.11,0,0.5,0",
    quadraticOut: "0.5,1,0.89,1",
    quadraticInOut: "0.45,0,0.55,1",
    quarticIn: "0.5,0,0.75,0",
    quarticOut: "0.25,1,0.5,1",
    quarticInOut: "0.76,0,0.24,1",
    quinticIn: "0.64,0,0.78,0",
    quinticOut: "0.22,1,0.36,1",
    quinticInOut: "0.83,0,0.17,1",
    sinusoidalIn: "0.12,0,0.39,0",
    sinusoidalOut: "0.61,1,0.88,1",
    sinusoidalInOut: "0.37,0,0.63,1",
    exponentialIn: "0.7,0,0.84,0",
    exponentialOut: "0.16,1,0.3,1",
    exponentialInOut: "0.87,0,0.13,1",
    circularIn: "0.55,0,1,0.45",
    circularOut: "0,0.55,0.45,1",
    circularInOut: "0.85,0,0.15,1"
  };
  var transformOriginKey = "transform-origin";
  function buildPathString(el, kfShape, path) {
    var shape = extend({}, el.shape);
    extend(shape, kfShape);
    el.buildPath(path, shape);
    var svgPathBuilder = new SVGPathRebuilder_default();
    svgPathBuilder.reset(getPathPrecision(el));
    path.rebuildPath(svgPathBuilder, 1);
    svgPathBuilder.generateStr();
    return svgPathBuilder.getStr();
  }
  function setTransformOrigin(target, transform2) {
    var originX = transform2.originX, originY = transform2.originY;
    if (originX || originY) {
      target[transformOriginKey] = originX + "px " + originY + "px";
    }
  }
  var ANIMATE_STYLE_MAP = {
    fill: "fill",
    opacity: "opacity",
    lineWidth: "stroke-width",
    lineDashOffset: "stroke-dashoffset"
  };
  function addAnimation(cssAnim, scope) {
    var animationName = scope.zrId + "-ani-" + scope.cssAnimIdx++;
    scope.cssAnims[animationName] = cssAnim;
    return animationName;
  }
  function createCompoundPathCSSAnimation(el, attrs, scope) {
    var paths = el.shape.paths;
    var composedAnim = {};
    var cssAnimationCfg;
    var cssAnimationName;
    each(paths, function(path) {
      var subScope = createBrushScope(scope.zrId);
      subScope.animation = true;
      createCSSAnimation(path, {}, subScope, true);
      var cssAnims = subScope.cssAnims;
      var cssNodes = subScope.cssNodes;
      var animNames = keys(cssAnims);
      var len2 = animNames.length;
      if (!len2) {
        return;
      }
      cssAnimationName = animNames[len2 - 1];
      var lastAnim = cssAnims[cssAnimationName];
      for (var percent in lastAnim) {
        var kf = lastAnim[percent];
        composedAnim[percent] = composedAnim[percent] || { d: "" };
        composedAnim[percent].d += kf.d || "";
      }
      for (var className in cssNodes) {
        var val = cssNodes[className].animation;
        if (val.indexOf(cssAnimationName) >= 0) {
          cssAnimationCfg = val;
        }
      }
    });
    if (!cssAnimationCfg) {
      return;
    }
    attrs.d = false;
    var animationName = addAnimation(composedAnim, scope);
    return cssAnimationCfg.replace(cssAnimationName, animationName);
  }
  function getEasingFunc(easing) {
    return isString(easing) ? EASING_MAP[easing] ? "cubic-bezier(" + EASING_MAP[easing] + ")" : createCubicEasingFunc(easing) ? easing : "" : "";
  }
  function createCSSAnimation(el, attrs, scope, onlyShape) {
    var animators = el.animators;
    var len2 = animators.length;
    var cssAnimations = [];
    if (el instanceof CompoundPath_default) {
      var animationCfg = createCompoundPathCSSAnimation(el, attrs, scope);
      if (animationCfg) {
        cssAnimations.push(animationCfg);
      } else if (!len2) {
        return;
      }
    } else if (!len2) {
      return;
    }
    var groupAnimators = {};
    for (var i = 0; i < len2; i++) {
      var animator = animators[i];
      var cfgArr = [animator.getMaxTime() / 1e3 + "s"];
      var easing = getEasingFunc(animator.getClip().easing);
      var delay = animator.getDelay();
      if (easing) {
        cfgArr.push(easing);
      } else {
        cfgArr.push("linear");
      }
      if (delay) {
        cfgArr.push(delay / 1e3 + "s");
      }
      if (animator.getLoop()) {
        cfgArr.push("infinite");
      }
      var cfg = cfgArr.join(" ");
      groupAnimators[cfg] = groupAnimators[cfg] || [cfg, []];
      groupAnimators[cfg][1].push(animator);
    }
    function createSingleCSSAnimation(groupAnimator) {
      var animators2 = groupAnimator[1];
      var len3 = animators2.length;
      var transformKfs = {};
      var shapeKfs = {};
      var finalKfs = {};
      var animationTimingFunctionAttrName = "animation-timing-function";
      function saveAnimatorTrackToCssKfs(animator3, cssKfs, toCssAttrName) {
        var tracks = animator3.getTracks();
        var maxTime = animator3.getMaxTime();
        for (var k = 0; k < tracks.length; k++) {
          var track = tracks[k];
          if (track.needsAnimate()) {
            var kfs = track.keyframes;
            var attrName = track.propName;
            toCssAttrName && (attrName = toCssAttrName(attrName));
            if (attrName) {
              for (var i3 = 0; i3 < kfs.length; i3++) {
                var kf = kfs[i3];
                var percent2 = Math.round(kf.time / maxTime * 100) + "%";
                var kfEasing = getEasingFunc(kf.easing);
                var rawValue = kf.rawValue;
                if (isString(rawValue) || isNumber(rawValue)) {
                  cssKfs[percent2] = cssKfs[percent2] || {};
                  cssKfs[percent2][attrName] = kf.rawValue;
                  if (kfEasing) {
                    cssKfs[percent2][animationTimingFunctionAttrName] = kfEasing;
                  }
                }
              }
            }
          }
        }
      }
      for (var i2 = 0; i2 < len3; i2++) {
        var animator2 = animators2[i2];
        var targetProp = animator2.targetName;
        if (!targetProp) {
          !onlyShape && saveAnimatorTrackToCssKfs(animator2, transformKfs);
        } else if (targetProp === "shape") {
          saveAnimatorTrackToCssKfs(animator2, shapeKfs);
        }
      }
      for (var percent in transformKfs) {
        var transform2 = {};
        copyTransform(transform2, el);
        extend(transform2, transformKfs[percent]);
        var str = getSRTTransformString(transform2);
        var timingFunction = transformKfs[percent][animationTimingFunctionAttrName];
        finalKfs[percent] = str ? {
          transform: str
        } : {};
        setTransformOrigin(finalKfs[percent], transform2);
        if (timingFunction) {
          finalKfs[percent][animationTimingFunctionAttrName] = timingFunction;
        }
      }
      ;
      var path;
      var canAnimateShape = true;
      for (var percent in shapeKfs) {
        finalKfs[percent] = finalKfs[percent] || {};
        var isFirst = !path;
        var timingFunction = shapeKfs[percent][animationTimingFunctionAttrName];
        if (isFirst) {
          path = new PathProxy_default();
        }
        var len_1 = path.len();
        path.reset();
        finalKfs[percent].d = buildPathString(el, shapeKfs[percent], path);
        var newLen = path.len();
        if (!isFirst && len_1 !== newLen) {
          canAnimateShape = false;
          break;
        }
        if (timingFunction) {
          finalKfs[percent][animationTimingFunctionAttrName] = timingFunction;
        }
      }
      ;
      if (!canAnimateShape) {
        for (var percent in finalKfs) {
          delete finalKfs[percent].d;
        }
      }
      if (!onlyShape) {
        for (var i2 = 0; i2 < len3; i2++) {
          var animator2 = animators2[i2];
          var targetProp = animator2.targetName;
          if (targetProp === "style") {
            saveAnimatorTrackToCssKfs(animator2, finalKfs, function(propName) {
              return ANIMATE_STYLE_MAP[propName];
            });
          }
        }
      }
      var percents = keys(finalKfs);
      var allTransformOriginSame = true;
      var transformOrigin;
      for (var i2 = 1; i2 < percents.length; i2++) {
        var p0 = percents[i2 - 1];
        var p1 = percents[i2];
        if (finalKfs[p0][transformOriginKey] !== finalKfs[p1][transformOriginKey]) {
          allTransformOriginSame = false;
          break;
        }
        transformOrigin = finalKfs[p0][transformOriginKey];
      }
      if (allTransformOriginSame && transformOrigin) {
        for (var percent in finalKfs) {
          if (finalKfs[percent][transformOriginKey]) {
            delete finalKfs[percent][transformOriginKey];
          }
        }
        attrs[transformOriginKey] = transformOrigin;
      }
      if (filter(percents, function(percent2) {
        return keys(finalKfs[percent2]).length > 0;
      }).length) {
        var animationName = addAnimation(finalKfs, scope);
        return animationName + " " + groupAnimator[0] + " both";
      }
    }
    for (var key in groupAnimators) {
      var animationCfg = createSingleCSSAnimation(groupAnimators[key]);
      if (animationCfg) {
        cssAnimations.push(animationCfg);
      }
    }
    if (cssAnimations.length) {
      var className = scope.zrId + "-cls-" + scope.cssClassIdx++;
      scope.cssNodes["." + className] = {
        animation: cssAnimations.join(",")
      };
      attrs["class"] = className;
    }
  }

  // node_modules/zrender/lib/svg/graphic.js
  var round5 = Math.round;
  function isImageLike2(val) {
    return val && isString(val.src);
  }
  function isCanvasLike(val) {
    return val && isFunction(val.toDataURL);
  }
  function setStyleAttrs(attrs, style, el, scope) {
    mapStyleToAttrs(function(key, val) {
      var isFillStroke = key === "fill" || key === "stroke";
      if (isFillStroke && isGradient(val)) {
        setGradient(style, attrs, key, scope);
      } else if (isFillStroke && isPattern(val)) {
        setPattern(el, attrs, key, scope);
      } else {
        attrs[key] = val;
      }
    }, style, el, false);
    setShadow(el, attrs, scope);
  }
  function noRotateScale(m2) {
    return isAroundZero2(m2[0] - 1) && isAroundZero2(m2[1]) && isAroundZero2(m2[2]) && isAroundZero2(m2[3] - 1);
  }
  function noTranslate(m2) {
    return isAroundZero2(m2[4]) && isAroundZero2(m2[5]);
  }
  function setTransform(attrs, m2, compress) {
    if (m2 && !(noTranslate(m2) && noRotateScale(m2))) {
      var mul3 = compress ? 10 : 1e4;
      attrs.transform = noRotateScale(m2) ? "translate(" + round5(m2[4] * mul3) / mul3 + " " + round5(m2[5] * mul3) / mul3 + ")" : getMatrixStr(m2);
    }
  }
  function convertPolyShape(shape, attrs, mul3) {
    var points4 = shape.points;
    var strArr = [];
    for (var i = 0; i < points4.length; i++) {
      strArr.push(round5(points4[i][0] * mul3) / mul3);
      strArr.push(round5(points4[i][1] * mul3) / mul3);
    }
    attrs.points = strArr.join(" ");
  }
  function validatePolyShape(shape) {
    return !shape.smooth;
  }
  function createAttrsConvert(desc) {
    var normalizedDesc = map(desc, function(item) {
      return typeof item === "string" ? [item, item] : item;
    });
    return function(shape, attrs, mul3) {
      for (var i = 0; i < normalizedDesc.length; i++) {
        var item = normalizedDesc[i];
        var val = shape[item[0]];
        if (val != null) {
          attrs[item[1]] = round5(val * mul3) / mul3;
        }
      }
    };
  }
  var buitinShapesDef = {
    circle: [createAttrsConvert(["cx", "cy", "r"])],
    polyline: [convertPolyShape, validatePolyShape],
    polygon: [convertPolyShape, validatePolyShape]
  };
  function hasShapeAnimation(el) {
    var animators = el.animators;
    for (var i = 0; i < animators.length; i++) {
      if (animators[i].targetName === "shape") {
        return true;
      }
    }
    return false;
  }
  function brushSVGPath(el, scope) {
    var style = el.style;
    var shape = el.shape;
    var builtinShpDef = buitinShapesDef[el.type];
    var attrs = {};
    var needsAnimate = scope.animation;
    var svgElType = "path";
    var strokePercent = el.style.strokePercent;
    var precision = scope.compress && getPathPrecision(el) || 4;
    if (builtinShpDef && !scope.willUpdate && !(builtinShpDef[1] && !builtinShpDef[1](shape)) && !(needsAnimate && hasShapeAnimation(el)) && !(strokePercent < 1)) {
      svgElType = el.type;
      var mul3 = Math.pow(10, precision);
      builtinShpDef[0](shape, attrs, mul3);
    } else {
      if (!el.path) {
        el.createPathProxy();
      }
      var path = el.path;
      if (el.shapeChanged()) {
        path.beginPath();
        el.buildPath(path, el.shape);
        el.pathUpdated();
      }
      var pathVersion = path.getVersion();
      var elExt = el;
      var svgPathBuilder = elExt.__svgPathBuilder;
      if (elExt.__svgPathVersion !== pathVersion || !svgPathBuilder || strokePercent !== elExt.__svgPathStrokePercent) {
        if (!svgPathBuilder) {
          svgPathBuilder = elExt.__svgPathBuilder = new SVGPathRebuilder_default();
        }
        svgPathBuilder.reset(precision);
        path.rebuildPath(svgPathBuilder, strokePercent);
        svgPathBuilder.generateStr();
        elExt.__svgPathVersion = pathVersion;
        elExt.__svgPathStrokePercent = strokePercent;
      }
      attrs.d = svgPathBuilder.getStr();
    }
    setTransform(attrs, el.transform);
    setStyleAttrs(attrs, style, el, scope);
    scope.animation && createCSSAnimation(el, attrs, scope);
    return createVNode(svgElType, el.id + "", attrs);
  }
  function brushSVGImage(el, scope) {
    var style = el.style;
    var image = style.image;
    if (image && !isString(image)) {
      if (isImageLike2(image)) {
        image = image.src;
      } else if (isCanvasLike(image)) {
        image = image.toDataURL();
      }
    }
    if (!image) {
      return;
    }
    var x = style.x || 0;
    var y = style.y || 0;
    var dw = style.width;
    var dh = style.height;
    var attrs = {
      href: image,
      width: dw,
      height: dh
    };
    if (x) {
      attrs.x = x;
    }
    if (y) {
      attrs.y = y;
    }
    setTransform(attrs, el.transform);
    setStyleAttrs(attrs, style, el, scope);
    scope.animation && createCSSAnimation(el, attrs, scope);
    return createVNode("image", el.id + "", attrs);
  }
  function brushSVGTSpan(el, scope) {
    var style = el.style;
    var text = style.text;
    text != null && (text += "");
    if (!text || isNaN(style.x) || isNaN(style.y)) {
      return;
    }
    var font = style.font || DEFAULT_FONT;
    var x = style.x || 0;
    var y = adjustTextY(style.y || 0, getLineHeight(font), style.textBaseline);
    var textAlign = TEXT_ALIGN_TO_ANCHOR[style.textAlign] || style.textAlign;
    var attrs = {
      "dominant-baseline": "central",
      "text-anchor": textAlign
    };
    if (hasSeparateFont(style)) {
      var separatedFontStr = "";
      var fontStyle = style.fontStyle;
      var fontSize = parseFontSize(style.fontSize);
      if (!parseFloat(fontSize)) {
        return;
      }
      var fontFamily = style.fontFamily || DEFAULT_FONT_FAMILY;
      var fontWeight = style.fontWeight;
      separatedFontStr += "font-size:" + fontSize + ";font-family:" + fontFamily + ";";
      if (fontStyle && fontStyle !== "normal") {
        separatedFontStr += "font-style:" + fontStyle + ";";
      }
      if (fontWeight && fontWeight !== "normal") {
        separatedFontStr += "font-weight:" + fontWeight + ";";
      }
      attrs.style = separatedFontStr;
    } else {
      attrs.style = "font: " + font;
    }
    if (text.match(/\s/)) {
      attrs["xml:space"] = "preserve";
    }
    if (x) {
      attrs.x = x;
    }
    if (y) {
      attrs.y = y;
    }
    setTransform(attrs, el.transform);
    setStyleAttrs(attrs, style, el, scope);
    scope.animation && createCSSAnimation(el, attrs, scope);
    return createVNode("text", el.id + "", attrs, void 0, text);
  }
  function brush2(el, scope) {
    if (el instanceof Path_default) {
      return brushSVGPath(el, scope);
    } else if (el instanceof Image_default) {
      return brushSVGImage(el, scope);
    } else if (el instanceof TSpan_default) {
      return brushSVGTSpan(el, scope);
    }
  }
  function setShadow(el, attrs, scope) {
    var style = el.style;
    if (hasShadow(style)) {
      var shadowKey = getShadowKey(el);
      var shadowCache = scope.shadowCache;
      var shadowId = shadowCache[shadowKey];
      if (!shadowId) {
        var globalScale = el.getGlobalScale();
        var scaleX = globalScale[0];
        var scaleY = globalScale[1];
        if (!scaleX || !scaleY) {
          return;
        }
        var offsetX = style.shadowOffsetX || 0;
        var offsetY = style.shadowOffsetY || 0;
        var blur_1 = style.shadowBlur;
        var _a2 = normalizeColor(style.shadowColor), opacity = _a2.opacity, color = _a2.color;
        var stdDx = blur_1 / 2 / scaleX;
        var stdDy = blur_1 / 2 / scaleY;
        var stdDeviation = stdDx + " " + stdDy;
        shadowId = scope.zrId + "-s" + scope.shadowIdx++;
        scope.defs[shadowId] = createVNode("filter", shadowId, {
          "id": shadowId,
          "x": "-100%",
          "y": "-100%",
          "width": "300%",
          "height": "300%"
        }, [
          createVNode("feDropShadow", "", {
            "dx": offsetX / scaleX,
            "dy": offsetY / scaleY,
            "stdDeviation": stdDeviation,
            "flood-color": color,
            "flood-opacity": opacity
          })
        ]);
        shadowCache[shadowKey] = shadowId;
      }
      attrs.filter = getIdURL(shadowId);
    }
  }
  function setGradient(style, attrs, target, scope) {
    var val = style[target];
    var gradientTag;
    var gradientAttrs = {
      "gradientUnits": val.global ? "userSpaceOnUse" : "objectBoundingBox"
    };
    if (isLinearGradient(val)) {
      gradientTag = "linearGradient";
      gradientAttrs.x1 = val.x;
      gradientAttrs.y1 = val.y;
      gradientAttrs.x2 = val.x2;
      gradientAttrs.y2 = val.y2;
    } else if (isRadialGradient(val)) {
      gradientTag = "radialGradient";
      gradientAttrs.cx = retrieve2(val.x, 0.5);
      gradientAttrs.cy = retrieve2(val.y, 0.5);
      gradientAttrs.r = retrieve2(val.r, 0.5);
    } else {
      if (true) {
        logError("Illegal gradient type.");
      }
      return;
    }
    var colors = val.colorStops;
    var colorStops = [];
    for (var i = 0, len2 = colors.length; i < len2; ++i) {
      var offset = round4(colors[i].offset) * 100 + "%";
      var stopColor = colors[i].color;
      var _a2 = normalizeColor(stopColor), color = _a2.color, opacity = _a2.opacity;
      var stopsAttrs = {
        "offset": offset
      };
      stopsAttrs["stop-color"] = color;
      if (opacity < 1) {
        stopsAttrs["stop-opacity"] = opacity;
      }
      colorStops.push(createVNode("stop", i + "", stopsAttrs));
    }
    var gradientVNode = createVNode(gradientTag, "", gradientAttrs, colorStops);
    var gradientKey = vNodeToString(gradientVNode);
    var gradientCache = scope.gradientCache;
    var gradientId = gradientCache[gradientKey];
    if (!gradientId) {
      gradientId = scope.zrId + "-g" + scope.gradientIdx++;
      gradientCache[gradientKey] = gradientId;
      gradientAttrs.id = gradientId;
      scope.defs[gradientId] = createVNode(gradientTag, gradientId, gradientAttrs, colorStops);
    }
    attrs[target] = getIdURL(gradientId);
  }
  function setPattern(el, attrs, target, scope) {
    var val = el.style[target];
    var patternAttrs = {
      "patternUnits": "userSpaceOnUse"
    };
    var child;
    if (isImagePattern(val)) {
      var imageWidth_1 = val.imageWidth;
      var imageHeight_1 = val.imageHeight;
      var imageSrc = void 0;
      var patternImage = val.image;
      if (isString(patternImage)) {
        imageSrc = patternImage;
      } else if (isImageLike2(patternImage)) {
        imageSrc = patternImage.src;
      } else if (isCanvasLike(patternImage)) {
        imageSrc = patternImage.toDataURL();
      }
      if (typeof Image === "undefined") {
        var errMsg = "Image width/height must been given explictly in svg-ssr renderer.";
        assert(imageWidth_1, errMsg);
        assert(imageHeight_1, errMsg);
      } else if (imageWidth_1 == null || imageHeight_1 == null) {
        var setSizeToVNode_1 = function(vNode, img) {
          if (vNode) {
            var svgEl = vNode.elm;
            var width = vNode.attrs.width = imageWidth_1 || img.width;
            var height = vNode.attrs.height = imageHeight_1 || img.height;
            if (svgEl) {
              svgEl.setAttribute("width", width);
              svgEl.setAttribute("height", height);
            }
          }
        };
        var createdImage = createOrUpdateImage(imageSrc, null, el, function(img) {
          setSizeToVNode_1(patternVNode, img);
          setSizeToVNode_1(child, img);
        });
        if (createdImage && createdImage.width && createdImage.height) {
          imageWidth_1 = imageWidth_1 || createdImage.width;
          imageHeight_1 = imageHeight_1 || createdImage.height;
        }
      }
      child = createVNode("image", "img", {
        href: imageSrc,
        width: imageWidth_1,
        height: imageHeight_1
      });
      patternAttrs.width = imageWidth_1;
      patternAttrs.height = imageHeight_1;
    } else if (val.svgElement) {
      child = clone(val.svgElement);
      patternAttrs.width = val.svgWidth;
      patternAttrs.height = val.svgHeight;
    }
    if (!child) {
      return;
    }
    patternAttrs.patternTransform = getSRTTransformString(val);
    var patternVNode = createVNode("pattern", "", patternAttrs, [child]);
    var patternKey = vNodeToString(patternVNode);
    var patternCache = scope.patternCache;
    var patternId = patternCache[patternKey];
    if (!patternId) {
      patternId = scope.zrId + "-p" + scope.patternIdx++;
      patternCache[patternKey] = patternId;
      patternAttrs.id = patternId;
      patternVNode = scope.defs[patternId] = createVNode("pattern", patternId, patternAttrs, [child]);
    }
    attrs[target] = getIdURL(patternId);
  }
  function setClipPath(clipPath, attrs, scope) {
    var clipPathCache = scope.clipPathCache, defs = scope.defs;
    var clipPathId = clipPathCache[clipPath.id];
    if (!clipPathId) {
      clipPathId = scope.zrId + "-c" + scope.clipPathIdx++;
      var clipPathAttrs = {
        id: clipPathId
      };
      clipPathCache[clipPath.id] = clipPathId;
      defs[clipPathId] = createVNode("clipPath", clipPathId, clipPathAttrs, [brushSVGPath(clipPath, scope)]);
    }
    attrs["clip-path"] = getIdURL(clipPathId);
  }

  // node_modules/zrender/lib/svg/domapi.js
  function createTextNode(text) {
    return document.createTextNode(text);
  }
  function insertBefore(parentNode2, newNode, referenceNode) {
    parentNode2.insertBefore(newNode, referenceNode);
  }
  function removeChild(node, child) {
    node.removeChild(child);
  }
  function appendChild(node, child) {
    node.appendChild(child);
  }
  function parentNode(node) {
    return node.parentNode;
  }
  function nextSibling(node) {
    return node.nextSibling;
  }
  function setTextContent(node, text) {
    node.textContent = text;
  }

  // node_modules/zrender/lib/svg/patch.js
  var colonChar = 58;
  var xChar = 120;
  var emptyNode = createVNode("", "");
  function isUndef(s) {
    return s === void 0;
  }
  function isDef(s) {
    return s !== void 0;
  }
  function createKeyToOldIdx(children, beginIdx, endIdx) {
    var map3 = {};
    for (var i = beginIdx; i <= endIdx; ++i) {
      var key = children[i].key;
      if (key !== void 0) {
        if (true) {
          if (map3[key] != null) {
            console.error("Duplicate key " + key);
          }
        }
        map3[key] = i;
      }
    }
    return map3;
  }
  function sameVnode(vnode1, vnode2) {
    var isSameKey = vnode1.key === vnode2.key;
    var isSameTag = vnode1.tag === vnode2.tag;
    return isSameTag && isSameKey;
  }
  function createElm(vnode) {
    var i;
    var children = vnode.children;
    var tag = vnode.tag;
    if (isDef(tag)) {
      var elm = vnode.elm = createElement(tag);
      updateAttrs(emptyNode, vnode);
      if (isArray(children)) {
        for (i = 0; i < children.length; ++i) {
          var ch = children[i];
          if (ch != null) {
            appendChild(elm, createElm(ch));
          }
        }
      } else if (isDef(vnode.text) && !isObject(vnode.text)) {
        appendChild(elm, createTextNode(vnode.text));
      }
    } else {
      vnode.elm = createTextNode(vnode.text);
    }
    return vnode.elm;
  }
  function addVnodes(parentElm, before, vnodes, startIdx, endIdx) {
    for (; startIdx <= endIdx; ++startIdx) {
      var ch = vnodes[startIdx];
      if (ch != null) {
        insertBefore(parentElm, createElm(ch), before);
      }
    }
  }
  function removeVnodes(parentElm, vnodes, startIdx, endIdx) {
    for (; startIdx <= endIdx; ++startIdx) {
      var ch = vnodes[startIdx];
      if (ch != null) {
        if (isDef(ch.tag)) {
          var parent_1 = parentNode(ch.elm);
          removeChild(parent_1, ch.elm);
        } else {
          removeChild(parentElm, ch.elm);
        }
      }
    }
  }
  function updateAttrs(oldVnode, vnode) {
    var key;
    var elm = vnode.elm;
    var oldAttrs = oldVnode && oldVnode.attrs || {};
    var attrs = vnode.attrs || {};
    if (oldAttrs === attrs) {
      return;
    }
    for (key in attrs) {
      var cur = attrs[key];
      var old = oldAttrs[key];
      if (old !== cur) {
        if (cur === true) {
          elm.setAttribute(key, "");
        } else if (cur === false) {
          elm.removeAttribute(key);
        } else {
          if (key.charCodeAt(0) !== xChar) {
            elm.setAttribute(key, cur);
          } else if (key === "xmlns:xlink" || key === "xmlns") {
            elm.setAttributeNS(XMLNS, key, cur);
          } else if (key.charCodeAt(3) === colonChar) {
            elm.setAttributeNS(XML_NAMESPACE, key, cur);
          } else if (key.charCodeAt(5) === colonChar) {
            elm.setAttributeNS(XLINKNS, key, cur);
          } else {
            elm.setAttribute(key, cur);
          }
        }
      }
    }
    for (key in oldAttrs) {
      if (!(key in attrs)) {
        elm.removeAttribute(key);
      }
    }
  }
  function updateChildren(parentElm, oldCh, newCh) {
    var oldStartIdx = 0;
    var newStartIdx = 0;
    var oldEndIdx = oldCh.length - 1;
    var oldStartVnode = oldCh[0];
    var oldEndVnode = oldCh[oldEndIdx];
    var newEndIdx = newCh.length - 1;
    var newStartVnode = newCh[0];
    var newEndVnode = newCh[newEndIdx];
    var oldKeyToIdx;
    var idxInOld;
    var elmToMove;
    var before;
    while (oldStartIdx <= oldEndIdx && newStartIdx <= newEndIdx) {
      if (oldStartVnode == null) {
        oldStartVnode = oldCh[++oldStartIdx];
      } else if (oldEndVnode == null) {
        oldEndVnode = oldCh[--oldEndIdx];
      } else if (newStartVnode == null) {
        newStartVnode = newCh[++newStartIdx];
      } else if (newEndVnode == null) {
        newEndVnode = newCh[--newEndIdx];
      } else if (sameVnode(oldStartVnode, newStartVnode)) {
        patchVnode(oldStartVnode, newStartVnode);
        oldStartVnode = oldCh[++oldStartIdx];
        newStartVnode = newCh[++newStartIdx];
      } else if (sameVnode(oldEndVnode, newEndVnode)) {
        patchVnode(oldEndVnode, newEndVnode);
        oldEndVnode = oldCh[--oldEndIdx];
        newEndVnode = newCh[--newEndIdx];
      } else if (sameVnode(oldStartVnode, newEndVnode)) {
        patchVnode(oldStartVnode, newEndVnode);
        insertBefore(parentElm, oldStartVnode.elm, nextSibling(oldEndVnode.elm));
        oldStartVnode = oldCh[++oldStartIdx];
        newEndVnode = newCh[--newEndIdx];
      } else if (sameVnode(oldEndVnode, newStartVnode)) {
        patchVnode(oldEndVnode, newStartVnode);
        insertBefore(parentElm, oldEndVnode.elm, oldStartVnode.elm);
        oldEndVnode = oldCh[--oldEndIdx];
        newStartVnode = newCh[++newStartIdx];
      } else {
        if (isUndef(oldKeyToIdx)) {
          oldKeyToIdx = createKeyToOldIdx(oldCh, oldStartIdx, oldEndIdx);
        }
        idxInOld = oldKeyToIdx[newStartVnode.key];
        if (isUndef(idxInOld)) {
          insertBefore(parentElm, createElm(newStartVnode), oldStartVnode.elm);
        } else {
          elmToMove = oldCh[idxInOld];
          if (elmToMove.tag !== newStartVnode.tag) {
            insertBefore(parentElm, createElm(newStartVnode), oldStartVnode.elm);
          } else {
            patchVnode(elmToMove, newStartVnode);
            oldCh[idxInOld] = void 0;
            insertBefore(parentElm, elmToMove.elm, oldStartVnode.elm);
          }
        }
        newStartVnode = newCh[++newStartIdx];
      }
    }
    if (oldStartIdx <= oldEndIdx || newStartIdx <= newEndIdx) {
      if (oldStartIdx > oldEndIdx) {
        before = newCh[newEndIdx + 1] == null ? null : newCh[newEndIdx + 1].elm;
        addVnodes(parentElm, before, newCh, newStartIdx, newEndIdx);
      } else {
        removeVnodes(parentElm, oldCh, oldStartIdx, oldEndIdx);
      }
    }
  }
  function patchVnode(oldVnode, vnode) {
    var elm = vnode.elm = oldVnode.elm;
    var oldCh = oldVnode.children;
    var ch = vnode.children;
    if (oldVnode === vnode) {
      return;
    }
    updateAttrs(oldVnode, vnode);
    if (isUndef(vnode.text)) {
      if (isDef(oldCh) && isDef(ch)) {
        if (oldCh !== ch) {
          updateChildren(elm, oldCh, ch);
        }
      } else if (isDef(ch)) {
        if (isDef(oldVnode.text)) {
          setTextContent(elm, "");
        }
        addVnodes(elm, null, ch, 0, ch.length - 1);
      } else if (isDef(oldCh)) {
        removeVnodes(elm, oldCh, 0, oldCh.length - 1);
      } else if (isDef(oldVnode.text)) {
        setTextContent(elm, "");
      }
    } else if (oldVnode.text !== vnode.text) {
      if (isDef(oldCh)) {
        removeVnodes(elm, oldCh, 0, oldCh.length - 1);
      }
      setTextContent(elm, vnode.text);
    }
  }
  function patch(oldVnode, vnode) {
    if (sameVnode(oldVnode, vnode)) {
      patchVnode(oldVnode, vnode);
    } else {
      var elm = oldVnode.elm;
      var parent_2 = parentNode(elm);
      createElm(vnode);
      if (parent_2 !== null) {
        insertBefore(parent_2, vnode.elm, nextSibling(elm));
        removeVnodes(parent_2, [oldVnode], 0, 0);
      }
    }
    return vnode;
  }

  // node_modules/zrender/lib/svg/Painter.js
  var svgId = 0;
  var SVGPainter = function() {
    function SVGPainter2(root, storage2, opts) {
      this.type = "svg";
      this.refreshHover = createMethodNotSupport("refreshHover");
      this.configLayer = createMethodNotSupport("configLayer");
      this.storage = storage2;
      this._opts = opts = extend({}, opts);
      this.root = root;
      this._id = "zr" + svgId++;
      this._oldVNode = createSVGVNode(opts.width, opts.height);
      if (root && !opts.ssr) {
        var viewport = this._viewport = document.createElement("div");
        viewport.style.cssText = "position:relative;overflow:hidden";
        var svgDom = this._svgDom = this._oldVNode.elm = createElement("svg");
        updateAttrs(null, this._oldVNode);
        viewport.appendChild(svgDom);
        root.appendChild(viewport);
      }
      this.resize(opts.width, opts.height);
    }
    SVGPainter2.prototype.getType = function() {
      return this.type;
    };
    SVGPainter2.prototype.getViewportRoot = function() {
      return this._viewport;
    };
    SVGPainter2.prototype.getViewportRootOffset = function() {
      var viewportRoot = this.getViewportRoot();
      if (viewportRoot) {
        return {
          offsetLeft: viewportRoot.offsetLeft || 0,
          offsetTop: viewportRoot.offsetTop || 0
        };
      }
    };
    SVGPainter2.prototype.getSvgDom = function() {
      return this._svgDom;
    };
    SVGPainter2.prototype.refresh = function() {
      if (this.root) {
        var vnode = this.renderToVNode({
          willUpdate: true
        });
        vnode.attrs.style = "position:absolute;left:0;top:0;user-select:none";
        patch(this._oldVNode, vnode);
        this._oldVNode = vnode;
      }
    };
    SVGPainter2.prototype.renderOneToVNode = function(el) {
      return brush2(el, createBrushScope(this._id));
    };
    SVGPainter2.prototype.renderToVNode = function(opts) {
      opts = opts || {};
      var list = this.storage.getDisplayList(true);
      var bgColor = this._backgroundColor;
      var width = this._width;
      var height = this._height;
      var scope = createBrushScope(this._id);
      scope.animation = opts.animation;
      scope.willUpdate = opts.willUpdate;
      scope.compress = opts.compress;
      var children = [];
      if (bgColor && bgColor !== "none") {
        var _a2 = normalizeColor(bgColor), color = _a2.color, opacity = _a2.opacity;
        this._bgVNode = createVNode("rect", "bg", {
          width,
          height,
          x: "0",
          y: "0",
          id: "0",
          fill: color,
          "fill-opacity": opacity
        });
        children.push(this._bgVNode);
      } else {
        this._bgVNode = null;
      }
      var mainVNode = !opts.compress ? this._mainVNode = createVNode("g", "main", {}, []) : null;
      this._paintList(list, scope, mainVNode ? mainVNode.children : children);
      mainVNode && children.push(mainVNode);
      var defs = map(keys(scope.defs), function(id) {
        return scope.defs[id];
      });
      if (defs.length) {
        children.push(createVNode("defs", "defs", {}, defs));
      }
      if (opts.animation) {
        var animationCssStr = getCssString(scope.cssNodes, scope.cssAnims, { newline: true });
        if (animationCssStr) {
          var styleNode = createVNode("style", "stl", {}, [], animationCssStr);
          children.push(styleNode);
        }
      }
      return createSVGVNode(width, height, children, opts.useViewBox);
    };
    SVGPainter2.prototype.renderToString = function(opts) {
      opts = opts || {};
      return vNodeToString(this.renderToVNode({
        animation: retrieve2(opts.cssAnimation, true),
        willUpdate: false,
        compress: true,
        useViewBox: retrieve2(opts.useViewBox, true)
      }), { newline: true });
    };
    SVGPainter2.prototype.setBackgroundColor = function(backgroundColor2) {
      this._backgroundColor = backgroundColor2;
      var bgVNode = this._bgVNode;
      if (bgVNode && bgVNode.elm) {
        var _a2 = normalizeColor(backgroundColor2), color = _a2.color, opacity = _a2.opacity;
        bgVNode.elm.setAttribute("fill", color);
        if (opacity < 1) {
          bgVNode.elm.setAttribute("fill-opacity", opacity);
        }
      }
    };
    SVGPainter2.prototype.getSvgRoot = function() {
      return this._mainVNode && this._mainVNode.elm;
    };
    SVGPainter2.prototype._paintList = function(list, scope, out2) {
      var listLen = list.length;
      var clipPathsGroupsStack = [];
      var clipPathsGroupsStackDepth = 0;
      var currentClipPathGroup;
      var prevClipPaths;
      var clipGroupNodeIdx = 0;
      for (var i = 0; i < listLen; i++) {
        var displayable = list[i];
        if (!displayable.invisible) {
          var clipPaths = displayable.__clipPaths;
          var len2 = clipPaths && clipPaths.length || 0;
          var prevLen = prevClipPaths && prevClipPaths.length || 0;
          var lca = void 0;
          for (lca = Math.max(len2 - 1, prevLen - 1); lca >= 0; lca--) {
            if (clipPaths && prevClipPaths && clipPaths[lca] === prevClipPaths[lca]) {
              break;
            }
          }
          for (var i_1 = prevLen - 1; i_1 > lca; i_1--) {
            clipPathsGroupsStackDepth--;
            currentClipPathGroup = clipPathsGroupsStack[clipPathsGroupsStackDepth - 1];
          }
          for (var i_2 = lca + 1; i_2 < len2; i_2++) {
            var groupAttrs = {};
            setClipPath(clipPaths[i_2], groupAttrs, scope);
            var g = createVNode("g", "clip-g-" + clipGroupNodeIdx++, groupAttrs, []);
            (currentClipPathGroup ? currentClipPathGroup.children : out2).push(g);
            clipPathsGroupsStack[clipPathsGroupsStackDepth++] = g;
            currentClipPathGroup = g;
          }
          prevClipPaths = clipPaths;
          var ret = brush2(displayable, scope);
          if (ret) {
            (currentClipPathGroup ? currentClipPathGroup.children : out2).push(ret);
          }
        }
      }
    };
    SVGPainter2.prototype.resize = function(width, height) {
      var opts = this._opts;
      var root = this.root;
      var viewport = this._viewport;
      width != null && (opts.width = width);
      height != null && (opts.height = height);
      if (root && viewport) {
        viewport.style.display = "none";
        width = getSize(root, 0, opts);
        height = getSize(root, 1, opts);
        viewport.style.display = "";
      }
      if (this._width !== width || this._height !== height) {
        this._width = width;
        this._height = height;
        if (viewport) {
          var viewportStyle = viewport.style;
          viewportStyle.width = width + "px";
          viewportStyle.height = height + "px";
        }
        var svgDom = this._svgDom;
        if (svgDom) {
          svgDom.setAttribute("width", width);
          svgDom.setAttribute("height", height);
        }
      }
    };
    SVGPainter2.prototype.getWidth = function() {
      return this._width;
    };
    SVGPainter2.prototype.getHeight = function() {
      return this._height;
    };
    SVGPainter2.prototype.dispose = function() {
      if (this.root) {
        this.root.innerHTML = "";
      }
      this._svgDom = this._viewport = this.storage = this._oldVNode = this._bgVNode = this._mainVNode = null;
    };
    SVGPainter2.prototype.clear = function() {
      if (this._svgDom) {
        this._svgDom.innerHTML = null;
      }
      this._oldVNode = null;
    };
    SVGPainter2.prototype.toDataURL = function(base64) {
      var str = encodeURIComponent(this.renderToString());
      var prefix = "data:image/svg+xml;";
      if (base64) {
        str = encodeBase64(str);
        return str && prefix + "base64," + str;
      }
      return prefix + "charset=UTF-8," + str;
    };
    return SVGPainter2;
  }();
  function createMethodNotSupport(method) {
    return function() {
      if (true) {
        logError('In SVG mode painter not support method "' + method + '"');
      }
    };
  }
  var Painter_default = SVGPainter;

  // node_modules/echarts/lib/renderer/installSVGRenderer.js
  function install(registers) {
    registers.registerPainter("svg", Painter_default);
  }

  // node_modules/zrender/lib/canvas/Layer.js
  function createDom(id, painter, dpr2) {
    var newDom = platformApi.createCanvas();
    var width = painter.getWidth();
    var height = painter.getHeight();
    var newDomStyle = newDom.style;
    if (newDomStyle) {
      newDomStyle.position = "absolute";
      newDomStyle.left = "0";
      newDomStyle.top = "0";
      newDomStyle.width = width + "px";
      newDomStyle.height = height + "px";
      newDom.setAttribute("data-zr-dom-id", id);
    }
    newDom.width = width * dpr2;
    newDom.height = height * dpr2;
    return newDom;
  }
  var Layer = function(_super) {
    __extends2(Layer2, _super);
    function Layer2(id, painter, dpr2) {
      var _this = _super.call(this) || this;
      _this.motionBlur = false;
      _this.lastFrameAlpha = 0.7;
      _this.dpr = 1;
      _this.virtual = false;
      _this.config = {};
      _this.incremental = false;
      _this.zlevel = 0;
      _this.maxRepaintRectCount = 5;
      _this.__dirty = true;
      _this.__firstTimePaint = true;
      _this.__used = false;
      _this.__drawIndex = 0;
      _this.__startIndex = 0;
      _this.__endIndex = 0;
      _this.__prevStartIndex = null;
      _this.__prevEndIndex = null;
      var dom;
      dpr2 = dpr2 || devicePixelRatio;
      if (typeof id === "string") {
        dom = createDom(id, painter, dpr2);
      } else if (isObject(id)) {
        dom = id;
        id = dom.id;
      }
      _this.id = id;
      _this.dom = dom;
      var domStyle = dom.style;
      if (domStyle) {
        disableUserSelect(dom);
        dom.onselectstart = function() {
          return false;
        };
        domStyle.padding = "0";
        domStyle.margin = "0";
        domStyle.borderWidth = "0";
      }
      _this.painter = painter;
      _this.dpr = dpr2;
      return _this;
    }
    Layer2.prototype.getElementCount = function() {
      return this.__endIndex - this.__startIndex;
    };
    Layer2.prototype.afterBrush = function() {
      this.__prevStartIndex = this.__startIndex;
      this.__prevEndIndex = this.__endIndex;
    };
    Layer2.prototype.initContext = function() {
      this.ctx = this.dom.getContext("2d");
      this.ctx.dpr = this.dpr;
    };
    Layer2.prototype.setUnpainted = function() {
      this.__firstTimePaint = true;
    };
    Layer2.prototype.createBackBuffer = function() {
      var dpr2 = this.dpr;
      this.domBack = createDom("back-" + this.id, this.painter, dpr2);
      this.ctxBack = this.domBack.getContext("2d");
      if (dpr2 !== 1) {
        this.ctxBack.scale(dpr2, dpr2);
      }
    };
    Layer2.prototype.createRepaintRects = function(displayList, prevList, viewWidth, viewHeight) {
      if (this.__firstTimePaint) {
        this.__firstTimePaint = false;
        return null;
      }
      var mergedRepaintRects = [];
      var maxRepaintRectCount = this.maxRepaintRectCount;
      var full = false;
      var pendingRect = new BoundingRect_default(0, 0, 0, 0);
      function addRectToMergePool(rect) {
        if (!rect.isFinite() || rect.isZero()) {
          return;
        }
        if (mergedRepaintRects.length === 0) {
          var boundingRect = new BoundingRect_default(0, 0, 0, 0);
          boundingRect.copy(rect);
          mergedRepaintRects.push(boundingRect);
        } else {
          var isMerged = false;
          var minDeltaArea = Infinity;
          var bestRectToMergeIdx = 0;
          for (var i2 = 0; i2 < mergedRepaintRects.length; ++i2) {
            var mergedRect = mergedRepaintRects[i2];
            if (mergedRect.intersect(rect)) {
              var pendingRect_1 = new BoundingRect_default(0, 0, 0, 0);
              pendingRect_1.copy(mergedRect);
              pendingRect_1.union(rect);
              mergedRepaintRects[i2] = pendingRect_1;
              isMerged = true;
              break;
            } else if (full) {
              pendingRect.copy(rect);
              pendingRect.union(mergedRect);
              var aArea = rect.width * rect.height;
              var bArea = mergedRect.width * mergedRect.height;
              var pendingArea = pendingRect.width * pendingRect.height;
              var deltaArea = pendingArea - aArea - bArea;
              if (deltaArea < minDeltaArea) {
                minDeltaArea = deltaArea;
                bestRectToMergeIdx = i2;
              }
            }
          }
          if (full) {
            mergedRepaintRects[bestRectToMergeIdx].union(rect);
            isMerged = true;
          }
          if (!isMerged) {
            var boundingRect = new BoundingRect_default(0, 0, 0, 0);
            boundingRect.copy(rect);
            mergedRepaintRects.push(boundingRect);
          }
          if (!full) {
            full = mergedRepaintRects.length >= maxRepaintRectCount;
          }
        }
      }
      for (var i = this.__startIndex; i < this.__endIndex; ++i) {
        var el = displayList[i];
        if (el) {
          var shouldPaint = el.shouldBePainted(viewWidth, viewHeight, true, true);
          var prevRect = el.__isRendered && (el.__dirty & REDRAW_BIT || !shouldPaint) ? el.getPrevPaintRect() : null;
          if (prevRect) {
            addRectToMergePool(prevRect);
          }
          var curRect = shouldPaint && (el.__dirty & REDRAW_BIT || !el.__isRendered) ? el.getPaintRect() : null;
          if (curRect) {
            addRectToMergePool(curRect);
          }
        }
      }
      for (var i = this.__prevStartIndex; i < this.__prevEndIndex; ++i) {
        var el = prevList[i];
        var shouldPaint = el.shouldBePainted(viewWidth, viewHeight, true, true);
        if (el && (!shouldPaint || !el.__zr) && el.__isRendered) {
          var prevRect = el.getPrevPaintRect();
          if (prevRect) {
            addRectToMergePool(prevRect);
          }
        }
      }
      var hasIntersections;
      do {
        hasIntersections = false;
        for (var i = 0; i < mergedRepaintRects.length; ) {
          if (mergedRepaintRects[i].isZero()) {
            mergedRepaintRects.splice(i, 1);
            continue;
          }
          for (var j = i + 1; j < mergedRepaintRects.length; ) {
            if (mergedRepaintRects[i].intersect(mergedRepaintRects[j])) {
              hasIntersections = true;
              mergedRepaintRects[i].union(mergedRepaintRects[j]);
              mergedRepaintRects.splice(j, 1);
            } else {
              j++;
            }
          }
          i++;
        }
      } while (hasIntersections);
      this._paintRects = mergedRepaintRects;
      return mergedRepaintRects;
    };
    Layer2.prototype.debugGetPaintRects = function() {
      return (this._paintRects || []).slice();
    };
    Layer2.prototype.resize = function(width, height) {
      var dpr2 = this.dpr;
      var dom = this.dom;
      var domStyle = dom.style;
      var domBack = this.domBack;
      if (domStyle) {
        domStyle.width = width + "px";
        domStyle.height = height + "px";
      }
      dom.width = width * dpr2;
      dom.height = height * dpr2;
      if (domBack) {
        domBack.width = width * dpr2;
        domBack.height = height * dpr2;
        if (dpr2 !== 1) {
          this.ctxBack.scale(dpr2, dpr2);
        }
      }
    };
    Layer2.prototype.clear = function(clearAll, clearColor, repaintRects) {
      var dom = this.dom;
      var ctx = this.ctx;
      var width = dom.width;
      var height = dom.height;
      clearColor = clearColor || this.clearColor;
      var haveMotionBLur = this.motionBlur && !clearAll;
      var lastFrameAlpha = this.lastFrameAlpha;
      var dpr2 = this.dpr;
      var self2 = this;
      if (haveMotionBLur) {
        if (!this.domBack) {
          this.createBackBuffer();
        }
        this.ctxBack.globalCompositeOperation = "copy";
        this.ctxBack.drawImage(dom, 0, 0, width / dpr2, height / dpr2);
      }
      var domBack = this.domBack;
      function doClear(x, y, width2, height2) {
        ctx.clearRect(x, y, width2, height2);
        if (clearColor && clearColor !== "transparent") {
          var clearColorGradientOrPattern = void 0;
          if (isGradientObject(clearColor)) {
            clearColorGradientOrPattern = clearColor.__canvasGradient || getCanvasGradient(ctx, clearColor, {
              x: 0,
              y: 0,
              width: width2,
              height: height2
            });
            clearColor.__canvasGradient = clearColorGradientOrPattern;
          } else if (isImagePatternObject(clearColor)) {
            clearColorGradientOrPattern = createCanvasPattern(ctx, clearColor, {
              dirty: function() {
                self2.setUnpainted();
                self2.__painter.refresh();
              }
            });
          }
          ctx.save();
          ctx.fillStyle = clearColorGradientOrPattern || clearColor;
          ctx.fillRect(x, y, width2, height2);
          ctx.restore();
        }
        if (haveMotionBLur) {
          ctx.save();
          ctx.globalAlpha = lastFrameAlpha;
          ctx.drawImage(domBack, x, y, width2, height2);
          ctx.restore();
        }
      }
      ;
      if (!repaintRects || haveMotionBLur) {
        doClear(0, 0, width, height);
      } else if (repaintRects.length) {
        each(repaintRects, function(rect) {
          doClear(rect.x * dpr2, rect.y * dpr2, rect.width * dpr2, rect.height * dpr2);
        });
      }
    };
    return Layer2;
  }(Eventful_default);
  var Layer_default = Layer;

  // node_modules/zrender/lib/canvas/Painter.js
  var HOVER_LAYER_ZLEVEL = 1e5;
  var CANVAS_ZLEVEL = 314159;
  var EL_AFTER_INCREMENTAL_INC = 0.01;
  var INCREMENTAL_INC = 1e-3;
  function isLayerValid(layer) {
    if (!layer) {
      return false;
    }
    if (layer.__builtin__) {
      return true;
    }
    if (typeof layer.resize !== "function" || typeof layer.refresh !== "function") {
      return false;
    }
    return true;
  }
  function createRoot(width, height) {
    var domRoot = document.createElement("div");
    domRoot.style.cssText = [
      "position:relative",
      "width:" + width + "px",
      "height:" + height + "px",
      "padding:0",
      "margin:0",
      "border-width:0"
    ].join(";") + ";";
    return domRoot;
  }
  var CanvasPainter = function() {
    function CanvasPainter2(root, storage2, opts, id) {
      this.type = "canvas";
      this._zlevelList = [];
      this._prevDisplayList = [];
      this._layers = {};
      this._layerConfig = {};
      this._needsManuallyCompositing = false;
      this.type = "canvas";
      var singleCanvas = !root.nodeName || root.nodeName.toUpperCase() === "CANVAS";
      this._opts = opts = extend({}, opts || {});
      this.dpr = opts.devicePixelRatio || devicePixelRatio;
      this._singleCanvas = singleCanvas;
      this.root = root;
      var rootStyle = root.style;
      if (rootStyle) {
        disableUserSelect(root);
        root.innerHTML = "";
      }
      this.storage = storage2;
      var zlevelList = this._zlevelList;
      this._prevDisplayList = [];
      var layers = this._layers;
      if (!singleCanvas) {
        this._width = getSize(root, 0, opts);
        this._height = getSize(root, 1, opts);
        var domRoot = this._domRoot = createRoot(this._width, this._height);
        root.appendChild(domRoot);
      } else {
        var rootCanvas = root;
        var width = rootCanvas.width;
        var height = rootCanvas.height;
        if (opts.width != null) {
          width = opts.width;
        }
        if (opts.height != null) {
          height = opts.height;
        }
        this.dpr = opts.devicePixelRatio || 1;
        rootCanvas.width = width * this.dpr;
        rootCanvas.height = height * this.dpr;
        this._width = width;
        this._height = height;
        var mainLayer = new Layer_default(rootCanvas, this, this.dpr);
        mainLayer.__builtin__ = true;
        mainLayer.initContext();
        layers[CANVAS_ZLEVEL] = mainLayer;
        mainLayer.zlevel = CANVAS_ZLEVEL;
        zlevelList.push(CANVAS_ZLEVEL);
        this._domRoot = root;
      }
    }
    CanvasPainter2.prototype.getType = function() {
      return "canvas";
    };
    CanvasPainter2.prototype.isSingleCanvas = function() {
      return this._singleCanvas;
    };
    CanvasPainter2.prototype.getViewportRoot = function() {
      return this._domRoot;
    };
    CanvasPainter2.prototype.getViewportRootOffset = function() {
      var viewportRoot = this.getViewportRoot();
      if (viewportRoot) {
        return {
          offsetLeft: viewportRoot.offsetLeft || 0,
          offsetTop: viewportRoot.offsetTop || 0
        };
      }
    };
    CanvasPainter2.prototype.refresh = function(paintAll) {
      var list = this.storage.getDisplayList(true);
      var prevList = this._prevDisplayList;
      var zlevelList = this._zlevelList;
      this._redrawId = Math.random();
      this._paintList(list, prevList, paintAll, this._redrawId);
      for (var i = 0; i < zlevelList.length; i++) {
        var z = zlevelList[i];
        var layer = this._layers[z];
        if (!layer.__builtin__ && layer.refresh) {
          var clearColor = i === 0 ? this._backgroundColor : null;
          layer.refresh(clearColor);
        }
      }
      if (this._opts.useDirtyRect) {
        this._prevDisplayList = list.slice();
      }
      return this;
    };
    CanvasPainter2.prototype.refreshHover = function() {
      this._paintHoverList(this.storage.getDisplayList(false));
    };
    CanvasPainter2.prototype._paintHoverList = function(list) {
      var len2 = list.length;
      var hoverLayer = this._hoverlayer;
      hoverLayer && hoverLayer.clear();
      if (!len2) {
        return;
      }
      var scope = {
        inHover: true,
        viewWidth: this._width,
        viewHeight: this._height
      };
      var ctx;
      for (var i = 0; i < len2; i++) {
        var el = list[i];
        if (el.__inHover) {
          if (!hoverLayer) {
            hoverLayer = this._hoverlayer = this.getLayer(HOVER_LAYER_ZLEVEL);
          }
          if (!ctx) {
            ctx = hoverLayer.ctx;
            ctx.save();
          }
          brush(ctx, el, scope, i === len2 - 1);
        }
      }
      if (ctx) {
        ctx.restore();
      }
    };
    CanvasPainter2.prototype.getHoverLayer = function() {
      return this.getLayer(HOVER_LAYER_ZLEVEL);
    };
    CanvasPainter2.prototype.paintOne = function(ctx, el) {
      brushSingle(ctx, el);
    };
    CanvasPainter2.prototype._paintList = function(list, prevList, paintAll, redrawId) {
      if (this._redrawId !== redrawId) {
        return;
      }
      paintAll = paintAll || false;
      this._updateLayerStatus(list);
      var _a2 = this._doPaintList(list, prevList, paintAll), finished = _a2.finished, needsRefreshHover = _a2.needsRefreshHover;
      if (this._needsManuallyCompositing) {
        this._compositeManually();
      }
      if (needsRefreshHover) {
        this._paintHoverList(list);
      }
      if (!finished) {
        var self_1 = this;
        requestAnimationFrame_default(function() {
          self_1._paintList(list, prevList, paintAll, redrawId);
        });
      } else {
        this.eachLayer(function(layer) {
          layer.afterBrush && layer.afterBrush();
        });
      }
    };
    CanvasPainter2.prototype._compositeManually = function() {
      var ctx = this.getLayer(CANVAS_ZLEVEL).ctx;
      var width = this._domRoot.width;
      var height = this._domRoot.height;
      ctx.clearRect(0, 0, width, height);
      this.eachBuiltinLayer(function(layer) {
        if (layer.virtual) {
          ctx.drawImage(layer.dom, 0, 0, width, height);
        }
      });
    };
    CanvasPainter2.prototype._doPaintList = function(list, prevList, paintAll) {
      var _this = this;
      var layerList = [];
      var useDirtyRect = this._opts.useDirtyRect;
      for (var zi = 0; zi < this._zlevelList.length; zi++) {
        var zlevel = this._zlevelList[zi];
        var layer = this._layers[zlevel];
        if (layer.__builtin__ && layer !== this._hoverlayer && (layer.__dirty || paintAll)) {
          layerList.push(layer);
        }
      }
      var finished = true;
      var needsRefreshHover = false;
      var _loop_1 = function(k2) {
        var layer2 = layerList[k2];
        var ctx = layer2.ctx;
        var repaintRects = useDirtyRect && layer2.createRepaintRects(list, prevList, this_1._width, this_1._height);
        var start2 = paintAll ? layer2.__startIndex : layer2.__drawIndex;
        var useTimer = !paintAll && layer2.incremental && Date.now;
        var startTime = useTimer && Date.now();
        var clearColor = layer2.zlevel === this_1._zlevelList[0] ? this_1._backgroundColor : null;
        if (layer2.__startIndex === layer2.__endIndex) {
          layer2.clear(false, clearColor, repaintRects);
        } else if (start2 === layer2.__startIndex) {
          var firstEl = list[start2];
          if (!firstEl.incremental || !firstEl.notClear || paintAll) {
            layer2.clear(false, clearColor, repaintRects);
          }
        }
        if (start2 === -1) {
          console.error("For some unknown reason. drawIndex is -1");
          start2 = layer2.__startIndex;
        }
        var i;
        var repaint = function(repaintRect) {
          var scope = {
            inHover: false,
            allClipped: false,
            prevEl: null,
            viewWidth: _this._width,
            viewHeight: _this._height
          };
          for (i = start2; i < layer2.__endIndex; i++) {
            var el = list[i];
            if (el.__inHover) {
              needsRefreshHover = true;
            }
            _this._doPaintEl(el, layer2, useDirtyRect, repaintRect, scope, i === layer2.__endIndex - 1);
            if (useTimer) {
              var dTime = Date.now() - startTime;
              if (dTime > 15) {
                break;
              }
            }
          }
          if (scope.prevElClipPaths) {
            ctx.restore();
          }
        };
        if (repaintRects) {
          if (repaintRects.length === 0) {
            i = layer2.__endIndex;
          } else {
            var dpr2 = this_1.dpr;
            for (var r = 0; r < repaintRects.length; ++r) {
              var rect = repaintRects[r];
              ctx.save();
              ctx.beginPath();
              ctx.rect(rect.x * dpr2, rect.y * dpr2, rect.width * dpr2, rect.height * dpr2);
              ctx.clip();
              repaint(rect);
              ctx.restore();
            }
          }
        } else {
          ctx.save();
          repaint();
          ctx.restore();
        }
        layer2.__drawIndex = i;
        if (layer2.__drawIndex < layer2.__endIndex) {
          finished = false;
        }
      };
      var this_1 = this;
      for (var k = 0; k < layerList.length; k++) {
        _loop_1(k);
      }
      if (env_default.wxa) {
        each(this._layers, function(layer2) {
          if (layer2 && layer2.ctx && layer2.ctx.draw) {
            layer2.ctx.draw();
          }
        });
      }
      return {
        finished,
        needsRefreshHover
      };
    };
    CanvasPainter2.prototype._doPaintEl = function(el, currentLayer, useDirtyRect, repaintRect, scope, isLast) {
      var ctx = currentLayer.ctx;
      if (useDirtyRect) {
        var paintRect = el.getPaintRect();
        if (!repaintRect || paintRect && paintRect.intersect(repaintRect)) {
          brush(ctx, el, scope, isLast);
          el.setPrevPaintRect(paintRect);
        }
      } else {
        brush(ctx, el, scope, isLast);
      }
    };
    CanvasPainter2.prototype.getLayer = function(zlevel, virtual) {
      if (this._singleCanvas && !this._needsManuallyCompositing) {
        zlevel = CANVAS_ZLEVEL;
      }
      var layer = this._layers[zlevel];
      if (!layer) {
        layer = new Layer_default("zr_" + zlevel, this, this.dpr);
        layer.zlevel = zlevel;
        layer.__builtin__ = true;
        if (this._layerConfig[zlevel]) {
          merge(layer, this._layerConfig[zlevel], true);
        } else if (this._layerConfig[zlevel - EL_AFTER_INCREMENTAL_INC]) {
          merge(layer, this._layerConfig[zlevel - EL_AFTER_INCREMENTAL_INC], true);
        }
        if (virtual) {
          layer.virtual = virtual;
        }
        this.insertLayer(zlevel, layer);
        layer.initContext();
      }
      return layer;
    };
    CanvasPainter2.prototype.insertLayer = function(zlevel, layer) {
      var layersMap = this._layers;
      var zlevelList = this._zlevelList;
      var len2 = zlevelList.length;
      var domRoot = this._domRoot;
      var prevLayer = null;
      var i = -1;
      if (layersMap[zlevel]) {
        if (true) {
          logError("ZLevel " + zlevel + " has been used already");
        }
        return;
      }
      if (!isLayerValid(layer)) {
        if (true) {
          logError("Layer of zlevel " + zlevel + " is not valid");
        }
        return;
      }
      if (len2 > 0 && zlevel > zlevelList[0]) {
        for (i = 0; i < len2 - 1; i++) {
          if (zlevelList[i] < zlevel && zlevelList[i + 1] > zlevel) {
            break;
          }
        }
        prevLayer = layersMap[zlevelList[i]];
      }
      zlevelList.splice(i + 1, 0, zlevel);
      layersMap[zlevel] = layer;
      if (!layer.virtual) {
        if (prevLayer) {
          var prevDom = prevLayer.dom;
          if (prevDom.nextSibling) {
            domRoot.insertBefore(layer.dom, prevDom.nextSibling);
          } else {
            domRoot.appendChild(layer.dom);
          }
        } else {
          if (domRoot.firstChild) {
            domRoot.insertBefore(layer.dom, domRoot.firstChild);
          } else {
            domRoot.appendChild(layer.dom);
          }
        }
      }
      layer.__painter = this;
    };
    CanvasPainter2.prototype.eachLayer = function(cb, context) {
      var zlevelList = this._zlevelList;
      for (var i = 0; i < zlevelList.length; i++) {
        var z = zlevelList[i];
        cb.call(context, this._layers[z], z);
      }
    };
    CanvasPainter2.prototype.eachBuiltinLayer = function(cb, context) {
      var zlevelList = this._zlevelList;
      for (var i = 0; i < zlevelList.length; i++) {
        var z = zlevelList[i];
        var layer = this._layers[z];
        if (layer.__builtin__) {
          cb.call(context, layer, z);
        }
      }
    };
    CanvasPainter2.prototype.eachOtherLayer = function(cb, context) {
      var zlevelList = this._zlevelList;
      for (var i = 0; i < zlevelList.length; i++) {
        var z = zlevelList[i];
        var layer = this._layers[z];
        if (!layer.__builtin__) {
          cb.call(context, layer, z);
        }
      }
    };
    CanvasPainter2.prototype.getLayers = function() {
      return this._layers;
    };
    CanvasPainter2.prototype._updateLayerStatus = function(list) {
      this.eachBuiltinLayer(function(layer2, z) {
        layer2.__dirty = layer2.__used = false;
      });
      function updatePrevLayer(idx) {
        if (prevLayer) {
          if (prevLayer.__endIndex !== idx) {
            prevLayer.__dirty = true;
          }
          prevLayer.__endIndex = idx;
        }
      }
      if (this._singleCanvas) {
        for (var i_1 = 1; i_1 < list.length; i_1++) {
          var el = list[i_1];
          if (el.zlevel !== list[i_1 - 1].zlevel || el.incremental) {
            this._needsManuallyCompositing = true;
            break;
          }
        }
      }
      var prevLayer = null;
      var incrementalLayerCount = 0;
      var prevZlevel;
      var i;
      for (i = 0; i < list.length; i++) {
        var el = list[i];
        var zlevel = el.zlevel;
        var layer = void 0;
        if (prevZlevel !== zlevel) {
          prevZlevel = zlevel;
          incrementalLayerCount = 0;
        }
        if (el.incremental) {
          layer = this.getLayer(zlevel + INCREMENTAL_INC, this._needsManuallyCompositing);
          layer.incremental = true;
          incrementalLayerCount = 1;
        } else {
          layer = this.getLayer(zlevel + (incrementalLayerCount > 0 ? EL_AFTER_INCREMENTAL_INC : 0), this._needsManuallyCompositing);
        }
        if (!layer.__builtin__) {
          logError("ZLevel " + zlevel + " has been used by unkown layer " + layer.id);
        }
        if (layer !== prevLayer) {
          layer.__used = true;
          if (layer.__startIndex !== i) {
            layer.__dirty = true;
          }
          layer.__startIndex = i;
          if (!layer.incremental) {
            layer.__drawIndex = i;
          } else {
            layer.__drawIndex = -1;
          }
          updatePrevLayer(i);
          prevLayer = layer;
        }
        if (el.__dirty & REDRAW_BIT && !el.__inHover) {
          layer.__dirty = true;
          if (layer.incremental && layer.__drawIndex < 0) {
            layer.__drawIndex = i;
          }
        }
      }
      updatePrevLayer(i);
      this.eachBuiltinLayer(function(layer2, z) {
        if (!layer2.__used && layer2.getElementCount() > 0) {
          layer2.__dirty = true;
          layer2.__startIndex = layer2.__endIndex = layer2.__drawIndex = 0;
        }
        if (layer2.__dirty && layer2.__drawIndex < 0) {
          layer2.__drawIndex = layer2.__startIndex;
        }
      });
    };
    CanvasPainter2.prototype.clear = function() {
      this.eachBuiltinLayer(this._clearLayer);
      return this;
    };
    CanvasPainter2.prototype._clearLayer = function(layer) {
      layer.clear();
    };
    CanvasPainter2.prototype.setBackgroundColor = function(backgroundColor2) {
      this._backgroundColor = backgroundColor2;
      each(this._layers, function(layer) {
        layer.setUnpainted();
      });
    };
    CanvasPainter2.prototype.configLayer = function(zlevel, config) {
      if (config) {
        var layerConfig = this._layerConfig;
        if (!layerConfig[zlevel]) {
          layerConfig[zlevel] = config;
        } else {
          merge(layerConfig[zlevel], config, true);
        }
        for (var i = 0; i < this._zlevelList.length; i++) {
          var _zlevel = this._zlevelList[i];
          if (_zlevel === zlevel || _zlevel === zlevel + EL_AFTER_INCREMENTAL_INC) {
            var layer = this._layers[_zlevel];
            merge(layer, layerConfig[zlevel], true);
          }
        }
      }
    };
    CanvasPainter2.prototype.delLayer = function(zlevel) {
      var layers = this._layers;
      var zlevelList = this._zlevelList;
      var layer = layers[zlevel];
      if (!layer) {
        return;
      }
      layer.dom.parentNode.removeChild(layer.dom);
      delete layers[zlevel];
      zlevelList.splice(indexOf(zlevelList, zlevel), 1);
    };
    CanvasPainter2.prototype.resize = function(width, height) {
      if (!this._domRoot.style) {
        if (width == null || height == null) {
          return;
        }
        this._width = width;
        this._height = height;
        this.getLayer(CANVAS_ZLEVEL).resize(width, height);
      } else {
        var domRoot = this._domRoot;
        domRoot.style.display = "none";
        var opts = this._opts;
        var root = this.root;
        width != null && (opts.width = width);
        height != null && (opts.height = height);
        width = getSize(root, 0, opts);
        height = getSize(root, 1, opts);
        domRoot.style.display = "";
        if (this._width !== width || height !== this._height) {
          domRoot.style.width = width + "px";
          domRoot.style.height = height + "px";
          for (var id in this._layers) {
            if (this._layers.hasOwnProperty(id)) {
              this._layers[id].resize(width, height);
            }
          }
          this.refresh(true);
        }
        this._width = width;
        this._height = height;
      }
      return this;
    };
    CanvasPainter2.prototype.clearLayer = function(zlevel) {
      var layer = this._layers[zlevel];
      if (layer) {
        layer.clear();
      }
    };
    CanvasPainter2.prototype.dispose = function() {
      this.root.innerHTML = "";
      this.root = this.storage = this._domRoot = this._layers = null;
    };
    CanvasPainter2.prototype.getRenderedCanvas = function(opts) {
      opts = opts || {};
      if (this._singleCanvas && !this._compositeManually) {
        return this._layers[CANVAS_ZLEVEL].dom;
      }
      var imageLayer = new Layer_default("image", this, opts.pixelRatio || this.dpr);
      imageLayer.initContext();
      imageLayer.clear(false, opts.backgroundColor || this._backgroundColor);
      var ctx = imageLayer.ctx;
      if (opts.pixelRatio <= this.dpr) {
        this.refresh();
        var width_1 = imageLayer.dom.width;
        var height_1 = imageLayer.dom.height;
        this.eachLayer(function(layer) {
          if (layer.__builtin__) {
            ctx.drawImage(layer.dom, 0, 0, width_1, height_1);
          } else if (layer.renderToCanvas) {
            ctx.save();
            layer.renderToCanvas(ctx);
            ctx.restore();
          }
        });
      } else {
        var scope = {
          inHover: false,
          viewWidth: this._width,
          viewHeight: this._height
        };
        var displayList = this.storage.getDisplayList(true);
        for (var i = 0, len2 = displayList.length; i < len2; i++) {
          var el = displayList[i];
          brush(ctx, el, scope, i === len2 - 1);
        }
      }
      return imageLayer.dom;
    };
    CanvasPainter2.prototype.getWidth = function() {
      return this._width;
    };
    CanvasPainter2.prototype.getHeight = function() {
      return this._height;
    };
    return CanvasPainter2;
  }();
  var Painter_default2 = CanvasPainter;

  // node_modules/echarts/lib/renderer/installCanvasRenderer.js
  function install2(registers) {
    registers.registerPainter("canvas", Painter_default2);
  }

  // node_modules/echarts/lib/chart/line/LineSeries.js
  var LineSeriesModel = function(_super) {
    __extends(LineSeriesModel2, _super);
    function LineSeriesModel2() {
      var _this = _super !== null && _super.apply(this, arguments) || this;
      _this.type = LineSeriesModel2.type;
      _this.hasSymbolVisual = true;
      return _this;
    }
    LineSeriesModel2.prototype.getInitialData = function(option) {
      if (true) {
        var coordSys = option.coordinateSystem;
        if (coordSys !== "polar" && coordSys !== "cartesian2d") {
          throw new Error("Line not support coordinateSystem besides cartesian and polar");
        }
      }
      return createSeriesData_default(null, this, {
        useEncodeDefaulter: true
      });
    };
    LineSeriesModel2.prototype.getLegendIcon = function(opt) {
      var group = new Group_default();
      var line = createSymbol("line", 0, opt.itemHeight / 2, opt.itemWidth, 0, opt.lineStyle.stroke, false);
      group.add(line);
      line.setStyle(opt.lineStyle);
      var visualType = this.getData().getVisual("symbol");
      var visualRotate = this.getData().getVisual("symbolRotate");
      var symbolType = visualType === "none" ? "circle" : visualType;
      var size = opt.itemHeight * 0.8;
      var symbol = createSymbol(symbolType, (opt.itemWidth - size) / 2, (opt.itemHeight - size) / 2, size, size, opt.itemStyle.fill);
      group.add(symbol);
      symbol.setStyle(opt.itemStyle);
      var symbolRotate = opt.iconRotate === "inherit" ? visualRotate : opt.iconRotate || 0;
      symbol.rotation = symbolRotate * Math.PI / 180;
      symbol.setOrigin([opt.itemWidth / 2, opt.itemHeight / 2]);
      if (symbolType.indexOf("empty") > -1) {
        symbol.style.stroke = symbol.style.fill;
        symbol.style.fill = "#fff";
        symbol.style.lineWidth = 2;
      }
      return group;
    };
    LineSeriesModel2.type = "series.line";
    LineSeriesModel2.dependencies = ["grid", "polar"];
    LineSeriesModel2.defaultOption = {
      z: 3,
      coordinateSystem: "cartesian2d",
      legendHoverLink: true,
      clip: true,
      label: {
        position: "top"
      },
      endLabel: {
        show: false,
        valueAnimation: true,
        distance: 8
      },
      lineStyle: {
        width: 2,
        type: "solid"
      },
      emphasis: {
        scale: true
      },
      step: false,
      smooth: false,
      smoothMonotone: null,
      symbol: "emptyCircle",
      symbolSize: 4,
      symbolRotate: null,
      showSymbol: true,
      showAllSymbol: "auto",
      connectNulls: false,
      sampling: "none",
      animationEasing: "linear",
      progressive: 0,
      hoverLayerThreshold: Infinity,
      universalTransition: {
        divideShape: "clone"
      },
      triggerLineEvent: false
    };
    return LineSeriesModel2;
  }(Series_default);
  var LineSeries_default = LineSeriesModel;

  // node_modules/echarts/lib/chart/helper/labelHelper.js
  function getDefaultLabel(data, dataIndex) {
    var labelDims = data.mapDimensionsAll("defaultedLabel");
    var len2 = labelDims.length;
    if (len2 === 1) {
      var rawVal = retrieveRawValue(data, dataIndex, labelDims[0]);
      return rawVal != null ? rawVal + "" : null;
    } else if (len2) {
      var vals = [];
      for (var i = 0; i < labelDims.length; i++) {
        vals.push(retrieveRawValue(data, dataIndex, labelDims[i]));
      }
      return vals.join(" ");
    }
  }
  function getDefaultInterpolatedLabel(data, interpolatedValue) {
    var labelDims = data.mapDimensionsAll("defaultedLabel");
    if (!isArray(interpolatedValue)) {
      return interpolatedValue + "";
    }
    var vals = [];
    for (var i = 0; i < labelDims.length; i++) {
      var dimIndex = data.getDimensionIndex(labelDims[i]);
      if (dimIndex >= 0) {
        vals.push(interpolatedValue[dimIndex]);
      }
    }
    return vals.join(" ");
  }

  // node_modules/echarts/lib/chart/helper/Symbol.js
  var Symbol2 = function(_super) {
    __extends(Symbol3, _super);
    function Symbol3(data, idx, seriesScope, opts) {
      var _this = _super.call(this) || this;
      _this.updateData(data, idx, seriesScope, opts);
      return _this;
    }
    Symbol3.prototype._createSymbol = function(symbolType, data, idx, symbolSize, keepAspect) {
      this.removeAll();
      var symbolPath = createSymbol(symbolType, -1, -1, 2, 2, null, keepAspect);
      symbolPath.attr({
        z2: 100,
        culling: true,
        scaleX: symbolSize[0] / 2,
        scaleY: symbolSize[1] / 2
      });
      symbolPath.drift = driftSymbol;
      this._symbolType = symbolType;
      this.add(symbolPath);
    };
    Symbol3.prototype.stopSymbolAnimation = function(toLastFrame) {
      this.childAt(0).stopAnimation(null, toLastFrame);
    };
    Symbol3.prototype.getSymbolType = function() {
      return this._symbolType;
    };
    Symbol3.prototype.getSymbolPath = function() {
      return this.childAt(0);
    };
    Symbol3.prototype.highlight = function() {
      enterEmphasis(this.childAt(0));
    };
    Symbol3.prototype.downplay = function() {
      leaveEmphasis(this.childAt(0));
    };
    Symbol3.prototype.setZ = function(zlevel, z) {
      var symbolPath = this.childAt(0);
      symbolPath.zlevel = zlevel;
      symbolPath.z = z;
    };
    Symbol3.prototype.setDraggable = function(draggable, hasCursorOption) {
      var symbolPath = this.childAt(0);
      symbolPath.draggable = draggable;
      symbolPath.cursor = !hasCursorOption && draggable ? "move" : symbolPath.cursor;
    };
    Symbol3.prototype.updateData = function(data, idx, seriesScope, opts) {
      this.silent = false;
      var symbolType = data.getItemVisual(idx, "symbol") || "circle";
      var seriesModel = data.hostModel;
      var symbolSize = Symbol3.getSymbolSize(data, idx);
      var isInit = symbolType !== this._symbolType;
      var disableAnimation = opts && opts.disableAnimation;
      if (isInit) {
        var keepAspect = data.getItemVisual(idx, "symbolKeepAspect");
        this._createSymbol(symbolType, data, idx, symbolSize, keepAspect);
      } else {
        var symbolPath = this.childAt(0);
        symbolPath.silent = false;
        var target = {
          scaleX: symbolSize[0] / 2,
          scaleY: symbolSize[1] / 2
        };
        disableAnimation ? symbolPath.attr(target) : updateProps(symbolPath, target, seriesModel, idx);
        saveOldStyle(symbolPath);
      }
      this._updateCommon(data, idx, symbolSize, seriesScope, opts);
      if (isInit) {
        var symbolPath = this.childAt(0);
        if (!disableAnimation) {
          var target = {
            scaleX: this._sizeX,
            scaleY: this._sizeY,
            style: {
              opacity: symbolPath.style.opacity
            }
          };
          symbolPath.scaleX = symbolPath.scaleY = 0;
          symbolPath.style.opacity = 0;
          initProps(symbolPath, target, seriesModel, idx);
        }
      }
      if (disableAnimation) {
        this.childAt(0).stopAnimation("leave");
      }
    };
    Symbol3.prototype._updateCommon = function(data, idx, symbolSize, seriesScope, opts) {
      var symbolPath = this.childAt(0);
      var seriesModel = data.hostModel;
      var emphasisItemStyle;
      var blurItemStyle;
      var selectItemStyle;
      var focus;
      var blurScope;
      var emphasisDisabled;
      var labelStatesModels;
      var hoverScale;
      var cursorStyle;
      if (seriesScope) {
        emphasisItemStyle = seriesScope.emphasisItemStyle;
        blurItemStyle = seriesScope.blurItemStyle;
        selectItemStyle = seriesScope.selectItemStyle;
        focus = seriesScope.focus;
        blurScope = seriesScope.blurScope;
        labelStatesModels = seriesScope.labelStatesModels;
        hoverScale = seriesScope.hoverScale;
        cursorStyle = seriesScope.cursorStyle;
        emphasisDisabled = seriesScope.emphasisDisabled;
      }
      if (!seriesScope || data.hasItemOption) {
        var itemModel = seriesScope && seriesScope.itemModel ? seriesScope.itemModel : data.getItemModel(idx);
        var emphasisModel = itemModel.getModel("emphasis");
        emphasisItemStyle = emphasisModel.getModel("itemStyle").getItemStyle();
        selectItemStyle = itemModel.getModel(["select", "itemStyle"]).getItemStyle();
        blurItemStyle = itemModel.getModel(["blur", "itemStyle"]).getItemStyle();
        focus = emphasisModel.get("focus");
        blurScope = emphasisModel.get("blurScope");
        emphasisDisabled = emphasisModel.get("disabled");
        labelStatesModels = getLabelStatesModels(itemModel);
        hoverScale = emphasisModel.getShallow("scale");
        cursorStyle = itemModel.getShallow("cursor");
      }
      var symbolRotate = data.getItemVisual(idx, "symbolRotate");
      symbolPath.attr("rotation", (symbolRotate || 0) * Math.PI / 180 || 0);
      var symbolOffset = normalizeSymbolOffset(data.getItemVisual(idx, "symbolOffset"), symbolSize);
      if (symbolOffset) {
        symbolPath.x = symbolOffset[0];
        symbolPath.y = symbolOffset[1];
      }
      cursorStyle && symbolPath.attr("cursor", cursorStyle);
      var symbolStyle = data.getItemVisual(idx, "style");
      var visualColor = symbolStyle.fill;
      if (symbolPath instanceof Image_default) {
        var pathStyle = symbolPath.style;
        symbolPath.useStyle(extend({
          image: pathStyle.image,
          x: pathStyle.x,
          y: pathStyle.y,
          width: pathStyle.width,
          height: pathStyle.height
        }, symbolStyle));
      } else {
        if (symbolPath.__isEmptyBrush) {
          symbolPath.useStyle(extend({}, symbolStyle));
        } else {
          symbolPath.useStyle(symbolStyle);
        }
        symbolPath.style.decal = null;
        symbolPath.setColor(visualColor, opts && opts.symbolInnerColor);
        symbolPath.style.strokeNoScale = true;
      }
      var liftZ = data.getItemVisual(idx, "liftZ");
      var z2Origin = this._z2;
      if (liftZ != null) {
        if (z2Origin == null) {
          this._z2 = symbolPath.z2;
          symbolPath.z2 += liftZ;
        }
      } else if (z2Origin != null) {
        symbolPath.z2 = z2Origin;
        this._z2 = null;
      }
      var useNameLabel = opts && opts.useNameLabel;
      setLabelStyle(symbolPath, labelStatesModels, {
        labelFetcher: seriesModel,
        labelDataIndex: idx,
        defaultText: getLabelDefaultText,
        inheritColor: visualColor,
        defaultOpacity: symbolStyle.opacity
      });
      function getLabelDefaultText(idx2) {
        return useNameLabel ? data.getName(idx2) : getDefaultLabel(data, idx2);
      }
      this._sizeX = symbolSize[0] / 2;
      this._sizeY = symbolSize[1] / 2;
      var emphasisState = symbolPath.ensureState("emphasis");
      emphasisState.style = emphasisItemStyle;
      symbolPath.ensureState("select").style = selectItemStyle;
      symbolPath.ensureState("blur").style = blurItemStyle;
      if (hoverScale) {
        var scaleRatio = Math.max(isNumber(hoverScale) ? hoverScale : 1.1, 3 / this._sizeY);
        emphasisState.scaleX = this._sizeX * scaleRatio;
        emphasisState.scaleY = this._sizeY * scaleRatio;
      }
      this.setSymbolScale(1);
      toggleHoverEmphasis(this, focus, blurScope, emphasisDisabled);
    };
    Symbol3.prototype.setSymbolScale = function(scale4) {
      this.scaleX = this.scaleY = scale4;
    };
    Symbol3.prototype.fadeOut = function(cb, seriesModel, opt) {
      var symbolPath = this.childAt(0);
      var dataIndex = getECData(this).dataIndex;
      var animationOpt = opt && opt.animation;
      this.silent = symbolPath.silent = true;
      if (opt && opt.fadeLabel) {
        var textContent = symbolPath.getTextContent();
        if (textContent) {
          removeElement(textContent, {
            style: {
              opacity: 0
            }
          }, seriesModel, {
            dataIndex,
            removeOpt: animationOpt,
            cb: function() {
              symbolPath.removeTextContent();
            }
          });
        }
      } else {
        symbolPath.removeTextContent();
      }
      removeElement(symbolPath, {
        style: {
          opacity: 0
        },
        scaleX: 0,
        scaleY: 0
      }, seriesModel, {
        dataIndex,
        cb,
        removeOpt: animationOpt
      });
    };
    Symbol3.getSymbolSize = function(data, idx) {
      return normalizeSymbolSize(data.getItemVisual(idx, "symbolSize"));
    };
    return Symbol3;
  }(Group_default);
  function driftSymbol(dx, dy) {
    this.parent.drift(dx, dy);
  }
  var Symbol_default = Symbol2;

  // node_modules/echarts/lib/chart/helper/SymbolDraw.js
  function symbolNeedsDraw(data, point, idx, opt) {
    return point && !isNaN(point[0]) && !isNaN(point[1]) && !(opt.isIgnore && opt.isIgnore(idx)) && !(opt.clipShape && !opt.clipShape.contain(point[0], point[1])) && data.getItemVisual(idx, "symbol") !== "none";
  }
  function normalizeUpdateOpt(opt) {
    if (opt != null && !isObject(opt)) {
      opt = {
        isIgnore: opt
      };
    }
    return opt || {};
  }
  function makeSeriesScope(data) {
    var seriesModel = data.hostModel;
    var emphasisModel = seriesModel.getModel("emphasis");
    return {
      emphasisItemStyle: emphasisModel.getModel("itemStyle").getItemStyle(),
      blurItemStyle: seriesModel.getModel(["blur", "itemStyle"]).getItemStyle(),
      selectItemStyle: seriesModel.getModel(["select", "itemStyle"]).getItemStyle(),
      focus: emphasisModel.get("focus"),
      blurScope: emphasisModel.get("blurScope"),
      emphasisDisabled: emphasisModel.get("disabled"),
      hoverScale: emphasisModel.get("scale"),
      labelStatesModels: getLabelStatesModels(seriesModel),
      cursorStyle: seriesModel.get("cursor")
    };
  }
  var SymbolDraw = function() {
    function SymbolDraw2(SymbolCtor) {
      this.group = new Group_default();
      this._SymbolCtor = SymbolCtor || Symbol_default;
    }
    SymbolDraw2.prototype.updateData = function(data, opt) {
      this._progressiveEls = null;
      opt = normalizeUpdateOpt(opt);
      var group = this.group;
      var seriesModel = data.hostModel;
      var oldData = this._data;
      var SymbolCtor = this._SymbolCtor;
      var disableAnimation = opt.disableAnimation;
      var seriesScope = makeSeriesScope(data);
      var symbolUpdateOpt = {
        disableAnimation
      };
      var getSymbolPoint = opt.getSymbolPoint || function(idx) {
        return data.getItemLayout(idx);
      };
      if (!oldData) {
        group.removeAll();
      }
      data.diff(oldData).add(function(newIdx) {
        var point = getSymbolPoint(newIdx);
        if (symbolNeedsDraw(data, point, newIdx, opt)) {
          var symbolEl = new SymbolCtor(data, newIdx, seriesScope, symbolUpdateOpt);
          symbolEl.setPosition(point);
          data.setItemGraphicEl(newIdx, symbolEl);
          group.add(symbolEl);
        }
      }).update(function(newIdx, oldIdx) {
        var symbolEl = oldData.getItemGraphicEl(oldIdx);
        var point = getSymbolPoint(newIdx);
        if (!symbolNeedsDraw(data, point, newIdx, opt)) {
          group.remove(symbolEl);
          return;
        }
        var newSymbolType = data.getItemVisual(newIdx, "symbol") || "circle";
        var oldSymbolType = symbolEl && symbolEl.getSymbolType && symbolEl.getSymbolType();
        if (!symbolEl || oldSymbolType && oldSymbolType !== newSymbolType) {
          group.remove(symbolEl);
          symbolEl = new SymbolCtor(data, newIdx, seriesScope, symbolUpdateOpt);
          symbolEl.setPosition(point);
        } else {
          symbolEl.updateData(data, newIdx, seriesScope, symbolUpdateOpt);
          var target = {
            x: point[0],
            y: point[1]
          };
          disableAnimation ? symbolEl.attr(target) : updateProps(symbolEl, target, seriesModel);
        }
        group.add(symbolEl);
        data.setItemGraphicEl(newIdx, symbolEl);
      }).remove(function(oldIdx) {
        var el = oldData.getItemGraphicEl(oldIdx);
        el && el.fadeOut(function() {
          group.remove(el);
        }, seriesModel);
      }).execute();
      this._getSymbolPoint = getSymbolPoint;
      this._data = data;
    };
    ;
    SymbolDraw2.prototype.updateLayout = function() {
      var _this = this;
      var data = this._data;
      if (data) {
        data.eachItemGraphicEl(function(el, idx) {
          var point = _this._getSymbolPoint(idx);
          el.setPosition(point);
          el.markRedraw();
        });
      }
    };
    ;
    SymbolDraw2.prototype.incrementalPrepareUpdate = function(data) {
      this._seriesScope = makeSeriesScope(data);
      this._data = null;
      this.group.removeAll();
    };
    ;
    SymbolDraw2.prototype.incrementalUpdate = function(taskParams, data, opt) {
      this._progressiveEls = [];
      opt = normalizeUpdateOpt(opt);
      function updateIncrementalAndHover(el2) {
        if (!el2.isGroup) {
          el2.incremental = true;
          el2.ensureState("emphasis").hoverLayer = true;
        }
      }
      for (var idx = taskParams.start; idx < taskParams.end; idx++) {
        var point = data.getItemLayout(idx);
        if (symbolNeedsDraw(data, point, idx, opt)) {
          var el = new this._SymbolCtor(data, idx, this._seriesScope);
          el.traverse(updateIncrementalAndHover);
          el.setPosition(point);
          this.group.add(el);
          data.setItemGraphicEl(idx, el);
          this._progressiveEls.push(el);
        }
      }
    };
    ;
    SymbolDraw2.prototype.eachRendered = function(cb) {
      traverseElements(this._progressiveEls || this.group, cb);
    };
    SymbolDraw2.prototype.remove = function(enableAnimation) {
      var group = this.group;
      var data = this._data;
      if (data && enableAnimation) {
        data.eachItemGraphicEl(function(el) {
          el.fadeOut(function() {
            group.remove(el);
          }, data.hostModel);
        });
      } else {
        group.removeAll();
      }
    };
    ;
    return SymbolDraw2;
  }();
  var SymbolDraw_default = SymbolDraw;

  // node_modules/echarts/lib/chart/line/helper.js
  function prepareDataCoordInfo(coordSys, data, valueOrigin) {
    var baseAxis = coordSys.getBaseAxis();
    var valueAxis2 = coordSys.getOtherAxis(baseAxis);
    var valueStart = getValueStart(valueAxis2, valueOrigin);
    var baseAxisDim = baseAxis.dim;
    var valueAxisDim = valueAxis2.dim;
    var valueDim = data.mapDimension(valueAxisDim);
    var baseDim = data.mapDimension(baseAxisDim);
    var baseDataOffset = valueAxisDim === "x" || valueAxisDim === "radius" ? 1 : 0;
    var dims = map(coordSys.dimensions, function(coordDim) {
      return data.mapDimension(coordDim);
    });
    var stacked = false;
    var stackResultDim = data.getCalculationInfo("stackResultDimension");
    if (isDimensionStacked(data, dims[0])) {
      stacked = true;
      dims[0] = stackResultDim;
    }
    if (isDimensionStacked(data, dims[1])) {
      stacked = true;
      dims[1] = stackResultDim;
    }
    return {
      dataDimsForPoint: dims,
      valueStart,
      valueAxisDim,
      baseAxisDim,
      stacked: !!stacked,
      valueDim,
      baseDim,
      baseDataOffset,
      stackedOverDimension: data.getCalculationInfo("stackedOverDimension")
    };
  }
  function getValueStart(valueAxis2, valueOrigin) {
    var valueStart = 0;
    var extent3 = valueAxis2.scale.getExtent();
    if (valueOrigin === "start") {
      valueStart = extent3[0];
    } else if (valueOrigin === "end") {
      valueStart = extent3[1];
    } else if (isNumber(valueOrigin) && !isNaN(valueOrigin)) {
      valueStart = valueOrigin;
    } else {
      if (extent3[0] > 0) {
        valueStart = extent3[0];
      } else if (extent3[1] < 0) {
        valueStart = extent3[1];
      }
    }
    return valueStart;
  }
  function getStackedOnPoint(dataCoordInfo, coordSys, data, idx) {
    var value = NaN;
    if (dataCoordInfo.stacked) {
      value = data.get(data.getCalculationInfo("stackedOverDimension"), idx);
    }
    if (isNaN(value)) {
      value = dataCoordInfo.valueStart;
    }
    var baseDataOffset = dataCoordInfo.baseDataOffset;
    var stackedData = [];
    stackedData[baseDataOffset] = data.get(dataCoordInfo.baseDim, idx);
    stackedData[1 - baseDataOffset] = value;
    return coordSys.dataToPoint(stackedData);
  }

  // node_modules/echarts/lib/chart/line/lineAnimationDiff.js
  function diffData(oldData, newData) {
    var diffResult = [];
    newData.diff(oldData).add(function(idx) {
      diffResult.push({
        cmd: "+",
        idx
      });
    }).update(function(newIdx, oldIdx) {
      diffResult.push({
        cmd: "=",
        idx: oldIdx,
        idx1: newIdx
      });
    }).remove(function(idx) {
      diffResult.push({
        cmd: "-",
        idx
      });
    }).execute();
    return diffResult;
  }
  function lineAnimationDiff(oldData, newData, oldStackedOnPoints, newStackedOnPoints, oldCoordSys, newCoordSys, oldValueOrigin, newValueOrigin) {
    var diff = diffData(oldData, newData);
    var currPoints = [];
    var nextPoints = [];
    var currStackedPoints = [];
    var nextStackedPoints = [];
    var status = [];
    var sortedIndices = [];
    var rawIndices = [];
    var newDataOldCoordInfo = prepareDataCoordInfo(oldCoordSys, newData, oldValueOrigin);
    var oldPoints = oldData.getLayout("points") || [];
    var newPoints = newData.getLayout("points") || [];
    for (var i = 0; i < diff.length; i++) {
      var diffItem = diff[i];
      var pointAdded = true;
      var oldIdx2 = void 0;
      var newIdx2 = void 0;
      switch (diffItem.cmd) {
        case "=":
          oldIdx2 = diffItem.idx * 2;
          newIdx2 = diffItem.idx1 * 2;
          var currentX = oldPoints[oldIdx2];
          var currentY = oldPoints[oldIdx2 + 1];
          var nextX = newPoints[newIdx2];
          var nextY = newPoints[newIdx2 + 1];
          if (isNaN(currentX) || isNaN(currentY)) {
            currentX = nextX;
            currentY = nextY;
          }
          currPoints.push(currentX, currentY);
          nextPoints.push(nextX, nextY);
          currStackedPoints.push(oldStackedOnPoints[oldIdx2], oldStackedOnPoints[oldIdx2 + 1]);
          nextStackedPoints.push(newStackedOnPoints[newIdx2], newStackedOnPoints[newIdx2 + 1]);
          rawIndices.push(newData.getRawIndex(diffItem.idx1));
          break;
        case "+":
          var newIdx = diffItem.idx;
          var newDataDimsForPoint = newDataOldCoordInfo.dataDimsForPoint;
          var oldPt = oldCoordSys.dataToPoint([newData.get(newDataDimsForPoint[0], newIdx), newData.get(newDataDimsForPoint[1], newIdx)]);
          newIdx2 = newIdx * 2;
          currPoints.push(oldPt[0], oldPt[1]);
          nextPoints.push(newPoints[newIdx2], newPoints[newIdx2 + 1]);
          var stackedOnPoint = getStackedOnPoint(newDataOldCoordInfo, oldCoordSys, newData, newIdx);
          currStackedPoints.push(stackedOnPoint[0], stackedOnPoint[1]);
          nextStackedPoints.push(newStackedOnPoints[newIdx2], newStackedOnPoints[newIdx2 + 1]);
          rawIndices.push(newData.getRawIndex(newIdx));
          break;
        case "-":
          pointAdded = false;
      }
      if (pointAdded) {
        status.push(diffItem);
        sortedIndices.push(sortedIndices.length);
      }
    }
    sortedIndices.sort(function(a, b) {
      return rawIndices[a] - rawIndices[b];
    });
    var len2 = currPoints.length;
    var sortedCurrPoints = createFloat32Array(len2);
    var sortedNextPoints = createFloat32Array(len2);
    var sortedCurrStackedPoints = createFloat32Array(len2);
    var sortedNextStackedPoints = createFloat32Array(len2);
    var sortedStatus = [];
    for (var i = 0; i < sortedIndices.length; i++) {
      var idx = sortedIndices[i];
      var i2 = i * 2;
      var idx2 = idx * 2;
      sortedCurrPoints[i2] = currPoints[idx2];
      sortedCurrPoints[i2 + 1] = currPoints[idx2 + 1];
      sortedNextPoints[i2] = nextPoints[idx2];
      sortedNextPoints[i2 + 1] = nextPoints[idx2 + 1];
      sortedCurrStackedPoints[i2] = currStackedPoints[idx2];
      sortedCurrStackedPoints[i2 + 1] = currStackedPoints[idx2 + 1];
      sortedNextStackedPoints[i2] = nextStackedPoints[idx2];
      sortedNextStackedPoints[i2 + 1] = nextStackedPoints[idx2 + 1];
      sortedStatus[i] = status[idx];
    }
    return {
      current: sortedCurrPoints,
      next: sortedNextPoints,
      stackedOnCurrent: sortedCurrStackedPoints,
      stackedOnNext: sortedNextStackedPoints,
      status: sortedStatus
    };
  }

  // node_modules/echarts/lib/chart/line/poly.js
  var mathMin6 = Math.min;
  var mathMax6 = Math.max;
  function isPointNull(x, y) {
    return isNaN(x) || isNaN(y);
  }
  function drawSegment(ctx, points4, start2, segLen, allLen, dir3, smooth, smoothMonotone, connectNulls) {
    var prevX;
    var prevY;
    var cpx0;
    var cpy0;
    var cpx1;
    var cpy1;
    var idx = start2;
    var k = 0;
    for (; k < segLen; k++) {
      var x = points4[idx * 2];
      var y = points4[idx * 2 + 1];
      if (idx >= allLen || idx < 0) {
        break;
      }
      if (isPointNull(x, y)) {
        if (connectNulls) {
          idx += dir3;
          continue;
        }
        break;
      }
      if (idx === start2) {
        ctx[dir3 > 0 ? "moveTo" : "lineTo"](x, y);
        cpx0 = x;
        cpy0 = y;
      } else {
        var dx = x - prevX;
        var dy = y - prevY;
        if (dx * dx + dy * dy < 0.5) {
          idx += dir3;
          continue;
        }
        if (smooth > 0) {
          var nextIdx = idx + dir3;
          var nextX = points4[nextIdx * 2];
          var nextY = points4[nextIdx * 2 + 1];
          while (nextX === x && nextY === y && k < segLen) {
            k++;
            nextIdx += dir3;
            idx += dir3;
            nextX = points4[nextIdx * 2];
            nextY = points4[nextIdx * 2 + 1];
            x = points4[idx * 2];
            y = points4[idx * 2 + 1];
            dx = x - prevX;
            dy = y - prevY;
          }
          var tmpK = k + 1;
          if (connectNulls) {
            while (isPointNull(nextX, nextY) && tmpK < segLen) {
              tmpK++;
              nextIdx += dir3;
              nextX = points4[nextIdx * 2];
              nextY = points4[nextIdx * 2 + 1];
            }
          }
          var ratioNextSeg = 0.5;
          var vx = 0;
          var vy = 0;
          var nextCpx0 = void 0;
          var nextCpy0 = void 0;
          if (tmpK >= segLen || isPointNull(nextX, nextY)) {
            cpx1 = x;
            cpy1 = y;
          } else {
            vx = nextX - prevX;
            vy = nextY - prevY;
            var dx0 = x - prevX;
            var dx1 = nextX - x;
            var dy0 = y - prevY;
            var dy1 = nextY - y;
            var lenPrevSeg = void 0;
            var lenNextSeg = void 0;
            if (smoothMonotone === "x") {
              lenPrevSeg = Math.abs(dx0);
              lenNextSeg = Math.abs(dx1);
              var dir_1 = vx > 0 ? 1 : -1;
              cpx1 = x - dir_1 * lenPrevSeg * smooth;
              cpy1 = y;
              nextCpx0 = x + dir_1 * lenNextSeg * smooth;
              nextCpy0 = y;
            } else if (smoothMonotone === "y") {
              lenPrevSeg = Math.abs(dy0);
              lenNextSeg = Math.abs(dy1);
              var dir_2 = vy > 0 ? 1 : -1;
              cpx1 = x;
              cpy1 = y - dir_2 * lenPrevSeg * smooth;
              nextCpx0 = x;
              nextCpy0 = y + dir_2 * lenNextSeg * smooth;
            } else {
              lenPrevSeg = Math.sqrt(dx0 * dx0 + dy0 * dy0);
              lenNextSeg = Math.sqrt(dx1 * dx1 + dy1 * dy1);
              ratioNextSeg = lenNextSeg / (lenNextSeg + lenPrevSeg);
              cpx1 = x - vx * smooth * (1 - ratioNextSeg);
              cpy1 = y - vy * smooth * (1 - ratioNextSeg);
              nextCpx0 = x + vx * smooth * ratioNextSeg;
              nextCpy0 = y + vy * smooth * ratioNextSeg;
              nextCpx0 = mathMin6(nextCpx0, mathMax6(nextX, x));
              nextCpy0 = mathMin6(nextCpy0, mathMax6(nextY, y));
              nextCpx0 = mathMax6(nextCpx0, mathMin6(nextX, x));
              nextCpy0 = mathMax6(nextCpy0, mathMin6(nextY, y));
              vx = nextCpx0 - x;
              vy = nextCpy0 - y;
              cpx1 = x - vx * lenPrevSeg / lenNextSeg;
              cpy1 = y - vy * lenPrevSeg / lenNextSeg;
              cpx1 = mathMin6(cpx1, mathMax6(prevX, x));
              cpy1 = mathMin6(cpy1, mathMax6(prevY, y));
              cpx1 = mathMax6(cpx1, mathMin6(prevX, x));
              cpy1 = mathMax6(cpy1, mathMin6(prevY, y));
              vx = x - cpx1;
              vy = y - cpy1;
              nextCpx0 = x + vx * lenNextSeg / lenPrevSeg;
              nextCpy0 = y + vy * lenNextSeg / lenPrevSeg;
            }
          }
          ctx.bezierCurveTo(cpx0, cpy0, cpx1, cpy1, x, y);
          cpx0 = nextCpx0;
          cpy0 = nextCpy0;
        } else {
          ctx.lineTo(x, y);
        }
      }
      prevX = x;
      prevY = y;
      idx += dir3;
    }
    return k;
  }
  var ECPolylineShape = function() {
    function ECPolylineShape2() {
      this.smooth = 0;
      this.smoothConstraint = true;
    }
    return ECPolylineShape2;
  }();
  var ECPolyline = function(_super) {
    __extends(ECPolyline2, _super);
    function ECPolyline2(opts) {
      var _this = _super.call(this, opts) || this;
      _this.type = "ec-polyline";
      return _this;
    }
    ECPolyline2.prototype.getDefaultStyle = function() {
      return {
        stroke: "#000",
        fill: null
      };
    };
    ECPolyline2.prototype.getDefaultShape = function() {
      return new ECPolylineShape();
    };
    ECPolyline2.prototype.buildPath = function(ctx, shape) {
      var points4 = shape.points;
      var i = 0;
      var len2 = points4.length / 2;
      if (shape.connectNulls) {
        for (; len2 > 0; len2--) {
          if (!isPointNull(points4[len2 * 2 - 2], points4[len2 * 2 - 1])) {
            break;
          }
        }
        for (; i < len2; i++) {
          if (!isPointNull(points4[i * 2], points4[i * 2 + 1])) {
            break;
          }
        }
      }
      while (i < len2) {
        i += drawSegment(ctx, points4, i, len2, len2, 1, shape.smooth, shape.smoothMonotone, shape.connectNulls) + 1;
      }
    };
    ECPolyline2.prototype.getPointOn = function(xOrY, dim) {
      if (!this.path) {
        this.createPathProxy();
        this.buildPath(this.path, this.shape);
      }
      var path = this.path;
      var data = path.data;
      var CMD6 = PathProxy_default.CMD;
      var x0;
      var y0;
      var isDimX = dim === "x";
      var roots2 = [];
      for (var i = 0; i < data.length; ) {
        var cmd = data[i++];
        var x = void 0;
        var y = void 0;
        var x2 = void 0;
        var y2 = void 0;
        var x3 = void 0;
        var y3 = void 0;
        var t = void 0;
        switch (cmd) {
          case CMD6.M:
            x0 = data[i++];
            y0 = data[i++];
            break;
          case CMD6.L:
            x = data[i++];
            y = data[i++];
            t = isDimX ? (xOrY - x0) / (x - x0) : (xOrY - y0) / (y - y0);
            if (t <= 1 && t >= 0) {
              var val = isDimX ? (y - y0) * t + y0 : (x - x0) * t + x0;
              return isDimX ? [xOrY, val] : [val, xOrY];
            }
            x0 = x;
            y0 = y;
            break;
          case CMD6.C:
            x = data[i++];
            y = data[i++];
            x2 = data[i++];
            y2 = data[i++];
            x3 = data[i++];
            y3 = data[i++];
            var nRoot = isDimX ? cubicRootAt(x0, x, x2, x3, xOrY, roots2) : cubicRootAt(y0, y, y2, y3, xOrY, roots2);
            if (nRoot > 0) {
              for (var i_1 = 0; i_1 < nRoot; i_1++) {
                var t_1 = roots2[i_1];
                if (t_1 <= 1 && t_1 >= 0) {
                  var val = isDimX ? cubicAt(y0, y, y2, y3, t_1) : cubicAt(x0, x, x2, x3, t_1);
                  return isDimX ? [xOrY, val] : [val, xOrY];
                }
              }
            }
            x0 = x3;
            y0 = y3;
            break;
        }
      }
    };
    return ECPolyline2;
  }(Path_default);
  var ECPolygonShape = function(_super) {
    __extends(ECPolygonShape2, _super);
    function ECPolygonShape2() {
      return _super !== null && _super.apply(this, arguments) || this;
    }
    return ECPolygonShape2;
  }(ECPolylineShape);
  var ECPolygon = function(_super) {
    __extends(ECPolygon2, _super);
    function ECPolygon2(opts) {
      var _this = _super.call(this, opts) || this;
      _this.type = "ec-polygon";
      return _this;
    }
    ECPolygon2.prototype.getDefaultShape = function() {
      return new ECPolygonShape();
    };
    ECPolygon2.prototype.buildPath = function(ctx, shape) {
      var points4 = shape.points;
      var stackedOnPoints = shape.stackedOnPoints;
      var i = 0;
      var len2 = points4.length / 2;
      var smoothMonotone = shape.smoothMonotone;
      if (shape.connectNulls) {
        for (; len2 > 0; len2--) {
          if (!isPointNull(points4[len2 * 2 - 2], points4[len2 * 2 - 1])) {
            break;
          }
        }
        for (; i < len2; i++) {
          if (!isPointNull(points4[i * 2], points4[i * 2 + 1])) {
            break;
          }
        }
      }
      while (i < len2) {
        var k = drawSegment(ctx, points4, i, len2, len2, 1, shape.smooth, smoothMonotone, shape.connectNulls);
        drawSegment(ctx, stackedOnPoints, i + k - 1, k, len2, -1, shape.stackedOnSmooth, smoothMonotone, shape.connectNulls);
        i += k + 1;
        ctx.closePath();
      }
    };
    return ECPolygon2;
  }(Path_default);

  // node_modules/echarts/lib/chart/helper/createClipPathFromCoordSys.js
  function createGridClipPath(cartesian, hasAnimation, seriesModel, done, during) {
    var rect = cartesian.getArea();
    var x = rect.x;
    var y = rect.y;
    var width = rect.width;
    var height = rect.height;
    var lineWidth = seriesModel.get(["lineStyle", "width"]) || 2;
    x -= lineWidth / 2;
    y -= lineWidth / 2;
    width += lineWidth;
    height += lineWidth;
    x = Math.floor(x);
    width = Math.round(width);
    var clipPath = new Rect_default({
      shape: {
        x,
        y,
        width,
        height
      }
    });
    if (hasAnimation) {
      var baseAxis = cartesian.getBaseAxis();
      var isHorizontal = baseAxis.isHorizontal();
      var isAxisInversed = baseAxis.inverse;
      if (isHorizontal) {
        if (isAxisInversed) {
          clipPath.shape.x += width;
        }
        clipPath.shape.width = 0;
      } else {
        if (!isAxisInversed) {
          clipPath.shape.y += height;
        }
        clipPath.shape.height = 0;
      }
      var duringCb = isFunction(during) ? function(percent) {
        during(percent, clipPath);
      } : null;
      initProps(clipPath, {
        shape: {
          width,
          height,
          x,
          y
        }
      }, seriesModel, null, done, duringCb);
    }
    return clipPath;
  }
  function createPolarClipPath(polar, hasAnimation, seriesModel) {
    var sectorArea = polar.getArea();
    var r0 = round(sectorArea.r0, 1);
    var r = round(sectorArea.r, 1);
    var clipPath = new Sector_default({
      shape: {
        cx: round(polar.cx, 1),
        cy: round(polar.cy, 1),
        r0,
        r,
        startAngle: sectorArea.startAngle,
        endAngle: sectorArea.endAngle,
        clockwise: sectorArea.clockwise
      }
    });
    if (hasAnimation) {
      var isRadial = polar.getBaseAxis().dim === "angle";
      if (isRadial) {
        clipPath.shape.endAngle = sectorArea.startAngle;
      } else {
        clipPath.shape.r = r0;
      }
      initProps(clipPath, {
        shape: {
          endAngle: sectorArea.endAngle,
          r
        }
      }, seriesModel);
    }
    return clipPath;
  }
  function createClipPath(coordSys, hasAnimation, seriesModel, done, during) {
    if (!coordSys) {
      return null;
    } else if (coordSys.type === "polar") {
      return createPolarClipPath(coordSys, hasAnimation, seriesModel);
    } else if (coordSys.type === "cartesian2d") {
      return createGridClipPath(coordSys, hasAnimation, seriesModel, done, during);
    }
    return null;
  }

  // node_modules/echarts/lib/coord/CoordinateSystem.js
  function isCoordinateSystemType(coordSys, type) {
    return coordSys.type === type;
  }

  // node_modules/echarts/lib/chart/line/LineView.js
  function isPointsSame(points1, points22) {
    if (points1.length !== points22.length) {
      return;
    }
    for (var i = 0; i < points1.length; i++) {
      if (points1[i] !== points22[i]) {
        return;
      }
    }
    return true;
  }
  function bboxFromPoints(points4) {
    var minX = Infinity;
    var minY = Infinity;
    var maxX = -Infinity;
    var maxY = -Infinity;
    for (var i = 0; i < points4.length; ) {
      var x = points4[i++];
      var y = points4[i++];
      if (!isNaN(x)) {
        minX = Math.min(x, minX);
        maxX = Math.max(x, maxX);
      }
      if (!isNaN(y)) {
        minY = Math.min(y, minY);
        maxY = Math.max(y, maxY);
      }
    }
    return [[minX, minY], [maxX, maxY]];
  }
  function getBoundingDiff(points1, points22) {
    var _a2 = bboxFromPoints(points1), min1 = _a2[0], max1 = _a2[1];
    var _b2 = bboxFromPoints(points22), min23 = _b2[0], max23 = _b2[1];
    return Math.max(Math.abs(min1[0] - min23[0]), Math.abs(min1[1] - min23[1]), Math.abs(max1[0] - max23[0]), Math.abs(max1[1] - max23[1]));
  }
  function getSmooth(smooth) {
    return isNumber(smooth) ? smooth : smooth ? 0.5 : 0;
  }
  function getStackedOnPoints(coordSys, data, dataCoordInfo) {
    if (!dataCoordInfo.valueDim) {
      return [];
    }
    var len2 = data.count();
    var points4 = createFloat32Array(len2 * 2);
    for (var idx = 0; idx < len2; idx++) {
      var pt = getStackedOnPoint(dataCoordInfo, coordSys, data, idx);
      points4[idx * 2] = pt[0];
      points4[idx * 2 + 1] = pt[1];
    }
    return points4;
  }
  function turnPointsIntoStep(points4, coordSys, stepTurnAt, connectNulls) {
    var baseAxis = coordSys.getBaseAxis();
    var baseIndex = baseAxis.dim === "x" || baseAxis.dim === "radius" ? 0 : 1;
    var stepPoints = [];
    var i = 0;
    var stepPt = [];
    var pt = [];
    var nextPt = [];
    var filteredPoints = [];
    if (connectNulls) {
      for (i = 0; i < points4.length; i += 2) {
        if (!isNaN(points4[i]) && !isNaN(points4[i + 1])) {
          filteredPoints.push(points4[i], points4[i + 1]);
        }
      }
      points4 = filteredPoints;
    }
    for (i = 0; i < points4.length - 2; i += 2) {
      nextPt[0] = points4[i + 2];
      nextPt[1] = points4[i + 3];
      pt[0] = points4[i];
      pt[1] = points4[i + 1];
      stepPoints.push(pt[0], pt[1]);
      switch (stepTurnAt) {
        case "end":
          stepPt[baseIndex] = nextPt[baseIndex];
          stepPt[1 - baseIndex] = pt[1 - baseIndex];
          stepPoints.push(stepPt[0], stepPt[1]);
          break;
        case "middle":
          var middle = (pt[baseIndex] + nextPt[baseIndex]) / 2;
          var stepPt2 = [];
          stepPt[baseIndex] = stepPt2[baseIndex] = middle;
          stepPt[1 - baseIndex] = pt[1 - baseIndex];
          stepPt2[1 - baseIndex] = nextPt[1 - baseIndex];
          stepPoints.push(stepPt[0], stepPt[1]);
          stepPoints.push(stepPt2[0], stepPt2[1]);
          break;
        default:
          stepPt[baseIndex] = pt[baseIndex];
          stepPt[1 - baseIndex] = nextPt[1 - baseIndex];
          stepPoints.push(stepPt[0], stepPt[1]);
      }
    }
    stepPoints.push(points4[i++], points4[i++]);
    return stepPoints;
  }
  function clipColorStops(colorStops, maxSize) {
    var newColorStops = [];
    var len2 = colorStops.length;
    var prevOutOfRangeColorStop;
    var prevInRangeColorStop;
    function lerpStop(stop0, stop1, clippedCoord) {
      var coord0 = stop0.coord;
      var p = (clippedCoord - coord0) / (stop1.coord - coord0);
      var color = lerp2(p, [stop0.color, stop1.color]);
      return {
        coord: clippedCoord,
        color
      };
    }
    for (var i = 0; i < len2; i++) {
      var stop_1 = colorStops[i];
      var coord = stop_1.coord;
      if (coord < 0) {
        prevOutOfRangeColorStop = stop_1;
      } else if (coord > maxSize) {
        if (prevInRangeColorStop) {
          newColorStops.push(lerpStop(prevInRangeColorStop, stop_1, maxSize));
        } else if (prevOutOfRangeColorStop) {
          newColorStops.push(lerpStop(prevOutOfRangeColorStop, stop_1, 0), lerpStop(prevOutOfRangeColorStop, stop_1, maxSize));
        }
        break;
      } else {
        if (prevOutOfRangeColorStop) {
          newColorStops.push(lerpStop(prevOutOfRangeColorStop, stop_1, 0));
          prevOutOfRangeColorStop = null;
        }
        newColorStops.push(stop_1);
        prevInRangeColorStop = stop_1;
      }
    }
    return newColorStops;
  }
  function getVisualGradient(data, coordSys, api) {
    var visualMetaList = data.getVisual("visualMeta");
    if (!visualMetaList || !visualMetaList.length || !data.count()) {
      return;
    }
    if (coordSys.type !== "cartesian2d") {
      if (true) {
        console.warn("Visual map on line style is only supported on cartesian2d.");
      }
      return;
    }
    var coordDim;
    var visualMeta;
    for (var i = visualMetaList.length - 1; i >= 0; i--) {
      var dimInfo = data.getDimensionInfo(visualMetaList[i].dimension);
      coordDim = dimInfo && dimInfo.coordDim;
      if (coordDim === "x" || coordDim === "y") {
        visualMeta = visualMetaList[i];
        break;
      }
    }
    if (!visualMeta) {
      if (true) {
        console.warn("Visual map on line style only support x or y dimension.");
      }
      return;
    }
    var axis = coordSys.getAxis(coordDim);
    var colorStops = map(visualMeta.stops, function(stop2) {
      return {
        coord: axis.toGlobalCoord(axis.dataToCoord(stop2.value)),
        color: stop2.color
      };
    });
    var stopLen = colorStops.length;
    var outerColors = visualMeta.outerColors.slice();
    if (stopLen && colorStops[0].coord > colorStops[stopLen - 1].coord) {
      colorStops.reverse();
      outerColors.reverse();
    }
    var colorStopsInRange = clipColorStops(colorStops, coordDim === "x" ? api.getWidth() : api.getHeight());
    var inRangeStopLen = colorStopsInRange.length;
    if (!inRangeStopLen && stopLen) {
      return colorStops[0].coord < 0 ? outerColors[1] ? outerColors[1] : colorStops[stopLen - 1].color : outerColors[0] ? outerColors[0] : colorStops[0].color;
    }
    var tinyExtent = 10;
    var minCoord = colorStopsInRange[0].coord - tinyExtent;
    var maxCoord = colorStopsInRange[inRangeStopLen - 1].coord + tinyExtent;
    var coordSpan = maxCoord - minCoord;
    if (coordSpan < 1e-3) {
      return "transparent";
    }
    each(colorStopsInRange, function(stop2) {
      stop2.offset = (stop2.coord - minCoord) / coordSpan;
    });
    colorStopsInRange.push({
      offset: inRangeStopLen ? colorStopsInRange[inRangeStopLen - 1].offset : 0.5,
      color: outerColors[1] || "transparent"
    });
    colorStopsInRange.unshift({
      offset: inRangeStopLen ? colorStopsInRange[0].offset : 0.5,
      color: outerColors[0] || "transparent"
    });
    var gradient = new LinearGradient_default(0, 0, 0, 0, colorStopsInRange, true);
    gradient[coordDim] = minCoord;
    gradient[coordDim + "2"] = maxCoord;
    return gradient;
  }
  function getIsIgnoreFunc(seriesModel, data, coordSys) {
    var showAllSymbol = seriesModel.get("showAllSymbol");
    var isAuto = showAllSymbol === "auto";
    if (showAllSymbol && !isAuto) {
      return;
    }
    var categoryAxis2 = coordSys.getAxesByScale("ordinal")[0];
    if (!categoryAxis2) {
      return;
    }
    if (isAuto && canShowAllSymbolForCategory(categoryAxis2, data)) {
      return;
    }
    var categoryDataDim = data.mapDimension(categoryAxis2.dim);
    var labelMap = {};
    each(categoryAxis2.getViewLabels(), function(labelItem) {
      var ordinalNumber = categoryAxis2.scale.getRawOrdinalNumber(labelItem.tickValue);
      labelMap[ordinalNumber] = 1;
    });
    return function(dataIndex) {
      return !labelMap.hasOwnProperty(data.get(categoryDataDim, dataIndex));
    };
  }
  function canShowAllSymbolForCategory(categoryAxis2, data) {
    var axisExtent = categoryAxis2.getExtent();
    var availSize = Math.abs(axisExtent[1] - axisExtent[0]) / categoryAxis2.scale.count();
    isNaN(availSize) && (availSize = 0);
    var dataLen = data.count();
    var step = Math.max(1, Math.round(dataLen / 5));
    for (var dataIndex = 0; dataIndex < dataLen; dataIndex += step) {
      if (Symbol_default.getSymbolSize(data, dataIndex)[categoryAxis2.isHorizontal() ? 1 : 0] * 1.5 > availSize) {
        return false;
      }
    }
    return true;
  }
  function isPointNull2(x, y) {
    return isNaN(x) || isNaN(y);
  }
  function getLastIndexNotNull(points4) {
    var len2 = points4.length / 2;
    for (; len2 > 0; len2--) {
      if (!isPointNull2(points4[len2 * 2 - 2], points4[len2 * 2 - 1])) {
        break;
      }
    }
    return len2 - 1;
  }
  function getPointAtIndex(points4, idx) {
    return [points4[idx * 2], points4[idx * 2 + 1]];
  }
  function getIndexRange(points4, xOrY, dim) {
    var len2 = points4.length / 2;
    var dimIdx = dim === "x" ? 0 : 1;
    var a;
    var b;
    var prevIndex = 0;
    var nextIndex = -1;
    for (var i = 0; i < len2; i++) {
      b = points4[i * 2 + dimIdx];
      if (isNaN(b) || isNaN(points4[i * 2 + 1 - dimIdx])) {
        continue;
      }
      if (i === 0) {
        a = b;
        continue;
      }
      if (a <= xOrY && b >= xOrY || a >= xOrY && b <= xOrY) {
        nextIndex = i;
        break;
      }
      prevIndex = i;
      a = b;
    }
    return {
      range: [prevIndex, nextIndex],
      t: (xOrY - a) / (b - a)
    };
  }
  function anyStateShowEndLabel(seriesModel) {
    if (seriesModel.get(["endLabel", "show"])) {
      return true;
    }
    for (var i = 0; i < SPECIAL_STATES.length; i++) {
      if (seriesModel.get([SPECIAL_STATES[i], "endLabel", "show"])) {
        return true;
      }
    }
    return false;
  }
  function createLineClipPath(lineView, coordSys, hasAnimation, seriesModel) {
    if (isCoordinateSystemType(coordSys, "cartesian2d")) {
      var endLabelModel_1 = seriesModel.getModel("endLabel");
      var valueAnimation_1 = endLabelModel_1.get("valueAnimation");
      var data_1 = seriesModel.getData();
      var labelAnimationRecord_1 = {
        lastFrameIndex: 0
      };
      var during = anyStateShowEndLabel(seriesModel) ? function(percent, clipRect) {
        lineView._endLabelOnDuring(percent, clipRect, data_1, labelAnimationRecord_1, valueAnimation_1, endLabelModel_1, coordSys);
      } : null;
      var isHorizontal = coordSys.getBaseAxis().isHorizontal();
      var clipPath = createGridClipPath(coordSys, hasAnimation, seriesModel, function() {
        var endLabel = lineView._endLabel;
        if (endLabel && hasAnimation) {
          if (labelAnimationRecord_1.originalX != null) {
            endLabel.attr({
              x: labelAnimationRecord_1.originalX,
              y: labelAnimationRecord_1.originalY
            });
          }
        }
      }, during);
      if (!seriesModel.get("clip", true)) {
        var rectShape = clipPath.shape;
        var expandSize = Math.max(rectShape.width, rectShape.height);
        if (isHorizontal) {
          rectShape.y -= expandSize;
          rectShape.height += expandSize * 2;
        } else {
          rectShape.x -= expandSize;
          rectShape.width += expandSize * 2;
        }
      }
      if (during) {
        during(1, clipPath);
      }
      return clipPath;
    } else {
      if (true) {
        if (seriesModel.get(["endLabel", "show"])) {
          console.warn("endLabel is not supported for lines in polar systems.");
        }
      }
      return createPolarClipPath(coordSys, hasAnimation, seriesModel);
    }
  }
  function getEndLabelStateSpecified(endLabelModel, coordSys) {
    var baseAxis = coordSys.getBaseAxis();
    var isHorizontal = baseAxis.isHorizontal();
    var isBaseInversed = baseAxis.inverse;
    var align = isHorizontal ? isBaseInversed ? "right" : "left" : "center";
    var verticalAlign = isHorizontal ? "middle" : isBaseInversed ? "top" : "bottom";
    return {
      normal: {
        align: endLabelModel.get("align") || align,
        verticalAlign: endLabelModel.get("verticalAlign") || verticalAlign
      }
    };
  }
  var LineView = function(_super) {
    __extends(LineView2, _super);
    function LineView2() {
      return _super !== null && _super.apply(this, arguments) || this;
    }
    LineView2.prototype.init = function() {
      var lineGroup = new Group_default();
      var symbolDraw = new SymbolDraw_default();
      this.group.add(symbolDraw.group);
      this._symbolDraw = symbolDraw;
      this._lineGroup = lineGroup;
    };
    LineView2.prototype.render = function(seriesModel, ecModel, api) {
      var _this = this;
      var coordSys = seriesModel.coordinateSystem;
      var group = this.group;
      var data = seriesModel.getData();
      var lineStyleModel = seriesModel.getModel("lineStyle");
      var areaStyleModel = seriesModel.getModel("areaStyle");
      var points4 = data.getLayout("points") || [];
      var isCoordSysPolar = coordSys.type === "polar";
      var prevCoordSys = this._coordSys;
      var symbolDraw = this._symbolDraw;
      var polyline = this._polyline;
      var polygon = this._polygon;
      var lineGroup = this._lineGroup;
      var hasAnimation = seriesModel.get("animation");
      var isAreaChart = !areaStyleModel.isEmpty();
      var valueOrigin = areaStyleModel.get("origin");
      var dataCoordInfo = prepareDataCoordInfo(coordSys, data, valueOrigin);
      var stackedOnPoints = isAreaChart && getStackedOnPoints(coordSys, data, dataCoordInfo);
      var showSymbol = seriesModel.get("showSymbol");
      var connectNulls = seriesModel.get("connectNulls");
      var isIgnoreFunc = showSymbol && !isCoordSysPolar && getIsIgnoreFunc(seriesModel, data, coordSys);
      var oldData = this._data;
      oldData && oldData.eachItemGraphicEl(function(el, idx) {
        if (el.__temp) {
          group.remove(el);
          oldData.setItemGraphicEl(idx, null);
        }
      });
      if (!showSymbol) {
        symbolDraw.remove();
      }
      group.add(lineGroup);
      var step = !isCoordSysPolar ? seriesModel.get("step") : false;
      var clipShapeForSymbol;
      if (coordSys && coordSys.getArea && seriesModel.get("clip", true)) {
        clipShapeForSymbol = coordSys.getArea();
        if (clipShapeForSymbol.width != null) {
          clipShapeForSymbol.x -= 0.1;
          clipShapeForSymbol.y -= 0.1;
          clipShapeForSymbol.width += 0.2;
          clipShapeForSymbol.height += 0.2;
        } else if (clipShapeForSymbol.r0) {
          clipShapeForSymbol.r0 -= 0.5;
          clipShapeForSymbol.r += 0.5;
        }
      }
      this._clipShapeForSymbol = clipShapeForSymbol;
      var visualColor = getVisualGradient(data, coordSys, api) || data.getVisual("style")[data.getVisual("drawType")];
      if (!(polyline && prevCoordSys.type === coordSys.type && step === this._step)) {
        showSymbol && symbolDraw.updateData(data, {
          isIgnore: isIgnoreFunc,
          clipShape: clipShapeForSymbol,
          disableAnimation: true,
          getSymbolPoint: function(idx) {
            return [points4[idx * 2], points4[idx * 2 + 1]];
          }
        });
        hasAnimation && this._initSymbolLabelAnimation(data, coordSys, clipShapeForSymbol);
        if (step) {
          points4 = turnPointsIntoStep(points4, coordSys, step, connectNulls);
          if (stackedOnPoints) {
            stackedOnPoints = turnPointsIntoStep(stackedOnPoints, coordSys, step, connectNulls);
          }
        }
        polyline = this._newPolyline(points4);
        if (isAreaChart) {
          polygon = this._newPolygon(points4, stackedOnPoints);
        } else if (polygon) {
          lineGroup.remove(polygon);
          polygon = this._polygon = null;
        }
        if (!isCoordSysPolar) {
          this._initOrUpdateEndLabel(seriesModel, coordSys, convertToColorString(visualColor));
        }
        lineGroup.setClipPath(createLineClipPath(this, coordSys, true, seriesModel));
      } else {
        if (isAreaChart && !polygon) {
          polygon = this._newPolygon(points4, stackedOnPoints);
        } else if (polygon && !isAreaChart) {
          lineGroup.remove(polygon);
          polygon = this._polygon = null;
        }
        if (!isCoordSysPolar) {
          this._initOrUpdateEndLabel(seriesModel, coordSys, convertToColorString(visualColor));
        }
        var oldClipPath = lineGroup.getClipPath();
        if (oldClipPath) {
          var newClipPath = createLineClipPath(this, coordSys, false, seriesModel);
          initProps(oldClipPath, {
            shape: newClipPath.shape
          }, seriesModel);
        } else {
          lineGroup.setClipPath(createLineClipPath(this, coordSys, true, seriesModel));
        }
        showSymbol && symbolDraw.updateData(data, {
          isIgnore: isIgnoreFunc,
          clipShape: clipShapeForSymbol,
          disableAnimation: true,
          getSymbolPoint: function(idx) {
            return [points4[idx * 2], points4[idx * 2 + 1]];
          }
        });
        if (!isPointsSame(this._stackedOnPoints, stackedOnPoints) || !isPointsSame(this._points, points4)) {
          if (hasAnimation) {
            this._doUpdateAnimation(data, stackedOnPoints, coordSys, api, step, valueOrigin, connectNulls);
          } else {
            if (step) {
              points4 = turnPointsIntoStep(points4, coordSys, step, connectNulls);
              if (stackedOnPoints) {
                stackedOnPoints = turnPointsIntoStep(stackedOnPoints, coordSys, step, connectNulls);
              }
            }
            polyline.setShape({
              points: points4
            });
            polygon && polygon.setShape({
              points: points4,
              stackedOnPoints
            });
          }
        }
      }
      var emphasisModel = seriesModel.getModel("emphasis");
      var focus = emphasisModel.get("focus");
      var blurScope = emphasisModel.get("blurScope");
      var emphasisDisabled = emphasisModel.get("disabled");
      polyline.useStyle(defaults(lineStyleModel.getLineStyle(), {
        fill: "none",
        stroke: visualColor,
        lineJoin: "bevel"
      }));
      setStatesStylesFromModel(polyline, seriesModel, "lineStyle");
      if (polyline.style.lineWidth > 0 && seriesModel.get(["emphasis", "lineStyle", "width"]) === "bolder") {
        var emphasisLineStyle = polyline.getState("emphasis").style;
        emphasisLineStyle.lineWidth = +polyline.style.lineWidth + 1;
      }
      getECData(polyline).seriesIndex = seriesModel.seriesIndex;
      toggleHoverEmphasis(polyline, focus, blurScope, emphasisDisabled);
      var smooth = getSmooth(seriesModel.get("smooth"));
      var smoothMonotone = seriesModel.get("smoothMonotone");
      polyline.setShape({
        smooth,
        smoothMonotone,
        connectNulls
      });
      if (polygon) {
        var stackedOnSeries = data.getCalculationInfo("stackedOnSeries");
        var stackedOnSmooth = 0;
        polygon.useStyle(defaults(areaStyleModel.getAreaStyle(), {
          fill: visualColor,
          opacity: 0.7,
          lineJoin: "bevel",
          decal: data.getVisual("style").decal
        }));
        if (stackedOnSeries) {
          stackedOnSmooth = getSmooth(stackedOnSeries.get("smooth"));
        }
        polygon.setShape({
          smooth,
          stackedOnSmooth,
          smoothMonotone,
          connectNulls
        });
        setStatesStylesFromModel(polygon, seriesModel, "areaStyle");
        getECData(polygon).seriesIndex = seriesModel.seriesIndex;
        toggleHoverEmphasis(polygon, focus, blurScope, emphasisDisabled);
      }
      var changePolyState = function(toState) {
        _this._changePolyState(toState);
      };
      data.eachItemGraphicEl(function(el) {
        el && (el.onHoverStateChange = changePolyState);
      });
      this._polyline.onHoverStateChange = changePolyState;
      this._data = data;
      this._coordSys = coordSys;
      this._stackedOnPoints = stackedOnPoints;
      this._points = points4;
      this._step = step;
      this._valueOrigin = valueOrigin;
      if (seriesModel.get("triggerLineEvent")) {
        this.packEventData(seriesModel, polyline);
        polygon && this.packEventData(seriesModel, polygon);
      }
    };
    LineView2.prototype.packEventData = function(seriesModel, el) {
      getECData(el).eventData = {
        componentType: "series",
        componentSubType: "line",
        componentIndex: seriesModel.componentIndex,
        seriesIndex: seriesModel.seriesIndex,
        seriesName: seriesModel.name,
        seriesType: "line"
      };
    };
    LineView2.prototype.highlight = function(seriesModel, ecModel, api, payload) {
      var data = seriesModel.getData();
      var dataIndex = queryDataIndex(data, payload);
      this._changePolyState("emphasis");
      if (!(dataIndex instanceof Array) && dataIndex != null && dataIndex >= 0) {
        var points4 = data.getLayout("points");
        var symbol = data.getItemGraphicEl(dataIndex);
        if (!symbol) {
          var x = points4[dataIndex * 2];
          var y = points4[dataIndex * 2 + 1];
          if (isNaN(x) || isNaN(y)) {
            return;
          }
          if (this._clipShapeForSymbol && !this._clipShapeForSymbol.contain(x, y)) {
            return;
          }
          var zlevel = seriesModel.get("zlevel");
          var z = seriesModel.get("z");
          symbol = new Symbol_default(data, dataIndex);
          symbol.x = x;
          symbol.y = y;
          symbol.setZ(zlevel, z);
          var symbolLabel = symbol.getSymbolPath().getTextContent();
          if (symbolLabel) {
            symbolLabel.zlevel = zlevel;
            symbolLabel.z = z;
            symbolLabel.z2 = this._polyline.z2 + 1;
          }
          symbol.__temp = true;
          data.setItemGraphicEl(dataIndex, symbol);
          symbol.stopSymbolAnimation(true);
          this.group.add(symbol);
        }
        symbol.highlight();
      } else {
        Chart_default.prototype.highlight.call(this, seriesModel, ecModel, api, payload);
      }
    };
    LineView2.prototype.downplay = function(seriesModel, ecModel, api, payload) {
      var data = seriesModel.getData();
      var dataIndex = queryDataIndex(data, payload);
      this._changePolyState("normal");
      if (dataIndex != null && dataIndex >= 0) {
        var symbol = data.getItemGraphicEl(dataIndex);
        if (symbol) {
          if (symbol.__temp) {
            data.setItemGraphicEl(dataIndex, null);
            this.group.remove(symbol);
          } else {
            symbol.downplay();
          }
        }
      } else {
        Chart_default.prototype.downplay.call(this, seriesModel, ecModel, api, payload);
      }
    };
    LineView2.prototype._changePolyState = function(toState) {
      var polygon = this._polygon;
      setStatesFlag(this._polyline, toState);
      polygon && setStatesFlag(polygon, toState);
    };
    LineView2.prototype._newPolyline = function(points4) {
      var polyline = this._polyline;
      if (polyline) {
        this._lineGroup.remove(polyline);
      }
      polyline = new ECPolyline({
        shape: {
          points: points4
        },
        segmentIgnoreThreshold: 2,
        z2: 10
      });
      this._lineGroup.add(polyline);
      this._polyline = polyline;
      return polyline;
    };
    LineView2.prototype._newPolygon = function(points4, stackedOnPoints) {
      var polygon = this._polygon;
      if (polygon) {
        this._lineGroup.remove(polygon);
      }
      polygon = new ECPolygon({
        shape: {
          points: points4,
          stackedOnPoints
        },
        segmentIgnoreThreshold: 2
      });
      this._lineGroup.add(polygon);
      this._polygon = polygon;
      return polygon;
    };
    LineView2.prototype._initSymbolLabelAnimation = function(data, coordSys, clipShape) {
      var isHorizontalOrRadial;
      var isCoordSysPolar;
      var baseAxis = coordSys.getBaseAxis();
      var isAxisInverse = baseAxis.inverse;
      if (coordSys.type === "cartesian2d") {
        isHorizontalOrRadial = baseAxis.isHorizontal();
        isCoordSysPolar = false;
      } else if (coordSys.type === "polar") {
        isHorizontalOrRadial = baseAxis.dim === "angle";
        isCoordSysPolar = true;
      }
      var seriesModel = data.hostModel;
      var seriesDuration = seriesModel.get("animationDuration");
      if (isFunction(seriesDuration)) {
        seriesDuration = seriesDuration(null);
      }
      var seriesDalay = seriesModel.get("animationDelay") || 0;
      var seriesDalayValue = isFunction(seriesDalay) ? seriesDalay(null) : seriesDalay;
      data.eachItemGraphicEl(function(symbol, idx) {
        var el = symbol;
        if (el) {
          var point = [symbol.x, symbol.y];
          var start2 = void 0;
          var end2 = void 0;
          var current = void 0;
          if (clipShape) {
            if (isCoordSysPolar) {
              var polarClip = clipShape;
              var coord = coordSys.pointToCoord(point);
              if (isHorizontalOrRadial) {
                start2 = polarClip.startAngle;
                end2 = polarClip.endAngle;
                current = -coord[1] / 180 * Math.PI;
              } else {
                start2 = polarClip.r0;
                end2 = polarClip.r;
                current = coord[0];
              }
            } else {
              var gridClip = clipShape;
              if (isHorizontalOrRadial) {
                start2 = gridClip.x;
                end2 = gridClip.x + gridClip.width;
                current = symbol.x;
              } else {
                start2 = gridClip.y + gridClip.height;
                end2 = gridClip.y;
                current = symbol.y;
              }
            }
          }
          var ratio = end2 === start2 ? 0 : (current - start2) / (end2 - start2);
          if (isAxisInverse) {
            ratio = 1 - ratio;
          }
          var delay = isFunction(seriesDalay) ? seriesDalay(idx) : seriesDuration * ratio + seriesDalayValue;
          var symbolPath = el.getSymbolPath();
          var text = symbolPath.getTextContent();
          el.attr({
            scaleX: 0,
            scaleY: 0
          });
          el.animateTo({
            scaleX: 1,
            scaleY: 1
          }, {
            duration: 200,
            setToFinal: true,
            delay
          });
          if (text) {
            text.animateFrom({
              style: {
                opacity: 0
              }
            }, {
              duration: 300,
              delay
            });
          }
          symbolPath.disableLabelAnimation = true;
        }
      });
    };
    LineView2.prototype._initOrUpdateEndLabel = function(seriesModel, coordSys, inheritColor) {
      var endLabelModel = seriesModel.getModel("endLabel");
      if (anyStateShowEndLabel(seriesModel)) {
        var data_2 = seriesModel.getData();
        var polyline = this._polyline;
        var points4 = data_2.getLayout("points");
        if (!points4) {
          polyline.removeTextContent();
          this._endLabel = null;
          return;
        }
        var endLabel = this._endLabel;
        if (!endLabel) {
          endLabel = this._endLabel = new Text_default({
            z2: 200
          });
          endLabel.ignoreClip = true;
          polyline.setTextContent(this._endLabel);
          polyline.disableLabelAnimation = true;
        }
        var dataIndex = getLastIndexNotNull(points4);
        if (dataIndex >= 0) {
          setLabelStyle(polyline, getLabelStatesModels(seriesModel, "endLabel"), {
            inheritColor,
            labelFetcher: seriesModel,
            labelDataIndex: dataIndex,
            defaultText: function(dataIndex2, opt, interpolatedValue) {
              return interpolatedValue != null ? getDefaultInterpolatedLabel(data_2, interpolatedValue) : getDefaultLabel(data_2, dataIndex2);
            },
            enableTextSetter: true
          }, getEndLabelStateSpecified(endLabelModel, coordSys));
          polyline.textConfig.position = null;
        }
      } else if (this._endLabel) {
        this._polyline.removeTextContent();
        this._endLabel = null;
      }
    };
    LineView2.prototype._endLabelOnDuring = function(percent, clipRect, data, animationRecord, valueAnimation, endLabelModel, coordSys) {
      var endLabel = this._endLabel;
      var polyline = this._polyline;
      if (endLabel) {
        if (percent < 1 && animationRecord.originalX == null) {
          animationRecord.originalX = endLabel.x;
          animationRecord.originalY = endLabel.y;
        }
        var points4 = data.getLayout("points");
        var seriesModel = data.hostModel;
        var connectNulls = seriesModel.get("connectNulls");
        var precision = endLabelModel.get("precision");
        var distance2 = endLabelModel.get("distance") || 0;
        var baseAxis = coordSys.getBaseAxis();
        var isHorizontal = baseAxis.isHorizontal();
        var isBaseInversed = baseAxis.inverse;
        var clipShape = clipRect.shape;
        var xOrY = isBaseInversed ? isHorizontal ? clipShape.x : clipShape.y + clipShape.height : isHorizontal ? clipShape.x + clipShape.width : clipShape.y;
        var distanceX = (isHorizontal ? distance2 : 0) * (isBaseInversed ? -1 : 1);
        var distanceY = (isHorizontal ? 0 : -distance2) * (isBaseInversed ? -1 : 1);
        var dim = isHorizontal ? "x" : "y";
        var dataIndexRange = getIndexRange(points4, xOrY, dim);
        var indices = dataIndexRange.range;
        var diff = indices[1] - indices[0];
        var value = void 0;
        if (diff >= 1) {
          if (diff > 1 && !connectNulls) {
            var pt = getPointAtIndex(points4, indices[0]);
            endLabel.attr({
              x: pt[0] + distanceX,
              y: pt[1] + distanceY
            });
            valueAnimation && (value = seriesModel.getRawValue(indices[0]));
          } else {
            var pt = polyline.getPointOn(xOrY, dim);
            pt && endLabel.attr({
              x: pt[0] + distanceX,
              y: pt[1] + distanceY
            });
            var startValue = seriesModel.getRawValue(indices[0]);
            var endValue = seriesModel.getRawValue(indices[1]);
            valueAnimation && (value = interpolateRawValues(data, precision, startValue, endValue, dataIndexRange.t));
          }
          animationRecord.lastFrameIndex = indices[0];
        } else {
          var idx = percent === 1 || animationRecord.lastFrameIndex > 0 ? indices[0] : 0;
          var pt = getPointAtIndex(points4, idx);
          valueAnimation && (value = seriesModel.getRawValue(idx));
          endLabel.attr({
            x: pt[0] + distanceX,
            y: pt[1] + distanceY
          });
        }
        if (valueAnimation) {
          labelInner(endLabel).setLabelText(value);
        }
      }
    };
    LineView2.prototype._doUpdateAnimation = function(data, stackedOnPoints, coordSys, api, step, valueOrigin, connectNulls) {
      var polyline = this._polyline;
      var polygon = this._polygon;
      var seriesModel = data.hostModel;
      var diff = lineAnimationDiff(this._data, data, this._stackedOnPoints, stackedOnPoints, this._coordSys, coordSys, this._valueOrigin, valueOrigin);
      var current = diff.current;
      var stackedOnCurrent = diff.stackedOnCurrent;
      var next = diff.next;
      var stackedOnNext = diff.stackedOnNext;
      if (step) {
        current = turnPointsIntoStep(diff.current, coordSys, step, connectNulls);
        stackedOnCurrent = turnPointsIntoStep(diff.stackedOnCurrent, coordSys, step, connectNulls);
        next = turnPointsIntoStep(diff.next, coordSys, step, connectNulls);
        stackedOnNext = turnPointsIntoStep(diff.stackedOnNext, coordSys, step, connectNulls);
      }
      if (getBoundingDiff(current, next) > 3e3 || polygon && getBoundingDiff(stackedOnCurrent, stackedOnNext) > 3e3) {
        polyline.stopAnimation();
        polyline.setShape({
          points: next
        });
        if (polygon) {
          polygon.stopAnimation();
          polygon.setShape({
            points: next,
            stackedOnPoints: stackedOnNext
          });
        }
        return;
      }
      polyline.shape.__points = diff.current;
      polyline.shape.points = current;
      var target = {
        shape: {
          points: next
        }
      };
      if (diff.current !== current) {
        target.shape.__points = diff.next;
      }
      polyline.stopAnimation();
      updateProps(polyline, target, seriesModel);
      if (polygon) {
        polygon.setShape({
          points: current,
          stackedOnPoints: stackedOnCurrent
        });
        polygon.stopAnimation();
        updateProps(polygon, {
          shape: {
            stackedOnPoints: stackedOnNext
          }
        }, seriesModel);
        if (polyline.shape.points !== polygon.shape.points) {
          polygon.shape.points = polyline.shape.points;
        }
      }
      var updatedDataInfo = [];
      var diffStatus = diff.status;
      for (var i = 0; i < diffStatus.length; i++) {
        var cmd = diffStatus[i].cmd;
        if (cmd === "=") {
          var el = data.getItemGraphicEl(diffStatus[i].idx1);
          if (el) {
            updatedDataInfo.push({
              el,
              ptIdx: i
            });
          }
        }
      }
      if (polyline.animators && polyline.animators.length) {
        polyline.animators[0].during(function() {
          polygon && polygon.dirtyShape();
          var points4 = polyline.shape.__points;
          for (var i2 = 0; i2 < updatedDataInfo.length; i2++) {
            var el2 = updatedDataInfo[i2].el;
            var offset = updatedDataInfo[i2].ptIdx * 2;
            el2.x = points4[offset];
            el2.y = points4[offset + 1];
            el2.markRedraw();
          }
        });
      }
    };
    LineView2.prototype.remove = function(ecModel) {
      var group = this.group;
      var oldData = this._data;
      this._lineGroup.removeAll();
      this._symbolDraw.remove(true);
      oldData && oldData.eachItemGraphicEl(function(el, idx) {
        if (el.__temp) {
          group.remove(el);
          oldData.setItemGraphicEl(idx, null);
        }
      });
      this._polyline = this._polygon = this._coordSys = this._points = this._stackedOnPoints = this._endLabel = this._data = null;
    };
    LineView2.type = "line";
    return LineView2;
  }(Chart_default);
  var LineView_default = LineView;

  // node_modules/echarts/lib/layout/points.js
  function pointsLayout(seriesType2, forceStoreInTypedArray) {
    return {
      seriesType: seriesType2,
      plan: createRenderPlanner(),
      reset: function(seriesModel) {
        var data = seriesModel.getData();
        var coordSys = seriesModel.coordinateSystem;
        var pipelineContext = seriesModel.pipelineContext;
        var useTypedArray = forceStoreInTypedArray || pipelineContext.large;
        if (!coordSys) {
          return;
        }
        var dims = map(coordSys.dimensions, function(dim) {
          return data.mapDimension(dim);
        }).slice(0, 2);
        var dimLen = dims.length;
        var stackResultDim = data.getCalculationInfo("stackResultDimension");
        if (isDimensionStacked(data, dims[0])) {
          dims[0] = stackResultDim;
        }
        if (isDimensionStacked(data, dims[1])) {
          dims[1] = stackResultDim;
        }
        var store = data.getStore();
        var dimIdx0 = data.getDimensionIndex(dims[0]);
        var dimIdx1 = data.getDimensionIndex(dims[1]);
        return dimLen && {
          progress: function(params, data2) {
            var segCount = params.end - params.start;
            var points4 = useTypedArray && createFloat32Array(segCount * dimLen);
            var tmpIn = [];
            var tmpOut = [];
            for (var i = params.start, offset = 0; i < params.end; i++) {
              var point = void 0;
              if (dimLen === 1) {
                var x = store.get(dimIdx0, i);
                point = coordSys.dataToPoint(x, null, tmpOut);
              } else {
                tmpIn[0] = store.get(dimIdx0, i);
                tmpIn[1] = store.get(dimIdx1, i);
                point = coordSys.dataToPoint(tmpIn, null, tmpOut);
              }
              if (useTypedArray) {
                points4[offset++] = point[0];
                points4[offset++] = point[1];
              } else {
                data2.setItemLayout(i, point.slice());
              }
            }
            useTypedArray && data2.setLayout("points", points4);
          }
        };
      }
    };
  }

  // node_modules/echarts/lib/processor/dataSample.js
  var samplers = {
    average: function(frame) {
      var sum2 = 0;
      var count2 = 0;
      for (var i = 0; i < frame.length; i++) {
        if (!isNaN(frame[i])) {
          sum2 += frame[i];
          count2++;
        }
      }
      return count2 === 0 ? NaN : sum2 / count2;
    },
    sum: function(frame) {
      var sum2 = 0;
      for (var i = 0; i < frame.length; i++) {
        sum2 += frame[i] || 0;
      }
      return sum2;
    },
    max: function(frame) {
      var max3 = -Infinity;
      for (var i = 0; i < frame.length; i++) {
        frame[i] > max3 && (max3 = frame[i]);
      }
      return isFinite(max3) ? max3 : NaN;
    },
    min: function(frame) {
      var min3 = Infinity;
      for (var i = 0; i < frame.length; i++) {
        frame[i] < min3 && (min3 = frame[i]);
      }
      return isFinite(min3) ? min3 : NaN;
    },
    nearest: function(frame) {
      return frame[0];
    }
  };
  var indexSampler = function(frame) {
    return Math.round(frame.length / 2);
  };
  function dataSample(seriesType2) {
    return {
      seriesType: seriesType2,
      reset: function(seriesModel, ecModel, api) {
        var data = seriesModel.getData();
        var sampling = seriesModel.get("sampling");
        var coordSys = seriesModel.coordinateSystem;
        var count2 = data.count();
        if (count2 > 10 && coordSys.type === "cartesian2d" && sampling) {
          var baseAxis = coordSys.getBaseAxis();
          var valueAxis2 = coordSys.getOtherAxis(baseAxis);
          var extent3 = baseAxis.getExtent();
          var dpr2 = api.getDevicePixelRatio();
          var size = Math.abs(extent3[1] - extent3[0]) * (dpr2 || 1);
          var rate = Math.round(count2 / size);
          if (isFinite(rate) && rate > 1) {
            if (sampling === "lttb") {
              seriesModel.setData(data.lttbDownSample(data.mapDimension(valueAxis2.dim), 1 / rate));
            }
            var sampler = void 0;
            if (isString(sampling)) {
              sampler = samplers[sampling];
            } else if (isFunction(sampling)) {
              sampler = sampling;
            }
            if (sampler) {
              seriesModel.setData(data.downSample(data.mapDimension(valueAxis2.dim), 1 / rate, sampler, indexSampler));
            }
          }
        }
      }
    };
  }

  // node_modules/echarts/lib/chart/line/install.js
  function install3(registers) {
    registers.registerChartView(LineView_default);
    registers.registerSeriesModel(LineSeries_default);
    registers.registerLayout(pointsLayout("line", true));
    registers.registerVisual({
      seriesType: "line",
      reset: function(seriesModel) {
        var data = seriesModel.getData();
        var lineStyle = seriesModel.getModel("lineStyle").getLineStyle();
        if (lineStyle && !lineStyle.stroke) {
          lineStyle.stroke = data.getVisual("style").fill;
        }
        data.setVisual("legendLineStyle", lineStyle);
      }
    });
    registers.registerProcessor(registers.PRIORITY.PROCESSOR.STATISTIC, dataSample("line"));
  }

  // node_modules/echarts/lib/chart/bar/BaseBarSeries.js
  var BaseBarSeriesModel = function(_super) {
    __extends(BaseBarSeriesModel2, _super);
    function BaseBarSeriesModel2() {
      var _this = _super !== null && _super.apply(this, arguments) || this;
      _this.type = BaseBarSeriesModel2.type;
      return _this;
    }
    BaseBarSeriesModel2.prototype.getInitialData = function(option, ecModel) {
      return createSeriesData_default(null, this, {
        useEncodeDefaulter: true
      });
    };
    BaseBarSeriesModel2.prototype.getMarkerPosition = function(value) {
      var coordSys = this.coordinateSystem;
      if (coordSys && coordSys.clampData) {
        var pt = coordSys.dataToPoint(coordSys.clampData(value));
        var data = this.getData();
        var offset = data.getLayout("offset");
        var size = data.getLayout("size");
        var offsetIndex = coordSys.getBaseAxis().isHorizontal() ? 0 : 1;
        pt[offsetIndex] += offset + size / 2;
        return pt;
      }
      return [NaN, NaN];
    };
    BaseBarSeriesModel2.type = "series.__base_bar__";
    BaseBarSeriesModel2.defaultOption = {
      z: 2,
      coordinateSystem: "cartesian2d",
      legendHoverLink: true,
      barMinHeight: 0,
      barMinAngle: 0,
      large: false,
      largeThreshold: 400,
      progressive: 3e3,
      progressiveChunkMode: "mod"
    };
    return BaseBarSeriesModel2;
  }(Series_default);
  Series_default.registerClass(BaseBarSeriesModel);
  var BaseBarSeries_default = BaseBarSeriesModel;

  // node_modules/echarts/lib/chart/bar/BarSeries.js
  var BarSeriesModel = function(_super) {
    __extends(BarSeriesModel2, _super);
    function BarSeriesModel2() {
      var _this = _super !== null && _super.apply(this, arguments) || this;
      _this.type = BarSeriesModel2.type;
      return _this;
    }
    BarSeriesModel2.prototype.getInitialData = function() {
      return createSeriesData_default(null, this, {
        useEncodeDefaulter: true,
        createInvertedIndices: !!this.get("realtimeSort", true) || null
      });
    };
    BarSeriesModel2.prototype.getProgressive = function() {
      return this.get("large") ? this.get("progressive") : false;
    };
    BarSeriesModel2.prototype.getProgressiveThreshold = function() {
      var progressiveThreshold = this.get("progressiveThreshold");
      var largeThreshold = this.get("largeThreshold");
      if (largeThreshold > progressiveThreshold) {
        progressiveThreshold = largeThreshold;
      }
      return progressiveThreshold;
    };
    BarSeriesModel2.prototype.brushSelector = function(dataIndex, data, selectors) {
      return selectors.rect(data.getItemLayout(dataIndex));
    };
    BarSeriesModel2.type = "series.bar";
    BarSeriesModel2.dependencies = ["grid", "polar"];
    BarSeriesModel2.defaultOption = inheritDefaultOption(BaseBarSeries_default.defaultOption, {
      clip: true,
      roundCap: false,
      showBackground: false,
      backgroundStyle: {
        color: "rgba(180, 180, 180, 0.2)",
        borderColor: null,
        borderWidth: 0,
        borderType: "solid",
        borderRadius: 0,
        shadowBlur: 0,
        shadowColor: null,
        shadowOffsetX: 0,
        shadowOffsetY: 0,
        opacity: 1
      },
      select: {
        itemStyle: {
          borderColor: "#212121"
        }
      },
      realtimeSort: false
    });
    return BarSeriesModel2;
  }(BaseBarSeries_default);
  var BarSeries_default = BarSeriesModel;

  // node_modules/echarts/lib/util/shape/sausage.js
  var SausageShape = function() {
    function SausageShape2() {
      this.cx = 0;
      this.cy = 0;
      this.r0 = 0;
      this.r = 0;
      this.startAngle = 0;
      this.endAngle = Math.PI * 2;
      this.clockwise = true;
    }
    return SausageShape2;
  }();
  var SausagePath = function(_super) {
    __extends(SausagePath2, _super);
    function SausagePath2(opts) {
      var _this = _super.call(this, opts) || this;
      _this.type = "sausage";
      return _this;
    }
    SausagePath2.prototype.getDefaultShape = function() {
      return new SausageShape();
    };
    SausagePath2.prototype.buildPath = function(ctx, shape) {
      var cx = shape.cx;
      var cy = shape.cy;
      var r0 = Math.max(shape.r0 || 0, 0);
      var r = Math.max(shape.r, 0);
      var dr = (r - r0) * 0.5;
      var rCenter = r0 + dr;
      var startAngle = shape.startAngle;
      var endAngle = shape.endAngle;
      var clockwise = shape.clockwise;
      var PI210 = Math.PI * 2;
      var lessThanCircle = clockwise ? endAngle - startAngle < PI210 : startAngle - endAngle < PI210;
      if (!lessThanCircle) {
        startAngle = endAngle - (clockwise ? PI210 : -PI210);
      }
      var unitStartX = Math.cos(startAngle);
      var unitStartY = Math.sin(startAngle);
      var unitEndX = Math.cos(endAngle);
      var unitEndY = Math.sin(endAngle);
      if (lessThanCircle) {
        ctx.moveTo(unitStartX * r0 + cx, unitStartY * r0 + cy);
        ctx.arc(unitStartX * rCenter + cx, unitStartY * rCenter + cy, dr, -Math.PI + startAngle, startAngle, !clockwise);
      } else {
        ctx.moveTo(unitStartX * r + cx, unitStartY * r + cy);
      }
      ctx.arc(cx, cy, r, startAngle, endAngle, !clockwise);
      ctx.arc(unitEndX * rCenter + cx, unitEndY * rCenter + cy, dr, endAngle - Math.PI * 2, endAngle - Math.PI, !clockwise);
      if (r0 !== 0) {
        ctx.arc(cx, cy, r0, endAngle, startAngle, clockwise);
      }
    };
    return SausagePath2;
  }(Path_default);
  var sausage_default = SausagePath;

  // node_modules/echarts/lib/label/sectorLabel.js
  function createSectorCalculateTextPosition(positionMapping, opts) {
    opts = opts || {};
    var isRoundCap = opts.isRoundCap;
    return function(out2, opts2, boundingRect) {
      var textPosition = opts2.position;
      if (!textPosition || textPosition instanceof Array) {
        return calculateTextPosition(out2, opts2, boundingRect);
      }
      var mappedSectorPosition = positionMapping(textPosition);
      var distance2 = opts2.distance != null ? opts2.distance : 5;
      var sector = this.shape;
      var cx = sector.cx;
      var cy = sector.cy;
      var r = sector.r;
      var r0 = sector.r0;
      var middleR = (r + r0) / 2;
      var startAngle = sector.startAngle;
      var endAngle = sector.endAngle;
      var middleAngle = (startAngle + endAngle) / 2;
      var extraDist = isRoundCap ? Math.abs(r - r0) / 2 : 0;
      var mathCos6 = Math.cos;
      var mathSin6 = Math.sin;
      var x = cx + r * mathCos6(startAngle);
      var y = cy + r * mathSin6(startAngle);
      var textAlign = "left";
      var textVerticalAlign = "top";
      switch (mappedSectorPosition) {
        case "startArc":
          x = cx + (r0 - distance2) * mathCos6(middleAngle);
          y = cy + (r0 - distance2) * mathSin6(middleAngle);
          textAlign = "center";
          textVerticalAlign = "top";
          break;
        case "insideStartArc":
          x = cx + (r0 + distance2) * mathCos6(middleAngle);
          y = cy + (r0 + distance2) * mathSin6(middleAngle);
          textAlign = "center";
          textVerticalAlign = "bottom";
          break;
        case "startAngle":
          x = cx + middleR * mathCos6(startAngle) + adjustAngleDistanceX(startAngle, distance2 + extraDist, false);
          y = cy + middleR * mathSin6(startAngle) + adjustAngleDistanceY(startAngle, distance2 + extraDist, false);
          textAlign = "right";
          textVerticalAlign = "middle";
          break;
        case "insideStartAngle":
          x = cx + middleR * mathCos6(startAngle) + adjustAngleDistanceX(startAngle, -distance2 + extraDist, false);
          y = cy + middleR * mathSin6(startAngle) + adjustAngleDistanceY(startAngle, -distance2 + extraDist, false);
          textAlign = "left";
          textVerticalAlign = "middle";
          break;
        case "middle":
          x = cx + middleR * mathCos6(middleAngle);
          y = cy + middleR * mathSin6(middleAngle);
          textAlign = "center";
          textVerticalAlign = "middle";
          break;
        case "endArc":
          x = cx + (r + distance2) * mathCos6(middleAngle);
          y = cy + (r + distance2) * mathSin6(middleAngle);
          textAlign = "center";
          textVerticalAlign = "bottom";
          break;
        case "insideEndArc":
          x = cx + (r - distance2) * mathCos6(middleAngle);
          y = cy + (r - distance2) * mathSin6(middleAngle);
          textAlign = "center";
          textVerticalAlign = "top";
          break;
        case "endAngle":
          x = cx + middleR * mathCos6(endAngle) + adjustAngleDistanceX(endAngle, distance2 + extraDist, true);
          y = cy + middleR * mathSin6(endAngle) + adjustAngleDistanceY(endAngle, distance2 + extraDist, true);
          textAlign = "left";
          textVerticalAlign = "middle";
          break;
        case "insideEndAngle":
          x = cx + middleR * mathCos6(endAngle) + adjustAngleDistanceX(endAngle, -distance2 + extraDist, true);
          y = cy + middleR * mathSin6(endAngle) + adjustAngleDistanceY(endAngle, -distance2 + extraDist, true);
          textAlign = "right";
          textVerticalAlign = "middle";
          break;
        default:
          return calculateTextPosition(out2, opts2, boundingRect);
      }
      out2 = out2 || {};
      out2.x = x;
      out2.y = y;
      out2.align = textAlign;
      out2.verticalAlign = textVerticalAlign;
      return out2;
    };
  }
  function setSectorTextRotation(sector, textPosition, positionMapping, rotateType) {
    if (isNumber(rotateType)) {
      sector.setTextConfig({
        rotation: rotateType
      });
      return;
    } else if (isArray(textPosition)) {
      sector.setTextConfig({
        rotation: 0
      });
      return;
    }
    var shape = sector.shape;
    var startAngle = shape.clockwise ? shape.startAngle : shape.endAngle;
    var endAngle = shape.clockwise ? shape.endAngle : shape.startAngle;
    var middleAngle = (startAngle + endAngle) / 2;
    var anchorAngle;
    var mappedSectorPosition = positionMapping(textPosition);
    switch (mappedSectorPosition) {
      case "startArc":
      case "insideStartArc":
      case "middle":
      case "insideEndArc":
      case "endArc":
        anchorAngle = middleAngle;
        break;
      case "startAngle":
      case "insideStartAngle":
        anchorAngle = startAngle;
        break;
      case "endAngle":
      case "insideEndAngle":
        anchorAngle = endAngle;
        break;
      default:
        sector.setTextConfig({
          rotation: 0
        });
        return;
    }
    var rotate2 = Math.PI * 1.5 - anchorAngle;
    if (mappedSectorPosition === "middle" && rotate2 > Math.PI / 2 && rotate2 < Math.PI * 1.5) {
      rotate2 -= Math.PI;
    }
    sector.setTextConfig({
      rotation: rotate2
    });
  }
  function adjustAngleDistanceX(angle, distance2, isEnd) {
    return distance2 * Math.sin(angle) * (isEnd ? -1 : 1);
  }
  function adjustAngleDistanceY(angle, distance2, isEnd) {
    return distance2 * Math.cos(angle) * (isEnd ? 1 : -1);
  }

  // node_modules/echarts/lib/chart/bar/BarView.js
  var mathMax7 = Math.max;
  var mathMin7 = Math.min;
  function getClipArea(coord, data) {
    var coordSysClipArea = coord.getArea && coord.getArea();
    if (isCoordinateSystemType(coord, "cartesian2d")) {
      var baseAxis = coord.getBaseAxis();
      if (baseAxis.type !== "category" || !baseAxis.onBand) {
        var expandWidth = data.getLayout("bandWidth");
        if (baseAxis.isHorizontal()) {
          coordSysClipArea.x -= expandWidth;
          coordSysClipArea.width += expandWidth * 2;
        } else {
          coordSysClipArea.y -= expandWidth;
          coordSysClipArea.height += expandWidth * 2;
        }
      }
    }
    return coordSysClipArea;
  }
  var BarView = function(_super) {
    __extends(BarView2, _super);
    function BarView2() {
      var _this = _super.call(this) || this;
      _this.type = BarView2.type;
      _this._isFirstFrame = true;
      return _this;
    }
    BarView2.prototype.render = function(seriesModel, ecModel, api, payload) {
      this._model = seriesModel;
      this._removeOnRenderedListener(api);
      this._updateDrawMode(seriesModel);
      var coordinateSystemType = seriesModel.get("coordinateSystem");
      if (coordinateSystemType === "cartesian2d" || coordinateSystemType === "polar") {
        this._progressiveEls = null;
        this._isLargeDraw ? this._renderLarge(seriesModel, ecModel, api) : this._renderNormal(seriesModel, ecModel, api, payload);
      } else if (true) {
        warn("Only cartesian2d and polar supported for bar.");
      }
    };
    BarView2.prototype.incrementalPrepareRender = function(seriesModel) {
      this._clear();
      this._updateDrawMode(seriesModel);
      this._updateLargeClip(seriesModel);
    };
    BarView2.prototype.incrementalRender = function(params, seriesModel) {
      this._progressiveEls = [];
      this._incrementalRenderLarge(params, seriesModel);
    };
    BarView2.prototype.eachRendered = function(cb) {
      traverseElements(this._progressiveEls || this.group, cb);
    };
    BarView2.prototype._updateDrawMode = function(seriesModel) {
      var isLargeDraw = seriesModel.pipelineContext.large;
      if (this._isLargeDraw == null || isLargeDraw !== this._isLargeDraw) {
        this._isLargeDraw = isLargeDraw;
        this._clear();
      }
    };
    BarView2.prototype._renderNormal = function(seriesModel, ecModel, api, payload) {
      var group = this.group;
      var data = seriesModel.getData();
      var oldData = this._data;
      var coord = seriesModel.coordinateSystem;
      var baseAxis = coord.getBaseAxis();
      var isHorizontalOrRadial;
      if (coord.type === "cartesian2d") {
        isHorizontalOrRadial = baseAxis.isHorizontal();
      } else if (coord.type === "polar") {
        isHorizontalOrRadial = baseAxis.dim === "angle";
      }
      var animationModel = seriesModel.isAnimationEnabled() ? seriesModel : null;
      var realtimeSortCfg = shouldRealtimeSort(seriesModel, coord);
      if (realtimeSortCfg) {
        this._enableRealtimeSort(realtimeSortCfg, data, api);
      }
      var needsClip = seriesModel.get("clip", true) || realtimeSortCfg;
      var coordSysClipArea = getClipArea(coord, data);
      group.removeClipPath();
      var roundCap = seriesModel.get("roundCap", true);
      var drawBackground = seriesModel.get("showBackground", true);
      var backgroundModel = seriesModel.getModel("backgroundStyle");
      var barBorderRadius = backgroundModel.get("borderRadius") || 0;
      var bgEls = [];
      var oldBgEls = this._backgroundEls;
      var isInitSort = payload && payload.isInitSort;
      var isChangeOrder = payload && payload.type === "changeAxisOrder";
      function createBackground(dataIndex) {
        var bgLayout = getLayout[coord.type](data, dataIndex);
        var bgEl = createBackgroundEl(coord, isHorizontalOrRadial, bgLayout);
        bgEl.useStyle(backgroundModel.getItemStyle());
        if (coord.type === "cartesian2d") {
          bgEl.setShape("r", barBorderRadius);
        }
        bgEls[dataIndex] = bgEl;
        return bgEl;
      }
      ;
      data.diff(oldData).add(function(dataIndex) {
        var itemModel = data.getItemModel(dataIndex);
        var layout5 = getLayout[coord.type](data, dataIndex, itemModel);
        if (drawBackground) {
          createBackground(dataIndex);
        }
        if (!data.hasValue(dataIndex) || !isValidLayout[coord.type](layout5)) {
          return;
        }
        var isClipped = false;
        if (needsClip) {
          isClipped = clip[coord.type](coordSysClipArea, layout5);
        }
        var el = elementCreator[coord.type](seriesModel, data, dataIndex, layout5, isHorizontalOrRadial, animationModel, baseAxis.model, false, roundCap);
        if (realtimeSortCfg) {
          el.forceLabelAnimation = true;
        }
        updateStyle(el, data, dataIndex, itemModel, layout5, seriesModel, isHorizontalOrRadial, coord.type === "polar");
        if (isInitSort) {
          el.attr({
            shape: layout5
          });
        } else if (realtimeSortCfg) {
          updateRealtimeAnimation(realtimeSortCfg, animationModel, el, layout5, dataIndex, isHorizontalOrRadial, false, false);
        } else {
          initProps(el, {
            shape: layout5
          }, seriesModel, dataIndex);
        }
        data.setItemGraphicEl(dataIndex, el);
        group.add(el);
        el.ignore = isClipped;
      }).update(function(newIndex, oldIndex) {
        var itemModel = data.getItemModel(newIndex);
        var layout5 = getLayout[coord.type](data, newIndex, itemModel);
        if (drawBackground) {
          var bgEl = void 0;
          if (oldBgEls.length === 0) {
            bgEl = createBackground(oldIndex);
          } else {
            bgEl = oldBgEls[oldIndex];
            bgEl.useStyle(backgroundModel.getItemStyle());
            if (coord.type === "cartesian2d") {
              bgEl.setShape("r", barBorderRadius);
            }
            bgEls[newIndex] = bgEl;
          }
          var bgLayout = getLayout[coord.type](data, newIndex);
          var shape = createBackgroundShape(isHorizontalOrRadial, bgLayout, coord);
          updateProps(bgEl, {
            shape
          }, animationModel, newIndex);
        }
        var el = oldData.getItemGraphicEl(oldIndex);
        if (!data.hasValue(newIndex) || !isValidLayout[coord.type](layout5)) {
          group.remove(el);
          return;
        }
        var isClipped = false;
        if (needsClip) {
          isClipped = clip[coord.type](coordSysClipArea, layout5);
          if (isClipped) {
            group.remove(el);
          }
        }
        if (!el) {
          el = elementCreator[coord.type](seriesModel, data, newIndex, layout5, isHorizontalOrRadial, animationModel, baseAxis.model, !!el, roundCap);
        } else {
          saveOldStyle(el);
        }
        if (realtimeSortCfg) {
          el.forceLabelAnimation = true;
        }
        if (isChangeOrder) {
          var textEl = el.getTextContent();
          if (textEl) {
            var labelInnerStore = labelInner(textEl);
            if (labelInnerStore.prevValue != null) {
              labelInnerStore.prevValue = labelInnerStore.value;
            }
          }
        } else {
          updateStyle(el, data, newIndex, itemModel, layout5, seriesModel, isHorizontalOrRadial, coord.type === "polar");
        }
        if (isInitSort) {
          el.attr({
            shape: layout5
          });
        } else if (realtimeSortCfg) {
          updateRealtimeAnimation(realtimeSortCfg, animationModel, el, layout5, newIndex, isHorizontalOrRadial, true, isChangeOrder);
        } else {
          updateProps(el, {
            shape: layout5
          }, seriesModel, newIndex, null);
        }
        data.setItemGraphicEl(newIndex, el);
        el.ignore = isClipped;
        group.add(el);
      }).remove(function(dataIndex) {
        var el = oldData.getItemGraphicEl(dataIndex);
        el && removeElementWithFadeOut(el, seriesModel, dataIndex);
      }).execute();
      var bgGroup = this._backgroundGroup || (this._backgroundGroup = new Group_default());
      bgGroup.removeAll();
      for (var i = 0; i < bgEls.length; ++i) {
        bgGroup.add(bgEls[i]);
      }
      group.add(bgGroup);
      this._backgroundEls = bgEls;
      this._data = data;
    };
    BarView2.prototype._renderLarge = function(seriesModel, ecModel, api) {
      this._clear();
      createLarge(seriesModel, this.group);
      this._updateLargeClip(seriesModel);
    };
    BarView2.prototype._incrementalRenderLarge = function(params, seriesModel) {
      this._removeBackground();
      createLarge(seriesModel, this.group, this._progressiveEls, true);
    };
    BarView2.prototype._updateLargeClip = function(seriesModel) {
      var clipPath = seriesModel.get("clip", true) && createClipPath(seriesModel.coordinateSystem, false, seriesModel);
      var group = this.group;
      if (clipPath) {
        group.setClipPath(clipPath);
      } else {
        group.removeClipPath();
      }
    };
    BarView2.prototype._enableRealtimeSort = function(realtimeSortCfg, data, api) {
      var _this = this;
      if (!data.count()) {
        return;
      }
      var baseAxis = realtimeSortCfg.baseAxis;
      if (this._isFirstFrame) {
        this._dispatchInitSort(data, realtimeSortCfg, api);
        this._isFirstFrame = false;
      } else {
        var orderMapping_1 = function(idx) {
          var el = data.getItemGraphicEl(idx);
          var shape = el && el.shape;
          return shape && Math.abs(baseAxis.isHorizontal() ? shape.height : shape.width) || 0;
        };
        this._onRendered = function() {
          _this._updateSortWithinSameData(data, orderMapping_1, baseAxis, api);
        };
        api.getZr().on("rendered", this._onRendered);
      }
    };
    BarView2.prototype._dataSort = function(data, baseAxis, orderMapping) {
      var info = [];
      data.each(data.mapDimension(baseAxis.dim), function(ordinalNumber, dataIdx) {
        var mappedValue = orderMapping(dataIdx);
        mappedValue = mappedValue == null ? NaN : mappedValue;
        info.push({
          dataIndex: dataIdx,
          mappedValue,
          ordinalNumber
        });
      });
      info.sort(function(a, b) {
        return b.mappedValue - a.mappedValue;
      });
      return {
        ordinalNumbers: map(info, function(item) {
          return item.ordinalNumber;
        })
      };
    };
    BarView2.prototype._isOrderChangedWithinSameData = function(data, orderMapping, baseAxis) {
      var scale4 = baseAxis.scale;
      var ordinalDataDim = data.mapDimension(baseAxis.dim);
      var lastValue = Number.MAX_VALUE;
      for (var tickNum = 0, len2 = scale4.getOrdinalMeta().categories.length; tickNum < len2; ++tickNum) {
        var rawIdx = data.rawIndexOf(ordinalDataDim, scale4.getRawOrdinalNumber(tickNum));
        var value = rawIdx < 0 ? Number.MIN_VALUE : orderMapping(data.indexOfRawIndex(rawIdx));
        if (value > lastValue) {
          return true;
        }
        lastValue = value;
      }
      return false;
    };
    BarView2.prototype._isOrderDifferentInView = function(orderInfo, baseAxis) {
      var scale4 = baseAxis.scale;
      var extent3 = scale4.getExtent();
      var tickNum = Math.max(0, extent3[0]);
      var tickMax = Math.min(extent3[1], scale4.getOrdinalMeta().categories.length - 1);
      for (; tickNum <= tickMax; ++tickNum) {
        if (orderInfo.ordinalNumbers[tickNum] !== scale4.getRawOrdinalNumber(tickNum)) {
          return true;
        }
      }
    };
    BarView2.prototype._updateSortWithinSameData = function(data, orderMapping, baseAxis, api) {
      if (!this._isOrderChangedWithinSameData(data, orderMapping, baseAxis)) {
        return;
      }
      var sortInfo = this._dataSort(data, baseAxis, orderMapping);
      if (this._isOrderDifferentInView(sortInfo, baseAxis)) {
        this._removeOnRenderedListener(api);
        api.dispatchAction({
          type: "changeAxisOrder",
          componentType: baseAxis.dim + "Axis",
          axisId: baseAxis.index,
          sortInfo
        });
      }
    };
    BarView2.prototype._dispatchInitSort = function(data, realtimeSortCfg, api) {
      var baseAxis = realtimeSortCfg.baseAxis;
      var sortResult = this._dataSort(data, baseAxis, function(dataIdx) {
        return data.get(data.mapDimension(realtimeSortCfg.otherAxis.dim), dataIdx);
      });
      api.dispatchAction({
        type: "changeAxisOrder",
        componentType: baseAxis.dim + "Axis",
        isInitSort: true,
        axisId: baseAxis.index,
        sortInfo: sortResult
      });
    };
    BarView2.prototype.remove = function(ecModel, api) {
      this._clear(this._model);
      this._removeOnRenderedListener(api);
    };
    BarView2.prototype.dispose = function(ecModel, api) {
      this._removeOnRenderedListener(api);
    };
    BarView2.prototype._removeOnRenderedListener = function(api) {
      if (this._onRendered) {
        api.getZr().off("rendered", this._onRendered);
        this._onRendered = null;
      }
    };
    BarView2.prototype._clear = function(model) {
      var group = this.group;
      var data = this._data;
      if (model && model.isAnimationEnabled() && data && !this._isLargeDraw) {
        this._removeBackground();
        this._backgroundEls = [];
        data.eachItemGraphicEl(function(el) {
          removeElementWithFadeOut(el, model, getECData(el).dataIndex);
        });
      } else {
        group.removeAll();
      }
      this._data = null;
      this._isFirstFrame = true;
    };
    BarView2.prototype._removeBackground = function() {
      this.group.remove(this._backgroundGroup);
      this._backgroundGroup = null;
    };
    BarView2.type = "bar";
    return BarView2;
  }(Chart_default);
  var clip = {
    cartesian2d: function(coordSysBoundingRect, layout5) {
      var signWidth = layout5.width < 0 ? -1 : 1;
      var signHeight = layout5.height < 0 ? -1 : 1;
      if (signWidth < 0) {
        layout5.x += layout5.width;
        layout5.width = -layout5.width;
      }
      if (signHeight < 0) {
        layout5.y += layout5.height;
        layout5.height = -layout5.height;
      }
      var coordSysX2 = coordSysBoundingRect.x + coordSysBoundingRect.width;
      var coordSysY2 = coordSysBoundingRect.y + coordSysBoundingRect.height;
      var x = mathMax7(layout5.x, coordSysBoundingRect.x);
      var x2 = mathMin7(layout5.x + layout5.width, coordSysX2);
      var y = mathMax7(layout5.y, coordSysBoundingRect.y);
      var y2 = mathMin7(layout5.y + layout5.height, coordSysY2);
      var xClipped = x2 < x;
      var yClipped = y2 < y;
      layout5.x = xClipped && x > coordSysX2 ? x2 : x;
      layout5.y = yClipped && y > coordSysY2 ? y2 : y;
      layout5.width = xClipped ? 0 : x2 - x;
      layout5.height = yClipped ? 0 : y2 - y;
      if (signWidth < 0) {
        layout5.x += layout5.width;
        layout5.width = -layout5.width;
      }
      if (signHeight < 0) {
        layout5.y += layout5.height;
        layout5.height = -layout5.height;
      }
      return xClipped || yClipped;
    },
    polar: function(coordSysClipArea, layout5) {
      var signR = layout5.r0 <= layout5.r ? 1 : -1;
      if (signR < 0) {
        var tmp = layout5.r;
        layout5.r = layout5.r0;
        layout5.r0 = tmp;
      }
      var r = mathMin7(layout5.r, coordSysClipArea.r);
      var r0 = mathMax7(layout5.r0, coordSysClipArea.r0);
      layout5.r = r;
      layout5.r0 = r0;
      var clipped = r - r0 < 0;
      if (signR < 0) {
        var tmp = layout5.r;
        layout5.r = layout5.r0;
        layout5.r0 = tmp;
      }
      return clipped;
    }
  };
  var elementCreator = {
    cartesian2d: function(seriesModel, data, newIndex, layout5, isHorizontal, animationModel, axisModel, isUpdate, roundCap) {
      var rect = new Rect_default({
        shape: extend({}, layout5),
        z2: 1
      });
      rect.__dataIndex = newIndex;
      rect.name = "item";
      if (animationModel) {
        var rectShape = rect.shape;
        var animateProperty = isHorizontal ? "height" : "width";
        rectShape[animateProperty] = 0;
      }
      return rect;
    },
    polar: function(seriesModel, data, newIndex, layout5, isRadial, animationModel, axisModel, isUpdate, roundCap) {
      var ShapeClass = !isRadial && roundCap ? sausage_default : Sector_default;
      var sector = new ShapeClass({
        shape: layout5,
        z2: 1
      });
      sector.name = "item";
      var positionMap = createPolarPositionMapping(isRadial);
      sector.calculateTextPosition = createSectorCalculateTextPosition(positionMap, {
        isRoundCap: ShapeClass === sausage_default
      });
      if (animationModel) {
        var sectorShape = sector.shape;
        var animateProperty = isRadial ? "r" : "endAngle";
        var animateTarget = {};
        sectorShape[animateProperty] = isRadial ? 0 : layout5.startAngle;
        animateTarget[animateProperty] = layout5[animateProperty];
        (isUpdate ? updateProps : initProps)(sector, {
          shape: animateTarget
        }, animationModel);
      }
      return sector;
    }
  };
  function shouldRealtimeSort(seriesModel, coordSys) {
    var realtimeSortOption = seriesModel.get("realtimeSort", true);
    var baseAxis = coordSys.getBaseAxis();
    if (true) {
      if (realtimeSortOption) {
        if (baseAxis.type !== "category") {
          warn("`realtimeSort` will not work because this bar series is not based on a category axis.");
        }
        if (coordSys.type !== "cartesian2d") {
          warn("`realtimeSort` will not work because this bar series is not on cartesian2d.");
        }
      }
    }
    if (realtimeSortOption && baseAxis.type === "category" && coordSys.type === "cartesian2d") {
      return {
        baseAxis,
        otherAxis: coordSys.getOtherAxis(baseAxis)
      };
    }
  }
  function updateRealtimeAnimation(realtimeSortCfg, seriesAnimationModel, el, layout5, newIndex, isHorizontal, isUpdate, isChangeOrder) {
    var seriesTarget;
    var axisTarget;
    if (isHorizontal) {
      axisTarget = {
        x: layout5.x,
        width: layout5.width
      };
      seriesTarget = {
        y: layout5.y,
        height: layout5.height
      };
    } else {
      axisTarget = {
        y: layout5.y,
        height: layout5.height
      };
      seriesTarget = {
        x: layout5.x,
        width: layout5.width
      };
    }
    if (!isChangeOrder) {
      (isUpdate ? updateProps : initProps)(el, {
        shape: seriesTarget
      }, seriesAnimationModel, newIndex, null);
    }
    var axisAnimationModel = seriesAnimationModel ? realtimeSortCfg.baseAxis.model : null;
    (isUpdate ? updateProps : initProps)(el, {
      shape: axisTarget
    }, axisAnimationModel, newIndex);
  }
  function checkPropertiesNotValid(obj, props) {
    for (var i = 0; i < props.length; i++) {
      if (!isFinite(obj[props[i]])) {
        return true;
      }
    }
    return false;
  }
  var rectPropties = ["x", "y", "width", "height"];
  var polarPropties = ["cx", "cy", "r", "startAngle", "endAngle"];
  var isValidLayout = {
    cartesian2d: function(layout5) {
      return !checkPropertiesNotValid(layout5, rectPropties);
    },
    polar: function(layout5) {
      return !checkPropertiesNotValid(layout5, polarPropties);
    }
  };
  var getLayout = {
    cartesian2d: function(data, dataIndex, itemModel) {
      var layout5 = data.getItemLayout(dataIndex);
      var fixedLineWidth = itemModel ? getLineWidth(itemModel, layout5) : 0;
      var signX = layout5.width > 0 ? 1 : -1;
      var signY = layout5.height > 0 ? 1 : -1;
      return {
        x: layout5.x + signX * fixedLineWidth / 2,
        y: layout5.y + signY * fixedLineWidth / 2,
        width: layout5.width - signX * fixedLineWidth,
        height: layout5.height - signY * fixedLineWidth
      };
    },
    polar: function(data, dataIndex, itemModel) {
      var layout5 = data.getItemLayout(dataIndex);
      return {
        cx: layout5.cx,
        cy: layout5.cy,
        r0: layout5.r0,
        r: layout5.r,
        startAngle: layout5.startAngle,
        endAngle: layout5.endAngle,
        clockwise: layout5.clockwise
      };
    }
  };
  function isZeroOnPolar(layout5) {
    return layout5.startAngle != null && layout5.endAngle != null && layout5.startAngle === layout5.endAngle;
  }
  function createPolarPositionMapping(isRadial) {
    return function(isRadial2) {
      var arcOrAngle = isRadial2 ? "Arc" : "Angle";
      return function(position2) {
        switch (position2) {
          case "start":
          case "insideStart":
          case "end":
          case "insideEnd":
            return position2 + arcOrAngle;
          default:
            return position2;
        }
      };
    }(isRadial);
  }
  function updateStyle(el, data, dataIndex, itemModel, layout5, seriesModel, isHorizontalOrRadial, isPolar) {
    var style = data.getItemVisual(dataIndex, "style");
    if (!isPolar) {
      el.setShape("r", itemModel.get(["itemStyle", "borderRadius"]) || 0);
    }
    el.useStyle(style);
    var cursorStyle = itemModel.getShallow("cursor");
    cursorStyle && el.attr("cursor", cursorStyle);
    var labelPositionOutside = isPolar ? isHorizontalOrRadial ? layout5.r >= layout5.r0 ? "endArc" : "startArc" : layout5.endAngle >= layout5.startAngle ? "endAngle" : "startAngle" : isHorizontalOrRadial ? layout5.height >= 0 ? "bottom" : "top" : layout5.width >= 0 ? "right" : "left";
    var labelStatesModels = getLabelStatesModels(itemModel);
    setLabelStyle(el, labelStatesModels, {
      labelFetcher: seriesModel,
      labelDataIndex: dataIndex,
      defaultText: getDefaultLabel(seriesModel.getData(), dataIndex),
      inheritColor: style.fill,
      defaultOpacity: style.opacity,
      defaultOutsidePosition: labelPositionOutside
    });
    var label = el.getTextContent();
    if (isPolar && label) {
      var position2 = itemModel.get(["label", "position"]);
      el.textConfig.inside = position2 === "middle" ? true : null;
      setSectorTextRotation(el, position2 === "outside" ? labelPositionOutside : position2, createPolarPositionMapping(isHorizontalOrRadial), itemModel.get(["label", "rotate"]));
    }
    setLabelValueAnimation(label, labelStatesModels, seriesModel.getRawValue(dataIndex), function(value) {
      return getDefaultInterpolatedLabel(data, value);
    });
    var emphasisModel = itemModel.getModel(["emphasis"]);
    toggleHoverEmphasis(el, emphasisModel.get("focus"), emphasisModel.get("blurScope"), emphasisModel.get("disabled"));
    setStatesStylesFromModel(el, itemModel);
    if (isZeroOnPolar(layout5)) {
      el.style.fill = "none";
      el.style.stroke = "none";
      each(el.states, function(state) {
        if (state.style) {
          state.style.fill = state.style.stroke = "none";
        }
      });
    }
  }
  function getLineWidth(itemModel, rawLayout) {
    var borderColor = itemModel.get(["itemStyle", "borderColor"]);
    if (!borderColor || borderColor === "none") {
      return 0;
    }
    var lineWidth = itemModel.get(["itemStyle", "borderWidth"]) || 0;
    var width = isNaN(rawLayout.width) ? Number.MAX_VALUE : Math.abs(rawLayout.width);
    var height = isNaN(rawLayout.height) ? Number.MAX_VALUE : Math.abs(rawLayout.height);
    return Math.min(lineWidth, width, height);
  }
  var LagePathShape = function() {
    function LagePathShape2() {
    }
    return LagePathShape2;
  }();
  var LargePath = function(_super) {
    __extends(LargePath2, _super);
    function LargePath2(opts) {
      var _this = _super.call(this, opts) || this;
      _this.type = "largeBar";
      return _this;
    }
    LargePath2.prototype.getDefaultShape = function() {
      return new LagePathShape();
    };
    LargePath2.prototype.buildPath = function(ctx, shape) {
      var points4 = shape.points;
      var baseDimIdx = this.baseDimIdx;
      var valueDimIdx = 1 - this.baseDimIdx;
      var startPoint = [];
      var size = [];
      var barWidth = this.barWidth;
      for (var i = 0; i < points4.length; i += 3) {
        size[baseDimIdx] = barWidth;
        size[valueDimIdx] = points4[i + 2];
        startPoint[baseDimIdx] = points4[i + baseDimIdx];
        startPoint[valueDimIdx] = points4[i + valueDimIdx];
        ctx.rect(startPoint[0], startPoint[1], size[0], size[1]);
      }
    };
    return LargePath2;
  }(Path_default);
  function createLarge(seriesModel, group, progressiveEls, incremental) {
    var data = seriesModel.getData();
    var baseDimIdx = data.getLayout("valueAxisHorizontal") ? 1 : 0;
    var largeDataIndices = data.getLayout("largeDataIndices");
    var barWidth = data.getLayout("size");
    var backgroundModel = seriesModel.getModel("backgroundStyle");
    var bgPoints = data.getLayout("largeBackgroundPoints");
    if (bgPoints) {
      var bgEl = new LargePath({
        shape: {
          points: bgPoints
        },
        incremental: !!incremental,
        silent: true,
        z2: 0
      });
      bgEl.baseDimIdx = baseDimIdx;
      bgEl.largeDataIndices = largeDataIndices;
      bgEl.barWidth = barWidth;
      bgEl.useStyle(backgroundModel.getItemStyle());
      group.add(bgEl);
      progressiveEls && progressiveEls.push(bgEl);
    }
    var el = new LargePath({
      shape: {
        points: data.getLayout("largePoints")
      },
      incremental: !!incremental,
      z2: 1
    });
    el.baseDimIdx = baseDimIdx;
    el.largeDataIndices = largeDataIndices;
    el.barWidth = barWidth;
    group.add(el);
    el.useStyle(data.getVisual("style"));
    getECData(el).seriesIndex = seriesModel.seriesIndex;
    if (!seriesModel.get("silent")) {
      el.on("mousedown", largePathUpdateDataIndex);
      el.on("mousemove", largePathUpdateDataIndex);
    }
    progressiveEls && progressiveEls.push(el);
  }
  var largePathUpdateDataIndex = throttle(function(event) {
    var largePath = this;
    var dataIndex = largePathFindDataIndex(largePath, event.offsetX, event.offsetY);
    getECData(largePath).dataIndex = dataIndex >= 0 ? dataIndex : null;
  }, 30, false);
  function largePathFindDataIndex(largePath, x, y) {
    var baseDimIdx = largePath.baseDimIdx;
    var valueDimIdx = 1 - baseDimIdx;
    var points4 = largePath.shape.points;
    var largeDataIndices = largePath.largeDataIndices;
    var startPoint = [];
    var size = [];
    var barWidth = largePath.barWidth;
    for (var i = 0, len2 = points4.length / 3; i < len2; i++) {
      var ii = i * 3;
      size[baseDimIdx] = barWidth;
      size[valueDimIdx] = points4[ii + 2];
      startPoint[baseDimIdx] = points4[ii + baseDimIdx];
      startPoint[valueDimIdx] = points4[ii + valueDimIdx];
      if (size[valueDimIdx] < 0) {
        startPoint[valueDimIdx] += size[valueDimIdx];
        size[valueDimIdx] = -size[valueDimIdx];
      }
      if (x >= startPoint[0] && x <= startPoint[0] + size[0] && y >= startPoint[1] && y <= startPoint[1] + size[1]) {
        return largeDataIndices[i];
      }
    }
    return -1;
  }
  function createBackgroundShape(isHorizontalOrRadial, layout5, coord) {
    if (isCoordinateSystemType(coord, "cartesian2d")) {
      var rectShape = layout5;
      var coordLayout = coord.getArea();
      return {
        x: isHorizontalOrRadial ? rectShape.x : coordLayout.x,
        y: isHorizontalOrRadial ? coordLayout.y : rectShape.y,
        width: isHorizontalOrRadial ? rectShape.width : coordLayout.width,
        height: isHorizontalOrRadial ? coordLayout.height : rectShape.height
      };
    } else {
      var coordLayout = coord.getArea();
      var sectorShape = layout5;
      return {
        cx: coordLayout.cx,
        cy: coordLayout.cy,
        r0: isHorizontalOrRadial ? coordLayout.r0 : sectorShape.r0,
        r: isHorizontalOrRadial ? coordLayout.r : sectorShape.r,
        startAngle: isHorizontalOrRadial ? sectorShape.startAngle : 0,
        endAngle: isHorizontalOrRadial ? sectorShape.endAngle : Math.PI * 2
      };
    }
  }
  function createBackgroundEl(coord, isHorizontalOrRadial, layout5) {
    var ElementClz = coord.type === "polar" ? Sector_default : Rect_default;
    return new ElementClz({
      shape: createBackgroundShape(isHorizontalOrRadial, layout5, coord),
      silent: true,
      z2: 0
    });
  }
  var BarView_default = BarView;

  // node_modules/echarts/lib/chart/bar/install.js
  function install4(registers) {
    registers.registerChartView(BarView_default);
    registers.registerSeriesModel(BarSeries_default);
    registers.registerLayout(registers.PRIORITY.VISUAL.LAYOUT, curry(layout, "bar"));
    registers.registerLayout(registers.PRIORITY.VISUAL.PROGRESSIVE_LAYOUT, createProgressiveLayout("bar"));
    registers.registerProcessor(registers.PRIORITY.PROCESSOR.STATISTIC, dataSample("bar"));
    registers.registerAction({
      type: "changeAxisOrder",
      event: "changeAxisOrder",
      update: "update"
    }, function(payload, ecModel) {
      var componentType = payload.componentType || "series";
      ecModel.eachComponent({
        mainType: componentType,
        query: payload
      }, function(componentModel) {
        if (payload.sortInfo) {
          componentModel.axis.setCategorySortInfo(payload.sortInfo);
        }
      });
    });
  }

  // node_modules/echarts/lib/chart/pie/pieLayout.js
  var PI29 = Math.PI * 2;
  var RADIAN = Math.PI / 180;
  function getViewRect(seriesModel, api) {
    return getLayoutRect(seriesModel.getBoxLayoutParams(), {
      width: api.getWidth(),
      height: api.getHeight()
    });
  }
  function getBasicPieLayout(seriesModel, api) {
    var viewRect2 = getViewRect(seriesModel, api);
    var center3 = seriesModel.get("center");
    var radius = seriesModel.get("radius");
    if (!isArray(radius)) {
      radius = [0, radius];
    }
    if (!isArray(center3)) {
      center3 = [center3, center3];
    }
    var width = parsePercent2(viewRect2.width, api.getWidth());
    var height = parsePercent2(viewRect2.height, api.getHeight());
    var size = Math.min(width, height);
    var cx = parsePercent2(center3[0], width) + viewRect2.x;
    var cy = parsePercent2(center3[1], height) + viewRect2.y;
    var r0 = parsePercent2(radius[0], size / 2);
    var r = parsePercent2(radius[1], size / 2);
    return {
      cx,
      cy,
      r0,
      r
    };
  }
  function pieLayout(seriesType2, ecModel, api) {
    ecModel.eachSeriesByType(seriesType2, function(seriesModel) {
      var data = seriesModel.getData();
      var valueDim = data.mapDimension("value");
      var viewRect2 = getViewRect(seriesModel, api);
      var _a2 = getBasicPieLayout(seriesModel, api), cx = _a2.cx, cy = _a2.cy, r = _a2.r, r0 = _a2.r0;
      var startAngle = -seriesModel.get("startAngle") * RADIAN;
      var minAngle = seriesModel.get("minAngle") * RADIAN;
      var validDataCount = 0;
      data.each(valueDim, function(value) {
        !isNaN(value) && validDataCount++;
      });
      var sum2 = data.getSum(valueDim);
      var unitRadian = Math.PI / (sum2 || validDataCount) * 2;
      var clockwise = seriesModel.get("clockwise");
      var roseType = seriesModel.get("roseType");
      var stillShowZeroSum = seriesModel.get("stillShowZeroSum");
      var extent3 = data.getDataExtent(valueDim);
      extent3[0] = 0;
      var restAngle = PI29;
      var valueSumLargerThanMinAngle = 0;
      var currentAngle = startAngle;
      var dir3 = clockwise ? 1 : -1;
      data.setLayout({
        viewRect: viewRect2,
        r
      });
      data.each(valueDim, function(value, idx) {
        var angle;
        if (isNaN(value)) {
          data.setItemLayout(idx, {
            angle: NaN,
            startAngle: NaN,
            endAngle: NaN,
            clockwise,
            cx,
            cy,
            r0,
            r: roseType ? NaN : r
          });
          return;
        }
        if (roseType !== "area") {
          angle = sum2 === 0 && stillShowZeroSum ? unitRadian : value * unitRadian;
        } else {
          angle = PI29 / validDataCount;
        }
        if (angle < minAngle) {
          angle = minAngle;
          restAngle -= minAngle;
        } else {
          valueSumLargerThanMinAngle += value;
        }
        var endAngle = currentAngle + dir3 * angle;
        data.setItemLayout(idx, {
          angle,
          startAngle: currentAngle,
          endAngle,
          clockwise,
          cx,
          cy,
          r0,
          r: roseType ? linearMap(value, extent3, [r0, r]) : r
        });
        currentAngle = endAngle;
      });
      if (restAngle < PI29 && validDataCount) {
        if (restAngle <= 1e-3) {
          var angle_1 = PI29 / validDataCount;
          data.each(valueDim, function(value, idx) {
            if (!isNaN(value)) {
              var layout_1 = data.getItemLayout(idx);
              layout_1.angle = angle_1;
              layout_1.startAngle = startAngle + dir3 * idx * angle_1;
              layout_1.endAngle = startAngle + dir3 * (idx + 1) * angle_1;
            }
          });
        } else {
          unitRadian = restAngle / valueSumLargerThanMinAngle;
          currentAngle = startAngle;
          data.each(valueDim, function(value, idx) {
            if (!isNaN(value)) {
              var layout_2 = data.getItemLayout(idx);
              var angle = layout_2.angle === minAngle ? minAngle : value * unitRadian;
              layout_2.startAngle = currentAngle;
              layout_2.endAngle = currentAngle + dir3 * angle;
              currentAngle += dir3 * angle;
            }
          });
        }
      }
    });
  }

  // node_modules/echarts/lib/processor/dataFilter.js
  function dataFilter(seriesType2) {
    return {
      seriesType: seriesType2,
      reset: function(seriesModel, ecModel) {
        var legendModels = ecModel.findComponents({
          mainType: "legend"
        });
        if (!legendModels || !legendModels.length) {
          return;
        }
        var data = seriesModel.getData();
        data.filterSelf(function(idx) {
          var name = data.getName(idx);
          for (var i = 0; i < legendModels.length; i++) {
            if (!legendModels[i].isSelected(name)) {
              return false;
            }
          }
          return true;
        });
      }
    };
  }

  // node_modules/echarts/lib/chart/pie/labelLayout.js
  var RADIAN2 = Math.PI / 180;
  function adjustSingleSide(list, cx, cy, r, dir3, viewWidth, viewHeight, viewLeft, viewTop, farthestX) {
    if (list.length < 2) {
      return;
    }
    ;
    function recalculateXOnSemiToAlignOnEllipseCurve(semi) {
      var rB = semi.rB;
      var rB2 = rB * rB;
      for (var i2 = 0; i2 < semi.list.length; i2++) {
        var item = semi.list[i2];
        var dy = Math.abs(item.label.y - cy);
        var rA = r + item.len;
        var rA2 = rA * rA;
        var dx2 = Math.sqrt((1 - Math.abs(dy * dy / rB2)) * rA2);
        var newX = cx + (dx2 + item.len2) * dir3;
        var deltaX = newX - item.label.x;
        var newTargetWidth = item.targetTextWidth - deltaX * dir3;
        constrainTextWidth(item, newTargetWidth, true);
        item.label.x = newX;
      }
    }
    function recalculateX(items) {
      var topSemi = {
        list: [],
        maxY: 0
      };
      var bottomSemi = {
        list: [],
        maxY: 0
      };
      for (var i2 = 0; i2 < items.length; i2++) {
        if (items[i2].labelAlignTo !== "none") {
          continue;
        }
        var item = items[i2];
        var semi = item.label.y > cy ? bottomSemi : topSemi;
        var dy = Math.abs(item.label.y - cy);
        if (dy >= semi.maxY) {
          var dx2 = item.label.x - cx - item.len2 * dir3;
          var rA = r + item.len;
          var rB = Math.abs(dx2) < rA ? Math.sqrt(dy * dy / (1 - dx2 * dx2 / rA / rA)) : rA;
          semi.rB = rB;
          semi.maxY = dy;
        }
        semi.list.push(item);
      }
      recalculateXOnSemiToAlignOnEllipseCurve(topSemi);
      recalculateXOnSemiToAlignOnEllipseCurve(bottomSemi);
    }
    var len2 = list.length;
    for (var i = 0; i < len2; i++) {
      if (list[i].position === "outer" && list[i].labelAlignTo === "labelLine") {
        var dx = list[i].label.x - farthestX;
        list[i].linePoints[1][0] += dx;
        list[i].label.x = farthestX;
      }
    }
    if (shiftLayoutOnY(list, viewTop, viewTop + viewHeight)) {
      recalculateX(list);
    }
  }
  function avoidOverlap(labelLayoutList, cx, cy, r, viewWidth, viewHeight, viewLeft, viewTop) {
    var leftList = [];
    var rightList = [];
    var leftmostX = Number.MAX_VALUE;
    var rightmostX = -Number.MAX_VALUE;
    for (var i = 0; i < labelLayoutList.length; i++) {
      var label = labelLayoutList[i].label;
      if (isPositionCenter(labelLayoutList[i])) {
        continue;
      }
      if (label.x < cx) {
        leftmostX = Math.min(leftmostX, label.x);
        leftList.push(labelLayoutList[i]);
      } else {
        rightmostX = Math.max(rightmostX, label.x);
        rightList.push(labelLayoutList[i]);
      }
    }
    for (var i = 0; i < labelLayoutList.length; i++) {
      var layout5 = labelLayoutList[i];
      if (!isPositionCenter(layout5) && layout5.linePoints) {
        if (layout5.labelStyleWidth != null) {
          continue;
        }
        var label = layout5.label;
        var linePoints = layout5.linePoints;
        var targetTextWidth = void 0;
        if (layout5.labelAlignTo === "edge") {
          if (label.x < cx) {
            targetTextWidth = linePoints[2][0] - layout5.labelDistance - viewLeft - layout5.edgeDistance;
          } else {
            targetTextWidth = viewLeft + viewWidth - layout5.edgeDistance - linePoints[2][0] - layout5.labelDistance;
          }
        } else if (layout5.labelAlignTo === "labelLine") {
          if (label.x < cx) {
            targetTextWidth = leftmostX - viewLeft - layout5.bleedMargin;
          } else {
            targetTextWidth = viewLeft + viewWidth - rightmostX - layout5.bleedMargin;
          }
        } else {
          if (label.x < cx) {
            targetTextWidth = label.x - viewLeft - layout5.bleedMargin;
          } else {
            targetTextWidth = viewLeft + viewWidth - label.x - layout5.bleedMargin;
          }
        }
        layout5.targetTextWidth = targetTextWidth;
        constrainTextWidth(layout5, targetTextWidth);
      }
    }
    adjustSingleSide(rightList, cx, cy, r, 1, viewWidth, viewHeight, viewLeft, viewTop, rightmostX);
    adjustSingleSide(leftList, cx, cy, r, -1, viewWidth, viewHeight, viewLeft, viewTop, leftmostX);
    for (var i = 0; i < labelLayoutList.length; i++) {
      var layout5 = labelLayoutList[i];
      if (!isPositionCenter(layout5) && layout5.linePoints) {
        var label = layout5.label;
        var linePoints = layout5.linePoints;
        var isAlignToEdge = layout5.labelAlignTo === "edge";
        var padding = label.style.padding;
        var paddingH = padding ? padding[1] + padding[3] : 0;
        var extraPaddingH = label.style.backgroundColor ? 0 : paddingH;
        var realTextWidth = layout5.rect.width + extraPaddingH;
        var dist3 = linePoints[1][0] - linePoints[2][0];
        if (isAlignToEdge) {
          if (label.x < cx) {
            linePoints[2][0] = viewLeft + layout5.edgeDistance + realTextWidth + layout5.labelDistance;
          } else {
            linePoints[2][0] = viewLeft + viewWidth - layout5.edgeDistance - realTextWidth - layout5.labelDistance;
          }
        } else {
          if (label.x < cx) {
            linePoints[2][0] = label.x + layout5.labelDistance;
          } else {
            linePoints[2][0] = label.x - layout5.labelDistance;
          }
          linePoints[1][0] = linePoints[2][0] + dist3;
        }
        linePoints[1][1] = linePoints[2][1] = label.y;
      }
    }
  }
  function constrainTextWidth(layout5, availableWidth, forceRecalculate) {
    if (forceRecalculate === void 0) {
      forceRecalculate = false;
    }
    if (layout5.labelStyleWidth != null) {
      return;
    }
    var label = layout5.label;
    var style = label.style;
    var textRect = layout5.rect;
    var bgColor = style.backgroundColor;
    var padding = style.padding;
    var paddingH = padding ? padding[1] + padding[3] : 0;
    var overflow = style.overflow;
    var oldOuterWidth = textRect.width + (bgColor ? 0 : paddingH);
    if (availableWidth < oldOuterWidth || forceRecalculate) {
      var oldHeight = textRect.height;
      if (overflow && overflow.match("break")) {
        label.setStyle("backgroundColor", null);
        label.setStyle("width", availableWidth - paddingH);
        var innerRect = label.getBoundingRect();
        label.setStyle("width", Math.ceil(innerRect.width));
        label.setStyle("backgroundColor", bgColor);
      } else {
        var availableInnerWidth = availableWidth - paddingH;
        var newWidth = availableWidth < oldOuterWidth ? availableInnerWidth : forceRecalculate ? availableInnerWidth > layout5.unconstrainedWidth ? null : availableInnerWidth : null;
        label.setStyle("width", newWidth);
      }
      var newRect = label.getBoundingRect();
      textRect.width = newRect.width;
      var margin = (label.style.margin || 0) + 2.1;
      textRect.height = newRect.height + margin;
      textRect.y -= (textRect.height - oldHeight) / 2;
    }
  }
  function isPositionCenter(sectorShape) {
    return sectorShape.position === "center";
  }
  function pieLabelLayout(seriesModel) {
    var data = seriesModel.getData();
    var labelLayoutList = [];
    var cx;
    var cy;
    var hasLabelRotate = false;
    var minShowLabelRadian = (seriesModel.get("minShowLabelAngle") || 0) * RADIAN2;
    var viewRect2 = data.getLayout("viewRect");
    var r = data.getLayout("r");
    var viewWidth = viewRect2.width;
    var viewLeft = viewRect2.x;
    var viewTop = viewRect2.y;
    var viewHeight = viewRect2.height;
    function setNotShow(el) {
      el.ignore = true;
    }
    function isLabelShown(label2) {
      if (!label2.ignore) {
        return true;
      }
      for (var key in label2.states) {
        if (label2.states[key].ignore === false) {
          return true;
        }
      }
      return false;
    }
    data.each(function(idx) {
      var sector = data.getItemGraphicEl(idx);
      var sectorShape = sector.shape;
      var label2 = sector.getTextContent();
      var labelLine2 = sector.getTextGuideLine();
      var itemModel = data.getItemModel(idx);
      var labelModel = itemModel.getModel("label");
      var labelPosition = labelModel.get("position") || itemModel.get(["emphasis", "label", "position"]);
      var labelDistance = labelModel.get("distanceToLabelLine");
      var labelAlignTo = labelModel.get("alignTo");
      var edgeDistance = parsePercent2(labelModel.get("edgeDistance"), viewWidth);
      var bleedMargin = labelModel.get("bleedMargin");
      var labelLineModel = itemModel.getModel("labelLine");
      var labelLineLen = labelLineModel.get("length");
      labelLineLen = parsePercent2(labelLineLen, viewWidth);
      var labelLineLen2 = labelLineModel.get("length2");
      labelLineLen2 = parsePercent2(labelLineLen2, viewWidth);
      if (Math.abs(sectorShape.endAngle - sectorShape.startAngle) < minShowLabelRadian) {
        each(label2.states, setNotShow);
        label2.ignore = true;
        return;
      }
      if (!isLabelShown(label2)) {
        return;
      }
      var midAngle = (sectorShape.startAngle + sectorShape.endAngle) / 2;
      var nx = Math.cos(midAngle);
      var ny = Math.sin(midAngle);
      var textX;
      var textY;
      var linePoints2;
      var textAlign;
      cx = sectorShape.cx;
      cy = sectorShape.cy;
      var isLabelInside = labelPosition === "inside" || labelPosition === "inner";
      if (labelPosition === "center") {
        textX = sectorShape.cx;
        textY = sectorShape.cy;
        textAlign = "center";
      } else {
        var x1 = (isLabelInside ? (sectorShape.r + sectorShape.r0) / 2 * nx : sectorShape.r * nx) + cx;
        var y1 = (isLabelInside ? (sectorShape.r + sectorShape.r0) / 2 * ny : sectorShape.r * ny) + cy;
        textX = x1 + nx * 3;
        textY = y1 + ny * 3;
        if (!isLabelInside) {
          var x2 = x1 + nx * (labelLineLen + r - sectorShape.r);
          var y2 = y1 + ny * (labelLineLen + r - sectorShape.r);
          var x3 = x2 + (nx < 0 ? -1 : 1) * labelLineLen2;
          var y3 = y2;
          if (labelAlignTo === "edge") {
            textX = nx < 0 ? viewLeft + edgeDistance : viewLeft + viewWidth - edgeDistance;
          } else {
            textX = x3 + (nx < 0 ? -labelDistance : labelDistance);
          }
          textY = y3;
          linePoints2 = [[x1, y1], [x2, y2], [x3, y3]];
        }
        textAlign = isLabelInside ? "center" : labelAlignTo === "edge" ? nx > 0 ? "right" : "left" : nx > 0 ? "left" : "right";
      }
      var PI11 = Math.PI;
      var labelRotate = 0;
      var rotate2 = labelModel.get("rotate");
      if (isNumber(rotate2)) {
        labelRotate = rotate2 * (PI11 / 180);
      } else if (labelPosition === "center") {
        labelRotate = 0;
      } else if (rotate2 === "radial" || rotate2 === true) {
        var radialAngle = nx < 0 ? -midAngle + PI11 : -midAngle;
        labelRotate = radialAngle;
      } else if (rotate2 === "tangential" && labelPosition !== "outside" && labelPosition !== "outer") {
        var rad = Math.atan2(nx, ny);
        if (rad < 0) {
          rad = PI11 * 2 + rad;
        }
        var isDown = ny > 0;
        if (isDown) {
          rad = PI11 + rad;
        }
        labelRotate = rad - PI11;
      }
      hasLabelRotate = !!labelRotate;
      label2.x = textX;
      label2.y = textY;
      label2.rotation = labelRotate;
      label2.setStyle({
        verticalAlign: "middle"
      });
      if (!isLabelInside) {
        var textRect = label2.getBoundingRect().clone();
        textRect.applyTransform(label2.getComputedTransform());
        var margin = (label2.style.margin || 0) + 2.1;
        textRect.y -= margin / 2;
        textRect.height += margin;
        labelLayoutList.push({
          label: label2,
          labelLine: labelLine2,
          position: labelPosition,
          len: labelLineLen,
          len2: labelLineLen2,
          minTurnAngle: labelLineModel.get("minTurnAngle"),
          maxSurfaceAngle: labelLineModel.get("maxSurfaceAngle"),
          surfaceNormal: new Point_default(nx, ny),
          linePoints: linePoints2,
          textAlign,
          labelDistance,
          labelAlignTo,
          edgeDistance,
          bleedMargin,
          rect: textRect,
          unconstrainedWidth: textRect.width,
          labelStyleWidth: label2.style.width
        });
      } else {
        label2.setStyle({
          align: textAlign
        });
        var selectState2 = label2.states.select;
        if (selectState2) {
          selectState2.x += label2.x;
          selectState2.y += label2.y;
        }
      }
      sector.setTextConfig({
        inside: isLabelInside
      });
    });
    if (!hasLabelRotate && seriesModel.get("avoidLabelOverlap")) {
      avoidOverlap(labelLayoutList, cx, cy, r, viewWidth, viewHeight, viewLeft, viewTop);
    }
    for (var i = 0; i < labelLayoutList.length; i++) {
      var layout5 = labelLayoutList[i];
      var label = layout5.label;
      var labelLine = layout5.labelLine;
      var notShowLabel = isNaN(label.x) || isNaN(label.y);
      if (label) {
        label.setStyle({
          align: layout5.textAlign
        });
        if (notShowLabel) {
          each(label.states, setNotShow);
          label.ignore = true;
        }
        var selectState = label.states.select;
        if (selectState) {
          selectState.x += label.x;
          selectState.y += label.y;
        }
      }
      if (labelLine) {
        var linePoints = layout5.linePoints;
        if (notShowLabel || !linePoints) {
          each(labelLine.states, setNotShow);
          labelLine.ignore = true;
        } else {
          limitTurnAngle(linePoints, layout5.minTurnAngle);
          limitSurfaceAngle(linePoints, layout5.surfaceNormal, layout5.maxSurfaceAngle);
          labelLine.setShape({
            points: linePoints
          });
          label.__hostTarget.textGuideLineConfig = {
            anchor: new Point_default(linePoints[0][0], linePoints[0][1])
          };
        }
      }
    }
  }

  // node_modules/echarts/lib/chart/helper/pieHelper.js
  function getSectorCornerRadius(model, shape, zeroIfNull) {
    var cornerRadius = model.get("borderRadius");
    if (cornerRadius == null) {
      return zeroIfNull ? {
        cornerRadius: 0
      } : null;
    }
    if (!isArray(cornerRadius)) {
      cornerRadius = [cornerRadius, cornerRadius, cornerRadius, cornerRadius];
    }
    var dr = Math.abs(shape.r || 0 - shape.r0 || 0);
    return {
      cornerRadius: map(cornerRadius, function(cr) {
        return parsePercent(cr, dr);
      })
    };
  }

  // node_modules/echarts/lib/chart/pie/PieView.js
  var PiePiece = function(_super) {
    __extends(PiePiece2, _super);
    function PiePiece2(data, idx, startAngle) {
      var _this = _super.call(this) || this;
      _this.z2 = 2;
      var text = new Text_default();
      _this.setTextContent(text);
      _this.updateData(data, idx, startAngle, true);
      return _this;
    }
    PiePiece2.prototype.updateData = function(data, idx, startAngle, firstCreate) {
      var sector = this;
      var seriesModel = data.hostModel;
      var itemModel = data.getItemModel(idx);
      var emphasisModel = itemModel.getModel("emphasis");
      var layout5 = data.getItemLayout(idx);
      var sectorShape = extend(getSectorCornerRadius(itemModel.getModel("itemStyle"), layout5, true), layout5);
      if (isNaN(sectorShape.startAngle)) {
        sector.setShape(sectorShape);
        return;
      }
      if (firstCreate) {
        sector.setShape(sectorShape);
        var animationType = seriesModel.getShallow("animationType");
        if (seriesModel.ecModel.ssr) {
          initProps(sector, {
            scaleX: 0,
            scaleY: 0
          }, seriesModel, {
            dataIndex: idx,
            isFrom: true
          });
          sector.originX = sectorShape.cx;
          sector.originY = sectorShape.cy;
        } else if (animationType === "scale") {
          sector.shape.r = layout5.r0;
          initProps(sector, {
            shape: {
              r: layout5.r
            }
          }, seriesModel, idx);
        } else {
          if (startAngle != null) {
            sector.setShape({
              startAngle,
              endAngle: startAngle
            });
            initProps(sector, {
              shape: {
                startAngle: layout5.startAngle,
                endAngle: layout5.endAngle
              }
            }, seriesModel, idx);
          } else {
            sector.shape.endAngle = layout5.startAngle;
            updateProps(sector, {
              shape: {
                endAngle: layout5.endAngle
              }
            }, seriesModel, idx);
          }
        }
      } else {
        saveOldStyle(sector);
        updateProps(sector, {
          shape: sectorShape
        }, seriesModel, idx);
      }
      sector.useStyle(data.getItemVisual(idx, "style"));
      setStatesStylesFromModel(sector, itemModel);
      var midAngle = (layout5.startAngle + layout5.endAngle) / 2;
      var offset = seriesModel.get("selectedOffset");
      var dx = Math.cos(midAngle) * offset;
      var dy = Math.sin(midAngle) * offset;
      var cursorStyle = itemModel.getShallow("cursor");
      cursorStyle && sector.attr("cursor", cursorStyle);
      this._updateLabel(seriesModel, data, idx);
      sector.ensureState("emphasis").shape = extend({
        r: layout5.r + (emphasisModel.get("scale") ? emphasisModel.get("scaleSize") || 0 : 0)
      }, getSectorCornerRadius(emphasisModel.getModel("itemStyle"), layout5));
      extend(sector.ensureState("select"), {
        x: dx,
        y: dy,
        shape: getSectorCornerRadius(itemModel.getModel(["select", "itemStyle"]), layout5)
      });
      extend(sector.ensureState("blur"), {
        shape: getSectorCornerRadius(itemModel.getModel(["blur", "itemStyle"]), layout5)
      });
      var labelLine = sector.getTextGuideLine();
      var labelText = sector.getTextContent();
      labelLine && extend(labelLine.ensureState("select"), {
        x: dx,
        y: dy
      });
      extend(labelText.ensureState("select"), {
        x: dx,
        y: dy
      });
      toggleHoverEmphasis(this, emphasisModel.get("focus"), emphasisModel.get("blurScope"), emphasisModel.get("disabled"));
    };
    PiePiece2.prototype._updateLabel = function(seriesModel, data, idx) {
      var sector = this;
      var itemModel = data.getItemModel(idx);
      var labelLineModel = itemModel.getModel("labelLine");
      var style = data.getItemVisual(idx, "style");
      var visualColor = style && style.fill;
      var visualOpacity = style && style.opacity;
      setLabelStyle(sector, getLabelStatesModels(itemModel), {
        labelFetcher: data.hostModel,
        labelDataIndex: idx,
        inheritColor: visualColor,
        defaultOpacity: visualOpacity,
        defaultText: seriesModel.getFormattedLabel(idx, "normal") || data.getName(idx)
      });
      var labelText = sector.getTextContent();
      sector.setTextConfig({
        position: null,
        rotation: null
      });
      labelText.attr({
        z2: 10
      });
      var labelPosition = seriesModel.get(["label", "position"]);
      if (labelPosition !== "outside" && labelPosition !== "outer") {
        sector.removeTextGuideLine();
      } else {
        var polyline = this.getTextGuideLine();
        if (!polyline) {
          polyline = new Polyline_default();
          this.setTextGuideLine(polyline);
        }
        setLabelLineStyle(this, getLabelLineStatesModels(itemModel), {
          stroke: visualColor,
          opacity: retrieve3(labelLineModel.get(["lineStyle", "opacity"]), visualOpacity, 1)
        });
      }
    };
    return PiePiece2;
  }(Sector_default);
  var PieView = function(_super) {
    __extends(PieView2, _super);
    function PieView2() {
      var _this = _super !== null && _super.apply(this, arguments) || this;
      _this.ignoreLabelLineUpdate = true;
      return _this;
    }
    PieView2.prototype.render = function(seriesModel, ecModel, api, payload) {
      var data = seriesModel.getData();
      var oldData = this._data;
      var group = this.group;
      var startAngle;
      if (!oldData && data.count() > 0) {
        var shape = data.getItemLayout(0);
        for (var s = 1; isNaN(shape && shape.startAngle) && s < data.count(); ++s) {
          shape = data.getItemLayout(s);
        }
        if (shape) {
          startAngle = shape.startAngle;
        }
      }
      if (this._emptyCircleSector) {
        group.remove(this._emptyCircleSector);
      }
      if (data.count() === 0 && seriesModel.get("showEmptyCircle")) {
        var sector = new Sector_default({
          shape: getBasicPieLayout(seriesModel, api)
        });
        sector.useStyle(seriesModel.getModel("emptyCircleStyle").getItemStyle());
        this._emptyCircleSector = sector;
        group.add(sector);
      }
      data.diff(oldData).add(function(idx) {
        var piePiece = new PiePiece(data, idx, startAngle);
        data.setItemGraphicEl(idx, piePiece);
        group.add(piePiece);
      }).update(function(newIdx, oldIdx) {
        var piePiece = oldData.getItemGraphicEl(oldIdx);
        piePiece.updateData(data, newIdx, startAngle);
        piePiece.off("click");
        group.add(piePiece);
        data.setItemGraphicEl(newIdx, piePiece);
      }).remove(function(idx) {
        var piePiece = oldData.getItemGraphicEl(idx);
        removeElementWithFadeOut(piePiece, seriesModel, idx);
      }).execute();
      pieLabelLayout(seriesModel);
      if (seriesModel.get("animationTypeUpdate") !== "expansion") {
        this._data = data;
      }
    };
    PieView2.prototype.dispose = function() {
    };
    PieView2.prototype.containPoint = function(point, seriesModel) {
      var data = seriesModel.getData();
      var itemLayout = data.getItemLayout(0);
      if (itemLayout) {
        var dx = point[0] - itemLayout.cx;
        var dy = point[1] - itemLayout.cy;
        var radius = Math.sqrt(dx * dx + dy * dy);
        return radius <= itemLayout.r && radius >= itemLayout.r0;
      }
    };
    PieView2.type = "pie";
    return PieView2;
  }(Chart_default);
  var PieView_default = PieView;

  // node_modules/echarts/lib/chart/helper/createSeriesDataSimply.js
  function createSeriesDataSimply(seriesModel, opt, nameList) {
    opt = isArray(opt) && {
      coordDimensions: opt
    } || extend({
      encodeDefine: seriesModel.getEncode()
    }, opt);
    var source = seriesModel.getSource();
    var dimensions = prepareSeriesDataSchema(source, opt).dimensions;
    var list = new SeriesData_default(dimensions, seriesModel);
    list.initData(source, nameList);
    return list;
  }

  // node_modules/echarts/lib/visual/LegendVisualProvider.js
  var LegendVisualProvider = function() {
    function LegendVisualProvider2(getDataWithEncodedVisual, getRawData2) {
      this._getDataWithEncodedVisual = getDataWithEncodedVisual;
      this._getRawData = getRawData2;
    }
    LegendVisualProvider2.prototype.getAllNames = function() {
      var rawData = this._getRawData();
      return rawData.mapArray(rawData.getName);
    };
    LegendVisualProvider2.prototype.containName = function(name) {
      var rawData = this._getRawData();
      return rawData.indexOfName(name) >= 0;
    };
    LegendVisualProvider2.prototype.indexOfName = function(name) {
      var dataWithEncodedVisual = this._getDataWithEncodedVisual();
      return dataWithEncodedVisual.indexOfName(name);
    };
    LegendVisualProvider2.prototype.getItemVisual = function(dataIndex, key) {
      var dataWithEncodedVisual = this._getDataWithEncodedVisual();
      return dataWithEncodedVisual.getItemVisual(dataIndex, key);
    };
    return LegendVisualProvider2;
  }();
  var LegendVisualProvider_default = LegendVisualProvider;

  // node_modules/echarts/lib/chart/pie/PieSeries.js
  var PieSeriesModel = function(_super) {
    __extends(PieSeriesModel2, _super);
    function PieSeriesModel2() {
      return _super !== null && _super.apply(this, arguments) || this;
    }
    PieSeriesModel2.prototype.init = function(option) {
      _super.prototype.init.apply(this, arguments);
      this.legendVisualProvider = new LegendVisualProvider_default(bind(this.getData, this), bind(this.getRawData, this));
      this._defaultLabelLine(option);
    };
    PieSeriesModel2.prototype.mergeOption = function() {
      _super.prototype.mergeOption.apply(this, arguments);
    };
    PieSeriesModel2.prototype.getInitialData = function() {
      return createSeriesDataSimply(this, {
        coordDimensions: ["value"],
        encodeDefaulter: curry(makeSeriesEncodeForNameBased, this)
      });
    };
    PieSeriesModel2.prototype.getDataParams = function(dataIndex) {
      var data = this.getData();
      var params = _super.prototype.getDataParams.call(this, dataIndex);
      var valueList = [];
      data.each(data.mapDimension("value"), function(value) {
        valueList.push(value);
      });
      params.percent = getPercentWithPrecision(valueList, dataIndex, data.hostModel.get("percentPrecision"));
      params.$vars.push("percent");
      return params;
    };
    PieSeriesModel2.prototype._defaultLabelLine = function(option) {
      defaultEmphasis(option, "labelLine", ["show"]);
      var labelLineNormalOpt = option.labelLine;
      var labelLineEmphasisOpt = option.emphasis.labelLine;
      labelLineNormalOpt.show = labelLineNormalOpt.show && option.label.show;
      labelLineEmphasisOpt.show = labelLineEmphasisOpt.show && option.emphasis.label.show;
    };
    PieSeriesModel2.type = "series.pie";
    PieSeriesModel2.defaultOption = {
      z: 2,
      legendHoverLink: true,
      colorBy: "data",
      center: ["50%", "50%"],
      radius: [0, "75%"],
      clockwise: true,
      startAngle: 90,
      minAngle: 0,
      minShowLabelAngle: 0,
      selectedOffset: 10,
      percentPrecision: 2,
      stillShowZeroSum: true,
      left: 0,
      top: 0,
      right: 0,
      bottom: 0,
      width: null,
      height: null,
      label: {
        rotate: 0,
        show: true,
        overflow: "truncate",
        position: "outer",
        alignTo: "none",
        edgeDistance: "25%",
        bleedMargin: 10,
        distanceToLabelLine: 5
      },
      labelLine: {
        show: true,
        length: 15,
        length2: 15,
        smooth: false,
        minTurnAngle: 90,
        maxSurfaceAngle: 90,
        lineStyle: {
          width: 1,
          type: "solid"
        }
      },
      itemStyle: {
        borderWidth: 1,
        borderJoin: "round"
      },
      showEmptyCircle: true,
      emptyCircleStyle: {
        color: "lightgray",
        opacity: 1
      },
      labelLayout: {
        hideOverlap: true
      },
      emphasis: {
        scale: true,
        scaleSize: 5
      },
      avoidLabelOverlap: true,
      animationType: "expansion",
      animationDuration: 1e3,
      animationTypeUpdate: "transition",
      animationEasingUpdate: "cubicInOut",
      animationDurationUpdate: 500,
      animationEasing: "cubicInOut"
    };
    return PieSeriesModel2;
  }(Series_default);
  var PieSeries_default = PieSeriesModel;

  // node_modules/echarts/lib/processor/negativeDataFilter.js
  function negativeDataFilter(seriesType2) {
    return {
      seriesType: seriesType2,
      reset: function(seriesModel, ecModel) {
        var data = seriesModel.getData();
        data.filterSelf(function(idx) {
          var valueDim = data.mapDimension("value");
          var curValue = data.get(valueDim, idx);
          if (isNumber(curValue) && !isNaN(curValue) && curValue < 0) {
            return false;
          }
          return true;
        });
      }
    };
  }

  // node_modules/echarts/lib/chart/pie/install.js
  function install5(registers) {
    registers.registerChartView(PieView_default);
    registers.registerSeriesModel(PieSeries_default);
    createLegacyDataSelectAction("pie", registers.registerAction);
    registers.registerLayout(curry(pieLayout, "pie"));
    registers.registerProcessor(dataFilter("pie"));
    registers.registerProcessor(negativeDataFilter("pie"));
  }

  // node_modules/echarts/lib/chart/scatter/ScatterSeries.js
  var ScatterSeriesModel = function(_super) {
    __extends(ScatterSeriesModel2, _super);
    function ScatterSeriesModel2() {
      var _this = _super !== null && _super.apply(this, arguments) || this;
      _this.type = ScatterSeriesModel2.type;
      _this.hasSymbolVisual = true;
      return _this;
    }
    ScatterSeriesModel2.prototype.getInitialData = function(option, ecModel) {
      return createSeriesData_default(null, this, {
        useEncodeDefaulter: true
      });
    };
    ScatterSeriesModel2.prototype.getProgressive = function() {
      var progressive = this.option.progressive;
      if (progressive == null) {
        return this.option.large ? 5e3 : this.get("progressive");
      }
      return progressive;
    };
    ScatterSeriesModel2.prototype.getProgressiveThreshold = function() {
      var progressiveThreshold = this.option.progressiveThreshold;
      if (progressiveThreshold == null) {
        return this.option.large ? 1e4 : this.get("progressiveThreshold");
      }
      return progressiveThreshold;
    };
    ScatterSeriesModel2.prototype.brushSelector = function(dataIndex, data, selectors) {
      return selectors.point(data.getItemLayout(dataIndex));
    };
    ScatterSeriesModel2.prototype.getZLevelKey = function() {
      return this.getData().count() > this.getProgressiveThreshold() ? this.id : "";
    };
    ScatterSeriesModel2.type = "series.scatter";
    ScatterSeriesModel2.dependencies = ["grid", "polar", "geo", "singleAxis", "calendar"];
    ScatterSeriesModel2.defaultOption = {
      coordinateSystem: "cartesian2d",
      z: 2,
      legendHoverLink: true,
      symbolSize: 10,
      large: false,
      largeThreshold: 2e3,
      itemStyle: {
        opacity: 0.8
      },
      emphasis: {
        scale: true
      },
      clip: true,
      select: {
        itemStyle: {
          borderColor: "#212121"
        }
      },
      universalTransition: {
        divideShape: "clone"
      }
    };
    return ScatterSeriesModel2;
  }(Series_default);
  var ScatterSeries_default = ScatterSeriesModel;

  // node_modules/echarts/lib/chart/helper/LargeSymbolDraw.js
  var BOOST_SIZE_THRESHOLD = 4;
  var LargeSymbolPathShape = function() {
    function LargeSymbolPathShape2() {
    }
    return LargeSymbolPathShape2;
  }();
  var LargeSymbolPath = function(_super) {
    __extends(LargeSymbolPath2, _super);
    function LargeSymbolPath2(opts) {
      var _this = _super.call(this, opts) || this;
      _this._off = 0;
      _this.hoverDataIdx = -1;
      return _this;
    }
    LargeSymbolPath2.prototype.getDefaultShape = function() {
      return new LargeSymbolPathShape();
    };
    LargeSymbolPath2.prototype.reset = function() {
      this.notClear = false;
      this._off = 0;
    };
    LargeSymbolPath2.prototype.buildPath = function(path, shape) {
      var points4 = shape.points;
      var size = shape.size;
      var symbolProxy = this.symbolProxy;
      var symbolProxyShape = symbolProxy.shape;
      var ctx = path.getContext ? path.getContext() : path;
      var canBoost = ctx && size[0] < BOOST_SIZE_THRESHOLD;
      var softClipShape = this.softClipShape;
      var i;
      if (canBoost) {
        this._ctx = ctx;
        return;
      }
      this._ctx = null;
      for (i = this._off; i < points4.length; ) {
        var x = points4[i++];
        var y = points4[i++];
        if (isNaN(x) || isNaN(y)) {
          continue;
        }
        if (softClipShape && !softClipShape.contain(x, y)) {
          continue;
        }
        symbolProxyShape.x = x - size[0] / 2;
        symbolProxyShape.y = y - size[1] / 2;
        symbolProxyShape.width = size[0];
        symbolProxyShape.height = size[1];
        symbolProxy.buildPath(path, symbolProxyShape, true);
      }
      if (this.incremental) {
        this._off = i;
        this.notClear = true;
      }
    };
    LargeSymbolPath2.prototype.afterBrush = function() {
      var shape = this.shape;
      var points4 = shape.points;
      var size = shape.size;
      var ctx = this._ctx;
      var softClipShape = this.softClipShape;
      var i;
      if (!ctx) {
        return;
      }
      for (i = this._off; i < points4.length; ) {
        var x = points4[i++];
        var y = points4[i++];
        if (isNaN(x) || isNaN(y)) {
          continue;
        }
        if (softClipShape && !softClipShape.contain(x, y)) {
          continue;
        }
        ctx.fillRect(x - size[0] / 2, y - size[1] / 2, size[0], size[1]);
      }
      if (this.incremental) {
        this._off = i;
        this.notClear = true;
      }
    };
    LargeSymbolPath2.prototype.findDataIndex = function(x, y) {
      var shape = this.shape;
      var points4 = shape.points;
      var size = shape.size;
      var w = Math.max(size[0], 4);
      var h = Math.max(size[1], 4);
      for (var idx = points4.length / 2 - 1; idx >= 0; idx--) {
        var i = idx * 2;
        var x0 = points4[i] - w / 2;
        var y0 = points4[i + 1] - h / 2;
        if (x >= x0 && y >= y0 && x <= x0 + w && y <= y0 + h) {
          return idx;
        }
      }
      return -1;
    };
    LargeSymbolPath2.prototype.contain = function(x, y) {
      var localPos = this.transformCoordToLocal(x, y);
      var rect = this.getBoundingRect();
      x = localPos[0];
      y = localPos[1];
      if (rect.contain(x, y)) {
        var dataIdx = this.hoverDataIdx = this.findDataIndex(x, y);
        return dataIdx >= 0;
      }
      this.hoverDataIdx = -1;
      return false;
    };
    LargeSymbolPath2.prototype.getBoundingRect = function() {
      var rect = this._rect;
      if (!rect) {
        var shape = this.shape;
        var points4 = shape.points;
        var size = shape.size;
        var w = size[0];
        var h = size[1];
        var minX = Infinity;
        var minY = Infinity;
        var maxX = -Infinity;
        var maxY = -Infinity;
        for (var i = 0; i < points4.length; ) {
          var x = points4[i++];
          var y = points4[i++];
          minX = Math.min(x, minX);
          maxX = Math.max(x, maxX);
          minY = Math.min(y, minY);
          maxY = Math.max(y, maxY);
        }
        rect = this._rect = new BoundingRect_default(minX - w / 2, minY - h / 2, maxX - minX + w, maxY - minY + h);
      }
      return rect;
    };
    return LargeSymbolPath2;
  }(Path_default);
  var LargeSymbolDraw = function() {
    function LargeSymbolDraw2() {
      this.group = new Group_default();
    }
    LargeSymbolDraw2.prototype.updateData = function(data, opt) {
      this._clear();
      var symbolEl = this._create();
      symbolEl.setShape({
        points: data.getLayout("points")
      });
      this._setCommon(symbolEl, data, opt);
    };
    LargeSymbolDraw2.prototype.updateLayout = function(data) {
      var points4 = data.getLayout("points");
      this.group.eachChild(function(child) {
        if (child.startIndex != null) {
          var len2 = (child.endIndex - child.startIndex) * 2;
          var byteOffset = child.startIndex * 4 * 2;
          points4 = new Float32Array(points4.buffer, byteOffset, len2);
        }
        child.setShape("points", points4);
        child.reset();
      });
    };
    LargeSymbolDraw2.prototype.incrementalPrepareUpdate = function(data) {
      this._clear();
    };
    LargeSymbolDraw2.prototype.incrementalUpdate = function(taskParams, data, opt) {
      var lastAdded = this._newAdded[0];
      var points4 = data.getLayout("points");
      var oldPoints = lastAdded && lastAdded.shape.points;
      if (oldPoints && oldPoints.length < 2e4) {
        var oldLen = oldPoints.length;
        var newPoints = new Float32Array(oldLen + points4.length);
        newPoints.set(oldPoints);
        newPoints.set(points4, oldLen);
        lastAdded.endIndex = taskParams.end;
        lastAdded.setShape({
          points: newPoints
        });
      } else {
        this._newAdded = [];
        var symbolEl = this._create();
        symbolEl.startIndex = taskParams.start;
        symbolEl.endIndex = taskParams.end;
        symbolEl.incremental = true;
        symbolEl.setShape({
          points: points4
        });
        this._setCommon(symbolEl, data, opt);
      }
    };
    LargeSymbolDraw2.prototype.eachRendered = function(cb) {
      this._newAdded[0] && cb(this._newAdded[0]);
    };
    LargeSymbolDraw2.prototype._create = function() {
      var symbolEl = new LargeSymbolPath({
        cursor: "default"
      });
      this.group.add(symbolEl);
      this._newAdded.push(symbolEl);
      return symbolEl;
    };
    LargeSymbolDraw2.prototype._setCommon = function(symbolEl, data, opt) {
      var hostModel = data.hostModel;
      opt = opt || {};
      var size = data.getVisual("symbolSize");
      symbolEl.setShape("size", size instanceof Array ? size : [size, size]);
      symbolEl.softClipShape = opt.clipShape || null;
      symbolEl.symbolProxy = createSymbol(data.getVisual("symbol"), 0, 0, 0, 0);
      symbolEl.setColor = symbolEl.symbolProxy.setColor;
      var extrudeShadow = symbolEl.shape.size[0] < BOOST_SIZE_THRESHOLD;
      symbolEl.useStyle(hostModel.getModel("itemStyle").getItemStyle(extrudeShadow ? ["color", "shadowBlur", "shadowColor"] : ["color"]));
      var globalStyle = data.getVisual("style");
      var visualColor = globalStyle && globalStyle.fill;
      if (visualColor) {
        symbolEl.setColor(visualColor);
      }
      var ecData = getECData(symbolEl);
      ecData.seriesIndex = hostModel.seriesIndex;
      symbolEl.on("mousemove", function(e2) {
        ecData.dataIndex = null;
        var dataIndex = symbolEl.hoverDataIdx;
        if (dataIndex >= 0) {
          ecData.dataIndex = dataIndex + (symbolEl.startIndex || 0);
        }
      });
    };
    LargeSymbolDraw2.prototype.remove = function() {
      this._clear();
    };
    LargeSymbolDraw2.prototype._clear = function() {
      this._newAdded = [];
      this.group.removeAll();
    };
    return LargeSymbolDraw2;
  }();
  var LargeSymbolDraw_default = LargeSymbolDraw;

  // node_modules/echarts/lib/chart/scatter/ScatterView.js
  var ScatterView = function(_super) {
    __extends(ScatterView2, _super);
    function ScatterView2() {
      var _this = _super !== null && _super.apply(this, arguments) || this;
      _this.type = ScatterView2.type;
      return _this;
    }
    ScatterView2.prototype.render = function(seriesModel, ecModel, api) {
      var data = seriesModel.getData();
      var symbolDraw = this._updateSymbolDraw(data, seriesModel);
      symbolDraw.updateData(data, {
        clipShape: this._getClipShape(seriesModel)
      });
      this._finished = true;
    };
    ScatterView2.prototype.incrementalPrepareRender = function(seriesModel, ecModel, api) {
      var data = seriesModel.getData();
      var symbolDraw = this._updateSymbolDraw(data, seriesModel);
      symbolDraw.incrementalPrepareUpdate(data);
      this._finished = false;
    };
    ScatterView2.prototype.incrementalRender = function(taskParams, seriesModel, ecModel) {
      this._symbolDraw.incrementalUpdate(taskParams, seriesModel.getData(), {
        clipShape: this._getClipShape(seriesModel)
      });
      this._finished = taskParams.end === seriesModel.getData().count();
    };
    ScatterView2.prototype.updateTransform = function(seriesModel, ecModel, api) {
      var data = seriesModel.getData();
      this.group.dirty();
      if (!this._finished || data.count() > 1e4) {
        return {
          update: true
        };
      } else {
        var res = pointsLayout("").reset(seriesModel, ecModel, api);
        if (res.progress) {
          res.progress({
            start: 0,
            end: data.count(),
            count: data.count()
          }, data);
        }
        this._symbolDraw.updateLayout(data);
      }
    };
    ScatterView2.prototype.eachRendered = function(cb) {
      this._symbolDraw && this._symbolDraw.eachRendered(cb);
    };
    ScatterView2.prototype._getClipShape = function(seriesModel) {
      var coordSys = seriesModel.coordinateSystem;
      var clipArea = coordSys && coordSys.getArea && coordSys.getArea();
      return seriesModel.get("clip", true) ? clipArea : null;
    };
    ScatterView2.prototype._updateSymbolDraw = function(data, seriesModel) {
      var symbolDraw = this._symbolDraw;
      var pipelineContext = seriesModel.pipelineContext;
      var isLargeDraw = pipelineContext.large;
      if (!symbolDraw || isLargeDraw !== this._isLargeDraw) {
        symbolDraw && symbolDraw.remove();
        symbolDraw = this._symbolDraw = isLargeDraw ? new LargeSymbolDraw_default() : new SymbolDraw_default();
        this._isLargeDraw = isLargeDraw;
        this.group.removeAll();
      }
      this.group.add(symbolDraw.group);
      return symbolDraw;
    };
    ScatterView2.prototype.remove = function(ecModel, api) {
      this._symbolDraw && this._symbolDraw.remove(true);
      this._symbolDraw = null;
    };
    ScatterView2.prototype.dispose = function() {
    };
    ScatterView2.type = "scatter";
    return ScatterView2;
  }(Chart_default);
  var ScatterView_default = ScatterView;

  // node_modules/echarts/lib/coord/cartesian/GridModel.js
  var GridModel = function(_super) {
    __extends(GridModel2, _super);
    function GridModel2() {
      return _super !== null && _super.apply(this, arguments) || this;
    }
    GridModel2.type = "grid";
    GridModel2.dependencies = ["xAxis", "yAxis"];
    GridModel2.layoutMode = "box";
    GridModel2.defaultOption = {
      show: false,
      z: 0,
      left: "10%",
      top: 60,
      right: "10%",
      bottom: 70,
      containLabel: false,
      backgroundColor: "rgba(0,0,0,0)",
      borderWidth: 1,
      borderColor: "#ccc"
    };
    return GridModel2;
  }(Component_default);
  var GridModel_default = GridModel;

  // node_modules/echarts/lib/coord/cartesian/AxisModel.js
  var CartesianAxisModel = function(_super) {
    __extends(CartesianAxisModel2, _super);
    function CartesianAxisModel2() {
      return _super !== null && _super.apply(this, arguments) || this;
    }
    CartesianAxisModel2.prototype.getCoordSysModel = function() {
      return this.getReferringComponents("grid", SINGLE_REFERRING).models[0];
    };
    CartesianAxisModel2.type = "cartesian2dAxis";
    return CartesianAxisModel2;
  }(Component_default);
  mixin(CartesianAxisModel, AxisModelCommonMixin);

  // node_modules/echarts/lib/coord/axisDefault.js
  var defaultOption = {
    show: true,
    z: 0,
    inverse: false,
    name: "",
    nameLocation: "end",
    nameRotate: null,
    nameTruncate: {
      maxWidth: null,
      ellipsis: "...",
      placeholder: "."
    },
    nameTextStyle: {},
    nameGap: 15,
    silent: false,
    triggerEvent: false,
    tooltip: {
      show: false
    },
    axisPointer: {},
    axisLine: {
      show: true,
      onZero: true,
      onZeroAxisIndex: null,
      lineStyle: {
        color: "#6E7079",
        width: 1,
        type: "solid"
      },
      symbol: ["none", "none"],
      symbolSize: [10, 15]
    },
    axisTick: {
      show: true,
      inside: false,
      length: 5,
      lineStyle: {
        width: 1
      }
    },
    axisLabel: {
      show: true,
      inside: false,
      rotate: 0,
      showMinLabel: null,
      showMaxLabel: null,
      margin: 8,
      fontSize: 12
    },
    splitLine: {
      show: true,
      lineStyle: {
        color: ["#E0E6F1"],
        width: 1,
        type: "solid"
      }
    },
    splitArea: {
      show: false,
      areaStyle: {
        color: ["rgba(250,250,250,0.2)", "rgba(210,219,238,0.2)"]
      }
    }
  };
  var categoryAxis = merge({
    boundaryGap: true,
    deduplication: null,
    splitLine: {
      show: false
    },
    axisTick: {
      alignWithLabel: false,
      interval: "auto"
    },
    axisLabel: {
      interval: "auto"
    }
  }, defaultOption);
  var valueAxis = merge({
    boundaryGap: [0, 0],
    axisLine: {
      show: "auto"
    },
    axisTick: {
      show: "auto"
    },
    splitNumber: 5,
    minorTick: {
      show: false,
      splitNumber: 5,
      length: 3,
      lineStyle: {}
    },
    minorSplitLine: {
      show: false,
      lineStyle: {
        color: "#F4F7FD",
        width: 1
      }
    }
  }, defaultOption);
  var timeAxis = merge({
    splitNumber: 6,
    axisLabel: {
      showMinLabel: false,
      showMaxLabel: false,
      rich: {
        primary: {
          fontWeight: "bold"
        }
      }
    },
    splitLine: {
      show: false
    }
  }, valueAxis);
  var logAxis = defaults({
    logBase: 10
  }, valueAxis);
  var axisDefault_default = {
    category: categoryAxis,
    value: valueAxis,
    time: timeAxis,
    log: logAxis
  };

  // node_modules/echarts/lib/coord/axisCommonTypes.js
  var AXIS_TYPES = {
    value: 1,
    category: 1,
    time: 1,
    log: 1
  };

  // node_modules/echarts/lib/coord/axisModelCreator.js
  function axisModelCreator(registers, axisName, BaseAxisModelClass, extraDefaultOption) {
    each(AXIS_TYPES, function(v, axisType) {
      var defaultOption3 = merge(merge({}, axisDefault_default[axisType], true), extraDefaultOption, true);
      var AxisModel = function(_super) {
        __extends(AxisModel2, _super);
        function AxisModel2() {
          var _this = _super !== null && _super.apply(this, arguments) || this;
          _this.type = axisName + "Axis." + axisType;
          return _this;
        }
        AxisModel2.prototype.mergeDefaultAndTheme = function(option, ecModel) {
          var layoutMode = fetchLayoutMode(this);
          var inputPositionParams = layoutMode ? getLayoutParams(option) : {};
          var themeModel = ecModel.getTheme();
          merge(option, themeModel.get(axisType + "Axis"));
          merge(option, this.getDefaultOption());
          option.type = getAxisType(option);
          if (layoutMode) {
            mergeLayoutParam(option, inputPositionParams, layoutMode);
          }
        };
        AxisModel2.prototype.optionUpdated = function() {
          var thisOption = this.option;
          if (thisOption.type === "category") {
            this.__ordinalMeta = OrdinalMeta_default.createByAxisModel(this);
          }
        };
        AxisModel2.prototype.getCategories = function(rawData) {
          var option = this.option;
          if (option.type === "category") {
            if (rawData) {
              return option.data;
            }
            return this.__ordinalMeta.categories;
          }
        };
        AxisModel2.prototype.getOrdinalMeta = function() {
          return this.__ordinalMeta;
        };
        AxisModel2.type = axisName + "Axis." + axisType;
        AxisModel2.defaultOption = defaultOption3;
        return AxisModel2;
      }(BaseAxisModelClass);
      registers.registerComponentModel(AxisModel);
    });
    registers.registerSubTypeDefaulter(axisName + "Axis", getAxisType);
  }
  function getAxisType(option) {
    return option.type || (option.data ? "category" : "value");
  }

  // node_modules/echarts/lib/coord/cartesian/Cartesian.js
  var Cartesian = function() {
    function Cartesian2(name) {
      this.type = "cartesian";
      this._dimList = [];
      this._axes = {};
      this.name = name || "";
    }
    Cartesian2.prototype.getAxis = function(dim) {
      return this._axes[dim];
    };
    Cartesian2.prototype.getAxes = function() {
      return map(this._dimList, function(dim) {
        return this._axes[dim];
      }, this);
    };
    Cartesian2.prototype.getAxesByScale = function(scaleType) {
      scaleType = scaleType.toLowerCase();
      return filter(this.getAxes(), function(axis) {
        return axis.scale.type === scaleType;
      });
    };
    Cartesian2.prototype.addAxis = function(axis) {
      var dim = axis.dim;
      this._axes[dim] = axis;
      this._dimList.push(dim);
    };
    return Cartesian2;
  }();
  var Cartesian_default = Cartesian;

  // node_modules/echarts/lib/coord/cartesian/Cartesian2D.js
  var cartesian2DDimensions = ["x", "y"];
  function canCalculateAffineTransform(scale4) {
    return scale4.type === "interval" || scale4.type === "time";
  }
  var Cartesian2D = function(_super) {
    __extends(Cartesian2D2, _super);
    function Cartesian2D2() {
      var _this = _super !== null && _super.apply(this, arguments) || this;
      _this.type = "cartesian2d";
      _this.dimensions = cartesian2DDimensions;
      return _this;
    }
    Cartesian2D2.prototype.calcAffineTransform = function() {
      this._transform = this._invTransform = null;
      var xAxisScale = this.getAxis("x").scale;
      var yAxisScale = this.getAxis("y").scale;
      if (!canCalculateAffineTransform(xAxisScale) || !canCalculateAffineTransform(yAxisScale)) {
        return;
      }
      var xScaleExtent = xAxisScale.getExtent();
      var yScaleExtent = yAxisScale.getExtent();
      var start2 = this.dataToPoint([xScaleExtent[0], yScaleExtent[0]]);
      var end2 = this.dataToPoint([xScaleExtent[1], yScaleExtent[1]]);
      var xScaleSpan = xScaleExtent[1] - xScaleExtent[0];
      var yScaleSpan = yScaleExtent[1] - yScaleExtent[0];
      if (!xScaleSpan || !yScaleSpan) {
        return;
      }
      var scaleX = (end2[0] - start2[0]) / xScaleSpan;
      var scaleY = (end2[1] - start2[1]) / yScaleSpan;
      var translateX = start2[0] - xScaleExtent[0] * scaleX;
      var translateY = start2[1] - yScaleExtent[0] * scaleY;
      var m2 = this._transform = [scaleX, 0, 0, scaleY, translateX, translateY];
      this._invTransform = invert([], m2);
    };
    Cartesian2D2.prototype.getBaseAxis = function() {
      return this.getAxesByScale("ordinal")[0] || this.getAxesByScale("time")[0] || this.getAxis("x");
    };
    Cartesian2D2.prototype.containPoint = function(point) {
      var axisX = this.getAxis("x");
      var axisY = this.getAxis("y");
      return axisX.contain(axisX.toLocalCoord(point[0])) && axisY.contain(axisY.toLocalCoord(point[1]));
    };
    Cartesian2D2.prototype.containData = function(data) {
      return this.getAxis("x").containData(data[0]) && this.getAxis("y").containData(data[1]);
    };
    Cartesian2D2.prototype.containZone = function(data1, data2) {
      var zoneDiag1 = this.dataToPoint(data1);
      var zoneDiag2 = this.dataToPoint(data2);
      var area = this.getArea();
      var zone = new BoundingRect_default(zoneDiag1[0], zoneDiag1[1], zoneDiag2[0] - zoneDiag1[0], zoneDiag2[1] - zoneDiag1[1]);
      return area.intersect(zone);
    };
    Cartesian2D2.prototype.dataToPoint = function(data, clamp2, out2) {
      out2 = out2 || [];
      var xVal = data[0];
      var yVal = data[1];
      if (this._transform && xVal != null && isFinite(xVal) && yVal != null && isFinite(yVal)) {
        return applyTransform(out2, data, this._transform);
      }
      var xAxis = this.getAxis("x");
      var yAxis = this.getAxis("y");
      out2[0] = xAxis.toGlobalCoord(xAxis.dataToCoord(xVal, clamp2));
      out2[1] = yAxis.toGlobalCoord(yAxis.dataToCoord(yVal, clamp2));
      return out2;
    };
    Cartesian2D2.prototype.clampData = function(data, out2) {
      var xScale = this.getAxis("x").scale;
      var yScale = this.getAxis("y").scale;
      var xAxisExtent = xScale.getExtent();
      var yAxisExtent = yScale.getExtent();
      var x = xScale.parse(data[0]);
      var y = yScale.parse(data[1]);
      out2 = out2 || [];
      out2[0] = Math.min(Math.max(Math.min(xAxisExtent[0], xAxisExtent[1]), x), Math.max(xAxisExtent[0], xAxisExtent[1]));
      out2[1] = Math.min(Math.max(Math.min(yAxisExtent[0], yAxisExtent[1]), y), Math.max(yAxisExtent[0], yAxisExtent[1]));
      return out2;
    };
    Cartesian2D2.prototype.pointToData = function(point, clamp2) {
      var out2 = [];
      if (this._invTransform) {
        return applyTransform(out2, point, this._invTransform);
      }
      var xAxis = this.getAxis("x");
      var yAxis = this.getAxis("y");
      out2[0] = xAxis.coordToData(xAxis.toLocalCoord(point[0]), clamp2);
      out2[1] = yAxis.coordToData(yAxis.toLocalCoord(point[1]), clamp2);
      return out2;
    };
    Cartesian2D2.prototype.getOtherAxis = function(axis) {
      return this.getAxis(axis.dim === "x" ? "y" : "x");
    };
    Cartesian2D2.prototype.getArea = function() {
      var xExtent = this.getAxis("x").getGlobalExtent();
      var yExtent = this.getAxis("y").getGlobalExtent();
      var x = Math.min(xExtent[0], xExtent[1]);
      var y = Math.min(yExtent[0], yExtent[1]);
      var width = Math.max(xExtent[0], xExtent[1]) - x;
      var height = Math.max(yExtent[0], yExtent[1]) - y;
      return new BoundingRect_default(x, y, width, height);
    };
    return Cartesian2D2;
  }(Cartesian_default);
  var Cartesian2D_default = Cartesian2D;

  // node_modules/echarts/lib/coord/cartesian/Axis2D.js
  var Axis2D = function(_super) {
    __extends(Axis2D2, _super);
    function Axis2D2(dim, scale4, coordExtent, axisType, position2) {
      var _this = _super.call(this, dim, scale4, coordExtent) || this;
      _this.index = 0;
      _this.type = axisType || "value";
      _this.position = position2 || "bottom";
      return _this;
    }
    Axis2D2.prototype.isHorizontal = function() {
      var position2 = this.position;
      return position2 === "top" || position2 === "bottom";
    };
    Axis2D2.prototype.getGlobalExtent = function(asc4) {
      var ret = this.getExtent();
      ret[0] = this.toGlobalCoord(ret[0]);
      ret[1] = this.toGlobalCoord(ret[1]);
      asc4 && ret[0] > ret[1] && ret.reverse();
      return ret;
    };
    Axis2D2.prototype.pointToData = function(point, clamp2) {
      return this.coordToData(this.toLocalCoord(point[this.dim === "x" ? 0 : 1]), clamp2);
    };
    Axis2D2.prototype.setCategorySortInfo = function(info) {
      if (this.type !== "category") {
        return false;
      }
      this.model.option.categorySortInfo = info;
      this.scale.setSortInfo(info);
    };
    return Axis2D2;
  }(Axis_default);
  var Axis2D_default = Axis2D;

  // node_modules/echarts/lib/coord/cartesian/cartesianAxisHelper.js
  function layout2(gridModel, axisModel, opt) {
    opt = opt || {};
    var grid = gridModel.coordinateSystem;
    var axis = axisModel.axis;
    var layout5 = {};
    var otherAxisOnZeroOf = axis.getAxesOnZeroOf()[0];
    var rawAxisPosition = axis.position;
    var axisPosition = otherAxisOnZeroOf ? "onZero" : rawAxisPosition;
    var axisDim = axis.dim;
    var rect = grid.getRect();
    var rectBound = [rect.x, rect.x + rect.width, rect.y, rect.y + rect.height];
    var idx = {
      left: 0,
      right: 1,
      top: 0,
      bottom: 1,
      onZero: 2
    };
    var axisOffset = axisModel.get("offset") || 0;
    var posBound = axisDim === "x" ? [rectBound[2] - axisOffset, rectBound[3] + axisOffset] : [rectBound[0] - axisOffset, rectBound[1] + axisOffset];
    if (otherAxisOnZeroOf) {
      var onZeroCoord = otherAxisOnZeroOf.toGlobalCoord(otherAxisOnZeroOf.dataToCoord(0));
      posBound[idx.onZero] = Math.max(Math.min(onZeroCoord, posBound[1]), posBound[0]);
    }
    layout5.position = [axisDim === "y" ? posBound[idx[axisPosition]] : rectBound[0], axisDim === "x" ? posBound[idx[axisPosition]] : rectBound[3]];
    layout5.rotation = Math.PI / 2 * (axisDim === "x" ? 0 : 1);
    var dirMap = {
      top: -1,
      bottom: 1,
      left: -1,
      right: 1
    };
    layout5.labelDirection = layout5.tickDirection = layout5.nameDirection = dirMap[rawAxisPosition];
    layout5.labelOffset = otherAxisOnZeroOf ? posBound[idx[rawAxisPosition]] - posBound[idx.onZero] : 0;
    if (axisModel.get(["axisTick", "inside"])) {
      layout5.tickDirection = -layout5.tickDirection;
    }
    if (retrieve(opt.labelInside, axisModel.get(["axisLabel", "inside"]))) {
      layout5.labelDirection = -layout5.labelDirection;
    }
    var labelRotate = axisModel.get(["axisLabel", "rotate"]);
    layout5.labelRotate = axisPosition === "top" ? -labelRotate : labelRotate;
    layout5.z2 = 1;
    return layout5;
  }
  function isCartesian2DSeries(seriesModel) {
    return seriesModel.get("coordinateSystem") === "cartesian2d";
  }
  function findAxisModels(seriesModel) {
    var axisModelMap = {
      xAxisModel: null,
      yAxisModel: null
    };
    each(axisModelMap, function(v, key) {
      var axisType = key.replace(/Model$/, "");
      var axisModel = seriesModel.getReferringComponents(axisType, SINGLE_REFERRING).models[0];
      if (true) {
        if (!axisModel) {
          throw new Error(axisType + ' "' + retrieve3(seriesModel.get(axisType + "Index"), seriesModel.get(axisType + "Id"), 0) + '" not found');
        }
      }
      axisModelMap[key] = axisModel;
    });
    return axisModelMap;
  }

  // node_modules/echarts/lib/coord/axisAlignTicks.js
  var mathLog2 = Math.log;
  function alignScaleTicks(scale4, axisModel, alignToScale) {
    var intervalScaleProto2 = Interval_default.prototype;
    var alignToTicks = intervalScaleProto2.getTicks.call(alignToScale);
    var alignToNicedTicks = intervalScaleProto2.getTicks.call(alignToScale, true);
    var alignToSplitNumber = alignToTicks.length - 1;
    var alignToInterval = intervalScaleProto2.getInterval.call(alignToScale);
    var scaleExtent = getScaleExtent(scale4, axisModel);
    var rawExtent = scaleExtent.extent;
    var isMinFixed = scaleExtent.fixMin;
    var isMaxFixed = scaleExtent.fixMax;
    if (scale4.type === "log") {
      var logBase = mathLog2(scale4.base);
      rawExtent = [mathLog2(rawExtent[0]) / logBase, mathLog2(rawExtent[1]) / logBase];
    }
    scale4.setExtent(rawExtent[0], rawExtent[1]);
    scale4.calcNiceExtent({
      splitNumber: alignToSplitNumber,
      fixMin: isMinFixed,
      fixMax: isMaxFixed
    });
    var extent3 = intervalScaleProto2.getExtent.call(scale4);
    if (isMinFixed) {
      rawExtent[0] = extent3[0];
    }
    if (isMaxFixed) {
      rawExtent[1] = extent3[1];
    }
    var interval = intervalScaleProto2.getInterval.call(scale4);
    var min3 = rawExtent[0];
    var max3 = rawExtent[1];
    if (isMinFixed && isMaxFixed) {
      interval = (max3 - min3) / alignToSplitNumber;
    } else if (isMinFixed) {
      max3 = rawExtent[0] + interval * alignToSplitNumber;
      while (max3 < rawExtent[1] && isFinite(max3) && isFinite(rawExtent[1])) {
        interval = increaseInterval(interval);
        max3 = rawExtent[0] + interval * alignToSplitNumber;
      }
    } else if (isMaxFixed) {
      min3 = rawExtent[1] - interval * alignToSplitNumber;
      while (min3 > rawExtent[0] && isFinite(min3) && isFinite(rawExtent[0])) {
        interval = increaseInterval(interval);
        min3 = rawExtent[1] - interval * alignToSplitNumber;
      }
    } else {
      var nicedSplitNumber = scale4.getTicks().length - 1;
      if (nicedSplitNumber > alignToSplitNumber) {
        interval = increaseInterval(interval);
      }
      var range = interval * alignToSplitNumber;
      max3 = Math.ceil(rawExtent[1] / interval) * interval;
      min3 = round(max3 - range);
      if (min3 < 0 && rawExtent[0] >= 0) {
        min3 = 0;
        max3 = round(range);
      } else if (max3 > 0 && rawExtent[1] <= 0) {
        max3 = 0;
        min3 = -round(range);
      }
    }
    var t0 = (alignToTicks[0].value - alignToNicedTicks[0].value) / alignToInterval;
    var t1 = (alignToTicks[alignToSplitNumber].value - alignToNicedTicks[alignToSplitNumber].value) / alignToInterval;
    intervalScaleProto2.setExtent.call(scale4, min3 + interval * t0, max3 + interval * t1);
    intervalScaleProto2.setInterval.call(scale4, interval);
    if (t0 || t1) {
      intervalScaleProto2.setNiceExtent.call(scale4, min3 + interval, max3 - interval);
    }
    if (true) {
      var ticks = intervalScaleProto2.getTicks.call(scale4);
      if (ticks[1] && (!isValueNice(interval) || getPrecisionSafe(ticks[1].value) > getPrecisionSafe(interval))) {
        warn("The ticks may be not readable when set min: " + axisModel.get("min") + ", max: " + axisModel.get("max") + " and alignTicks: true");
      }
    }
  }

  // node_modules/echarts/lib/coord/cartesian/Grid.js
  var Grid = function() {
    function Grid2(gridModel, ecModel, api) {
      this.type = "grid";
      this._coordsMap = {};
      this._coordsList = [];
      this._axesMap = {};
      this._axesList = [];
      this.axisPointerEnabled = true;
      this.dimensions = cartesian2DDimensions;
      this._initCartesian(gridModel, ecModel, api);
      this.model = gridModel;
    }
    Grid2.prototype.getRect = function() {
      return this._rect;
    };
    Grid2.prototype.update = function(ecModel, api) {
      var axesMap = this._axesMap;
      this._updateScale(ecModel, this.model);
      function updateAxisTicks(axes) {
        var alignTo;
        var axesIndices = keys(axes);
        var len2 = axesIndices.length;
        if (!len2) {
          return;
        }
        var axisNeedsAlign = [];
        for (var i = len2 - 1; i >= 0; i--) {
          var idx = +axesIndices[i];
          var axis = axes[idx];
          var model = axis.model;
          var scale4 = axis.scale;
          if (isIntervalOrLogScale(scale4) && model.get("alignTicks") && model.get("interval") == null) {
            axisNeedsAlign.push(axis);
          } else {
            niceScaleExtent(scale4, model);
            if (isIntervalOrLogScale(scale4)) {
              alignTo = axis;
            }
          }
        }
        ;
        if (axisNeedsAlign.length) {
          if (!alignTo) {
            alignTo = axisNeedsAlign.pop();
            niceScaleExtent(alignTo.scale, alignTo.model);
          }
          each(axisNeedsAlign, function(axis2) {
            alignScaleTicks(axis2.scale, axis2.model, alignTo.scale);
          });
        }
      }
      updateAxisTicks(axesMap.x);
      updateAxisTicks(axesMap.y);
      var onZeroRecords = {};
      each(axesMap.x, function(xAxis) {
        fixAxisOnZero(axesMap, "y", xAxis, onZeroRecords);
      });
      each(axesMap.y, function(yAxis) {
        fixAxisOnZero(axesMap, "x", yAxis, onZeroRecords);
      });
      this.resize(this.model, api);
    };
    Grid2.prototype.resize = function(gridModel, api, ignoreContainLabel) {
      var boxLayoutParams = gridModel.getBoxLayoutParams();
      var isContainLabel = !ignoreContainLabel && gridModel.get("containLabel");
      var gridRect = getLayoutRect(boxLayoutParams, {
        width: api.getWidth(),
        height: api.getHeight()
      });
      this._rect = gridRect;
      var axesList = this._axesList;
      adjustAxes();
      if (isContainLabel) {
        each(axesList, function(axis) {
          if (!axis.model.get(["axisLabel", "inside"])) {
            var labelUnionRect = estimateLabelUnionRect(axis);
            if (labelUnionRect) {
              var dim = axis.isHorizontal() ? "height" : "width";
              var margin = axis.model.get(["axisLabel", "margin"]);
              gridRect[dim] -= labelUnionRect[dim] + margin;
              if (axis.position === "top") {
                gridRect.y += labelUnionRect.height + margin;
              } else if (axis.position === "left") {
                gridRect.x += labelUnionRect.width + margin;
              }
            }
          }
        });
        adjustAxes();
      }
      each(this._coordsList, function(coord) {
        coord.calcAffineTransform();
      });
      function adjustAxes() {
        each(axesList, function(axis) {
          var isHorizontal = axis.isHorizontal();
          var extent3 = isHorizontal ? [0, gridRect.width] : [0, gridRect.height];
          var idx = axis.inverse ? 1 : 0;
          axis.setExtent(extent3[idx], extent3[1 - idx]);
          updateAxisTransform(axis, isHorizontal ? gridRect.x : gridRect.y);
        });
      }
    };
    Grid2.prototype.getAxis = function(dim, axisIndex) {
      var axesMapOnDim = this._axesMap[dim];
      if (axesMapOnDim != null) {
        return axesMapOnDim[axisIndex || 0];
      }
    };
    Grid2.prototype.getAxes = function() {
      return this._axesList.slice();
    };
    Grid2.prototype.getCartesian = function(xAxisIndex, yAxisIndex) {
      if (xAxisIndex != null && yAxisIndex != null) {
        var key = "x" + xAxisIndex + "y" + yAxisIndex;
        return this._coordsMap[key];
      }
      if (isObject(xAxisIndex)) {
        yAxisIndex = xAxisIndex.yAxisIndex;
        xAxisIndex = xAxisIndex.xAxisIndex;
      }
      for (var i = 0, coordList = this._coordsList; i < coordList.length; i++) {
        if (coordList[i].getAxis("x").index === xAxisIndex || coordList[i].getAxis("y").index === yAxisIndex) {
          return coordList[i];
        }
      }
    };
    Grid2.prototype.getCartesians = function() {
      return this._coordsList.slice();
    };
    Grid2.prototype.convertToPixel = function(ecModel, finder, value) {
      var target = this._findConvertTarget(finder);
      return target.cartesian ? target.cartesian.dataToPoint(value) : target.axis ? target.axis.toGlobalCoord(target.axis.dataToCoord(value)) : null;
    };
    Grid2.prototype.convertFromPixel = function(ecModel, finder, value) {
      var target = this._findConvertTarget(finder);
      return target.cartesian ? target.cartesian.pointToData(value) : target.axis ? target.axis.coordToData(target.axis.toLocalCoord(value)) : null;
    };
    Grid2.prototype._findConvertTarget = function(finder) {
      var seriesModel = finder.seriesModel;
      var xAxisModel = finder.xAxisModel || seriesModel && seriesModel.getReferringComponents("xAxis", SINGLE_REFERRING).models[0];
      var yAxisModel = finder.yAxisModel || seriesModel && seriesModel.getReferringComponents("yAxis", SINGLE_REFERRING).models[0];
      var gridModel = finder.gridModel;
      var coordsList = this._coordsList;
      var cartesian;
      var axis;
      if (seriesModel) {
        cartesian = seriesModel.coordinateSystem;
        indexOf(coordsList, cartesian) < 0 && (cartesian = null);
      } else if (xAxisModel && yAxisModel) {
        cartesian = this.getCartesian(xAxisModel.componentIndex, yAxisModel.componentIndex);
      } else if (xAxisModel) {
        axis = this.getAxis("x", xAxisModel.componentIndex);
      } else if (yAxisModel) {
        axis = this.getAxis("y", yAxisModel.componentIndex);
      } else if (gridModel) {
        var grid = gridModel.coordinateSystem;
        if (grid === this) {
          cartesian = this._coordsList[0];
        }
      }
      return {
        cartesian,
        axis
      };
    };
    Grid2.prototype.containPoint = function(point) {
      var coord = this._coordsList[0];
      if (coord) {
        return coord.containPoint(point);
      }
    };
    Grid2.prototype._initCartesian = function(gridModel, ecModel, api) {
      var _this = this;
      var grid = this;
      var axisPositionUsed = {
        left: false,
        right: false,
        top: false,
        bottom: false
      };
      var axesMap = {
        x: {},
        y: {}
      };
      var axesCount = {
        x: 0,
        y: 0
      };
      ecModel.eachComponent("xAxis", createAxisCreator("x"), this);
      ecModel.eachComponent("yAxis", createAxisCreator("y"), this);
      if (!axesCount.x || !axesCount.y) {
        this._axesMap = {};
        this._axesList = [];
        return;
      }
      this._axesMap = axesMap;
      each(axesMap.x, function(xAxis, xAxisIndex) {
        each(axesMap.y, function(yAxis, yAxisIndex) {
          var key = "x" + xAxisIndex + "y" + yAxisIndex;
          var cartesian = new Cartesian2D_default(key);
          cartesian.master = _this;
          cartesian.model = gridModel;
          _this._coordsMap[key] = cartesian;
          _this._coordsList.push(cartesian);
          cartesian.addAxis(xAxis);
          cartesian.addAxis(yAxis);
        });
      });
      function createAxisCreator(dimName) {
        return function(axisModel, idx) {
          if (!isAxisUsedInTheGrid(axisModel, gridModel)) {
            return;
          }
          var axisPosition = axisModel.get("position");
          if (dimName === "x") {
            if (axisPosition !== "top" && axisPosition !== "bottom") {
              axisPosition = axisPositionUsed.bottom ? "top" : "bottom";
            }
          } else {
            if (axisPosition !== "left" && axisPosition !== "right") {
              axisPosition = axisPositionUsed.left ? "right" : "left";
            }
          }
          axisPositionUsed[axisPosition] = true;
          var axis = new Axis2D_default(dimName, createScaleByModel(axisModel), [0, 0], axisModel.get("type"), axisPosition);
          var isCategory2 = axis.type === "category";
          axis.onBand = isCategory2 && axisModel.get("boundaryGap");
          axis.inverse = axisModel.get("inverse");
          axisModel.axis = axis;
          axis.model = axisModel;
          axis.grid = grid;
          axis.index = idx;
          grid._axesList.push(axis);
          axesMap[dimName][idx] = axis;
          axesCount[dimName]++;
        };
      }
    };
    Grid2.prototype._updateScale = function(ecModel, gridModel) {
      each(this._axesList, function(axis) {
        axis.scale.setExtent(Infinity, -Infinity);
        if (axis.type === "category") {
          var categorySortInfo = axis.model.get("categorySortInfo");
          axis.scale.setSortInfo(categorySortInfo);
        }
      });
      ecModel.eachSeries(function(seriesModel) {
        if (isCartesian2DSeries(seriesModel)) {
          var axesModelMap = findAxisModels(seriesModel);
          var xAxisModel = axesModelMap.xAxisModel;
          var yAxisModel = axesModelMap.yAxisModel;
          if (!isAxisUsedInTheGrid(xAxisModel, gridModel) || !isAxisUsedInTheGrid(yAxisModel, gridModel)) {
            return;
          }
          var cartesian = this.getCartesian(xAxisModel.componentIndex, yAxisModel.componentIndex);
          var data = seriesModel.getData();
          var xAxis = cartesian.getAxis("x");
          var yAxis = cartesian.getAxis("y");
          unionExtent(data, xAxis);
          unionExtent(data, yAxis);
        }
      }, this);
      function unionExtent(data, axis) {
        each(getDataDimensionsOnAxis(data, axis.dim), function(dim) {
          axis.scale.unionExtentFromData(data, dim);
        });
      }
    };
    Grid2.prototype.getTooltipAxes = function(dim) {
      var baseAxes = [];
      var otherAxes = [];
      each(this.getCartesians(), function(cartesian) {
        var baseAxis = dim != null && dim !== "auto" ? cartesian.getAxis(dim) : cartesian.getBaseAxis();
        var otherAxis = cartesian.getOtherAxis(baseAxis);
        indexOf(baseAxes, baseAxis) < 0 && baseAxes.push(baseAxis);
        indexOf(otherAxes, otherAxis) < 0 && otherAxes.push(otherAxis);
      });
      return {
        baseAxes,
        otherAxes
      };
    };
    Grid2.create = function(ecModel, api) {
      var grids = [];
      ecModel.eachComponent("grid", function(gridModel, idx) {
        var grid = new Grid2(gridModel, ecModel, api);
        grid.name = "grid_" + idx;
        grid.resize(gridModel, api, true);
        gridModel.coordinateSystem = grid;
        grids.push(grid);
      });
      ecModel.eachSeries(function(seriesModel) {
        if (!isCartesian2DSeries(seriesModel)) {
          return;
        }
        var axesModelMap = findAxisModels(seriesModel);
        var xAxisModel = axesModelMap.xAxisModel;
        var yAxisModel = axesModelMap.yAxisModel;
        var gridModel = xAxisModel.getCoordSysModel();
        if (true) {
          if (!gridModel) {
            throw new Error('Grid "' + retrieve3(xAxisModel.get("gridIndex"), xAxisModel.get("gridId"), 0) + '" not found');
          }
          if (xAxisModel.getCoordSysModel() !== yAxisModel.getCoordSysModel()) {
            throw new Error("xAxis and yAxis must use the same grid");
          }
        }
        var grid = gridModel.coordinateSystem;
        seriesModel.coordinateSystem = grid.getCartesian(xAxisModel.componentIndex, yAxisModel.componentIndex);
      });
      return grids;
    };
    Grid2.dimensions = cartesian2DDimensions;
    return Grid2;
  }();
  function isAxisUsedInTheGrid(axisModel, gridModel) {
    return axisModel.getCoordSysModel() === gridModel;
  }
  function fixAxisOnZero(axesMap, otherAxisDim, axis, onZeroRecords) {
    axis.getAxesOnZeroOf = function() {
      return otherAxisOnZeroOf ? [otherAxisOnZeroOf] : [];
    };
    var otherAxes = axesMap[otherAxisDim];
    var otherAxisOnZeroOf;
    var axisModel = axis.model;
    var onZero = axisModel.get(["axisLine", "onZero"]);
    var onZeroAxisIndex = axisModel.get(["axisLine", "onZeroAxisIndex"]);
    if (!onZero) {
      return;
    }
    if (onZeroAxisIndex != null) {
      if (canOnZeroToAxis(otherAxes[onZeroAxisIndex])) {
        otherAxisOnZeroOf = otherAxes[onZeroAxisIndex];
      }
    } else {
      for (var idx in otherAxes) {
        if (otherAxes.hasOwnProperty(idx) && canOnZeroToAxis(otherAxes[idx]) && !onZeroRecords[getOnZeroRecordKey(otherAxes[idx])]) {
          otherAxisOnZeroOf = otherAxes[idx];
          break;
        }
      }
    }
    if (otherAxisOnZeroOf) {
      onZeroRecords[getOnZeroRecordKey(otherAxisOnZeroOf)] = true;
    }
    function getOnZeroRecordKey(axis2) {
      return axis2.dim + "_" + axis2.index;
    }
  }
  function canOnZeroToAxis(axis) {
    return axis && axis.type !== "category" && axis.type !== "time" && ifAxisCrossZero(axis);
  }
  function updateAxisTransform(axis, coordBase) {
    var axisExtent = axis.getExtent();
    var axisExtentSum = axisExtent[0] + axisExtent[1];
    axis.toGlobalCoord = axis.dim === "x" ? function(coord) {
      return coord + coordBase;
    } : function(coord) {
      return axisExtentSum - coord + coordBase;
    };
    axis.toLocalCoord = axis.dim === "x" ? function(coord) {
      return coord - coordBase;
    } : function(coord) {
      return axisExtentSum - coord + coordBase;
    };
  }
  var Grid_default = Grid;

  // node_modules/echarts/lib/component/axis/AxisBuilder.js
  var PI7 = Math.PI;
  var AxisBuilder = function() {
    function AxisBuilder2(axisModel, opt) {
      this.group = new Group_default();
      this.opt = opt;
      this.axisModel = axisModel;
      defaults(opt, {
        labelOffset: 0,
        nameDirection: 1,
        tickDirection: 1,
        labelDirection: 1,
        silent: true,
        handleAutoShown: function() {
          return true;
        }
      });
      var transformGroup = new Group_default({
        x: opt.position[0],
        y: opt.position[1],
        rotation: opt.rotation
      });
      transformGroup.updateTransform();
      this._transformGroup = transformGroup;
    }
    AxisBuilder2.prototype.hasBuilder = function(name) {
      return !!builders[name];
    };
    AxisBuilder2.prototype.add = function(name) {
      builders[name](this.opt, this.axisModel, this.group, this._transformGroup);
    };
    AxisBuilder2.prototype.getGroup = function() {
      return this.group;
    };
    AxisBuilder2.innerTextLayout = function(axisRotation, textRotation, direction) {
      var rotationDiff = remRadian(textRotation - axisRotation);
      var textAlign;
      var textVerticalAlign;
      if (isRadianAroundZero(rotationDiff)) {
        textVerticalAlign = direction > 0 ? "top" : "bottom";
        textAlign = "center";
      } else if (isRadianAroundZero(rotationDiff - PI7)) {
        textVerticalAlign = direction > 0 ? "bottom" : "top";
        textAlign = "center";
      } else {
        textVerticalAlign = "middle";
        if (rotationDiff > 0 && rotationDiff < PI7) {
          textAlign = direction > 0 ? "right" : "left";
        } else {
          textAlign = direction > 0 ? "left" : "right";
        }
      }
      return {
        rotation: rotationDiff,
        textAlign,
        textVerticalAlign
      };
    };
    AxisBuilder2.makeAxisEventDataBase = function(axisModel) {
      var eventData = {
        componentType: axisModel.mainType,
        componentIndex: axisModel.componentIndex
      };
      eventData[axisModel.mainType + "Index"] = axisModel.componentIndex;
      return eventData;
    };
    AxisBuilder2.isLabelSilent = function(axisModel) {
      var tooltipOpt = axisModel.get("tooltip");
      return axisModel.get("silent") || !(axisModel.get("triggerEvent") || tooltipOpt && tooltipOpt.show);
    };
    return AxisBuilder2;
  }();
  var builders = {
    axisLine: function(opt, axisModel, group, transformGroup) {
      var shown = axisModel.get(["axisLine", "show"]);
      if (shown === "auto" && opt.handleAutoShown) {
        shown = opt.handleAutoShown("axisLine");
      }
      if (!shown) {
        return;
      }
      var extent3 = axisModel.axis.getExtent();
      var matrix = transformGroup.transform;
      var pt12 = [extent3[0], 0];
      var pt22 = [extent3[1], 0];
      if (matrix) {
        applyTransform(pt12, pt12, matrix);
        applyTransform(pt22, pt22, matrix);
      }
      var lineStyle = extend({
        lineCap: "round"
      }, axisModel.getModel(["axisLine", "lineStyle"]).getLineStyle());
      var line = new Line_default({
        subPixelOptimize: true,
        shape: {
          x1: pt12[0],
          y1: pt12[1],
          x2: pt22[0],
          y2: pt22[1]
        },
        style: lineStyle,
        strokeContainThreshold: opt.strokeContainThreshold || 5,
        silent: true,
        z2: 1
      });
      line.anid = "line";
      group.add(line);
      var arrows = axisModel.get(["axisLine", "symbol"]);
      if (arrows != null) {
        var arrowSize = axisModel.get(["axisLine", "symbolSize"]);
        if (isString(arrows)) {
          arrows = [arrows, arrows];
        }
        if (isString(arrowSize) || isNumber(arrowSize)) {
          arrowSize = [arrowSize, arrowSize];
        }
        var arrowOffset = normalizeSymbolOffset(axisModel.get(["axisLine", "symbolOffset"]) || 0, arrowSize);
        var symbolWidth_1 = arrowSize[0];
        var symbolHeight_1 = arrowSize[1];
        each([{
          rotate: opt.rotation + Math.PI / 2,
          offset: arrowOffset[0],
          r: 0
        }, {
          rotate: opt.rotation - Math.PI / 2,
          offset: arrowOffset[1],
          r: Math.sqrt((pt12[0] - pt22[0]) * (pt12[0] - pt22[0]) + (pt12[1] - pt22[1]) * (pt12[1] - pt22[1]))
        }], function(point, index) {
          if (arrows[index] !== "none" && arrows[index] != null) {
            var symbol = createSymbol(arrows[index], -symbolWidth_1 / 2, -symbolHeight_1 / 2, symbolWidth_1, symbolHeight_1, lineStyle.stroke, true);
            var r = point.r + point.offset;
            symbol.attr({
              rotation: point.rotate,
              x: pt12[0] + r * Math.cos(opt.rotation),
              y: pt12[1] - r * Math.sin(opt.rotation),
              silent: true,
              z2: 11
            });
            group.add(symbol);
          }
        });
      }
    },
    axisTickLabel: function(opt, axisModel, group, transformGroup) {
      var ticksEls = buildAxisMajorTicks(group, transformGroup, axisModel, opt);
      var labelEls = buildAxisLabel(group, transformGroup, axisModel, opt);
      fixMinMaxLabelShow(axisModel, labelEls, ticksEls);
      buildAxisMinorTicks(group, transformGroup, axisModel, opt.tickDirection);
      if (axisModel.get(["axisLabel", "hideOverlap"])) {
        var labelList = prepareLayoutList(map(labelEls, function(label) {
          return {
            label,
            priority: label.z2,
            defaultAttr: {
              ignore: label.ignore
            }
          };
        }));
        hideOverlap(labelList);
      }
    },
    axisName: function(opt, axisModel, group, transformGroup) {
      var name = retrieve(opt.axisName, axisModel.get("name"));
      if (!name) {
        return;
      }
      var nameLocation = axisModel.get("nameLocation");
      var nameDirection = opt.nameDirection;
      var textStyleModel = axisModel.getModel("nameTextStyle");
      var gap = axisModel.get("nameGap") || 0;
      var extent3 = axisModel.axis.getExtent();
      var gapSignal = extent3[0] > extent3[1] ? -1 : 1;
      var pos = [
        nameLocation === "start" ? extent3[0] - gapSignal * gap : nameLocation === "end" ? extent3[1] + gapSignal * gap : (extent3[0] + extent3[1]) / 2,
        isNameLocationCenter(nameLocation) ? opt.labelOffset + nameDirection * gap : 0
      ];
      var labelLayout2;
      var nameRotation = axisModel.get("nameRotate");
      if (nameRotation != null) {
        nameRotation = nameRotation * PI7 / 180;
      }
      var axisNameAvailableWidth;
      if (isNameLocationCenter(nameLocation)) {
        labelLayout2 = AxisBuilder.innerTextLayout(opt.rotation, nameRotation != null ? nameRotation : opt.rotation, nameDirection);
      } else {
        labelLayout2 = endTextLayout(opt.rotation, nameLocation, nameRotation || 0, extent3);
        axisNameAvailableWidth = opt.axisNameAvailableWidth;
        if (axisNameAvailableWidth != null) {
          axisNameAvailableWidth = Math.abs(axisNameAvailableWidth / Math.sin(labelLayout2.rotation));
          !isFinite(axisNameAvailableWidth) && (axisNameAvailableWidth = null);
        }
      }
      var textFont = textStyleModel.getFont();
      var truncateOpt = axisModel.get("nameTruncate", true) || {};
      var ellipsis = truncateOpt.ellipsis;
      var maxWidth = retrieve(opt.nameTruncateMaxWidth, truncateOpt.maxWidth, axisNameAvailableWidth);
      var textEl = new Text_default({
        x: pos[0],
        y: pos[1],
        rotation: labelLayout2.rotation,
        silent: AxisBuilder.isLabelSilent(axisModel),
        style: createTextStyle(textStyleModel, {
          text: name,
          font: textFont,
          overflow: "truncate",
          width: maxWidth,
          ellipsis,
          fill: textStyleModel.getTextColor() || axisModel.get(["axisLine", "lineStyle", "color"]),
          align: textStyleModel.get("align") || labelLayout2.textAlign,
          verticalAlign: textStyleModel.get("verticalAlign") || labelLayout2.textVerticalAlign
        }),
        z2: 1
      });
      setTooltipConfig({
        el: textEl,
        componentModel: axisModel,
        itemName: name
      });
      textEl.__fullText = name;
      textEl.anid = "name";
      if (axisModel.get("triggerEvent")) {
        var eventData = AxisBuilder.makeAxisEventDataBase(axisModel);
        eventData.targetType = "axisName";
        eventData.name = name;
        getECData(textEl).eventData = eventData;
      }
      transformGroup.add(textEl);
      textEl.updateTransform();
      group.add(textEl);
      textEl.decomposeTransform();
    }
  };
  function endTextLayout(rotation, textPosition, textRotate, extent3) {
    var rotationDiff = remRadian(textRotate - rotation);
    var textAlign;
    var textVerticalAlign;
    var inverse = extent3[0] > extent3[1];
    var onLeft = textPosition === "start" && !inverse || textPosition !== "start" && inverse;
    if (isRadianAroundZero(rotationDiff - PI7 / 2)) {
      textVerticalAlign = onLeft ? "bottom" : "top";
      textAlign = "center";
    } else if (isRadianAroundZero(rotationDiff - PI7 * 1.5)) {
      textVerticalAlign = onLeft ? "top" : "bottom";
      textAlign = "center";
    } else {
      textVerticalAlign = "middle";
      if (rotationDiff < PI7 * 1.5 && rotationDiff > PI7 / 2) {
        textAlign = onLeft ? "left" : "right";
      } else {
        textAlign = onLeft ? "right" : "left";
      }
    }
    return {
      rotation: rotationDiff,
      textAlign,
      textVerticalAlign
    };
  }
  function fixMinMaxLabelShow(axisModel, labelEls, tickEls) {
    if (shouldShowAllLabels(axisModel.axis)) {
      return;
    }
    var showMinLabel = axisModel.get(["axisLabel", "showMinLabel"]);
    var showMaxLabel = axisModel.get(["axisLabel", "showMaxLabel"]);
    labelEls = labelEls || [];
    tickEls = tickEls || [];
    var firstLabel = labelEls[0];
    var nextLabel = labelEls[1];
    var lastLabel = labelEls[labelEls.length - 1];
    var prevLabel = labelEls[labelEls.length - 2];
    var firstTick = tickEls[0];
    var nextTick = tickEls[1];
    var lastTick = tickEls[tickEls.length - 1];
    var prevTick = tickEls[tickEls.length - 2];
    if (showMinLabel === false) {
      ignoreEl(firstLabel);
      ignoreEl(firstTick);
    } else if (isTwoLabelOverlapped(firstLabel, nextLabel)) {
      if (showMinLabel) {
        ignoreEl(nextLabel);
        ignoreEl(nextTick);
      } else {
        ignoreEl(firstLabel);
        ignoreEl(firstTick);
      }
    }
    if (showMaxLabel === false) {
      ignoreEl(lastLabel);
      ignoreEl(lastTick);
    } else if (isTwoLabelOverlapped(prevLabel, lastLabel)) {
      if (showMaxLabel) {
        ignoreEl(prevLabel);
        ignoreEl(prevTick);
      } else {
        ignoreEl(lastLabel);
        ignoreEl(lastTick);
      }
    }
  }
  function ignoreEl(el) {
    el && (el.ignore = true);
  }
  function isTwoLabelOverlapped(current, next) {
    var firstRect = current && current.getBoundingRect().clone();
    var nextRect = next && next.getBoundingRect().clone();
    if (!firstRect || !nextRect) {
      return;
    }
    var mRotationBack = identity([]);
    rotate(mRotationBack, mRotationBack, -current.rotation);
    firstRect.applyTransform(mul2([], mRotationBack, current.getLocalTransform()));
    nextRect.applyTransform(mul2([], mRotationBack, next.getLocalTransform()));
    return firstRect.intersect(nextRect);
  }
  function isNameLocationCenter(nameLocation) {
    return nameLocation === "middle" || nameLocation === "center";
  }
  function createTicks(ticksCoords, tickTransform, tickEndCoord, tickLineStyle, anidPrefix) {
    var tickEls = [];
    var pt12 = [];
    var pt22 = [];
    for (var i = 0; i < ticksCoords.length; i++) {
      var tickCoord = ticksCoords[i].coord;
      pt12[0] = tickCoord;
      pt12[1] = 0;
      pt22[0] = tickCoord;
      pt22[1] = tickEndCoord;
      if (tickTransform) {
        applyTransform(pt12, pt12, tickTransform);
        applyTransform(pt22, pt22, tickTransform);
      }
      var tickEl = new Line_default({
        subPixelOptimize: true,
        shape: {
          x1: pt12[0],
          y1: pt12[1],
          x2: pt22[0],
          y2: pt22[1]
        },
        style: tickLineStyle,
        z2: 2,
        autoBatch: true,
        silent: true
      });
      tickEl.anid = anidPrefix + "_" + ticksCoords[i].tickValue;
      tickEls.push(tickEl);
    }
    return tickEls;
  }
  function buildAxisMajorTicks(group, transformGroup, axisModel, opt) {
    var axis = axisModel.axis;
    var tickModel = axisModel.getModel("axisTick");
    var shown = tickModel.get("show");
    if (shown === "auto" && opt.handleAutoShown) {
      shown = opt.handleAutoShown("axisTick");
    }
    if (!shown || axis.scale.isBlank()) {
      return;
    }
    var lineStyleModel = tickModel.getModel("lineStyle");
    var tickEndCoord = opt.tickDirection * tickModel.get("length");
    var ticksCoords = axis.getTicksCoords();
    var ticksEls = createTicks(ticksCoords, transformGroup.transform, tickEndCoord, defaults(lineStyleModel.getLineStyle(), {
      stroke: axisModel.get(["axisLine", "lineStyle", "color"])
    }), "ticks");
    for (var i = 0; i < ticksEls.length; i++) {
      group.add(ticksEls[i]);
    }
    return ticksEls;
  }
  function buildAxisMinorTicks(group, transformGroup, axisModel, tickDirection) {
    var axis = axisModel.axis;
    var minorTickModel = axisModel.getModel("minorTick");
    if (!minorTickModel.get("show") || axis.scale.isBlank()) {
      return;
    }
    var minorTicksCoords = axis.getMinorTicksCoords();
    if (!minorTicksCoords.length) {
      return;
    }
    var lineStyleModel = minorTickModel.getModel("lineStyle");
    var tickEndCoord = tickDirection * minorTickModel.get("length");
    var minorTickLineStyle = defaults(lineStyleModel.getLineStyle(), defaults(axisModel.getModel("axisTick").getLineStyle(), {
      stroke: axisModel.get(["axisLine", "lineStyle", "color"])
    }));
    for (var i = 0; i < minorTicksCoords.length; i++) {
      var minorTicksEls = createTicks(minorTicksCoords[i], transformGroup.transform, tickEndCoord, minorTickLineStyle, "minorticks_" + i);
      for (var k = 0; k < minorTicksEls.length; k++) {
        group.add(minorTicksEls[k]);
      }
    }
  }
  function buildAxisLabel(group, transformGroup, axisModel, opt) {
    var axis = axisModel.axis;
    var show = retrieve(opt.axisLabelShow, axisModel.get(["axisLabel", "show"]));
    if (!show || axis.scale.isBlank()) {
      return;
    }
    var labelModel = axisModel.getModel("axisLabel");
    var labelMargin = labelModel.get("margin");
    var labels = axis.getViewLabels();
    var labelRotation = (retrieve(opt.labelRotate, labelModel.get("rotate")) || 0) * PI7 / 180;
    var labelLayout2 = AxisBuilder.innerTextLayout(opt.rotation, labelRotation, opt.labelDirection);
    var rawCategoryData = axisModel.getCategories && axisModel.getCategories(true);
    var labelEls = [];
    var silent = AxisBuilder.isLabelSilent(axisModel);
    var triggerEvent = axisModel.get("triggerEvent");
    each(labels, function(labelItem, index) {
      var tickValue = axis.scale.type === "ordinal" ? axis.scale.getRawOrdinalNumber(labelItem.tickValue) : labelItem.tickValue;
      var formattedLabel = labelItem.formattedLabel;
      var rawLabel = labelItem.rawLabel;
      var itemLabelModel = labelModel;
      if (rawCategoryData && rawCategoryData[tickValue]) {
        var rawCategoryItem = rawCategoryData[tickValue];
        if (isObject(rawCategoryItem) && rawCategoryItem.textStyle) {
          itemLabelModel = new Model_default(rawCategoryItem.textStyle, labelModel, axisModel.ecModel);
        }
      }
      var textColor = itemLabelModel.getTextColor() || axisModel.get(["axisLine", "lineStyle", "color"]);
      var tickCoord = axis.dataToCoord(tickValue);
      var textEl = new Text_default({
        x: tickCoord,
        y: opt.labelOffset + opt.labelDirection * labelMargin,
        rotation: labelLayout2.rotation,
        silent,
        z2: 10 + (labelItem.level || 0),
        style: createTextStyle(itemLabelModel, {
          text: formattedLabel,
          align: itemLabelModel.getShallow("align", true) || labelLayout2.textAlign,
          verticalAlign: itemLabelModel.getShallow("verticalAlign", true) || itemLabelModel.getShallow("baseline", true) || labelLayout2.textVerticalAlign,
          fill: isFunction(textColor) ? textColor(axis.type === "category" ? rawLabel : axis.type === "value" ? tickValue + "" : tickValue, index) : textColor
        })
      });
      textEl.anid = "label_" + tickValue;
      if (triggerEvent) {
        var eventData = AxisBuilder.makeAxisEventDataBase(axisModel);
        eventData.targetType = "axisLabel";
        eventData.value = rawLabel;
        eventData.tickIndex = index;
        if (axis.type === "category") {
          eventData.dataIndex = tickValue;
        }
        getECData(textEl).eventData = eventData;
      }
      transformGroup.add(textEl);
      textEl.updateTransform();
      labelEls.push(textEl);
      group.add(textEl);
      textEl.decomposeTransform();
    });
    return labelEls;
  }
  var AxisBuilder_default = AxisBuilder;

  // node_modules/echarts/lib/component/axisPointer/modelHelper.js
  function collect(ecModel, api) {
    var result = {
      axesInfo: {},
      seriesInvolved: false,
      coordSysAxesInfo: {},
      coordSysMap: {}
    };
    collectAxesInfo(result, ecModel, api);
    result.seriesInvolved && collectSeriesInfo(result, ecModel);
    return result;
  }
  function collectAxesInfo(result, ecModel, api) {
    var globalTooltipModel = ecModel.getComponent("tooltip");
    var globalAxisPointerModel = ecModel.getComponent("axisPointer");
    var linksOption = globalAxisPointerModel.get("link", true) || [];
    var linkGroups = [];
    each(api.getCoordinateSystems(), function(coordSys) {
      if (!coordSys.axisPointerEnabled) {
        return;
      }
      var coordSysKey = makeKey(coordSys.model);
      var axesInfoInCoordSys = result.coordSysAxesInfo[coordSysKey] = {};
      result.coordSysMap[coordSysKey] = coordSys;
      var coordSysModel = coordSys.model;
      var baseTooltipModel = coordSysModel.getModel("tooltip", globalTooltipModel);
      each(coordSys.getAxes(), curry(saveTooltipAxisInfo, false, null));
      if (coordSys.getTooltipAxes && globalTooltipModel && baseTooltipModel.get("show")) {
        var triggerAxis = baseTooltipModel.get("trigger") === "axis";
        var cross = baseTooltipModel.get(["axisPointer", "type"]) === "cross";
        var tooltipAxes = coordSys.getTooltipAxes(baseTooltipModel.get(["axisPointer", "axis"]));
        if (triggerAxis || cross) {
          each(tooltipAxes.baseAxes, curry(saveTooltipAxisInfo, cross ? "cross" : true, triggerAxis));
        }
        if (cross) {
          each(tooltipAxes.otherAxes, curry(saveTooltipAxisInfo, "cross", false));
        }
      }
      function saveTooltipAxisInfo(fromTooltip, triggerTooltip, axis) {
        var axisPointerModel = axis.model.getModel("axisPointer", globalAxisPointerModel);
        var axisPointerShow = axisPointerModel.get("show");
        if (!axisPointerShow || axisPointerShow === "auto" && !fromTooltip && !isHandleTrigger(axisPointerModel)) {
          return;
        }
        if (triggerTooltip == null) {
          triggerTooltip = axisPointerModel.get("triggerTooltip");
        }
        axisPointerModel = fromTooltip ? makeAxisPointerModel(axis, baseTooltipModel, globalAxisPointerModel, ecModel, fromTooltip, triggerTooltip) : axisPointerModel;
        var snap = axisPointerModel.get("snap");
        var axisKey = makeKey(axis.model);
        var involveSeries = triggerTooltip || snap || axis.type === "category";
        var axisInfo = result.axesInfo[axisKey] = {
          key: axisKey,
          axis,
          coordSys,
          axisPointerModel,
          triggerTooltip,
          involveSeries,
          snap,
          useHandle: isHandleTrigger(axisPointerModel),
          seriesModels: [],
          linkGroup: null
        };
        axesInfoInCoordSys[axisKey] = axisInfo;
        result.seriesInvolved = result.seriesInvolved || involveSeries;
        var groupIndex = getLinkGroupIndex(linksOption, axis);
        if (groupIndex != null) {
          var linkGroup = linkGroups[groupIndex] || (linkGroups[groupIndex] = {
            axesInfo: {}
          });
          linkGroup.axesInfo[axisKey] = axisInfo;
          linkGroup.mapper = linksOption[groupIndex].mapper;
          axisInfo.linkGroup = linkGroup;
        }
      }
    });
  }
  function makeAxisPointerModel(axis, baseTooltipModel, globalAxisPointerModel, ecModel, fromTooltip, triggerTooltip) {
    var tooltipAxisPointerModel = baseTooltipModel.getModel("axisPointer");
    var fields = ["type", "snap", "lineStyle", "shadowStyle", "label", "animation", "animationDurationUpdate", "animationEasingUpdate", "z"];
    var volatileOption = {};
    each(fields, function(field) {
      volatileOption[field] = clone(tooltipAxisPointerModel.get(field));
    });
    volatileOption.snap = axis.type !== "category" && !!triggerTooltip;
    if (tooltipAxisPointerModel.get("type") === "cross") {
      volatileOption.type = "line";
    }
    var labelOption = volatileOption.label || (volatileOption.label = {});
    labelOption.show == null && (labelOption.show = false);
    if (fromTooltip === "cross") {
      var tooltipAxisPointerLabelShow = tooltipAxisPointerModel.get(["label", "show"]);
      labelOption.show = tooltipAxisPointerLabelShow != null ? tooltipAxisPointerLabelShow : true;
      if (!triggerTooltip) {
        var crossStyle = volatileOption.lineStyle = tooltipAxisPointerModel.get("crossStyle");
        crossStyle && defaults(labelOption, crossStyle.textStyle);
      }
    }
    return axis.model.getModel("axisPointer", new Model_default(volatileOption, globalAxisPointerModel, ecModel));
  }
  function collectSeriesInfo(result, ecModel) {
    ecModel.eachSeries(function(seriesModel) {
      var coordSys = seriesModel.coordinateSystem;
      var seriesTooltipTrigger = seriesModel.get(["tooltip", "trigger"], true);
      var seriesTooltipShow = seriesModel.get(["tooltip", "show"], true);
      if (!coordSys || seriesTooltipTrigger === "none" || seriesTooltipTrigger === false || seriesTooltipTrigger === "item" || seriesTooltipShow === false || seriesModel.get(["axisPointer", "show"], true) === false) {
        return;
      }
      each(result.coordSysAxesInfo[makeKey(coordSys.model)], function(axisInfo) {
        var axis = axisInfo.axis;
        if (coordSys.getAxis(axis.dim) === axis) {
          axisInfo.seriesModels.push(seriesModel);
          axisInfo.seriesDataCount == null && (axisInfo.seriesDataCount = 0);
          axisInfo.seriesDataCount += seriesModel.getData().count();
        }
      });
    });
  }
  function getLinkGroupIndex(linksOption, axis) {
    var axisModel = axis.model;
    var dim = axis.dim;
    for (var i = 0; i < linksOption.length; i++) {
      var linkOption = linksOption[i] || {};
      if (checkPropInLink(linkOption[dim + "AxisId"], axisModel.id) || checkPropInLink(linkOption[dim + "AxisIndex"], axisModel.componentIndex) || checkPropInLink(linkOption[dim + "AxisName"], axisModel.name)) {
        return i;
      }
    }
  }
  function checkPropInLink(linkPropValue, axisPropValue) {
    return linkPropValue === "all" || isArray(linkPropValue) && indexOf(linkPropValue, axisPropValue) >= 0 || linkPropValue === axisPropValue;
  }
  function fixValue(axisModel) {
    var axisInfo = getAxisInfo(axisModel);
    if (!axisInfo) {
      return;
    }
    var axisPointerModel = axisInfo.axisPointerModel;
    var scale4 = axisInfo.axis.scale;
    var option = axisPointerModel.option;
    var status = axisPointerModel.get("status");
    var value = axisPointerModel.get("value");
    if (value != null) {
      value = scale4.parse(value);
    }
    var useHandle = isHandleTrigger(axisPointerModel);
    if (status == null) {
      option.status = useHandle ? "show" : "hide";
    }
    var extent3 = scale4.getExtent().slice();
    extent3[0] > extent3[1] && extent3.reverse();
    if (value == null || value > extent3[1]) {
      value = extent3[1];
    }
    if (value < extent3[0]) {
      value = extent3[0];
    }
    option.value = value;
    if (useHandle) {
      option.status = axisInfo.axis.scale.isBlank() ? "hide" : "show";
    }
  }
  function getAxisInfo(axisModel) {
    var coordSysAxesInfo = (axisModel.ecModel.getComponent("axisPointer") || {}).coordSysAxesInfo;
    return coordSysAxesInfo && coordSysAxesInfo.axesInfo[makeKey(axisModel)];
  }
  function getAxisPointerModel(axisModel) {
    var axisInfo = getAxisInfo(axisModel);
    return axisInfo && axisInfo.axisPointerModel;
  }
  function isHandleTrigger(axisPointerModel) {
    return !!axisPointerModel.get(["handle", "show"]);
  }
  function makeKey(model) {
    return model.type + "||" + model.id;
  }

  // node_modules/echarts/lib/component/axis/AxisView.js
  var axisPointerClazz = {};
  var AxisView = function(_super) {
    __extends(AxisView2, _super);
    function AxisView2() {
      var _this = _super !== null && _super.apply(this, arguments) || this;
      _this.type = AxisView2.type;
      return _this;
    }
    AxisView2.prototype.render = function(axisModel, ecModel, api, payload) {
      this.axisPointerClass && fixValue(axisModel);
      _super.prototype.render.apply(this, arguments);
      this._doUpdateAxisPointerClass(axisModel, api, true);
    };
    AxisView2.prototype.updateAxisPointer = function(axisModel, ecModel, api, payload) {
      this._doUpdateAxisPointerClass(axisModel, api, false);
    };
    AxisView2.prototype.remove = function(ecModel, api) {
      var axisPointer = this._axisPointer;
      axisPointer && axisPointer.remove(api);
    };
    AxisView2.prototype.dispose = function(ecModel, api) {
      this._disposeAxisPointer(api);
      _super.prototype.dispose.apply(this, arguments);
    };
    AxisView2.prototype._doUpdateAxisPointerClass = function(axisModel, api, forceRender) {
      var Clazz = AxisView2.getAxisPointerClass(this.axisPointerClass);
      if (!Clazz) {
        return;
      }
      var axisPointerModel = getAxisPointerModel(axisModel);
      axisPointerModel ? (this._axisPointer || (this._axisPointer = new Clazz())).render(axisModel, axisPointerModel, api, forceRender) : this._disposeAxisPointer(api);
    };
    AxisView2.prototype._disposeAxisPointer = function(api) {
      this._axisPointer && this._axisPointer.dispose(api);
      this._axisPointer = null;
    };
    AxisView2.registerAxisPointerClass = function(type, clazz) {
      if (true) {
        if (axisPointerClazz[type]) {
          throw new Error("axisPointer " + type + " exists");
        }
      }
      axisPointerClazz[type] = clazz;
    };
    ;
    AxisView2.getAxisPointerClass = function(type) {
      return type && axisPointerClazz[type];
    };
    ;
    AxisView2.type = "axis";
    return AxisView2;
  }(Component_default2);
  var AxisView_default = AxisView;

  // node_modules/echarts/lib/component/axis/axisSplitHelper.js
  var inner7 = makeInner();
  function rectCoordAxisBuildSplitArea(axisView, axisGroup, axisModel, gridModel) {
    var axis = axisModel.axis;
    if (axis.scale.isBlank()) {
      return;
    }
    var splitAreaModel = axisModel.getModel("splitArea");
    var areaStyleModel = splitAreaModel.getModel("areaStyle");
    var areaColors = areaStyleModel.get("color");
    var gridRect = gridModel.coordinateSystem.getRect();
    var ticksCoords = axis.getTicksCoords({
      tickModel: splitAreaModel,
      clamp: true
    });
    if (!ticksCoords.length) {
      return;
    }
    var areaColorsLen = areaColors.length;
    var lastSplitAreaColors = inner7(axisView).splitAreaColors;
    var newSplitAreaColors = createHashMap();
    var colorIndex = 0;
    if (lastSplitAreaColors) {
      for (var i = 0; i < ticksCoords.length; i++) {
        var cIndex = lastSplitAreaColors.get(ticksCoords[i].tickValue);
        if (cIndex != null) {
          colorIndex = (cIndex + (areaColorsLen - 1) * i) % areaColorsLen;
          break;
        }
      }
    }
    var prev = axis.toGlobalCoord(ticksCoords[0].coord);
    var areaStyle = areaStyleModel.getAreaStyle();
    areaColors = isArray(areaColors) ? areaColors : [areaColors];
    for (var i = 1; i < ticksCoords.length; i++) {
      var tickCoord = axis.toGlobalCoord(ticksCoords[i].coord);
      var x = void 0;
      var y = void 0;
      var width = void 0;
      var height = void 0;
      if (axis.isHorizontal()) {
        x = prev;
        y = gridRect.y;
        width = tickCoord - x;
        height = gridRect.height;
        prev = x + width;
      } else {
        x = gridRect.x;
        y = prev;
        width = gridRect.width;
        height = tickCoord - y;
        prev = y + height;
      }
      var tickValue = ticksCoords[i - 1].tickValue;
      tickValue != null && newSplitAreaColors.set(tickValue, colorIndex);
      axisGroup.add(new Rect_default({
        anid: tickValue != null ? "area_" + tickValue : null,
        shape: {
          x,
          y,
          width,
          height
        },
        style: defaults({
          fill: areaColors[colorIndex]
        }, areaStyle),
        autoBatch: true,
        silent: true
      }));
      colorIndex = (colorIndex + 1) % areaColorsLen;
    }
    inner7(axisView).splitAreaColors = newSplitAreaColors;
  }
  function rectCoordAxisHandleRemove(axisView) {
    inner7(axisView).splitAreaColors = null;
  }

  // node_modules/echarts/lib/component/axis/CartesianAxisView.js
  var axisBuilderAttrs = ["axisLine", "axisTickLabel", "axisName"];
  var selfBuilderAttrs = ["splitArea", "splitLine", "minorSplitLine"];
  var CartesianAxisView = function(_super) {
    __extends(CartesianAxisView2, _super);
    function CartesianAxisView2() {
      var _this = _super !== null && _super.apply(this, arguments) || this;
      _this.type = CartesianAxisView2.type;
      _this.axisPointerClass = "CartesianAxisPointer";
      return _this;
    }
    CartesianAxisView2.prototype.render = function(axisModel, ecModel, api, payload) {
      this.group.removeAll();
      var oldAxisGroup = this._axisGroup;
      this._axisGroup = new Group_default();
      this.group.add(this._axisGroup);
      if (!axisModel.get("show")) {
        return;
      }
      var gridModel = axisModel.getCoordSysModel();
      var layout5 = layout2(gridModel, axisModel);
      var axisBuilder = new AxisBuilder_default(axisModel, extend({
        handleAutoShown: function(elementType) {
          var cartesians = gridModel.coordinateSystem.getCartesians();
          for (var i = 0; i < cartesians.length; i++) {
            if (isIntervalOrLogScale(cartesians[i].getOtherAxis(axisModel.axis).scale)) {
              return true;
            }
          }
          return false;
        }
      }, layout5));
      each(axisBuilderAttrs, axisBuilder.add, axisBuilder);
      this._axisGroup.add(axisBuilder.getGroup());
      each(selfBuilderAttrs, function(name) {
        if (axisModel.get([name, "show"])) {
          axisElementBuilders[name](this, this._axisGroup, axisModel, gridModel);
        }
      }, this);
      var isInitialSortFromBarRacing = payload && payload.type === "changeAxisOrder" && payload.isInitSort;
      if (!isInitialSortFromBarRacing) {
        groupTransition(oldAxisGroup, this._axisGroup, axisModel);
      }
      _super.prototype.render.call(this, axisModel, ecModel, api, payload);
    };
    CartesianAxisView2.prototype.remove = function() {
      rectCoordAxisHandleRemove(this);
    };
    CartesianAxisView2.type = "cartesianAxis";
    return CartesianAxisView2;
  }(AxisView_default);
  var axisElementBuilders = {
    splitLine: function(axisView, axisGroup, axisModel, gridModel) {
      var axis = axisModel.axis;
      if (axis.scale.isBlank()) {
        return;
      }
      var splitLineModel = axisModel.getModel("splitLine");
      var lineStyleModel = splitLineModel.getModel("lineStyle");
      var lineColors = lineStyleModel.get("color");
      lineColors = isArray(lineColors) ? lineColors : [lineColors];
      var gridRect = gridModel.coordinateSystem.getRect();
      var isHorizontal = axis.isHorizontal();
      var lineCount = 0;
      var ticksCoords = axis.getTicksCoords({
        tickModel: splitLineModel
      });
      var p1 = [];
      var p2 = [];
      var lineStyle = lineStyleModel.getLineStyle();
      for (var i = 0; i < ticksCoords.length; i++) {
        var tickCoord = axis.toGlobalCoord(ticksCoords[i].coord);
        if (isHorizontal) {
          p1[0] = tickCoord;
          p1[1] = gridRect.y;
          p2[0] = tickCoord;
          p2[1] = gridRect.y + gridRect.height;
        } else {
          p1[0] = gridRect.x;
          p1[1] = tickCoord;
          p2[0] = gridRect.x + gridRect.width;
          p2[1] = tickCoord;
        }
        var colorIndex = lineCount++ % lineColors.length;
        var tickValue = ticksCoords[i].tickValue;
        axisGroup.add(new Line_default({
          anid: tickValue != null ? "line_" + ticksCoords[i].tickValue : null,
          subPixelOptimize: true,
          autoBatch: true,
          shape: {
            x1: p1[0],
            y1: p1[1],
            x2: p2[0],
            y2: p2[1]
          },
          style: defaults({
            stroke: lineColors[colorIndex]
          }, lineStyle),
          silent: true
        }));
      }
    },
    minorSplitLine: function(axisView, axisGroup, axisModel, gridModel) {
      var axis = axisModel.axis;
      var minorSplitLineModel = axisModel.getModel("minorSplitLine");
      var lineStyleModel = minorSplitLineModel.getModel("lineStyle");
      var gridRect = gridModel.coordinateSystem.getRect();
      var isHorizontal = axis.isHorizontal();
      var minorTicksCoords = axis.getMinorTicksCoords();
      if (!minorTicksCoords.length) {
        return;
      }
      var p1 = [];
      var p2 = [];
      var lineStyle = lineStyleModel.getLineStyle();
      for (var i = 0; i < minorTicksCoords.length; i++) {
        for (var k = 0; k < minorTicksCoords[i].length; k++) {
          var tickCoord = axis.toGlobalCoord(minorTicksCoords[i][k].coord);
          if (isHorizontal) {
            p1[0] = tickCoord;
            p1[1] = gridRect.y;
            p2[0] = tickCoord;
            p2[1] = gridRect.y + gridRect.height;
          } else {
            p1[0] = gridRect.x;
            p1[1] = tickCoord;
            p2[0] = gridRect.x + gridRect.width;
            p2[1] = tickCoord;
          }
          axisGroup.add(new Line_default({
            anid: "minor_line_" + minorTicksCoords[i][k].tickValue,
            subPixelOptimize: true,
            autoBatch: true,
            shape: {
              x1: p1[0],
              y1: p1[1],
              x2: p2[0],
              y2: p2[1]
            },
            style: lineStyle,
            silent: true
          }));
        }
      }
    },
    splitArea: function(axisView, axisGroup, axisModel, gridModel) {
      rectCoordAxisBuildSplitArea(axisView, axisGroup, axisModel, gridModel);
    }
  };
  var CartesianXAxisView = function(_super) {
    __extends(CartesianXAxisView2, _super);
    function CartesianXAxisView2() {
      var _this = _super !== null && _super.apply(this, arguments) || this;
      _this.type = CartesianXAxisView2.type;
      return _this;
    }
    CartesianXAxisView2.type = "xAxis";
    return CartesianXAxisView2;
  }(CartesianAxisView);
  var CartesianYAxisView = function(_super) {
    __extends(CartesianYAxisView2, _super);
    function CartesianYAxisView2() {
      var _this = _super !== null && _super.apply(this, arguments) || this;
      _this.type = CartesianXAxisView.type;
      return _this;
    }
    CartesianYAxisView2.type = "yAxis";
    return CartesianYAxisView2;
  }(CartesianAxisView);

  // node_modules/echarts/lib/component/grid/installSimple.js
  var GridView = function(_super) {
    __extends(GridView2, _super);
    function GridView2() {
      var _this = _super !== null && _super.apply(this, arguments) || this;
      _this.type = "grid";
      return _this;
    }
    GridView2.prototype.render = function(gridModel, ecModel) {
      this.group.removeAll();
      if (gridModel.get("show")) {
        this.group.add(new Rect_default({
          shape: gridModel.coordinateSystem.getRect(),
          style: defaults({
            fill: gridModel.get("backgroundColor")
          }, gridModel.getItemStyle()),
          silent: true,
          z2: -1
        }));
      }
    };
    GridView2.type = "grid";
    return GridView2;
  }(Component_default2);
  var extraOption = {
    offset: 0
  };
  function install6(registers) {
    registers.registerComponentView(GridView);
    registers.registerComponentModel(GridModel_default);
    registers.registerCoordinateSystem("cartesian2d", Grid_default);
    axisModelCreator(registers, "x", CartesianAxisModel, extraOption);
    axisModelCreator(registers, "y", CartesianAxisModel, extraOption);
    registers.registerComponentView(CartesianXAxisView);
    registers.registerComponentView(CartesianYAxisView);
    registers.registerPreprocessor(function(option) {
      if (option.xAxis && option.yAxis && !option.grid) {
        option.grid = {};
      }
    });
  }

  // node_modules/echarts/lib/chart/scatter/install.js
  function install7(registers) {
    use(install6);
    registers.registerSeriesModel(ScatterSeries_default);
    registers.registerChartView(ScatterView_default);
    registers.registerLayout(pointsLayout("scatter"));
  }

  // node_modules/echarts/lib/chart/radar/radarLayout.js
  function radarLayout(ecModel) {
    ecModel.eachSeriesByType("radar", function(seriesModel) {
      var data = seriesModel.getData();
      var points4 = [];
      var coordSys = seriesModel.coordinateSystem;
      if (!coordSys) {
        return;
      }
      var axes = coordSys.getIndicatorAxes();
      each(axes, function(axis, axisIndex) {
        data.each(data.mapDimension(axes[axisIndex].dim), function(val, dataIndex) {
          points4[dataIndex] = points4[dataIndex] || [];
          var point = coordSys.dataToPoint(val, axisIndex);
          points4[dataIndex][axisIndex] = isValidPoint(point) ? point : getValueMissingPoint(coordSys);
        });
      });
      data.each(function(idx) {
        var firstPoint = find(points4[idx], function(point) {
          return isValidPoint(point);
        }) || getValueMissingPoint(coordSys);
        points4[idx].push(firstPoint.slice());
        data.setItemLayout(idx, points4[idx]);
      });
    });
  }
  function isValidPoint(point) {
    return !isNaN(point[0]) && !isNaN(point[1]);
  }
  function getValueMissingPoint(coordSys) {
    return [coordSys.cx, coordSys.cy];
  }

  // node_modules/echarts/lib/chart/radar/backwardCompat.js
  function radarBackwardCompat(option) {
    var polarOptArr = option.polar;
    if (polarOptArr) {
      if (!isArray(polarOptArr)) {
        polarOptArr = [polarOptArr];
      }
      var polarNotRadar_1 = [];
      each(polarOptArr, function(polarOpt, idx) {
        if (polarOpt.indicator) {
          if (polarOpt.type && !polarOpt.shape) {
            polarOpt.shape = polarOpt.type;
          }
          option.radar = option.radar || [];
          if (!isArray(option.radar)) {
            option.radar = [option.radar];
          }
          option.radar.push(polarOpt);
        } else {
          polarNotRadar_1.push(polarOpt);
        }
      });
      option.polar = polarNotRadar_1;
    }
    each(option.series, function(seriesOpt) {
      if (seriesOpt && seriesOpt.type === "radar" && seriesOpt.polarIndex) {
        seriesOpt.radarIndex = seriesOpt.polarIndex;
      }
    });
  }

  // node_modules/echarts/lib/chart/radar/RadarView.js
  var RadarView = function(_super) {
    __extends(RadarView3, _super);
    function RadarView3() {
      var _this = _super !== null && _super.apply(this, arguments) || this;
      _this.type = RadarView3.type;
      return _this;
    }
    RadarView3.prototype.render = function(seriesModel, ecModel, api) {
      var polar = seriesModel.coordinateSystem;
      var group = this.group;
      var data = seriesModel.getData();
      var oldData = this._data;
      function createSymbol3(data2, idx) {
        var symbolType = data2.getItemVisual(idx, "symbol") || "circle";
        if (symbolType === "none") {
          return;
        }
        var symbolSize = normalizeSymbolSize(data2.getItemVisual(idx, "symbolSize"));
        var symbolPath = createSymbol(symbolType, -1, -1, 2, 2);
        var symbolRotate = data2.getItemVisual(idx, "symbolRotate") || 0;
        symbolPath.attr({
          style: {
            strokeNoScale: true
          },
          z2: 100,
          scaleX: symbolSize[0] / 2,
          scaleY: symbolSize[1] / 2,
          rotation: symbolRotate * Math.PI / 180 || 0
        });
        return symbolPath;
      }
      function updateSymbols(oldPoints, newPoints, symbolGroup, data2, idx, isInit) {
        symbolGroup.removeAll();
        for (var i = 0; i < newPoints.length - 1; i++) {
          var symbolPath = createSymbol3(data2, idx);
          if (symbolPath) {
            symbolPath.__dimIdx = i;
            if (oldPoints[i]) {
              symbolPath.setPosition(oldPoints[i]);
              graphic_exports[isInit ? "initProps" : "updateProps"](symbolPath, {
                x: newPoints[i][0],
                y: newPoints[i][1]
              }, seriesModel, idx);
            } else {
              symbolPath.setPosition(newPoints[i]);
            }
            symbolGroup.add(symbolPath);
          }
        }
      }
      function getInitialPoints(points4) {
        return map(points4, function(pt) {
          return [polar.cx, polar.cy];
        });
      }
      data.diff(oldData).add(function(idx) {
        var points4 = data.getItemLayout(idx);
        if (!points4) {
          return;
        }
        var polygon = new Polygon_default();
        var polyline = new Polyline_default();
        var target = {
          shape: {
            points: points4
          }
        };
        polygon.shape.points = getInitialPoints(points4);
        polyline.shape.points = getInitialPoints(points4);
        initProps(polygon, target, seriesModel, idx);
        initProps(polyline, target, seriesModel, idx);
        var itemGroup = new Group_default();
        var symbolGroup = new Group_default();
        itemGroup.add(polyline);
        itemGroup.add(polygon);
        itemGroup.add(symbolGroup);
        updateSymbols(polyline.shape.points, points4, symbolGroup, data, idx, true);
        data.setItemGraphicEl(idx, itemGroup);
      }).update(function(newIdx, oldIdx) {
        var itemGroup = oldData.getItemGraphicEl(oldIdx);
        var polyline = itemGroup.childAt(0);
        var polygon = itemGroup.childAt(1);
        var symbolGroup = itemGroup.childAt(2);
        var target = {
          shape: {
            points: data.getItemLayout(newIdx)
          }
        };
        if (!target.shape.points) {
          return;
        }
        updateSymbols(polyline.shape.points, target.shape.points, symbolGroup, data, newIdx, false);
        saveOldStyle(polygon);
        saveOldStyle(polyline);
        updateProps(polyline, target, seriesModel);
        updateProps(polygon, target, seriesModel);
        data.setItemGraphicEl(newIdx, itemGroup);
      }).remove(function(idx) {
        group.remove(oldData.getItemGraphicEl(idx));
      }).execute();
      data.eachItemGraphicEl(function(itemGroup, idx) {
        var itemModel = data.getItemModel(idx);
        var polyline = itemGroup.childAt(0);
        var polygon = itemGroup.childAt(1);
        var symbolGroup = itemGroup.childAt(2);
        var itemStyle = data.getItemVisual(idx, "style");
        var color = itemStyle.fill;
        group.add(itemGroup);
        polyline.useStyle(defaults(itemModel.getModel("lineStyle").getLineStyle(), {
          fill: "none",
          stroke: color
        }));
        setStatesStylesFromModel(polyline, itemModel, "lineStyle");
        setStatesStylesFromModel(polygon, itemModel, "areaStyle");
        var areaStyleModel = itemModel.getModel("areaStyle");
        var polygonIgnore = areaStyleModel.isEmpty() && areaStyleModel.parentModel.isEmpty();
        polygon.ignore = polygonIgnore;
        each(["emphasis", "select", "blur"], function(stateName) {
          var stateModel = itemModel.getModel([stateName, "areaStyle"]);
          var stateIgnore = stateModel.isEmpty() && stateModel.parentModel.isEmpty();
          polygon.ensureState(stateName).ignore = stateIgnore && polygonIgnore;
        });
        polygon.useStyle(defaults(areaStyleModel.getAreaStyle(), {
          fill: color,
          opacity: 0.7,
          decal: itemStyle.decal
        }));
        var emphasisModel = itemModel.getModel("emphasis");
        var itemHoverStyle = emphasisModel.getModel("itemStyle").getItemStyle();
        symbolGroup.eachChild(function(symbolPath) {
          if (symbolPath instanceof Image_default) {
            var pathStyle = symbolPath.style;
            symbolPath.useStyle(extend({
              image: pathStyle.image,
              x: pathStyle.x,
              y: pathStyle.y,
              width: pathStyle.width,
              height: pathStyle.height
            }, itemStyle));
          } else {
            symbolPath.useStyle(itemStyle);
            symbolPath.setColor(color);
            symbolPath.style.strokeNoScale = true;
          }
          var pathEmphasisState = symbolPath.ensureState("emphasis");
          pathEmphasisState.style = clone(itemHoverStyle);
          var defaultText = data.getStore().get(data.getDimensionIndex(symbolPath.__dimIdx), idx);
          (defaultText == null || isNaN(defaultText)) && (defaultText = "");
          setLabelStyle(symbolPath, getLabelStatesModels(itemModel), {
            labelFetcher: data.hostModel,
            labelDataIndex: idx,
            labelDimIndex: symbolPath.__dimIdx,
            defaultText,
            inheritColor: color,
            defaultOpacity: itemStyle.opacity
          });
        });
        toggleHoverEmphasis(itemGroup, emphasisModel.get("focus"), emphasisModel.get("blurScope"), emphasisModel.get("disabled"));
      });
      this._data = data;
    };
    RadarView3.prototype.remove = function() {
      this.group.removeAll();
      this._data = null;
    };
    RadarView3.type = "radar";
    return RadarView3;
  }(Chart_default);
  var RadarView_default = RadarView;

  // node_modules/echarts/lib/chart/radar/RadarSeries.js
  var RadarSeriesModel = function(_super) {
    __extends(RadarSeriesModel2, _super);
    function RadarSeriesModel2() {
      var _this = _super !== null && _super.apply(this, arguments) || this;
      _this.type = RadarSeriesModel2.type;
      _this.hasSymbolVisual = true;
      return _this;
    }
    RadarSeriesModel2.prototype.init = function(option) {
      _super.prototype.init.apply(this, arguments);
      this.legendVisualProvider = new LegendVisualProvider_default(bind(this.getData, this), bind(this.getRawData, this));
    };
    RadarSeriesModel2.prototype.getInitialData = function(option, ecModel) {
      return createSeriesDataSimply(this, {
        generateCoord: "indicator_",
        generateCoordCount: Infinity
      });
    };
    RadarSeriesModel2.prototype.formatTooltip = function(dataIndex, multipleSeries, dataType) {
      var data = this.getData();
      var coordSys = this.coordinateSystem;
      var indicatorAxes = coordSys.getIndicatorAxes();
      var name = this.getData().getName(dataIndex);
      var nameToDisplay = name === "" ? this.name : name;
      var markerColor = retrieveVisualColorForTooltipMarker(this, dataIndex);
      return createTooltipMarkup("section", {
        header: nameToDisplay,
        sortBlocks: true,
        blocks: map(indicatorAxes, function(axis) {
          var val = data.get(data.mapDimension(axis.dim), dataIndex);
          return createTooltipMarkup("nameValue", {
            markerType: "subItem",
            markerColor,
            name: axis.name,
            value: val,
            sortParam: val
          });
        })
      });
    };
    RadarSeriesModel2.prototype.getTooltipPosition = function(dataIndex) {
      if (dataIndex != null) {
        var data_1 = this.getData();
        var coordSys = this.coordinateSystem;
        var values = data_1.getValues(map(coordSys.dimensions, function(dim) {
          return data_1.mapDimension(dim);
        }), dataIndex);
        for (var i = 0, len2 = values.length; i < len2; i++) {
          if (!isNaN(values[i])) {
            var indicatorAxes = coordSys.getIndicatorAxes();
            return coordSys.coordToPoint(indicatorAxes[i].dataToCoord(values[i]), i);
          }
        }
      }
    };
    RadarSeriesModel2.type = "series.radar";
    RadarSeriesModel2.dependencies = ["radar"];
    RadarSeriesModel2.defaultOption = {
      z: 2,
      colorBy: "data",
      coordinateSystem: "radar",
      legendHoverLink: true,
      radarIndex: 0,
      lineStyle: {
        width: 2,
        type: "solid",
        join: "round"
      },
      label: {
        position: "top"
      },
      symbolSize: 8
    };
    return RadarSeriesModel2;
  }(Series_default);
  var RadarSeries_default = RadarSeriesModel;

  // node_modules/echarts/lib/coord/radar/RadarModel.js
  var valueAxisDefault = axisDefault_default.value;
  function defaultsShow(opt, show) {
    return defaults({
      show
    }, opt);
  }
  var RadarModel = function(_super) {
    __extends(RadarModel2, _super);
    function RadarModel2() {
      var _this = _super !== null && _super.apply(this, arguments) || this;
      _this.type = RadarModel2.type;
      return _this;
    }
    RadarModel2.prototype.optionUpdated = function() {
      var boundaryGap = this.get("boundaryGap");
      var splitNumber = this.get("splitNumber");
      var scale4 = this.get("scale");
      var axisLine = this.get("axisLine");
      var axisTick = this.get("axisTick");
      var axisLabel = this.get("axisLabel");
      var nameTextStyle = this.get("axisName");
      var showName = this.get(["axisName", "show"]);
      var nameFormatter = this.get(["axisName", "formatter"]);
      var nameGap = this.get("axisNameGap");
      var triggerEvent = this.get("triggerEvent");
      var indicatorModels = map(this.get("indicator") || [], function(indicatorOpt) {
        if (indicatorOpt.max != null && indicatorOpt.max > 0 && !indicatorOpt.min) {
          indicatorOpt.min = 0;
        } else if (indicatorOpt.min != null && indicatorOpt.min < 0 && !indicatorOpt.max) {
          indicatorOpt.max = 0;
        }
        var iNameTextStyle = nameTextStyle;
        if (indicatorOpt.color != null) {
          iNameTextStyle = defaults({
            color: indicatorOpt.color
          }, nameTextStyle);
        }
        var innerIndicatorOpt = merge(clone(indicatorOpt), {
          boundaryGap,
          splitNumber,
          scale: scale4,
          axisLine,
          axisTick,
          axisLabel,
          name: indicatorOpt.text,
          showName,
          nameLocation: "end",
          nameGap,
          nameTextStyle: iNameTextStyle,
          triggerEvent
        }, false);
        if (isString(nameFormatter)) {
          var indName = innerIndicatorOpt.name;
          innerIndicatorOpt.name = nameFormatter.replace("{value}", indName != null ? indName : "");
        } else if (isFunction(nameFormatter)) {
          innerIndicatorOpt.name = nameFormatter(innerIndicatorOpt.name, innerIndicatorOpt);
        }
        var model = new Model_default(innerIndicatorOpt, null, this.ecModel);
        mixin(model, AxisModelCommonMixin.prototype);
        model.mainType = "radar";
        model.componentIndex = this.componentIndex;
        return model;
      }, this);
      this._indicatorModels = indicatorModels;
    };
    RadarModel2.prototype.getIndicatorModels = function() {
      return this._indicatorModels;
    };
    RadarModel2.type = "radar";
    RadarModel2.defaultOption = {
      z: 0,
      center: ["50%", "50%"],
      radius: "75%",
      startAngle: 90,
      axisName: {
        show: true
      },
      boundaryGap: [0, 0],
      splitNumber: 5,
      axisNameGap: 15,
      scale: false,
      shape: "polygon",
      axisLine: merge({
        lineStyle: {
          color: "#bbb"
        }
      }, valueAxisDefault.axisLine),
      axisLabel: defaultsShow(valueAxisDefault.axisLabel, false),
      axisTick: defaultsShow(valueAxisDefault.axisTick, false),
      splitLine: defaultsShow(valueAxisDefault.splitLine, true),
      splitArea: defaultsShow(valueAxisDefault.splitArea, true),
      indicator: []
    };
    return RadarModel2;
  }(Component_default);
  var RadarModel_default = RadarModel;

  // node_modules/echarts/lib/component/radar/RadarView.js
  var axisBuilderAttrs2 = ["axisLine", "axisTickLabel", "axisName"];
  var RadarView2 = function(_super) {
    __extends(RadarView3, _super);
    function RadarView3() {
      var _this = _super !== null && _super.apply(this, arguments) || this;
      _this.type = RadarView3.type;
      return _this;
    }
    RadarView3.prototype.render = function(radarModel, ecModel, api) {
      var group = this.group;
      group.removeAll();
      this._buildAxes(radarModel);
      this._buildSplitLineAndArea(radarModel);
    };
    RadarView3.prototype._buildAxes = function(radarModel) {
      var radar = radarModel.coordinateSystem;
      var indicatorAxes = radar.getIndicatorAxes();
      var axisBuilders = map(indicatorAxes, function(indicatorAxis) {
        var axisName = indicatorAxis.model.get("showName") ? indicatorAxis.name : "";
        var axisBuilder = new AxisBuilder_default(indicatorAxis.model, {
          axisName,
          position: [radar.cx, radar.cy],
          rotation: indicatorAxis.angle,
          labelDirection: -1,
          tickDirection: -1,
          nameDirection: 1
        });
        return axisBuilder;
      });
      each(axisBuilders, function(axisBuilder) {
        each(axisBuilderAttrs2, axisBuilder.add, axisBuilder);
        this.group.add(axisBuilder.getGroup());
      }, this);
    };
    RadarView3.prototype._buildSplitLineAndArea = function(radarModel) {
      var radar = radarModel.coordinateSystem;
      var indicatorAxes = radar.getIndicatorAxes();
      if (!indicatorAxes.length) {
        return;
      }
      var shape = radarModel.get("shape");
      var splitLineModel = radarModel.getModel("splitLine");
      var splitAreaModel = radarModel.getModel("splitArea");
      var lineStyleModel = splitLineModel.getModel("lineStyle");
      var areaStyleModel = splitAreaModel.getModel("areaStyle");
      var showSplitLine = splitLineModel.get("show");
      var showSplitArea = splitAreaModel.get("show");
      var splitLineColors = lineStyleModel.get("color");
      var splitAreaColors = areaStyleModel.get("color");
      var splitLineColorsArr = isArray(splitLineColors) ? splitLineColors : [splitLineColors];
      var splitAreaColorsArr = isArray(splitAreaColors) ? splitAreaColors : [splitAreaColors];
      var splitLines = [];
      var splitAreas = [];
      function getColorIndex(areaOrLine, areaOrLineColorList, idx) {
        var colorIndex2 = idx % areaOrLineColorList.length;
        areaOrLine[colorIndex2] = areaOrLine[colorIndex2] || [];
        return colorIndex2;
      }
      if (shape === "circle") {
        var ticksRadius = indicatorAxes[0].getTicksCoords();
        var cx = radar.cx;
        var cy = radar.cy;
        for (var i = 0; i < ticksRadius.length; i++) {
          if (showSplitLine) {
            var colorIndex = getColorIndex(splitLines, splitLineColorsArr, i);
            splitLines[colorIndex].push(new Circle_default({
              shape: {
                cx,
                cy,
                r: ticksRadius[i].coord
              }
            }));
          }
          if (showSplitArea && i < ticksRadius.length - 1) {
            var colorIndex = getColorIndex(splitAreas, splitAreaColorsArr, i);
            splitAreas[colorIndex].push(new Ring_default({
              shape: {
                cx,
                cy,
                r0: ticksRadius[i].coord,
                r: ticksRadius[i + 1].coord
              }
            }));
          }
        }
      } else {
        var realSplitNumber_1;
        var axesTicksPoints = map(indicatorAxes, function(indicatorAxis, idx) {
          var ticksCoords = indicatorAxis.getTicksCoords();
          realSplitNumber_1 = realSplitNumber_1 == null ? ticksCoords.length - 1 : Math.min(ticksCoords.length - 1, realSplitNumber_1);
          return map(ticksCoords, function(tickCoord) {
            return radar.coordToPoint(tickCoord.coord, idx);
          });
        });
        var prevPoints = [];
        for (var i = 0; i <= realSplitNumber_1; i++) {
          var points4 = [];
          for (var j = 0; j < indicatorAxes.length; j++) {
            points4.push(axesTicksPoints[j][i]);
          }
          if (points4[0]) {
            points4.push(points4[0].slice());
          } else {
            if (true) {
              console.error("Can't draw value axis " + i);
            }
          }
          if (showSplitLine) {
            var colorIndex = getColorIndex(splitLines, splitLineColorsArr, i);
            splitLines[colorIndex].push(new Polyline_default({
              shape: {
                points: points4
              }
            }));
          }
          if (showSplitArea && prevPoints) {
            var colorIndex = getColorIndex(splitAreas, splitAreaColorsArr, i - 1);
            splitAreas[colorIndex].push(new Polygon_default({
              shape: {
                points: points4.concat(prevPoints)
              }
            }));
          }
          prevPoints = points4.slice().reverse();
        }
      }
      var lineStyle = lineStyleModel.getLineStyle();
      var areaStyle = areaStyleModel.getAreaStyle();
      each(splitAreas, function(splitAreas2, idx) {
        this.group.add(mergePath2(splitAreas2, {
          style: defaults({
            stroke: "none",
            fill: splitAreaColorsArr[idx % splitAreaColorsArr.length]
          }, areaStyle),
          silent: true
        }));
      }, this);
      each(splitLines, function(splitLines2, idx) {
        this.group.add(mergePath2(splitLines2, {
          style: defaults({
            fill: "none",
            stroke: splitLineColorsArr[idx % splitLineColorsArr.length]
          }, lineStyle),
          silent: true
        }));
      }, this);
    };
    RadarView3.type = "radar";
    return RadarView3;
  }(Component_default2);
  var RadarView_default2 = RadarView2;

  // node_modules/echarts/lib/coord/radar/IndicatorAxis.js
  var IndicatorAxis = function(_super) {
    __extends(IndicatorAxis2, _super);
    function IndicatorAxis2(dim, scale4, radiusExtent) {
      var _this = _super.call(this, dim, scale4, radiusExtent) || this;
      _this.type = "value";
      _this.angle = 0;
      _this.name = "";
      return _this;
    }
    return IndicatorAxis2;
  }(Axis_default);
  var IndicatorAxis_default = IndicatorAxis;

  // node_modules/echarts/lib/coord/radar/Radar.js
  var Radar = function() {
    function Radar2(radarModel, ecModel, api) {
      this.dimensions = [];
      this._model = radarModel;
      this._indicatorAxes = map(radarModel.getIndicatorModels(), function(indicatorModel, idx) {
        var dim = "indicator_" + idx;
        var indicatorAxis = new IndicatorAxis_default(dim, new Interval_default());
        indicatorAxis.name = indicatorModel.get("name");
        indicatorAxis.model = indicatorModel;
        indicatorModel.axis = indicatorAxis;
        this.dimensions.push(dim);
        return indicatorAxis;
      }, this);
      this.resize(radarModel, api);
    }
    Radar2.prototype.getIndicatorAxes = function() {
      return this._indicatorAxes;
    };
    Radar2.prototype.dataToPoint = function(value, indicatorIndex) {
      var indicatorAxis = this._indicatorAxes[indicatorIndex];
      return this.coordToPoint(indicatorAxis.dataToCoord(value), indicatorIndex);
    };
    Radar2.prototype.coordToPoint = function(coord, indicatorIndex) {
      var indicatorAxis = this._indicatorAxes[indicatorIndex];
      var angle = indicatorAxis.angle;
      var x = this.cx + coord * Math.cos(angle);
      var y = this.cy - coord * Math.sin(angle);
      return [x, y];
    };
    Radar2.prototype.pointToData = function(pt) {
      var dx = pt[0] - this.cx;
      var dy = pt[1] - this.cy;
      var radius = Math.sqrt(dx * dx + dy * dy);
      dx /= radius;
      dy /= radius;
      var radian = Math.atan2(-dy, dx);
      var minRadianDiff = Infinity;
      var closestAxis;
      var closestAxisIdx = -1;
      for (var i = 0; i < this._indicatorAxes.length; i++) {
        var indicatorAxis = this._indicatorAxes[i];
        var diff = Math.abs(radian - indicatorAxis.angle);
        if (diff < minRadianDiff) {
          closestAxis = indicatorAxis;
          closestAxisIdx = i;
          minRadianDiff = diff;
        }
      }
      return [closestAxisIdx, +(closestAxis && closestAxis.coordToData(radius))];
    };
    Radar2.prototype.resize = function(radarModel, api) {
      var center3 = radarModel.get("center");
      var viewWidth = api.getWidth();
      var viewHeight = api.getHeight();
      var viewSize = Math.min(viewWidth, viewHeight) / 2;
      this.cx = parsePercent2(center3[0], viewWidth);
      this.cy = parsePercent2(center3[1], viewHeight);
      this.startAngle = radarModel.get("startAngle") * Math.PI / 180;
      var radius = radarModel.get("radius");
      if (isString(radius) || isNumber(radius)) {
        radius = [0, radius];
      }
      this.r0 = parsePercent2(radius[0], viewSize);
      this.r = parsePercent2(radius[1], viewSize);
      each(this._indicatorAxes, function(indicatorAxis, idx) {
        indicatorAxis.setExtent(this.r0, this.r);
        var angle = this.startAngle + idx * Math.PI * 2 / this._indicatorAxes.length;
        angle = Math.atan2(Math.sin(angle), Math.cos(angle));
        indicatorAxis.angle = angle;
      }, this);
    };
    Radar2.prototype.update = function(ecModel, api) {
      var indicatorAxes = this._indicatorAxes;
      var radarModel = this._model;
      each(indicatorAxes, function(indicatorAxis) {
        indicatorAxis.scale.setExtent(Infinity, -Infinity);
      });
      ecModel.eachSeriesByType("radar", function(radarSeries, idx) {
        if (radarSeries.get("coordinateSystem") !== "radar" || ecModel.getComponent("radar", radarSeries.get("radarIndex")) !== radarModel) {
          return;
        }
        var data = radarSeries.getData();
        each(indicatorAxes, function(indicatorAxis) {
          indicatorAxis.scale.unionExtentFromData(data, data.mapDimension(indicatorAxis.dim));
        });
      }, this);
      var splitNumber = radarModel.get("splitNumber");
      var dummyScale = new Interval_default();
      dummyScale.setExtent(0, splitNumber);
      dummyScale.setInterval(1);
      each(indicatorAxes, function(indicatorAxis, idx) {
        alignScaleTicks(indicatorAxis.scale, indicatorAxis.model, dummyScale);
      });
    };
    Radar2.prototype.convertToPixel = function(ecModel, finder, value) {
      console.warn("Not implemented.");
      return null;
    };
    Radar2.prototype.convertFromPixel = function(ecModel, finder, pixel) {
      console.warn("Not implemented.");
      return null;
    };
    Radar2.prototype.containPoint = function(point) {
      console.warn("Not implemented.");
      return false;
    };
    Radar2.create = function(ecModel, api) {
      var radarList = [];
      ecModel.eachComponent("radar", function(radarModel) {
        var radar = new Radar2(radarModel, ecModel, api);
        radarList.push(radar);
        radarModel.coordinateSystem = radar;
      });
      ecModel.eachSeriesByType("radar", function(radarSeries) {
        if (radarSeries.get("coordinateSystem") === "radar") {
          radarSeries.coordinateSystem = radarList[radarSeries.get("radarIndex") || 0];
        }
      });
      return radarList;
    };
    Radar2.dimensions = [];
    return Radar2;
  }();
  var Radar_default = Radar;

  // node_modules/echarts/lib/component/radar/install.js
  function install8(registers) {
    registers.registerCoordinateSystem("radar", Radar_default);
    registers.registerComponentModel(RadarModel_default);
    registers.registerComponentView(RadarView_default2);
    registers.registerVisual({
      seriesType: "radar",
      reset: function(seriesModel) {
        var data = seriesModel.getData();
        data.each(function(idx) {
          data.setItemVisual(idx, "legendIcon", "roundRect");
        });
        data.setVisual("legendIcon", "roundRect");
      }
    });
  }

  // node_modules/echarts/lib/chart/radar/install.js
  function install9(registers) {
    use(install8);
    registers.registerChartView(RadarView_default);
    registers.registerSeriesModel(RadarSeries_default);
    registers.registerLayout(radarLayout);
    registers.registerProcessor(dataFilter("radar"));
    registers.registerPreprocessor(radarBackwardCompat);
  }

  // node_modules/echarts/lib/component/helper/interactionMutex.js
  var ATTR = "\0_ec_interaction_mutex";
  function take(zr, resourceKey, userKey) {
    var store = getStore(zr);
    store[resourceKey] = userKey;
  }
  function release(zr, resourceKey, userKey) {
    var store = getStore(zr);
    var uKey = store[resourceKey];
    if (uKey === userKey) {
      store[resourceKey] = null;
    }
  }
  function isTaken(zr, resourceKey) {
    return !!getStore(zr)[resourceKey];
  }
  function getStore(zr) {
    return zr[ATTR] || (zr[ATTR] = {});
  }
  registerAction({
    type: "takeGlobalCursor",
    event: "globalCursorTaken",
    update: "update"
  }, noop);

  // node_modules/echarts/lib/component/helper/RoamController.js
  var RoamController = function(_super) {
    __extends(RoamController2, _super);
    function RoamController2(zr) {
      var _this = _super.call(this) || this;
      _this._zr = zr;
      var mousedownHandler = bind(_this._mousedownHandler, _this);
      var mousemoveHandler = bind(_this._mousemoveHandler, _this);
      var mouseupHandler = bind(_this._mouseupHandler, _this);
      var mousewheelHandler = bind(_this._mousewheelHandler, _this);
      var pinchHandler = bind(_this._pinchHandler, _this);
      _this.enable = function(controlType, opt) {
        this.disable();
        this._opt = defaults(clone(opt) || {}, {
          zoomOnMouseWheel: true,
          moveOnMouseMove: true,
          moveOnMouseWheel: false,
          preventDefaultMouseMove: true
        });
        if (controlType == null) {
          controlType = true;
        }
        if (controlType === true || controlType === "move" || controlType === "pan") {
          zr.on("mousedown", mousedownHandler);
          zr.on("mousemove", mousemoveHandler);
          zr.on("mouseup", mouseupHandler);
        }
        if (controlType === true || controlType === "scale" || controlType === "zoom") {
          zr.on("mousewheel", mousewheelHandler);
          zr.on("pinch", pinchHandler);
        }
      };
      _this.disable = function() {
        zr.off("mousedown", mousedownHandler);
        zr.off("mousemove", mousemoveHandler);
        zr.off("mouseup", mouseupHandler);
        zr.off("mousewheel", mousewheelHandler);
        zr.off("pinch", pinchHandler);
      };
      return _this;
    }
    RoamController2.prototype.isDragging = function() {
      return this._dragging;
    };
    RoamController2.prototype.isPinching = function() {
      return this._pinching;
    };
    RoamController2.prototype.setPointerChecker = function(pointerChecker) {
      this.pointerChecker = pointerChecker;
    };
    RoamController2.prototype.dispose = function() {
      this.disable();
    };
    RoamController2.prototype._mousedownHandler = function(e2) {
      if (isMiddleOrRightButtonOnMouseUpDown(e2) || e2.target && e2.target.draggable) {
        return;
      }
      var x = e2.offsetX;
      var y = e2.offsetY;
      if (this.pointerChecker && this.pointerChecker(e2, x, y)) {
        this._x = x;
        this._y = y;
        this._dragging = true;
      }
    };
    RoamController2.prototype._mousemoveHandler = function(e2) {
      if (!this._dragging || !isAvailableBehavior("moveOnMouseMove", e2, this._opt) || e2.gestureEvent === "pinch" || isTaken(this._zr, "globalPan")) {
        return;
      }
      var x = e2.offsetX;
      var y = e2.offsetY;
      var oldX = this._x;
      var oldY = this._y;
      var dx = x - oldX;
      var dy = y - oldY;
      this._x = x;
      this._y = y;
      this._opt.preventDefaultMouseMove && stop(e2.event);
      trigger(this, "pan", "moveOnMouseMove", e2, {
        dx,
        dy,
        oldX,
        oldY,
        newX: x,
        newY: y,
        isAvailableBehavior: null
      });
    };
    RoamController2.prototype._mouseupHandler = function(e2) {
      if (!isMiddleOrRightButtonOnMouseUpDown(e2)) {
        this._dragging = false;
      }
    };
    RoamController2.prototype._mousewheelHandler = function(e2) {
      var shouldZoom = isAvailableBehavior("zoomOnMouseWheel", e2, this._opt);
      var shouldMove = isAvailableBehavior("moveOnMouseWheel", e2, this._opt);
      var wheelDelta = e2.wheelDelta;
      var absWheelDeltaDelta = Math.abs(wheelDelta);
      var originX = e2.offsetX;
      var originY = e2.offsetY;
      if (wheelDelta === 0 || !shouldZoom && !shouldMove) {
        return;
      }
      if (shouldZoom) {
        var factor = absWheelDeltaDelta > 3 ? 1.4 : absWheelDeltaDelta > 1 ? 1.2 : 1.1;
        var scale4 = wheelDelta > 0 ? factor : 1 / factor;
        checkPointerAndTrigger(this, "zoom", "zoomOnMouseWheel", e2, {
          scale: scale4,
          originX,
          originY,
          isAvailableBehavior: null
        });
      }
      if (shouldMove) {
        var absDelta = Math.abs(wheelDelta);
        var scrollDelta = (wheelDelta > 0 ? 1 : -1) * (absDelta > 3 ? 0.4 : absDelta > 1 ? 0.15 : 0.05);
        checkPointerAndTrigger(this, "scrollMove", "moveOnMouseWheel", e2, {
          scrollDelta,
          originX,
          originY,
          isAvailableBehavior: null
        });
      }
    };
    RoamController2.prototype._pinchHandler = function(e2) {
      if (isTaken(this._zr, "globalPan")) {
        return;
      }
      var scale4 = e2.pinchScale > 1 ? 1.1 : 1 / 1.1;
      checkPointerAndTrigger(this, "zoom", null, e2, {
        scale: scale4,
        originX: e2.pinchX,
        originY: e2.pinchY,
        isAvailableBehavior: null
      });
    };
    return RoamController2;
  }(Eventful_default);
  function checkPointerAndTrigger(controller, eventName, behaviorToCheck, e2, contollerEvent) {
    if (controller.pointerChecker && controller.pointerChecker(e2, contollerEvent.originX, contollerEvent.originY)) {
      stop(e2.event);
      trigger(controller, eventName, behaviorToCheck, e2, contollerEvent);
    }
  }
  function trigger(controller, eventName, behaviorToCheck, e2, contollerEvent) {
    contollerEvent.isAvailableBehavior = bind(isAvailableBehavior, null, behaviorToCheck, e2);
    controller.trigger(eventName, contollerEvent);
  }
  function isAvailableBehavior(behaviorToCheck, e2, settings) {
    var setting = settings[behaviorToCheck];
    return !behaviorToCheck || setting && (!isString(setting) || e2.event[setting + "Key"]);
  }
  var RoamController_default = RoamController;

  // node_modules/echarts/lib/component/helper/roamHelper.js
  function updateViewOnPan(controllerHost, dx, dy) {
    var target = controllerHost.target;
    target.x += dx;
    target.y += dy;
    target.dirty();
  }
  function updateViewOnZoom(controllerHost, zoomDelta, zoomX, zoomY) {
    var target = controllerHost.target;
    var zoomLimit = controllerHost.zoomLimit;
    var newZoom = controllerHost.zoom = controllerHost.zoom || 1;
    newZoom *= zoomDelta;
    if (zoomLimit) {
      var zoomMin = zoomLimit.min || 0;
      var zoomMax = zoomLimit.max || Infinity;
      newZoom = Math.max(Math.min(zoomMax, newZoom), zoomMin);
    }
    var zoomScale = newZoom / controllerHost.zoom;
    controllerHost.zoom = newZoom;
    target.x -= (zoomX - target.x) * (zoomScale - 1);
    target.y -= (zoomY - target.y) * (zoomScale - 1);
    target.scaleX *= zoomScale;
    target.scaleY *= zoomScale;
    target.dirty();
  }

  // node_modules/echarts/lib/component/helper/cursorHelper.js
  var IRRELEVANT_EXCLUDES = {
    "axisPointer": 1,
    "tooltip": 1,
    "brush": 1
  };
  function onIrrelevantElement(e2, api, targetCoordSysModel) {
    var model = api.getComponentByElement(e2.topTarget);
    var coordSys = model && model.coordinateSystem;
    return model && model !== targetCoordSysModel && !IRRELEVANT_EXCLUDES.hasOwnProperty(model.mainType) && coordSys && coordSys.model !== targetCoordSysModel;
  }

  // node_modules/zrender/lib/tool/parseXML.js
  function parseXML(svg) {
    if (isString(svg)) {
      var parser = new DOMParser();
      svg = parser.parseFromString(svg, "text/xml");
    }
    var svgNode = svg;
    if (svgNode.nodeType === 9) {
      svgNode = svgNode.firstChild;
    }
    while (svgNode.nodeName.toLowerCase() !== "svg" || svgNode.nodeType !== 1) {
      svgNode = svgNode.nextSibling;
    }
    return svgNode;
  }

  // node_modules/zrender/lib/tool/parseSVG.js
  var nodeParsers;
  var INHERITABLE_STYLE_ATTRIBUTES_MAP = {
    "fill": "fill",
    "stroke": "stroke",
    "stroke-width": "lineWidth",
    "opacity": "opacity",
    "fill-opacity": "fillOpacity",
    "stroke-opacity": "strokeOpacity",
    "stroke-dasharray": "lineDash",
    "stroke-dashoffset": "lineDashOffset",
    "stroke-linecap": "lineCap",
    "stroke-linejoin": "lineJoin",
    "stroke-miterlimit": "miterLimit",
    "font-family": "fontFamily",
    "font-size": "fontSize",
    "font-style": "fontStyle",
    "font-weight": "fontWeight",
    "text-anchor": "textAlign",
    "visibility": "visibility",
    "display": "display"
  };
  var INHERITABLE_STYLE_ATTRIBUTES_MAP_KEYS = keys(INHERITABLE_STYLE_ATTRIBUTES_MAP);
  var SELF_STYLE_ATTRIBUTES_MAP = {
    "alignment-baseline": "textBaseline",
    "stop-color": "stopColor"
  };
  var SELF_STYLE_ATTRIBUTES_MAP_KEYS = keys(SELF_STYLE_ATTRIBUTES_MAP);
  var SVGParser = function() {
    function SVGParser2() {
      this._defs = {};
      this._root = null;
    }
    SVGParser2.prototype.parse = function(xml, opt) {
      opt = opt || {};
      var svg = parseXML(xml);
      if (true) {
        if (!svg) {
          throw new Error("Illegal svg");
        }
      }
      this._defsUsePending = [];
      var root = new Group_default();
      this._root = root;
      var named = [];
      var viewBox = svg.getAttribute("viewBox") || "";
      var width = parseFloat(svg.getAttribute("width") || opt.width);
      var height = parseFloat(svg.getAttribute("height") || opt.height);
      isNaN(width) && (width = null);
      isNaN(height) && (height = null);
      parseAttributes(svg, root, null, true, false);
      var child = svg.firstChild;
      while (child) {
        this._parseNode(child, root, named, null, false, false);
        child = child.nextSibling;
      }
      applyDefs(this._defs, this._defsUsePending);
      this._defsUsePending = [];
      var viewBoxRect;
      var viewBoxTransform;
      if (viewBox) {
        var viewBoxArr = splitNumberSequence(viewBox);
        if (viewBoxArr.length >= 4) {
          viewBoxRect = {
            x: parseFloat(viewBoxArr[0] || 0),
            y: parseFloat(viewBoxArr[1] || 0),
            width: parseFloat(viewBoxArr[2]),
            height: parseFloat(viewBoxArr[3])
          };
        }
      }
      if (viewBoxRect && width != null && height != null) {
        viewBoxTransform = makeViewBoxTransform(viewBoxRect, { x: 0, y: 0, width, height });
        if (!opt.ignoreViewBox) {
          var elRoot = root;
          root = new Group_default();
          root.add(elRoot);
          elRoot.scaleX = elRoot.scaleY = viewBoxTransform.scale;
          elRoot.x = viewBoxTransform.x;
          elRoot.y = viewBoxTransform.y;
        }
      }
      if (!opt.ignoreRootClip && width != null && height != null) {
        root.setClipPath(new Rect_default({
          shape: { x: 0, y: 0, width, height }
        }));
      }
      return {
        root,
        width,
        height,
        viewBoxRect,
        viewBoxTransform,
        named
      };
    };
    SVGParser2.prototype._parseNode = function(xmlNode, parentGroup, named, namedFrom, isInDefs, isInText) {
      var nodeName = xmlNode.nodeName.toLowerCase();
      var el;
      var namedFromForSub = namedFrom;
      if (nodeName === "defs") {
        isInDefs = true;
      }
      if (nodeName === "text") {
        isInText = true;
      }
      if (nodeName === "defs" || nodeName === "switch") {
        el = parentGroup;
      } else {
        if (!isInDefs) {
          var parser_1 = nodeParsers[nodeName];
          if (parser_1 && hasOwn(nodeParsers, nodeName)) {
            el = parser_1.call(this, xmlNode, parentGroup);
            var nameAttr = xmlNode.getAttribute("name");
            if (nameAttr) {
              var newNamed = {
                name: nameAttr,
                namedFrom: null,
                svgNodeTagLower: nodeName,
                el
              };
              named.push(newNamed);
              if (nodeName === "g") {
                namedFromForSub = newNamed;
              }
            } else if (namedFrom) {
              named.push({
                name: namedFrom.name,
                namedFrom,
                svgNodeTagLower: nodeName,
                el
              });
            }
            parentGroup.add(el);
          }
        }
        var parser = paintServerParsers[nodeName];
        if (parser && hasOwn(paintServerParsers, nodeName)) {
          var def = parser.call(this, xmlNode);
          var id = xmlNode.getAttribute("id");
          if (id) {
            this._defs[id] = def;
          }
        }
      }
      if (el && el.isGroup) {
        var child = xmlNode.firstChild;
        while (child) {
          if (child.nodeType === 1) {
            this._parseNode(child, el, named, namedFromForSub, isInDefs, isInText);
          } else if (child.nodeType === 3 && isInText) {
            this._parseText(child, el);
          }
          child = child.nextSibling;
        }
      }
    };
    SVGParser2.prototype._parseText = function(xmlNode, parentGroup) {
      var text = new TSpan_default({
        style: {
          text: xmlNode.textContent
        },
        silent: true,
        x: this._textX || 0,
        y: this._textY || 0
      });
      inheritStyle(parentGroup, text);
      parseAttributes(xmlNode, text, this._defsUsePending, false, false);
      applyTextAlignment(text, parentGroup);
      var textStyle = text.style;
      var fontSize = textStyle.fontSize;
      if (fontSize && fontSize < 9) {
        textStyle.fontSize = 9;
        text.scaleX *= fontSize / 9;
        text.scaleY *= fontSize / 9;
      }
      var font = (textStyle.fontSize || textStyle.fontFamily) && [
        textStyle.fontStyle,
        textStyle.fontWeight,
        (textStyle.fontSize || 12) + "px",
        textStyle.fontFamily || "sans-serif"
      ].join(" ");
      textStyle.font = font;
      var rect = text.getBoundingRect();
      this._textX += rect.width;
      parentGroup.add(text);
      return text;
    };
    SVGParser2.internalField = function() {
      nodeParsers = {
        "g": function(xmlNode, parentGroup) {
          var g = new Group_default();
          inheritStyle(parentGroup, g);
          parseAttributes(xmlNode, g, this._defsUsePending, false, false);
          return g;
        },
        "rect": function(xmlNode, parentGroup) {
          var rect = new Rect_default();
          inheritStyle(parentGroup, rect);
          parseAttributes(xmlNode, rect, this._defsUsePending, false, false);
          rect.setShape({
            x: parseFloat(xmlNode.getAttribute("x") || "0"),
            y: parseFloat(xmlNode.getAttribute("y") || "0"),
            width: parseFloat(xmlNode.getAttribute("width") || "0"),
            height: parseFloat(xmlNode.getAttribute("height") || "0")
          });
          rect.silent = true;
          return rect;
        },
        "circle": function(xmlNode, parentGroup) {
          var circle = new Circle_default();
          inheritStyle(parentGroup, circle);
          parseAttributes(xmlNode, circle, this._defsUsePending, false, false);
          circle.setShape({
            cx: parseFloat(xmlNode.getAttribute("cx") || "0"),
            cy: parseFloat(xmlNode.getAttribute("cy") || "0"),
            r: parseFloat(xmlNode.getAttribute("r") || "0")
          });
          circle.silent = true;
          return circle;
        },
        "line": function(xmlNode, parentGroup) {
          var line = new Line_default();
          inheritStyle(parentGroup, line);
          parseAttributes(xmlNode, line, this._defsUsePending, false, false);
          line.setShape({
            x1: parseFloat(xmlNode.getAttribute("x1") || "0"),
            y1: parseFloat(xmlNode.getAttribute("y1") || "0"),
            x2: parseFloat(xmlNode.getAttribute("x2") || "0"),
            y2: parseFloat(xmlNode.getAttribute("y2") || "0")
          });
          line.silent = true;
          return line;
        },
        "ellipse": function(xmlNode, parentGroup) {
          var ellipse = new Ellipse_default();
          inheritStyle(parentGroup, ellipse);
          parseAttributes(xmlNode, ellipse, this._defsUsePending, false, false);
          ellipse.setShape({
            cx: parseFloat(xmlNode.getAttribute("cx") || "0"),
            cy: parseFloat(xmlNode.getAttribute("cy") || "0"),
            rx: parseFloat(xmlNode.getAttribute("rx") || "0"),
            ry: parseFloat(xmlNode.getAttribute("ry") || "0")
          });
          ellipse.silent = true;
          return ellipse;
        },
        "polygon": function(xmlNode, parentGroup) {
          var pointsStr = xmlNode.getAttribute("points");
          var pointsArr;
          if (pointsStr) {
            pointsArr = parsePoints(pointsStr);
          }
          var polygon = new Polygon_default({
            shape: {
              points: pointsArr || []
            },
            silent: true
          });
          inheritStyle(parentGroup, polygon);
          parseAttributes(xmlNode, polygon, this._defsUsePending, false, false);
          return polygon;
        },
        "polyline": function(xmlNode, parentGroup) {
          var pointsStr = xmlNode.getAttribute("points");
          var pointsArr;
          if (pointsStr) {
            pointsArr = parsePoints(pointsStr);
          }
          var polyline = new Polyline_default({
            shape: {
              points: pointsArr || []
            },
            silent: true
          });
          inheritStyle(parentGroup, polyline);
          parseAttributes(xmlNode, polyline, this._defsUsePending, false, false);
          return polyline;
        },
        "image": function(xmlNode, parentGroup) {
          var img = new Image_default();
          inheritStyle(parentGroup, img);
          parseAttributes(xmlNode, img, this._defsUsePending, false, false);
          img.setStyle({
            image: xmlNode.getAttribute("xlink:href") || xmlNode.getAttribute("href"),
            x: +xmlNode.getAttribute("x"),
            y: +xmlNode.getAttribute("y"),
            width: +xmlNode.getAttribute("width"),
            height: +xmlNode.getAttribute("height")
          });
          img.silent = true;
          return img;
        },
        "text": function(xmlNode, parentGroup) {
          var x = xmlNode.getAttribute("x") || "0";
          var y = xmlNode.getAttribute("y") || "0";
          var dx = xmlNode.getAttribute("dx") || "0";
          var dy = xmlNode.getAttribute("dy") || "0";
          this._textX = parseFloat(x) + parseFloat(dx);
          this._textY = parseFloat(y) + parseFloat(dy);
          var g = new Group_default();
          inheritStyle(parentGroup, g);
          parseAttributes(xmlNode, g, this._defsUsePending, false, true);
          return g;
        },
        "tspan": function(xmlNode, parentGroup) {
          var x = xmlNode.getAttribute("x");
          var y = xmlNode.getAttribute("y");
          if (x != null) {
            this._textX = parseFloat(x);
          }
          if (y != null) {
            this._textY = parseFloat(y);
          }
          var dx = xmlNode.getAttribute("dx") || "0";
          var dy = xmlNode.getAttribute("dy") || "0";
          var g = new Group_default();
          inheritStyle(parentGroup, g);
          parseAttributes(xmlNode, g, this._defsUsePending, false, true);
          this._textX += parseFloat(dx);
          this._textY += parseFloat(dy);
          return g;
        },
        "path": function(xmlNode, parentGroup) {
          var d = xmlNode.getAttribute("d") || "";
          var path = createFromString(d);
          inheritStyle(parentGroup, path);
          parseAttributes(xmlNode, path, this._defsUsePending, false, false);
          path.silent = true;
          return path;
        }
      };
    }();
    return SVGParser2;
  }();
  var paintServerParsers = {
    "lineargradient": function(xmlNode) {
      var x1 = parseInt(xmlNode.getAttribute("x1") || "0", 10);
      var y1 = parseInt(xmlNode.getAttribute("y1") || "0", 10);
      var x2 = parseInt(xmlNode.getAttribute("x2") || "10", 10);
      var y2 = parseInt(xmlNode.getAttribute("y2") || "0", 10);
      var gradient = new LinearGradient_default(x1, y1, x2, y2);
      parsePaintServerUnit(xmlNode, gradient);
      parseGradientColorStops(xmlNode, gradient);
      return gradient;
    },
    "radialgradient": function(xmlNode) {
      var cx = parseInt(xmlNode.getAttribute("cx") || "0", 10);
      var cy = parseInt(xmlNode.getAttribute("cy") || "0", 10);
      var r = parseInt(xmlNode.getAttribute("r") || "0", 10);
      var gradient = new RadialGradient_default(cx, cy, r);
      parsePaintServerUnit(xmlNode, gradient);
      parseGradientColorStops(xmlNode, gradient);
      return gradient;
    }
  };
  function parsePaintServerUnit(xmlNode, gradient) {
    var gradientUnits = xmlNode.getAttribute("gradientUnits");
    if (gradientUnits === "userSpaceOnUse") {
      gradient.global = true;
    }
  }
  function parseGradientColorStops(xmlNode, gradient) {
    var stop2 = xmlNode.firstChild;
    while (stop2) {
      if (stop2.nodeType === 1 && stop2.nodeName.toLocaleLowerCase() === "stop") {
        var offsetStr = stop2.getAttribute("offset");
        var offset = void 0;
        if (offsetStr && offsetStr.indexOf("%") > 0) {
          offset = parseInt(offsetStr, 10) / 100;
        } else if (offsetStr) {
          offset = parseFloat(offsetStr);
        } else {
          offset = 0;
        }
        var styleVals = {};
        parseInlineStyle(stop2, styleVals, styleVals);
        var stopColor = styleVals.stopColor || stop2.getAttribute("stop-color") || "#000000";
        gradient.colorStops.push({
          offset,
          color: stopColor
        });
      }
      stop2 = stop2.nextSibling;
    }
  }
  function inheritStyle(parent, child) {
    if (parent && parent.__inheritedStyle) {
      if (!child.__inheritedStyle) {
        child.__inheritedStyle = {};
      }
      defaults(child.__inheritedStyle, parent.__inheritedStyle);
    }
  }
  function parsePoints(pointsString) {
    var list = splitNumberSequence(pointsString);
    var points4 = [];
    for (var i = 0; i < list.length; i += 2) {
      var x = parseFloat(list[i]);
      var y = parseFloat(list[i + 1]);
      points4.push([x, y]);
    }
    return points4;
  }
  function parseAttributes(xmlNode, el, defsUsePending, onlyInlineStyle, isTextGroup) {
    var disp = el;
    var inheritedStyle = disp.__inheritedStyle = disp.__inheritedStyle || {};
    var selfStyle = {};
    if (xmlNode.nodeType === 1) {
      parseTransformAttribute(xmlNode, el);
      parseInlineStyle(xmlNode, inheritedStyle, selfStyle);
      if (!onlyInlineStyle) {
        parseAttributeStyle(xmlNode, inheritedStyle, selfStyle);
      }
    }
    disp.style = disp.style || {};
    if (inheritedStyle.fill != null) {
      disp.style.fill = getFillStrokeStyle(disp, "fill", inheritedStyle.fill, defsUsePending);
    }
    if (inheritedStyle.stroke != null) {
      disp.style.stroke = getFillStrokeStyle(disp, "stroke", inheritedStyle.stroke, defsUsePending);
    }
    each([
      "lineWidth",
      "opacity",
      "fillOpacity",
      "strokeOpacity",
      "miterLimit",
      "fontSize"
    ], function(propName) {
      if (inheritedStyle[propName] != null) {
        disp.style[propName] = parseFloat(inheritedStyle[propName]);
      }
    });
    each([
      "lineDashOffset",
      "lineCap",
      "lineJoin",
      "fontWeight",
      "fontFamily",
      "fontStyle",
      "textAlign"
    ], function(propName) {
      if (inheritedStyle[propName] != null) {
        disp.style[propName] = inheritedStyle[propName];
      }
    });
    if (isTextGroup) {
      disp.__selfStyle = selfStyle;
    }
    if (inheritedStyle.lineDash) {
      disp.style.lineDash = map(splitNumberSequence(inheritedStyle.lineDash), function(str) {
        return parseFloat(str);
      });
    }
    if (inheritedStyle.visibility === "hidden" || inheritedStyle.visibility === "collapse") {
      disp.invisible = true;
    }
    if (inheritedStyle.display === "none") {
      disp.ignore = true;
    }
  }
  function applyTextAlignment(text, parentGroup) {
    var parentSelfStyle = parentGroup.__selfStyle;
    if (parentSelfStyle) {
      var textBaseline = parentSelfStyle.textBaseline;
      var zrTextBaseline = textBaseline;
      if (!textBaseline || textBaseline === "auto") {
        zrTextBaseline = "alphabetic";
      } else if (textBaseline === "baseline") {
        zrTextBaseline = "alphabetic";
      } else if (textBaseline === "before-edge" || textBaseline === "text-before-edge") {
        zrTextBaseline = "top";
      } else if (textBaseline === "after-edge" || textBaseline === "text-after-edge") {
        zrTextBaseline = "bottom";
      } else if (textBaseline === "central" || textBaseline === "mathematical") {
        zrTextBaseline = "middle";
      }
      text.style.textBaseline = zrTextBaseline;
    }
    var parentInheritedStyle = parentGroup.__inheritedStyle;
    if (parentInheritedStyle) {
      var textAlign = parentInheritedStyle.textAlign;
      var zrTextAlign = textAlign;
      if (textAlign) {
        if (textAlign === "middle") {
          zrTextAlign = "center";
        }
        text.style.textAlign = zrTextAlign;
      }
    }
  }
  var urlRegex = /^url\(\s*#(.*?)\)/;
  function getFillStrokeStyle(el, method, str, defsUsePending) {
    var urlMatch = str && str.match(urlRegex);
    if (urlMatch) {
      var url = trim(urlMatch[1]);
      defsUsePending.push([el, method, url]);
      return;
    }
    if (str === "none") {
      str = null;
    }
    return str;
  }
  function applyDefs(defs, defsUsePending) {
    for (var i = 0; i < defsUsePending.length; i++) {
      var item = defsUsePending[i];
      item[0].style[item[1]] = defs[item[2]];
    }
  }
  var numberReg2 = /-?([0-9]*\.)?[0-9]+([eE]-?[0-9]+)?/g;
  function splitNumberSequence(rawStr) {
    return rawStr.match(numberReg2) || [];
  }
  var transformRegex = /(translate|scale|rotate|skewX|skewY|matrix)\(([\-\s0-9\.eE,]*)\)/g;
  var DEGREE_TO_ANGLE = Math.PI / 180;
  function parseTransformAttribute(xmlNode, node) {
    var transform2 = xmlNode.getAttribute("transform");
    if (transform2) {
      transform2 = transform2.replace(/,/g, " ");
      var transformOps_1 = [];
      var mt = null;
      transform2.replace(transformRegex, function(str, type2, value2) {
        transformOps_1.push(type2, value2);
        return "";
      });
      for (var i = transformOps_1.length - 1; i > 0; i -= 2) {
        var value = transformOps_1[i];
        var type = transformOps_1[i - 1];
        var valueArr = splitNumberSequence(value);
        mt = mt || create2();
        switch (type) {
          case "translate":
            translate(mt, mt, [parseFloat(valueArr[0]), parseFloat(valueArr[1] || "0")]);
            break;
          case "scale":
            scale2(mt, mt, [parseFloat(valueArr[0]), parseFloat(valueArr[1] || valueArr[0])]);
            break;
          case "rotate":
            rotate(mt, mt, -parseFloat(valueArr[0]) * DEGREE_TO_ANGLE);
            break;
          case "skewX":
            var sx = Math.tan(parseFloat(valueArr[0]) * DEGREE_TO_ANGLE);
            mul2(mt, [1, 0, sx, 1, 0, 0], mt);
            break;
          case "skewY":
            var sy = Math.tan(parseFloat(valueArr[0]) * DEGREE_TO_ANGLE);
            mul2(mt, [1, sy, 0, 1, 0, 0], mt);
            break;
          case "matrix":
            mt[0] = parseFloat(valueArr[0]);
            mt[1] = parseFloat(valueArr[1]);
            mt[2] = parseFloat(valueArr[2]);
            mt[3] = parseFloat(valueArr[3]);
            mt[4] = parseFloat(valueArr[4]);
            mt[5] = parseFloat(valueArr[5]);
            break;
        }
      }
      node.setLocalTransform(mt);
    }
  }
  var styleRegex = /([^\s:;]+)\s*:\s*([^:;]+)/g;
  function parseInlineStyle(xmlNode, inheritableStyleResult, selfStyleResult) {
    var style = xmlNode.getAttribute("style");
    if (!style) {
      return;
    }
    styleRegex.lastIndex = 0;
    var styleRegResult;
    while ((styleRegResult = styleRegex.exec(style)) != null) {
      var svgStlAttr = styleRegResult[1];
      var zrInheritableStlAttr = hasOwn(INHERITABLE_STYLE_ATTRIBUTES_MAP, svgStlAttr) ? INHERITABLE_STYLE_ATTRIBUTES_MAP[svgStlAttr] : null;
      if (zrInheritableStlAttr) {
        inheritableStyleResult[zrInheritableStlAttr] = styleRegResult[2];
      }
      var zrSelfStlAttr = hasOwn(SELF_STYLE_ATTRIBUTES_MAP, svgStlAttr) ? SELF_STYLE_ATTRIBUTES_MAP[svgStlAttr] : null;
      if (zrSelfStlAttr) {
        selfStyleResult[zrSelfStlAttr] = styleRegResult[2];
      }
    }
  }
  function parseAttributeStyle(xmlNode, inheritableStyleResult, selfStyleResult) {
    for (var i = 0; i < INHERITABLE_STYLE_ATTRIBUTES_MAP_KEYS.length; i++) {
      var svgAttrName = INHERITABLE_STYLE_ATTRIBUTES_MAP_KEYS[i];
      var attrValue = xmlNode.getAttribute(svgAttrName);
      if (attrValue != null) {
        inheritableStyleResult[INHERITABLE_STYLE_ATTRIBUTES_MAP[svgAttrName]] = attrValue;
      }
    }
    for (var i = 0; i < SELF_STYLE_ATTRIBUTES_MAP_KEYS.length; i++) {
      var svgAttrName = SELF_STYLE_ATTRIBUTES_MAP_KEYS[i];
      var attrValue = xmlNode.getAttribute(svgAttrName);
      if (attrValue != null) {
        selfStyleResult[SELF_STYLE_ATTRIBUTES_MAP[svgAttrName]] = attrValue;
      }
    }
  }
  function makeViewBoxTransform(viewBoxRect, boundingRect) {
    var scaleX = boundingRect.width / viewBoxRect.width;
    var scaleY = boundingRect.height / viewBoxRect.height;
    var scale4 = Math.min(scaleX, scaleY);
    return {
      scale: scale4,
      x: -(viewBoxRect.x + viewBoxRect.width / 2) * scale4 + (boundingRect.x + boundingRect.width / 2),
      y: -(viewBoxRect.y + viewBoxRect.height / 2) * scale4 + (boundingRect.y + boundingRect.height / 2)
    };
  }
  function parseSVG(xml, opt) {
    var parser = new SVGParser();
    return parser.parse(xml, opt);
  }

  // node_modules/echarts/lib/coord/geo/GeoSVGResource.js
  var REGION_AVAILABLE_SVG_TAG_MAP = createHashMap([
    "rect",
    "circle",
    "line",
    "ellipse",
    "polygon",
    "polyline",
    "path",
    "text",
    "tspan",
    "g"
  ]);
  var GeoSVGResource = function() {
    function GeoSVGResource2(mapName, svg) {
      this.type = "geoSVG";
      this._usedGraphicMap = createHashMap();
      this._freedGraphics = [];
      this._mapName = mapName;
      this._parsedXML = parseXML(svg);
    }
    GeoSVGResource2.prototype.load = function() {
      var firstGraphic = this._firstGraphic;
      if (!firstGraphic) {
        firstGraphic = this._firstGraphic = this._buildGraphic(this._parsedXML);
        this._freedGraphics.push(firstGraphic);
        this._boundingRect = this._firstGraphic.boundingRect.clone();
        var _a2 = createRegions(firstGraphic.named), regions = _a2.regions, regionsMap = _a2.regionsMap;
        this._regions = regions;
        this._regionsMap = regionsMap;
      }
      return {
        boundingRect: this._boundingRect,
        regions: this._regions,
        regionsMap: this._regionsMap
      };
    };
    GeoSVGResource2.prototype._buildGraphic = function(svgXML) {
      var result;
      var rootFromParse;
      try {
        result = svgXML && parseSVG(svgXML, {
          ignoreViewBox: true,
          ignoreRootClip: true
        }) || {};
        rootFromParse = result.root;
        assert(rootFromParse != null);
      } catch (e2) {
        throw new Error("Invalid svg format\n" + e2.message);
      }
      var root = new Group_default();
      root.add(rootFromParse);
      root.isGeoSVGGraphicRoot = true;
      var svgWidth = result.width;
      var svgHeight = result.height;
      var viewBoxRect = result.viewBoxRect;
      var boundingRect = this._boundingRect;
      if (!boundingRect) {
        var bRectX = void 0;
        var bRectY = void 0;
        var bRectWidth = void 0;
        var bRectHeight = void 0;
        if (svgWidth != null) {
          bRectX = 0;
          bRectWidth = svgWidth;
        } else if (viewBoxRect) {
          bRectX = viewBoxRect.x;
          bRectWidth = viewBoxRect.width;
        }
        if (svgHeight != null) {
          bRectY = 0;
          bRectHeight = svgHeight;
        } else if (viewBoxRect) {
          bRectY = viewBoxRect.y;
          bRectHeight = viewBoxRect.height;
        }
        if (bRectX == null || bRectY == null) {
          var calculatedBoundingRect = rootFromParse.getBoundingRect();
          if (bRectX == null) {
            bRectX = calculatedBoundingRect.x;
            bRectWidth = calculatedBoundingRect.width;
          }
          if (bRectY == null) {
            bRectY = calculatedBoundingRect.y;
            bRectHeight = calculatedBoundingRect.height;
          }
        }
        boundingRect = this._boundingRect = new BoundingRect_default(bRectX, bRectY, bRectWidth, bRectHeight);
      }
      if (viewBoxRect) {
        var viewBoxTransform = makeViewBoxTransform(viewBoxRect, boundingRect);
        rootFromParse.scaleX = rootFromParse.scaleY = viewBoxTransform.scale;
        rootFromParse.x = viewBoxTransform.x;
        rootFromParse.y = viewBoxTransform.y;
      }
      root.setClipPath(new Rect_default({
        shape: boundingRect.plain()
      }));
      var named = [];
      each(result.named, function(namedItem) {
        if (REGION_AVAILABLE_SVG_TAG_MAP.get(namedItem.svgNodeTagLower) != null) {
          named.push(namedItem);
          setSilent(namedItem.el);
        }
      });
      return {
        root,
        boundingRect,
        named
      };
    };
    GeoSVGResource2.prototype.useGraphic = function(hostKey) {
      var usedRootMap = this._usedGraphicMap;
      var svgGraphic = usedRootMap.get(hostKey);
      if (svgGraphic) {
        return svgGraphic;
      }
      svgGraphic = this._freedGraphics.pop() || this._buildGraphic(this._parsedXML);
      usedRootMap.set(hostKey, svgGraphic);
      return svgGraphic;
    };
    GeoSVGResource2.prototype.freeGraphic = function(hostKey) {
      var usedRootMap = this._usedGraphicMap;
      var svgGraphic = usedRootMap.get(hostKey);
      if (svgGraphic) {
        usedRootMap.removeKey(hostKey);
        this._freedGraphics.push(svgGraphic);
      }
    };
    return GeoSVGResource2;
  }();
  function setSilent(el) {
    el.silent = false;
    if (el.isGroup) {
      el.traverse(function(child) {
        child.silent = false;
      });
    }
  }
  function createRegions(named) {
    var regions = [];
    var regionsMap = createHashMap();
    each(named, function(namedItem) {
      if (namedItem.namedFrom != null) {
        return;
      }
      var region = new GeoSVGRegion(namedItem.name, namedItem.el);
      regions.push(region);
      regionsMap.set(namedItem.name, region);
    });
    return {
      regions,
      regionsMap
    };
  }

  // node_modules/echarts/lib/coord/geo/fix/nanhai.js
  var geoCoord = [126, 25];
  var nanhaiName = "南海诸岛";
  var points2 = [[[0, 3.5], [7, 11.2], [15, 11.9], [30, 7], [42, 0.7], [52, 0.7], [56, 7.7], [59, 0.7], [64, 0.7], [64, 0], [5, 0], [0, 3.5]], [[13, 16.1], [19, 14.7], [16, 21.7], [11, 23.1], [13, 16.1]], [[12, 32.2], [14, 38.5], [15, 38.5], [13, 32.2], [12, 32.2]], [[16, 47.6], [12, 53.2], [13, 53.2], [18, 47.6], [16, 47.6]], [[6, 64.4], [8, 70], [9, 70], [8, 64.4], [6, 64.4]], [[23, 82.6], [29, 79.8], [30, 79.8], [25, 82.6], [23, 82.6]], [[37, 70.7], [43, 62.3], [44, 62.3], [39, 70.7], [37, 70.7]], [[48, 51.1], [51, 45.5], [53, 45.5], [50, 51.1], [48, 51.1]], [[51, 35], [51, 28.7], [53, 28.7], [53, 35], [51, 35]], [[52, 22.4], [55, 17.5], [56, 17.5], [53, 22.4], [52, 22.4]], [[58, 12.6], [62, 7], [63, 7], [60, 12.6], [58, 12.6]], [[0, 3.5], [0, 93.1], [64, 93.1], [64, 0], [63, 0], [63, 92.4], [1, 92.4], [1, 3.5], [0, 3.5]]];
  for (i = 0; i < points2.length; i++) {
    for (k = 0; k < points2[i].length; k++) {
      points2[i][k][0] /= 10.5;
      points2[i][k][1] /= -10.5 / 0.75;
      points2[i][k][0] += geoCoord[0];
      points2[i][k][1] += geoCoord[1];
    }
  }
  var k;
  var i;
  function fixNanhai(mapType, regions) {
    if (mapType === "china") {
      for (var i = 0; i < regions.length; i++) {
        if (regions[i].name === nanhaiName) {
          return;
        }
      }
      regions.push(new GeoJSONRegion(nanhaiName, map(points2, function(exterior) {
        return {
          type: "polygon",
          exterior
        };
      }), geoCoord));
    }
  }

  // node_modules/echarts/lib/coord/geo/fix/textCoord.js
  var coordsOffsetMap = {
    "南海诸岛": [32, 80],
    "广东": [0, -10],
    "香港": [10, 5],
    "澳门": [-10, 10],
    "天津": [5, 5]
  };
  function fixTextCoords(mapType, region) {
    if (mapType === "china") {
      var coordFix = coordsOffsetMap[region.name];
      if (coordFix) {
        var cp = region.getCenter();
        cp[0] += coordFix[0] / 10.5;
        cp[1] += -coordFix[1] / (10.5 / 0.75);
        region.setCenter(cp);
      }
    }
  }

  // node_modules/echarts/lib/coord/geo/fix/diaoyuIsland.js
  var points3 = [[[123.45165252685547, 25.73527164402261], [123.49731445312499, 25.73527164402261], [123.49731445312499, 25.750734064600884], [123.45165252685547, 25.750734064600884], [123.45165252685547, 25.73527164402261]]];
  function fixDiaoyuIsland(mapType, region) {
    if (mapType === "china" && region.name === "台湾") {
      region.geometries.push({
        type: "polygon",
        exterior: points3[0]
      });
    }
  }

  // node_modules/echarts/lib/coord/geo/GeoJSONResource.js
  var DEFAULT_NAME_PROPERTY = "name";
  var GeoJSONResource = function() {
    function GeoJSONResource2(mapName, geoJSON, specialAreas) {
      this.type = "geoJSON";
      this._parsedMap = createHashMap();
      this._mapName = mapName;
      this._specialAreas = specialAreas;
      this._geoJSON = parseInput(geoJSON);
    }
    GeoJSONResource2.prototype.load = function(nameMap, nameProperty) {
      nameProperty = nameProperty || DEFAULT_NAME_PROPERTY;
      var parsed = this._parsedMap.get(nameProperty);
      if (!parsed) {
        var rawRegions = this._parseToRegions(nameProperty);
        parsed = this._parsedMap.set(nameProperty, {
          regions: rawRegions,
          boundingRect: calculateBoundingRect(rawRegions)
        });
      }
      var regionsMap = createHashMap();
      var finalRegions = [];
      each(parsed.regions, function(region) {
        var regionName = region.name;
        if (nameMap && hasOwn(nameMap, regionName)) {
          region = region.cloneShallow(regionName = nameMap[regionName]);
        }
        finalRegions.push(region);
        regionsMap.set(regionName, region);
      });
      return {
        regions: finalRegions,
        boundingRect: parsed.boundingRect || new BoundingRect_default(0, 0, 0, 0),
        regionsMap
      };
    };
    GeoJSONResource2.prototype._parseToRegions = function(nameProperty) {
      var mapName = this._mapName;
      var geoJSON = this._geoJSON;
      var rawRegions;
      try {
        rawRegions = geoJSON ? parseGeoJSON(geoJSON, nameProperty) : [];
      } catch (e2) {
        throw new Error("Invalid geoJson format\n" + e2.message);
      }
      fixNanhai(mapName, rawRegions);
      each(rawRegions, function(region) {
        var regionName = region.name;
        fixTextCoords(mapName, region);
        fixDiaoyuIsland(mapName, region);
        var specialArea = this._specialAreas && this._specialAreas[regionName];
        if (specialArea) {
          region.transformTo(specialArea.left, specialArea.top, specialArea.width, specialArea.height);
        }
      }, this);
      return rawRegions;
    };
    GeoJSONResource2.prototype.getMapForUser = function() {
      return {
        geoJson: this._geoJSON,
        geoJSON: this._geoJSON,
        specialAreas: this._specialAreas
      };
    };
    return GeoJSONResource2;
  }();
  function calculateBoundingRect(regions) {
    var rect;
    for (var i = 0; i < regions.length; i++) {
      var regionRect = regions[i].getBoundingRect();
      rect = rect || regionRect.clone();
      rect.union(regionRect);
    }
    return rect;
  }
  function parseInput(source) {
    return !isString(source) ? source : typeof JSON !== "undefined" && JSON.parse ? JSON.parse(source) : new Function("return (" + source + ");")();
  }

  // node_modules/echarts/lib/coord/geo/geoSourceManager.js
  var storage = createHashMap();
  var geoSourceManager_default = {
    registerMap: function(mapName, rawDef, rawSpecialAreas) {
      if (rawDef.svg) {
        var resource = new GeoSVGResource(mapName, rawDef.svg);
        storage.set(mapName, resource);
      } else {
        var geoJSON = rawDef.geoJson || rawDef.geoJSON;
        if (geoJSON && !rawDef.features) {
          rawSpecialAreas = rawDef.specialAreas;
        } else {
          geoJSON = rawDef;
        }
        var resource = new GeoJSONResource(mapName, geoJSON, rawSpecialAreas);
        storage.set(mapName, resource);
      }
    },
    getGeoResource: function(mapName) {
      return storage.get(mapName);
    },
    getMapForUser: function(mapName) {
      var resource = storage.get(mapName);
      return resource && resource.type === "geoJSON" && resource.getMapForUser();
    },
    load: function(mapName, nameMap, nameProperty) {
      var resource = storage.get(mapName);
      if (!resource) {
        if (true) {
          console.error("Map " + mapName + " not exists. The GeoJSON of the map must be provided.");
        }
        return;
      }
      return resource.load(nameMap, nameProperty);
    }
  };

  // node_modules/echarts/lib/component/helper/MapDraw.js
  var OPTION_STYLE_ENABLED_TAGS = ["rect", "circle", "line", "ellipse", "polygon", "polyline", "path"];
  var OPTION_STYLE_ENABLED_TAG_MAP = createHashMap(OPTION_STYLE_ENABLED_TAGS);
  var STATE_TRIGGER_TAG_MAP = createHashMap(OPTION_STYLE_ENABLED_TAGS.concat(["g"]));
  var LABEL_HOST_MAP = createHashMap(OPTION_STYLE_ENABLED_TAGS.concat(["g"]));
  var mapLabelRaw = makeInner();
  function getFixedItemStyle(model) {
    var itemStyle = model.getItemStyle();
    var areaColor = model.get("areaColor");
    if (areaColor != null) {
      itemStyle.fill = areaColor;
    }
    return itemStyle;
  }
  function fixLineStyle(styleHost) {
    var style = styleHost.style;
    if (style) {
      style.stroke = style.stroke || style.fill;
      style.fill = null;
    }
  }
  var MapDraw = function() {
    function MapDraw2(api) {
      var group = new Group_default();
      this.uid = getUID("ec_map_draw");
      this._controller = new RoamController_default(api.getZr());
      this._controllerHost = {
        target: group
      };
      this.group = group;
      group.add(this._regionsGroup = new Group_default());
      group.add(this._svgGroup = new Group_default());
    }
    MapDraw2.prototype.draw = function(mapOrGeoModel, ecModel, api, fromView, payload) {
      var isGeo = mapOrGeoModel.mainType === "geo";
      var data = mapOrGeoModel.getData && mapOrGeoModel.getData();
      isGeo && ecModel.eachComponent({
        mainType: "series",
        subType: "map"
      }, function(mapSeries) {
        if (!data && mapSeries.getHostGeoModel() === mapOrGeoModel) {
          data = mapSeries.getData();
        }
      });
      var geo = mapOrGeoModel.coordinateSystem;
      var regionsGroup = this._regionsGroup;
      var group = this.group;
      var transformInfo = geo.getTransformInfo();
      var transformInfoRaw = transformInfo.raw;
      var transformInfoRoam = transformInfo.roam;
      var isFirstDraw = !regionsGroup.childAt(0) || payload;
      if (isFirstDraw) {
        group.x = transformInfoRoam.x;
        group.y = transformInfoRoam.y;
        group.scaleX = transformInfoRoam.scaleX;
        group.scaleY = transformInfoRoam.scaleY;
        group.dirty();
      } else {
        updateProps(group, transformInfoRoam, mapOrGeoModel);
      }
      var isVisualEncodedByVisualMap = data && data.getVisual("visualMeta") && data.getVisual("visualMeta").length > 0;
      var viewBuildCtx = {
        api,
        geo,
        mapOrGeoModel,
        data,
        isVisualEncodedByVisualMap,
        isGeo,
        transformInfoRaw
      };
      if (geo.resourceType === "geoJSON") {
        this._buildGeoJSON(viewBuildCtx);
      } else if (geo.resourceType === "geoSVG") {
        this._buildSVG(viewBuildCtx);
      }
      this._updateController(mapOrGeoModel, ecModel, api);
      this._updateMapSelectHandler(mapOrGeoModel, regionsGroup, api, fromView);
    };
    MapDraw2.prototype._buildGeoJSON = function(viewBuildCtx) {
      var regionsGroupByName = this._regionsGroupByName = createHashMap();
      var regionsInfoByName = createHashMap();
      var regionsGroup = this._regionsGroup;
      var transformInfoRaw = viewBuildCtx.transformInfoRaw;
      var mapOrGeoModel = viewBuildCtx.mapOrGeoModel;
      var data = viewBuildCtx.data;
      var projection = viewBuildCtx.geo.projection;
      var projectionStream = projection && projection.stream;
      function transformPoint(point, project) {
        if (project) {
          point = project(point);
        }
        return point && [point[0] * transformInfoRaw.scaleX + transformInfoRaw.x, point[1] * transformInfoRaw.scaleY + transformInfoRaw.y];
      }
      ;
      function transformPolygonPoints(inPoints) {
        var outPoints = [];
        var project = !projectionStream && projection && projection.project;
        for (var i = 0; i < inPoints.length; ++i) {
          var newPt = transformPoint(inPoints[i], project);
          newPt && outPoints.push(newPt);
        }
        return outPoints;
      }
      function getPolyShape(points4) {
        return {
          shape: {
            points: transformPolygonPoints(points4)
          }
        };
      }
      regionsGroup.removeAll();
      each(viewBuildCtx.geo.regions, function(region) {
        var regionName = region.name;
        var regionGroup = regionsGroupByName.get(regionName);
        var _a2 = regionsInfoByName.get(regionName) || {}, dataIdx = _a2.dataIdx, regionModel = _a2.regionModel;
        if (!regionGroup) {
          regionGroup = regionsGroupByName.set(regionName, new Group_default());
          regionsGroup.add(regionGroup);
          dataIdx = data ? data.indexOfName(regionName) : null;
          regionModel = viewBuildCtx.isGeo ? mapOrGeoModel.getRegionModel(regionName) : data ? data.getItemModel(dataIdx) : null;
          regionsInfoByName.set(regionName, {
            dataIdx,
            regionModel
          });
        }
        var polygonSubpaths = [];
        var polylineSubpaths = [];
        each(region.geometries, function(geometry) {
          if (geometry.type === "polygon") {
            var polys = [geometry.exterior].concat(geometry.interiors || []);
            if (projectionStream) {
              polys = projectPolys(polys, projectionStream);
            }
            each(polys, function(poly) {
              polygonSubpaths.push(new Polygon_default(getPolyShape(poly)));
            });
          } else {
            var points4 = geometry.points;
            if (projectionStream) {
              points4 = projectPolys(points4, projectionStream, true);
            }
            each(points4, function(points5) {
              polylineSubpaths.push(new Polyline_default(getPolyShape(points5)));
            });
          }
        });
        var centerPt = transformPoint(region.getCenter(), projection && projection.project);
        function createCompoundPath(subpaths, isLine) {
          if (!subpaths.length) {
            return;
          }
          var compoundPath = new CompoundPath_default({
            culling: true,
            segmentIgnoreThreshold: 1,
            shape: {
              paths: subpaths
            }
          });
          regionGroup.add(compoundPath);
          applyOptionStyleForRegion(viewBuildCtx, compoundPath, dataIdx, regionModel);
          resetLabelForRegion(viewBuildCtx, compoundPath, regionName, regionModel, mapOrGeoModel, dataIdx, centerPt);
          if (isLine) {
            fixLineStyle(compoundPath);
            each(compoundPath.states, fixLineStyle);
          }
        }
        createCompoundPath(polygonSubpaths);
        createCompoundPath(polylineSubpaths, true);
      });
      regionsGroupByName.each(function(regionGroup, regionName) {
        var _a2 = regionsInfoByName.get(regionName), dataIdx = _a2.dataIdx, regionModel = _a2.regionModel;
        resetEventTriggerForRegion(viewBuildCtx, regionGroup, regionName, regionModel, mapOrGeoModel, dataIdx);
        resetTooltipForRegion(viewBuildCtx, regionGroup, regionName, regionModel, mapOrGeoModel);
        resetStateTriggerForRegion(viewBuildCtx, regionGroup, regionName, regionModel, mapOrGeoModel);
      }, this);
    };
    MapDraw2.prototype._buildSVG = function(viewBuildCtx) {
      var mapName = viewBuildCtx.geo.map;
      var transformInfoRaw = viewBuildCtx.transformInfoRaw;
      this._svgGroup.x = transformInfoRaw.x;
      this._svgGroup.y = transformInfoRaw.y;
      this._svgGroup.scaleX = transformInfoRaw.scaleX;
      this._svgGroup.scaleY = transformInfoRaw.scaleY;
      if (this._svgResourceChanged(mapName)) {
        this._freeSVG();
        this._useSVG(mapName);
      }
      var svgDispatcherMap = this._svgDispatcherMap = createHashMap();
      var focusSelf = false;
      each(this._svgGraphicRecord.named, function(namedItem) {
        var regionName = namedItem.name;
        var mapOrGeoModel = viewBuildCtx.mapOrGeoModel;
        var data = viewBuildCtx.data;
        var svgNodeTagLower = namedItem.svgNodeTagLower;
        var el = namedItem.el;
        var dataIdx = data ? data.indexOfName(regionName) : null;
        var regionModel = mapOrGeoModel.getRegionModel(regionName);
        if (OPTION_STYLE_ENABLED_TAG_MAP.get(svgNodeTagLower) != null && el instanceof Displayable_default) {
          applyOptionStyleForRegion(viewBuildCtx, el, dataIdx, regionModel);
        }
        if (el instanceof Displayable_default) {
          el.culling = true;
        }
        el.z2EmphasisLift = 0;
        if (!namedItem.namedFrom) {
          if (LABEL_HOST_MAP.get(svgNodeTagLower) != null) {
            resetLabelForRegion(viewBuildCtx, el, regionName, regionModel, mapOrGeoModel, dataIdx, null);
          }
          resetEventTriggerForRegion(viewBuildCtx, el, regionName, regionModel, mapOrGeoModel, dataIdx);
          resetTooltipForRegion(viewBuildCtx, el, regionName, regionModel, mapOrGeoModel);
          if (STATE_TRIGGER_TAG_MAP.get(svgNodeTagLower) != null) {
            var focus_1 = resetStateTriggerForRegion(viewBuildCtx, el, regionName, regionModel, mapOrGeoModel);
            if (focus_1 === "self") {
              focusSelf = true;
            }
            var els = svgDispatcherMap.get(regionName) || svgDispatcherMap.set(regionName, []);
            els.push(el);
          }
        }
      }, this);
      this._enableBlurEntireSVG(focusSelf, viewBuildCtx);
    };
    MapDraw2.prototype._enableBlurEntireSVG = function(focusSelf, viewBuildCtx) {
      if (focusSelf && viewBuildCtx.isGeo) {
        var blurStyle = viewBuildCtx.mapOrGeoModel.getModel(["blur", "itemStyle"]).getItemStyle();
        var opacity_1 = blurStyle.opacity;
        this._svgGraphicRecord.root.traverse(function(el) {
          if (!el.isGroup) {
            setDefaultStateProxy(el);
            var style = el.ensureState("blur").style || {};
            if (style.opacity == null && opacity_1 != null) {
              style.opacity = opacity_1;
            }
            el.ensureState("emphasis");
          }
        });
      }
    };
    MapDraw2.prototype.remove = function() {
      this._regionsGroup.removeAll();
      this._regionsGroupByName = null;
      this._svgGroup.removeAll();
      this._freeSVG();
      this._controller.dispose();
      this._controllerHost = null;
    };
    MapDraw2.prototype.findHighDownDispatchers = function(name, geoModel) {
      if (name == null) {
        return [];
      }
      var geo = geoModel.coordinateSystem;
      if (geo.resourceType === "geoJSON") {
        var regionsGroupByName = this._regionsGroupByName;
        if (regionsGroupByName) {
          var regionGroup = regionsGroupByName.get(name);
          return regionGroup ? [regionGroup] : [];
        }
      } else if (geo.resourceType === "geoSVG") {
        return this._svgDispatcherMap && this._svgDispatcherMap.get(name) || [];
      }
    };
    MapDraw2.prototype._svgResourceChanged = function(mapName) {
      return this._svgMapName !== mapName;
    };
    MapDraw2.prototype._useSVG = function(mapName) {
      var resource = geoSourceManager_default.getGeoResource(mapName);
      if (resource && resource.type === "geoSVG") {
        var svgGraphic = resource.useGraphic(this.uid);
        this._svgGroup.add(svgGraphic.root);
        this._svgGraphicRecord = svgGraphic;
        this._svgMapName = mapName;
      }
    };
    MapDraw2.prototype._freeSVG = function() {
      var mapName = this._svgMapName;
      if (mapName == null) {
        return;
      }
      var resource = geoSourceManager_default.getGeoResource(mapName);
      if (resource && resource.type === "geoSVG") {
        resource.freeGraphic(this.uid);
      }
      this._svgGraphicRecord = null;
      this._svgDispatcherMap = null;
      this._svgGroup.removeAll();
      this._svgMapName = null;
    };
    MapDraw2.prototype._updateController = function(mapOrGeoModel, ecModel, api) {
      var geo = mapOrGeoModel.coordinateSystem;
      var controller = this._controller;
      var controllerHost = this._controllerHost;
      controllerHost.zoomLimit = mapOrGeoModel.get("scaleLimit");
      controllerHost.zoom = geo.getZoom();
      controller.enable(mapOrGeoModel.get("roam") || false);
      var mainType = mapOrGeoModel.mainType;
      function makeActionBase() {
        var action = {
          type: "geoRoam",
          componentType: mainType
        };
        action[mainType + "Id"] = mapOrGeoModel.id;
        return action;
      }
      controller.off("pan").on("pan", function(e2) {
        this._mouseDownFlag = false;
        updateViewOnPan(controllerHost, e2.dx, e2.dy);
        api.dispatchAction(extend(makeActionBase(), {
          dx: e2.dx,
          dy: e2.dy,
          animation: {
            duration: 0
          }
        }));
      }, this);
      controller.off("zoom").on("zoom", function(e2) {
        this._mouseDownFlag = false;
        updateViewOnZoom(controllerHost, e2.scale, e2.originX, e2.originY);
        api.dispatchAction(extend(makeActionBase(), {
          zoom: e2.scale,
          originX: e2.originX,
          originY: e2.originY,
          animation: {
            duration: 0
          }
        }));
      }, this);
      controller.setPointerChecker(function(e2, x, y) {
        return geo.containPoint([x, y]) && !onIrrelevantElement(e2, api, mapOrGeoModel);
      });
    };
    MapDraw2.prototype.resetForLabelLayout = function() {
      this.group.traverse(function(el) {
        var label = el.getTextContent();
        if (label) {
          label.ignore = mapLabelRaw(label).ignore;
        }
      });
    };
    MapDraw2.prototype._updateMapSelectHandler = function(mapOrGeoModel, regionsGroup, api, fromView) {
      var mapDraw = this;
      regionsGroup.off("mousedown");
      regionsGroup.off("click");
      if (mapOrGeoModel.get("selectedMode")) {
        regionsGroup.on("mousedown", function() {
          mapDraw._mouseDownFlag = true;
        });
        regionsGroup.on("click", function(e2) {
          if (!mapDraw._mouseDownFlag) {
            return;
          }
          mapDraw._mouseDownFlag = false;
        });
      }
    };
    return MapDraw2;
  }();
  function applyOptionStyleForRegion(viewBuildCtx, el, dataIndex, regionModel) {
    var normalStyleModel = regionModel.getModel("itemStyle");
    var emphasisStyleModel = regionModel.getModel(["emphasis", "itemStyle"]);
    var blurStyleModel = regionModel.getModel(["blur", "itemStyle"]);
    var selectStyleModel = regionModel.getModel(["select", "itemStyle"]);
    var normalStyle = getFixedItemStyle(normalStyleModel);
    var emphasisStyle = getFixedItemStyle(emphasisStyleModel);
    var selectStyle = getFixedItemStyle(selectStyleModel);
    var blurStyle = getFixedItemStyle(blurStyleModel);
    var data = viewBuildCtx.data;
    if (data) {
      var style = data.getItemVisual(dataIndex, "style");
      var decal = data.getItemVisual(dataIndex, "decal");
      if (viewBuildCtx.isVisualEncodedByVisualMap && style.fill) {
        normalStyle.fill = style.fill;
      }
      if (decal) {
        normalStyle.decal = createOrUpdatePatternFromDecal(decal, viewBuildCtx.api);
      }
    }
    el.setStyle(normalStyle);
    el.style.strokeNoScale = true;
    el.ensureState("emphasis").style = emphasisStyle;
    el.ensureState("select").style = selectStyle;
    el.ensureState("blur").style = blurStyle;
    setDefaultStateProxy(el);
  }
  function resetLabelForRegion(viewBuildCtx, el, regionName, regionModel, mapOrGeoModel, dataIdx, labelXY) {
    var data = viewBuildCtx.data;
    var isGeo = viewBuildCtx.isGeo;
    var isDataNaN = data && isNaN(data.get(data.mapDimension("value"), dataIdx));
    var itemLayout = data && data.getItemLayout(dataIdx);
    if (isGeo || isDataNaN || itemLayout && itemLayout.showLabel) {
      var query = !isGeo ? dataIdx : regionName;
      var labelFetcher = void 0;
      if (!data || dataIdx >= 0) {
        labelFetcher = mapOrGeoModel;
      }
      var specifiedTextOpt = labelXY ? {
        normal: {
          align: "center",
          verticalAlign: "middle"
        }
      } : null;
      setLabelStyle(el, getLabelStatesModels(regionModel), {
        labelFetcher,
        labelDataIndex: query,
        defaultText: regionName
      }, specifiedTextOpt);
      var textEl = el.getTextContent();
      if (textEl) {
        mapLabelRaw(textEl).ignore = textEl.ignore;
        if (el.textConfig && labelXY) {
          var rect = el.getBoundingRect().clone();
          el.textConfig.layoutRect = rect;
          el.textConfig.position = [(labelXY[0] - rect.x) / rect.width * 100 + "%", (labelXY[1] - rect.y) / rect.height * 100 + "%"];
        }
      }
      el.disableLabelAnimation = true;
    } else {
      el.removeTextContent();
      el.removeTextConfig();
      el.disableLabelAnimation = null;
    }
  }
  function resetEventTriggerForRegion(viewBuildCtx, eventTrigger, regionName, regionModel, mapOrGeoModel, dataIdx) {
    if (viewBuildCtx.data) {
      viewBuildCtx.data.setItemGraphicEl(dataIdx, eventTrigger);
    } else {
      getECData(eventTrigger).eventData = {
        componentType: "geo",
        componentIndex: mapOrGeoModel.componentIndex,
        geoIndex: mapOrGeoModel.componentIndex,
        name: regionName,
        region: regionModel && regionModel.option || {}
      };
    }
  }
  function resetTooltipForRegion(viewBuildCtx, el, regionName, regionModel, mapOrGeoModel) {
    if (!viewBuildCtx.data) {
      setTooltipConfig({
        el,
        componentModel: mapOrGeoModel,
        itemName: regionName,
        itemTooltipOption: regionModel.get("tooltip")
      });
    }
  }
  function resetStateTriggerForRegion(viewBuildCtx, el, regionName, regionModel, mapOrGeoModel) {
    el.highDownSilentOnTouch = !!mapOrGeoModel.get("selectedMode");
    var emphasisModel = regionModel.getModel("emphasis");
    var focus = emphasisModel.get("focus");
    toggleHoverEmphasis(el, focus, emphasisModel.get("blurScope"), emphasisModel.get("disabled"));
    if (viewBuildCtx.isGeo) {
      enableComponentHighDownFeatures(el, mapOrGeoModel, regionName);
    }
    return focus;
  }
  function projectPolys(rings, createStream, isLine) {
    var polygons = [];
    var curPoly;
    function startPolygon() {
      curPoly = [];
    }
    function endPolygon() {
      if (curPoly.length) {
        polygons.push(curPoly);
        curPoly = [];
      }
    }
    var stream = createStream({
      polygonStart: startPolygon,
      polygonEnd: endPolygon,
      lineStart: startPolygon,
      lineEnd: endPolygon,
      point: function(x, y) {
        if (isFinite(x) && isFinite(y)) {
          curPoly.push([x, y]);
        }
      },
      sphere: function() {
      }
    });
    !isLine && stream.polygonStart();
    each(rings, function(ring) {
      stream.lineStart();
      for (var i = 0; i < ring.length; i++) {
        stream.point(ring[i][0], ring[i][1]);
      }
      stream.lineEnd();
    });
    !isLine && stream.polygonEnd();
    return polygons;
  }
  var MapDraw_default = MapDraw;

  // node_modules/echarts/lib/chart/map/MapView.js
  var MapView = function(_super) {
    __extends(MapView2, _super);
    function MapView2() {
      var _this = _super !== null && _super.apply(this, arguments) || this;
      _this.type = MapView2.type;
      return _this;
    }
    MapView2.prototype.render = function(mapModel, ecModel, api, payload) {
      if (payload && payload.type === "mapToggleSelect" && payload.from === this.uid) {
        return;
      }
      var group = this.group;
      group.removeAll();
      if (mapModel.getHostGeoModel()) {
        return;
      }
      if (this._mapDraw && payload && payload.type === "geoRoam") {
        this._mapDraw.resetForLabelLayout();
      }
      if (!(payload && payload.type === "geoRoam" && payload.componentType === "series" && payload.seriesId === mapModel.id)) {
        if (mapModel.needsDrawMap) {
          var mapDraw = this._mapDraw || new MapDraw_default(api);
          group.add(mapDraw.group);
          mapDraw.draw(mapModel, ecModel, api, this, payload);
          this._mapDraw = mapDraw;
        } else {
          this._mapDraw && this._mapDraw.remove();
          this._mapDraw = null;
        }
      } else {
        var mapDraw = this._mapDraw;
        mapDraw && group.add(mapDraw.group);
      }
      mapModel.get("showLegendSymbol") && ecModel.getComponent("legend") && this._renderSymbols(mapModel, ecModel, api);
    };
    MapView2.prototype.remove = function() {
      this._mapDraw && this._mapDraw.remove();
      this._mapDraw = null;
      this.group.removeAll();
    };
    MapView2.prototype.dispose = function() {
      this._mapDraw && this._mapDraw.remove();
      this._mapDraw = null;
    };
    MapView2.prototype._renderSymbols = function(mapModel, ecModel, api) {
      var originalData = mapModel.originalData;
      var group = this.group;
      originalData.each(originalData.mapDimension("value"), function(value, originalDataIndex) {
        if (isNaN(value)) {
          return;
        }
        var layout5 = originalData.getItemLayout(originalDataIndex);
        if (!layout5 || !layout5.point) {
          return;
        }
        var point = layout5.point;
        var offset = layout5.offset;
        var circle = new Circle_default({
          style: {
            fill: mapModel.getData().getVisual("style").fill
          },
          shape: {
            cx: point[0] + offset * 9,
            cy: point[1],
            r: 3
          },
          silent: true,
          z2: 8 + (!offset ? Z2_EMPHASIS_LIFT + 1 : 0)
        });
        if (!offset) {
          var fullData = mapModel.mainSeries.getData();
          var name_1 = originalData.getName(originalDataIndex);
          var fullIndex_1 = fullData.indexOfName(name_1);
          var itemModel = originalData.getItemModel(originalDataIndex);
          var labelModel = itemModel.getModel("label");
          var regionGroup = fullData.getItemGraphicEl(fullIndex_1);
          setLabelStyle(circle, getLabelStatesModels(itemModel), {
            labelFetcher: {
              getFormattedLabel: function(idx, state) {
                return mapModel.getFormattedLabel(fullIndex_1, state);
              }
            },
            defaultText: name_1
          });
          circle.disableLabelAnimation = true;
          if (!labelModel.get("position")) {
            circle.setTextConfig({
              position: "bottom"
            });
          }
          regionGroup.onHoverStateChange = function(toState) {
            setStatesFlag(circle, toState);
          };
        }
        group.add(circle);
      });
    };
    MapView2.type = "map";
    return MapView2;
  }(Chart_default);
  var MapView_default = MapView;

  // node_modules/echarts/lib/chart/map/MapSeries.js
  var MapSeries = function(_super) {
    __extends(MapSeries2, _super);
    function MapSeries2() {
      var _this = _super !== null && _super.apply(this, arguments) || this;
      _this.type = MapSeries2.type;
      _this.needsDrawMap = false;
      _this.seriesGroup = [];
      _this.getTooltipPosition = function(dataIndex) {
        if (dataIndex != null) {
          var name_1 = this.getData().getName(dataIndex);
          var geo = this.coordinateSystem;
          var region = geo.getRegion(name_1);
          return region && geo.dataToPoint(region.getCenter());
        }
      };
      return _this;
    }
    MapSeries2.prototype.getInitialData = function(option) {
      var data = createSeriesDataSimply(this, {
        coordDimensions: ["value"],
        encodeDefaulter: curry(makeSeriesEncodeForNameBased, this)
      });
      var dataNameMap = createHashMap();
      var toAppendNames = [];
      for (var i = 0, len2 = data.count(); i < len2; i++) {
        var name_2 = data.getName(i);
        dataNameMap.set(name_2, true);
      }
      var geoSource = geoSourceManager_default.load(this.getMapType(), this.option.nameMap, this.option.nameProperty);
      each(geoSource.regions, function(region) {
        var name = region.name;
        if (!dataNameMap.get(name)) {
          toAppendNames.push(name);
        }
      });
      data.appendValues([], toAppendNames);
      return data;
    };
    MapSeries2.prototype.getHostGeoModel = function() {
      var geoIndex = this.option.geoIndex;
      return geoIndex != null ? this.ecModel.getComponent("geo", geoIndex) : null;
    };
    MapSeries2.prototype.getMapType = function() {
      return (this.getHostGeoModel() || this).option.map;
    };
    MapSeries2.prototype.getRawValue = function(dataIndex) {
      var data = this.getData();
      return data.get(data.mapDimension("value"), dataIndex);
    };
    MapSeries2.prototype.getRegionModel = function(regionName) {
      var data = this.getData();
      return data.getItemModel(data.indexOfName(regionName));
    };
    MapSeries2.prototype.formatTooltip = function(dataIndex, multipleSeries, dataType) {
      var data = this.getData();
      var value = this.getRawValue(dataIndex);
      var name = data.getName(dataIndex);
      var seriesGroup = this.seriesGroup;
      var seriesNames = [];
      for (var i = 0; i < seriesGroup.length; i++) {
        var otherIndex = seriesGroup[i].originalData.indexOfName(name);
        var valueDim = data.mapDimension("value");
        if (!isNaN(seriesGroup[i].originalData.get(valueDim, otherIndex))) {
          seriesNames.push(seriesGroup[i].name);
        }
      }
      return createTooltipMarkup("section", {
        header: seriesNames.join(", "),
        noHeader: !seriesNames.length,
        blocks: [createTooltipMarkup("nameValue", {
          name,
          value
        })]
      });
    };
    MapSeries2.prototype.setZoom = function(zoom) {
      this.option.zoom = zoom;
    };
    MapSeries2.prototype.setCenter = function(center3) {
      this.option.center = center3;
    };
    MapSeries2.prototype.getLegendIcon = function(opt) {
      var iconType = opt.icon || "roundRect";
      var icon = createSymbol(iconType, 0, 0, opt.itemWidth, opt.itemHeight, opt.itemStyle.fill);
      icon.setStyle(opt.itemStyle);
      icon.style.stroke = "none";
      if (iconType.indexOf("empty") > -1) {
        icon.style.stroke = icon.style.fill;
        icon.style.fill = "#fff";
        icon.style.lineWidth = 2;
      }
      return icon;
    };
    MapSeries2.type = "series.map";
    MapSeries2.dependencies = ["geo"];
    MapSeries2.layoutMode = "box";
    MapSeries2.defaultOption = {
      z: 2,
      coordinateSystem: "geo",
      map: "",
      left: "center",
      top: "center",
      aspectScale: null,
      showLegendSymbol: true,
      boundingCoords: null,
      center: null,
      zoom: 1,
      scaleLimit: null,
      selectedMode: true,
      label: {
        show: false,
        color: "#000"
      },
      itemStyle: {
        borderWidth: 0.5,
        borderColor: "#444",
        areaColor: "#eee"
      },
      emphasis: {
        label: {
          show: true,
          color: "rgb(100,0,0)"
        },
        itemStyle: {
          areaColor: "rgba(255,215,0,0.8)"
        }
      },
      select: {
        label: {
          show: true,
          color: "rgb(100,0,0)"
        },
        itemStyle: {
          color: "rgba(255,215,0,0.8)"
        }
      },
      nameProperty: "name"
    };
    return MapSeries2;
  }(Series_default);
  var MapSeries_default = MapSeries;

  // node_modules/echarts/lib/chart/map/mapDataStatistic.js
  function dataStatistics(datas, statisticType) {
    var dataNameMap = {};
    each(datas, function(data) {
      data.each(data.mapDimension("value"), function(value, idx) {
        var mapKey = "ec-" + data.getName(idx);
        dataNameMap[mapKey] = dataNameMap[mapKey] || [];
        if (!isNaN(value)) {
          dataNameMap[mapKey].push(value);
        }
      });
    });
    return datas[0].map(datas[0].mapDimension("value"), function(value, idx) {
      var mapKey = "ec-" + datas[0].getName(idx);
      var sum2 = 0;
      var min3 = Infinity;
      var max3 = -Infinity;
      var len2 = dataNameMap[mapKey].length;
      for (var i = 0; i < len2; i++) {
        min3 = Math.min(min3, dataNameMap[mapKey][i]);
        max3 = Math.max(max3, dataNameMap[mapKey][i]);
        sum2 += dataNameMap[mapKey][i];
      }
      var result;
      if (statisticType === "min") {
        result = min3;
      } else if (statisticType === "max") {
        result = max3;
      } else if (statisticType === "average") {
        result = sum2 / len2;
      } else {
        result = sum2;
      }
      return len2 === 0 ? NaN : result;
    });
  }
  function mapDataStatistic(ecModel) {
    var seriesGroups = {};
    ecModel.eachSeriesByType("map", function(seriesModel) {
      var hostGeoModel = seriesModel.getHostGeoModel();
      var key = hostGeoModel ? "o" + hostGeoModel.id : "i" + seriesModel.getMapType();
      (seriesGroups[key] = seriesGroups[key] || []).push(seriesModel);
    });
    each(seriesGroups, function(seriesList, key) {
      var data = dataStatistics(map(seriesList, function(seriesModel) {
        return seriesModel.getData();
      }), seriesList[0].get("mapValueCalculation"));
      for (var i = 0; i < seriesList.length; i++) {
        seriesList[i].originalData = seriesList[i].getData();
      }
      for (var i = 0; i < seriesList.length; i++) {
        seriesList[i].seriesGroup = seriesList;
        seriesList[i].needsDrawMap = i === 0 && !seriesList[i].getHostGeoModel();
        seriesList[i].setData(data.cloneShallow());
        seriesList[i].mainSeries = seriesList[0];
      }
    });
  }

  // node_modules/echarts/lib/chart/map/mapSymbolLayout.js
  function mapSymbolLayout(ecModel) {
    var processedMapType = {};
    ecModel.eachSeriesByType("map", function(mapSeries) {
      var mapType = mapSeries.getMapType();
      if (mapSeries.getHostGeoModel() || processedMapType[mapType]) {
        return;
      }
      var mapSymbolOffsets = {};
      each(mapSeries.seriesGroup, function(subMapSeries) {
        var geo = subMapSeries.coordinateSystem;
        var data2 = subMapSeries.originalData;
        if (subMapSeries.get("showLegendSymbol") && ecModel.getComponent("legend")) {
          data2.each(data2.mapDimension("value"), function(value, idx) {
            var name = data2.getName(idx);
            var region = geo.getRegion(name);
            if (!region || isNaN(value)) {
              return;
            }
            var offset = mapSymbolOffsets[name] || 0;
            var point = geo.dataToPoint(region.getCenter());
            mapSymbolOffsets[name] = offset + 1;
            data2.setItemLayout(idx, {
              point,
              offset
            });
          });
        }
      });
      var data = mapSeries.getData();
      data.each(function(idx) {
        var name = data.getName(idx);
        var layout5 = data.getItemLayout(idx) || {};
        layout5.showLabel = !mapSymbolOffsets[name];
        data.setItemLayout(idx, layout5);
      });
      processedMapType[mapType] = true;
    });
  }

  // node_modules/echarts/lib/coord/View.js
  var v2ApplyTransform = applyTransform;
  var View = function(_super) {
    __extends(View2, _super);
    function View2(name) {
      var _this = _super.call(this) || this;
      _this.type = "view";
      _this.dimensions = ["x", "y"];
      _this._roamTransformable = new Transformable_default();
      _this._rawTransformable = new Transformable_default();
      _this.name = name;
      return _this;
    }
    View2.prototype.setBoundingRect = function(x, y, width, height) {
      this._rect = new BoundingRect_default(x, y, width, height);
      return this._rect;
    };
    View2.prototype.getBoundingRect = function() {
      return this._rect;
    };
    View2.prototype.setViewRect = function(x, y, width, height) {
      this._transformTo(x, y, width, height);
      this._viewRect = new BoundingRect_default(x, y, width, height);
    };
    View2.prototype._transformTo = function(x, y, width, height) {
      var rect = this.getBoundingRect();
      var rawTransform = this._rawTransformable;
      rawTransform.transform = rect.calculateTransform(new BoundingRect_default(x, y, width, height));
      var rawParent = rawTransform.parent;
      rawTransform.parent = null;
      rawTransform.decomposeTransform();
      rawTransform.parent = rawParent;
      this._updateTransform();
    };
    View2.prototype.setCenter = function(centerCoord, api) {
      if (!centerCoord) {
        return;
      }
      this._center = [parsePercent2(centerCoord[0], api.getWidth()), parsePercent2(centerCoord[1], api.getHeight())];
      this._updateCenterAndZoom();
    };
    View2.prototype.setZoom = function(zoom) {
      zoom = zoom || 1;
      var zoomLimit = this.zoomLimit;
      if (zoomLimit) {
        if (zoomLimit.max != null) {
          zoom = Math.min(zoomLimit.max, zoom);
        }
        if (zoomLimit.min != null) {
          zoom = Math.max(zoomLimit.min, zoom);
        }
      }
      this._zoom = zoom;
      this._updateCenterAndZoom();
    };
    View2.prototype.getDefaultCenter = function() {
      var rawRect = this.getBoundingRect();
      var cx = rawRect.x + rawRect.width / 2;
      var cy = rawRect.y + rawRect.height / 2;
      return [cx, cy];
    };
    View2.prototype.getCenter = function() {
      return this._center || this.getDefaultCenter();
    };
    View2.prototype.getZoom = function() {
      return this._zoom || 1;
    };
    View2.prototype.getRoamTransform = function() {
      return this._roamTransformable.getLocalTransform();
    };
    View2.prototype._updateCenterAndZoom = function() {
      var rawTransformMatrix = this._rawTransformable.getLocalTransform();
      var roamTransform = this._roamTransformable;
      var defaultCenter = this.getDefaultCenter();
      var center3 = this.getCenter();
      var zoom = this.getZoom();
      center3 = applyTransform([], center3, rawTransformMatrix);
      defaultCenter = applyTransform([], defaultCenter, rawTransformMatrix);
      roamTransform.originX = center3[0];
      roamTransform.originY = center3[1];
      roamTransform.x = defaultCenter[0] - center3[0];
      roamTransform.y = defaultCenter[1] - center3[1];
      roamTransform.scaleX = roamTransform.scaleY = zoom;
      this._updateTransform();
    };
    View2.prototype._updateTransform = function() {
      var roamTransformable = this._roamTransformable;
      var rawTransformable = this._rawTransformable;
      rawTransformable.parent = roamTransformable;
      roamTransformable.updateTransform();
      rawTransformable.updateTransform();
      copy2(this.transform || (this.transform = []), rawTransformable.transform || create2());
      this._rawTransform = rawTransformable.getLocalTransform();
      this.invTransform = this.invTransform || [];
      invert(this.invTransform, this.transform);
      this.decomposeTransform();
    };
    View2.prototype.getTransformInfo = function() {
      var rawTransformable = this._rawTransformable;
      var roamTransformable = this._roamTransformable;
      var dummyTransformable2 = new Transformable_default();
      dummyTransformable2.transform = roamTransformable.transform;
      dummyTransformable2.decomposeTransform();
      return {
        roam: {
          x: dummyTransformable2.x,
          y: dummyTransformable2.y,
          scaleX: dummyTransformable2.scaleX,
          scaleY: dummyTransformable2.scaleY
        },
        raw: {
          x: rawTransformable.x,
          y: rawTransformable.y,
          scaleX: rawTransformable.scaleX,
          scaleY: rawTransformable.scaleY
        }
      };
    };
    View2.prototype.getViewRect = function() {
      return this._viewRect;
    };
    View2.prototype.getViewRectAfterRoam = function() {
      var rect = this.getBoundingRect().clone();
      rect.applyTransform(this.transform);
      return rect;
    };
    View2.prototype.dataToPoint = function(data, noRoam, out2) {
      var transform2 = noRoam ? this._rawTransform : this.transform;
      out2 = out2 || [];
      return transform2 ? v2ApplyTransform(out2, data, transform2) : copy(out2, data);
    };
    View2.prototype.pointToData = function(point) {
      var invTransform = this.invTransform;
      return invTransform ? v2ApplyTransform([], point, invTransform) : [point[0], point[1]];
    };
    View2.prototype.convertToPixel = function(ecModel, finder, value) {
      var coordSys = getCoordSys(finder);
      return coordSys === this ? coordSys.dataToPoint(value) : null;
    };
    View2.prototype.convertFromPixel = function(ecModel, finder, pixel) {
      var coordSys = getCoordSys(finder);
      return coordSys === this ? coordSys.pointToData(pixel) : null;
    };
    View2.prototype.containPoint = function(point) {
      return this.getViewRectAfterRoam().contain(point[0], point[1]);
    };
    View2.dimensions = ["x", "y"];
    return View2;
  }(Transformable_default);
  function getCoordSys(finder) {
    var seriesModel = finder.seriesModel;
    return seriesModel ? seriesModel.coordinateSystem : null;
  }
  var View_default = View;

  // node_modules/echarts/lib/coord/geo/Geo.js
  var GEO_DEFAULT_PARAMS = {
    "geoJSON": {
      aspectScale: 0.75,
      invertLongitute: true
    },
    "geoSVG": {
      aspectScale: 1,
      invertLongitute: false
    }
  };
  var geo2DDimensions = ["lng", "lat"];
  var Geo = function(_super) {
    __extends(Geo2, _super);
    function Geo2(name, map3, opt) {
      var _this = _super.call(this, name) || this;
      _this.dimensions = geo2DDimensions;
      _this.type = "geo";
      _this._nameCoordMap = createHashMap();
      _this.map = map3;
      var projection = opt.projection;
      var source = geoSourceManager_default.load(map3, opt.nameMap, opt.nameProperty);
      var resource = geoSourceManager_default.getGeoResource(map3);
      var resourceType = _this.resourceType = resource ? resource.type : null;
      var regions = _this.regions = source.regions;
      var defaultParams = GEO_DEFAULT_PARAMS[resource.type];
      _this._regionsMap = source.regionsMap;
      _this.regions = source.regions;
      if (projection) {
        if (resourceType === "geoSVG") {
          if (true) {
            warn("Map " + map3 + " with SVG source can't use projection. Only GeoJSON source supports projection.");
          }
          projection = null;
        }
        if (!(projection.project && projection.unproject)) {
          if (true) {
            warn("project and unproject must be both provided in the projeciton.");
          }
          projection = null;
        }
      }
      _this.projection = projection;
      var boundingRect;
      if (projection) {
        for (var i = 0; i < regions.length; i++) {
          var regionRect = regions[i].getBoundingRect(projection);
          boundingRect = boundingRect || regionRect.clone();
          boundingRect.union(regionRect);
        }
      } else {
        boundingRect = source.boundingRect;
      }
      _this.setBoundingRect(boundingRect.x, boundingRect.y, boundingRect.width, boundingRect.height);
      _this.aspectScale = projection ? 1 : retrieve2(opt.aspectScale, defaultParams.aspectScale);
      _this._invertLongitute = projection ? false : defaultParams.invertLongitute;
      return _this;
    }
    Geo2.prototype._transformTo = function(x, y, width, height) {
      var rect = this.getBoundingRect();
      var invertLongitute = this._invertLongitute;
      rect = rect.clone();
      if (invertLongitute) {
        rect.y = -rect.y - rect.height;
      }
      var rawTransformable = this._rawTransformable;
      rawTransformable.transform = rect.calculateTransform(new BoundingRect_default(x, y, width, height));
      var rawParent = rawTransformable.parent;
      rawTransformable.parent = null;
      rawTransformable.decomposeTransform();
      rawTransformable.parent = rawParent;
      if (invertLongitute) {
        rawTransformable.scaleY = -rawTransformable.scaleY;
      }
      this._updateTransform();
    };
    Geo2.prototype.getRegion = function(name) {
      return this._regionsMap.get(name);
    };
    Geo2.prototype.getRegionByCoord = function(coord) {
      var regions = this.regions;
      for (var i = 0; i < regions.length; i++) {
        var region = regions[i];
        if (region.type === "geoJSON" && region.contain(coord)) {
          return regions[i];
        }
      }
    };
    Geo2.prototype.addGeoCoord = function(name, geoCoord2) {
      this._nameCoordMap.set(name, geoCoord2);
    };
    Geo2.prototype.getGeoCoord = function(name) {
      var region = this._regionsMap.get(name);
      return this._nameCoordMap.get(name) || region && region.getCenter();
    };
    Geo2.prototype.dataToPoint = function(data, noRoam, out2) {
      if (isString(data)) {
        data = this.getGeoCoord(data);
      }
      if (data) {
        var projection = this.projection;
        if (projection) {
          data = projection.project(data);
        }
        return data && this.projectedToPoint(data, noRoam, out2);
      }
    };
    Geo2.prototype.pointToData = function(point) {
      var projection = this.projection;
      if (projection) {
        point = projection.unproject(point);
      }
      return point && this.pointToProjected(point);
    };
    Geo2.prototype.pointToProjected = function(point) {
      return _super.prototype.pointToData.call(this, point);
    };
    Geo2.prototype.projectedToPoint = function(projected, noRoam, out2) {
      return _super.prototype.dataToPoint.call(this, projected, noRoam, out2);
    };
    Geo2.prototype.convertToPixel = function(ecModel, finder, value) {
      var coordSys = getCoordSys2(finder);
      return coordSys === this ? coordSys.dataToPoint(value) : null;
    };
    Geo2.prototype.convertFromPixel = function(ecModel, finder, pixel) {
      var coordSys = getCoordSys2(finder);
      return coordSys === this ? coordSys.pointToData(pixel) : null;
    };
    return Geo2;
  }(View_default);
  mixin(Geo, View_default);
  function getCoordSys2(finder) {
    var geoModel = finder.geoModel;
    var seriesModel = finder.seriesModel;
    return geoModel ? geoModel.coordinateSystem : seriesModel ? seriesModel.coordinateSystem || (seriesModel.getReferringComponents("geo", SINGLE_REFERRING).models[0] || {}).coordinateSystem : null;
  }
  var Geo_default = Geo;

  // node_modules/echarts/lib/coord/geo/geoCreator.js
  function resizeGeo(geoModel, api) {
    var boundingCoords = geoModel.get("boundingCoords");
    if (boundingCoords != null) {
      var leftTop_1 = boundingCoords[0];
      var rightBottom_1 = boundingCoords[1];
      if (!(isFinite(leftTop_1[0]) && isFinite(leftTop_1[1]) && isFinite(rightBottom_1[0]) && isFinite(rightBottom_1[1]))) {
        if (true) {
          console.error("Invalid boundingCoords");
        }
      } else {
        var projection_1 = this.projection;
        if (projection_1) {
          var xMin = leftTop_1[0];
          var yMin = leftTop_1[1];
          var xMax = rightBottom_1[0];
          var yMax = rightBottom_1[1];
          leftTop_1 = [Infinity, Infinity];
          rightBottom_1 = [-Infinity, -Infinity];
          var sampleLine = function(x0, y0, x1, y1) {
            var dx = x1 - x0;
            var dy = y1 - y0;
            for (var i = 0; i <= 100; i++) {
              var p = i / 100;
              var pt = projection_1.project([x0 + dx * p, y0 + dy * p]);
              min(leftTop_1, leftTop_1, pt);
              max(rightBottom_1, rightBottom_1, pt);
            }
          };
          sampleLine(xMin, yMin, xMax, yMin);
          sampleLine(xMax, yMin, xMax, yMax);
          sampleLine(xMax, yMax, xMin, yMax);
          sampleLine(xMin, yMax, xMax, yMin);
        }
        this.setBoundingRect(leftTop_1[0], leftTop_1[1], rightBottom_1[0] - leftTop_1[0], rightBottom_1[1] - leftTop_1[1]);
      }
    }
    var rect = this.getBoundingRect();
    var centerOption = geoModel.get("layoutCenter");
    var sizeOption = geoModel.get("layoutSize");
    var viewWidth = api.getWidth();
    var viewHeight = api.getHeight();
    var aspect = rect.width / rect.height * this.aspectScale;
    var useCenterAndSize = false;
    var center3;
    var size;
    if (centerOption && sizeOption) {
      center3 = [parsePercent2(centerOption[0], viewWidth), parsePercent2(centerOption[1], viewHeight)];
      size = parsePercent2(sizeOption, Math.min(viewWidth, viewHeight));
      if (!isNaN(center3[0]) && !isNaN(center3[1]) && !isNaN(size)) {
        useCenterAndSize = true;
      } else {
        if (true) {
          console.warn("Given layoutCenter or layoutSize data are invalid. Use left/top/width/height instead.");
        }
      }
    }
    var viewRect2;
    if (useCenterAndSize) {
      viewRect2 = {};
      if (aspect > 1) {
        viewRect2.width = size;
        viewRect2.height = size / aspect;
      } else {
        viewRect2.height = size;
        viewRect2.width = size * aspect;
      }
      viewRect2.y = center3[1] - viewRect2.height / 2;
      viewRect2.x = center3[0] - viewRect2.width / 2;
    } else {
      var boxLayoutOption = geoModel.getBoxLayoutParams();
      boxLayoutOption.aspect = aspect;
      viewRect2 = getLayoutRect(boxLayoutOption, {
        width: viewWidth,
        height: viewHeight
      });
    }
    this.setViewRect(viewRect2.x, viewRect2.y, viewRect2.width, viewRect2.height);
    this.setCenter(geoModel.get("center"), api);
    this.setZoom(geoModel.get("zoom"));
  }
  function setGeoCoords(geo, model) {
    each(model.get("geoCoord"), function(geoCoord2, name) {
      geo.addGeoCoord(name, geoCoord2);
    });
  }
  var GeoCreator = function() {
    function GeoCreator2() {
      this.dimensions = geo2DDimensions;
    }
    GeoCreator2.prototype.create = function(ecModel, api) {
      var geoList = [];
      function getCommonGeoProperties(model) {
        return {
          nameProperty: model.get("nameProperty"),
          aspectScale: model.get("aspectScale"),
          projection: model.get("projection")
        };
      }
      ecModel.eachComponent("geo", function(geoModel, idx) {
        var mapName = geoModel.get("map");
        var geo = new Geo_default(mapName + idx, mapName, extend({
          nameMap: geoModel.get("nameMap")
        }, getCommonGeoProperties(geoModel)));
        geo.zoomLimit = geoModel.get("scaleLimit");
        geoList.push(geo);
        geoModel.coordinateSystem = geo;
        geo.model = geoModel;
        geo.resize = resizeGeo;
        geo.resize(geoModel, api);
      });
      ecModel.eachSeries(function(seriesModel) {
        var coordSys = seriesModel.get("coordinateSystem");
        if (coordSys === "geo") {
          var geoIndex = seriesModel.get("geoIndex") || 0;
          seriesModel.coordinateSystem = geoList[geoIndex];
        }
      });
      var mapModelGroupBySeries = {};
      ecModel.eachSeriesByType("map", function(seriesModel) {
        if (!seriesModel.getHostGeoModel()) {
          var mapType = seriesModel.getMapType();
          mapModelGroupBySeries[mapType] = mapModelGroupBySeries[mapType] || [];
          mapModelGroupBySeries[mapType].push(seriesModel);
        }
      });
      each(mapModelGroupBySeries, function(mapSeries, mapType) {
        var nameMapList = map(mapSeries, function(singleMapSeries) {
          return singleMapSeries.get("nameMap");
        });
        var geo = new Geo_default(mapType, mapType, extend({
          nameMap: mergeAll(nameMapList)
        }, getCommonGeoProperties(mapSeries[0])));
        geo.zoomLimit = retrieve.apply(null, map(mapSeries, function(singleMapSeries) {
          return singleMapSeries.get("scaleLimit");
        }));
        geoList.push(geo);
        geo.resize = resizeGeo;
        geo.resize(mapSeries[0], api);
        each(mapSeries, function(singleMapSeries) {
          singleMapSeries.coordinateSystem = geo;
          setGeoCoords(geo, singleMapSeries);
        });
      });
      return geoList;
    };
    GeoCreator2.prototype.getFilledRegions = function(originRegionArr, mapName, nameMap, nameProperty) {
      var regionsArr = (originRegionArr || []).slice();
      var dataNameMap = createHashMap();
      for (var i = 0; i < regionsArr.length; i++) {
        dataNameMap.set(regionsArr[i].name, regionsArr[i]);
      }
      var source = geoSourceManager_default.load(mapName, nameMap, nameProperty);
      each(source.regions, function(region) {
        var name = region.name;
        !dataNameMap.get(name) && regionsArr.push({
          name
        });
      });
      return regionsArr;
    };
    return GeoCreator2;
  }();
  var geoCreator = new GeoCreator();
  var geoCreator_default = geoCreator;

  // node_modules/echarts/lib/coord/geo/GeoModel.js
  var GeoModel = function(_super) {
    __extends(GeoModel2, _super);
    function GeoModel2() {
      var _this = _super !== null && _super.apply(this, arguments) || this;
      _this.type = GeoModel2.type;
      return _this;
    }
    GeoModel2.prototype.init = function(option, parentModel, ecModel) {
      var source = geoSourceManager_default.getGeoResource(option.map);
      if (source && source.type === "geoJSON") {
        var itemStyle = option.itemStyle = option.itemStyle || {};
        if (!("color" in itemStyle)) {
          itemStyle.color = "#eee";
        }
      }
      this.mergeDefaultAndTheme(option, ecModel);
      defaultEmphasis(option, "label", ["show"]);
    };
    GeoModel2.prototype.optionUpdated = function() {
      var _this = this;
      var option = this.option;
      option.regions = geoCreator_default.getFilledRegions(option.regions, option.map, option.nameMap, option.nameProperty);
      var selectedMap = {};
      this._optionModelMap = reduce(option.regions || [], function(optionModelMap, regionOpt) {
        var regionName = regionOpt.name;
        if (regionName) {
          optionModelMap.set(regionName, new Model_default(regionOpt, _this, _this.ecModel));
          if (regionOpt.selected) {
            selectedMap[regionName] = true;
          }
        }
        return optionModelMap;
      }, createHashMap());
      if (!option.selectedMap) {
        option.selectedMap = selectedMap;
      }
    };
    GeoModel2.prototype.getRegionModel = function(name) {
      return this._optionModelMap.get(name) || new Model_default(null, this, this.ecModel);
    };
    GeoModel2.prototype.getFormattedLabel = function(name, status) {
      var regionModel = this.getRegionModel(name);
      var formatter = status === "normal" ? regionModel.get(["label", "formatter"]) : regionModel.get(["emphasis", "label", "formatter"]);
      var params = {
        name
      };
      if (isFunction(formatter)) {
        params.status = status;
        return formatter(params);
      } else if (isString(formatter)) {
        return formatter.replace("{a}", name != null ? name : "");
      }
    };
    GeoModel2.prototype.setZoom = function(zoom) {
      this.option.zoom = zoom;
    };
    GeoModel2.prototype.setCenter = function(center3) {
      this.option.center = center3;
    };
    GeoModel2.prototype.select = function(name) {
      var option = this.option;
      var selectedMode = option.selectedMode;
      if (!selectedMode) {
        return;
      }
      if (selectedMode !== "multiple") {
        option.selectedMap = null;
      }
      var selectedMap = option.selectedMap || (option.selectedMap = {});
      selectedMap[name] = true;
    };
    GeoModel2.prototype.unSelect = function(name) {
      var selectedMap = this.option.selectedMap;
      if (selectedMap) {
        selectedMap[name] = false;
      }
    };
    GeoModel2.prototype.toggleSelected = function(name) {
      this[this.isSelected(name) ? "unSelect" : "select"](name);
    };
    GeoModel2.prototype.isSelected = function(name) {
      var selectedMap = this.option.selectedMap;
      return !!(selectedMap && selectedMap[name]);
    };
    GeoModel2.type = "geo";
    GeoModel2.layoutMode = "box";
    GeoModel2.defaultOption = {
      z: 0,
      show: true,
      left: "center",
      top: "center",
      aspectScale: null,
      silent: false,
      map: "",
      boundingCoords: null,
      center: null,
      zoom: 1,
      scaleLimit: null,
      label: {
        show: false,
        color: "#000"
      },
      itemStyle: {
        borderWidth: 0.5,
        borderColor: "#444"
      },
      emphasis: {
        label: {
          show: true,
          color: "rgb(100,0,0)"
        },
        itemStyle: {
          color: "rgba(255,215,0,0.8)"
        }
      },
      select: {
        label: {
          show: true,
          color: "rgb(100,0,0)"
        },
        itemStyle: {
          color: "rgba(255,215,0,0.8)"
        }
      },
      regions: []
    };
    return GeoModel2;
  }(Component_default);
  var GeoModel_default = GeoModel;

  // node_modules/echarts/lib/action/roamHelper.js
  function getCenterCoord(view, point) {
    return view.pointToProjected ? view.pointToProjected(point) : view.pointToData(point);
  }
  function updateCenterAndZoom(view, payload, zoomLimit, api) {
    var previousZoom = view.getZoom();
    var center3 = view.getCenter();
    var zoom = payload.zoom;
    var point = view.projectedToPoint ? view.projectedToPoint(center3) : view.dataToPoint(center3);
    if (payload.dx != null && payload.dy != null) {
      point[0] -= payload.dx;
      point[1] -= payload.dy;
      view.setCenter(getCenterCoord(view, point), api);
    }
    if (zoom != null) {
      if (zoomLimit) {
        var zoomMin = zoomLimit.min || 0;
        var zoomMax = zoomLimit.max || Infinity;
        zoom = Math.max(Math.min(previousZoom * zoom, zoomMax), zoomMin) / previousZoom;
      }
      view.scaleX *= zoom;
      view.scaleY *= zoom;
      var fixX = (payload.originX - view.x) * (zoom - 1);
      var fixY = (payload.originY - view.y) * (zoom - 1);
      view.x -= fixX;
      view.y -= fixY;
      view.updateTransform();
      view.setCenter(getCenterCoord(view, point), api);
      view.setZoom(zoom * previousZoom);
    }
    return {
      center: view.getCenter(),
      zoom: view.getZoom()
    };
  }

  // node_modules/echarts/lib/component/geo/GeoView.js
  var GeoView = function(_super) {
    __extends(GeoView2, _super);
    function GeoView2() {
      var _this = _super !== null && _super.apply(this, arguments) || this;
      _this.type = GeoView2.type;
      _this.focusBlurEnabled = true;
      return _this;
    }
    GeoView2.prototype.init = function(ecModel, api) {
      this._api = api;
    };
    GeoView2.prototype.render = function(geoModel, ecModel, api, payload) {
      this._model = geoModel;
      if (!geoModel.get("show")) {
        this._mapDraw && this._mapDraw.remove();
        this._mapDraw = null;
        return;
      }
      if (!this._mapDraw) {
        this._mapDraw = new MapDraw_default(api);
      }
      var mapDraw = this._mapDraw;
      mapDraw.draw(geoModel, ecModel, api, this, payload);
      mapDraw.group.on("click", this._handleRegionClick, this);
      mapDraw.group.silent = geoModel.get("silent");
      this.group.add(mapDraw.group);
      this.updateSelectStatus(geoModel, ecModel, api);
    };
    GeoView2.prototype._handleRegionClick = function(e2) {
      var eventData;
      findEventDispatcher(e2.target, function(current) {
        return (eventData = getECData(current).eventData) != null;
      }, true);
      if (eventData) {
        this._api.dispatchAction({
          type: "geoToggleSelect",
          geoId: this._model.id,
          name: eventData.name
        });
      }
    };
    GeoView2.prototype.updateSelectStatus = function(model, ecModel, api) {
      var _this = this;
      this._mapDraw.group.traverse(function(node) {
        var eventData = getECData(node).eventData;
        if (eventData) {
          _this._model.isSelected(eventData.name) ? api.enterSelect(node) : api.leaveSelect(node);
          return true;
        }
      });
    };
    GeoView2.prototype.findHighDownDispatchers = function(name) {
      return this._mapDraw && this._mapDraw.findHighDownDispatchers(name, this._model);
    };
    GeoView2.prototype.dispose = function() {
      this._mapDraw && this._mapDraw.remove();
    };
    GeoView2.type = "geo";
    return GeoView2;
  }(Component_default2);
  var GeoView_default = GeoView;

  // node_modules/echarts/lib/component/geo/install.js
  function registerMap2(mapName, geoJson, specialAreas) {
    geoSourceManager_default.registerMap(mapName, geoJson, specialAreas);
  }
  function install10(registers) {
    registers.registerCoordinateSystem("geo", geoCreator_default);
    registers.registerComponentModel(GeoModel_default);
    registers.registerComponentView(GeoView_default);
    registers.registerImpl("registerMap", registerMap2);
    registers.registerImpl("getMap", function(mapName) {
      return geoSourceManager_default.getMapForUser(mapName);
    });
    function makeAction(method, actionInfo3) {
      actionInfo3.update = "geo:updateSelectStatus";
      registers.registerAction(actionInfo3, function(payload, ecModel) {
        var selected = {};
        var allSelected = [];
        ecModel.eachComponent({
          mainType: "geo",
          query: payload
        }, function(geoModel) {
          geoModel[method](payload.name);
          var geo = geoModel.coordinateSystem;
          each(geo.regions, function(region) {
            selected[region.name] = geoModel.isSelected(region.name) || false;
          });
          var names = [];
          each(selected, function(v, name) {
            selected[name] && names.push(name);
          });
          allSelected.push({
            geoIndex: geoModel.componentIndex,
            name: names
          });
        });
        return {
          selected,
          allSelected,
          name: payload.name
        };
      });
    }
    makeAction("toggleSelected", {
      type: "geoToggleSelect",
      event: "geoselectchanged"
    });
    makeAction("select", {
      type: "geoSelect",
      event: "geoselected"
    });
    makeAction("unSelect", {
      type: "geoUnSelect",
      event: "geounselected"
    });
    registers.registerAction({
      type: "geoRoam",
      event: "geoRoam",
      update: "updateTransform"
    }, function(payload, ecModel, api) {
      var componentType = payload.componentType || "series";
      ecModel.eachComponent({
        mainType: componentType,
        query: payload
      }, function(componentModel) {
        var geo = componentModel.coordinateSystem;
        if (geo.type !== "geo") {
          return;
        }
        var res = updateCenterAndZoom(geo, payload, componentModel.get("scaleLimit"), api);
        componentModel.setCenter && componentModel.setCenter(res.center);
        componentModel.setZoom && componentModel.setZoom(res.zoom);
        if (componentType === "series") {
          each(componentModel.seriesGroup, function(seriesModel) {
            seriesModel.setCenter(res.center);
            seriesModel.setZoom(res.zoom);
          });
        }
      });
    });
  }

  // node_modules/echarts/lib/chart/map/install.js
  function install11(registers) {
    use(install10);
    registers.registerChartView(MapView_default);
    registers.registerSeriesModel(MapSeries_default);
    registers.registerLayout(mapSymbolLayout);
    registers.registerProcessor(registers.PRIORITY.PROCESSOR.STATISTIC, mapDataStatistic);
    createLegacyDataSelectAction("map", registers.registerAction);
  }

  // node_modules/echarts/lib/chart/tree/layoutHelper.js
  function init3(inRoot) {
    var root = inRoot;
    root.hierNode = {
      defaultAncestor: null,
      ancestor: root,
      prelim: 0,
      modifier: 0,
      change: 0,
      shift: 0,
      i: 0,
      thread: null
    };
    var nodes = [root];
    var node;
    var children;
    while (node = nodes.pop()) {
      children = node.children;
      if (node.isExpand && children.length) {
        var n = children.length;
        for (var i = n - 1; i >= 0; i--) {
          var child = children[i];
          child.hierNode = {
            defaultAncestor: null,
            ancestor: child,
            prelim: 0,
            modifier: 0,
            change: 0,
            shift: 0,
            i,
            thread: null
          };
          nodes.push(child);
        }
      }
    }
  }
  function firstWalk(node, separation2) {
    var children = node.isExpand ? node.children : [];
    var siblings = node.parentNode.children;
    var subtreeW = node.hierNode.i ? siblings[node.hierNode.i - 1] : null;
    if (children.length) {
      executeShifts(node);
      var midPoint = (children[0].hierNode.prelim + children[children.length - 1].hierNode.prelim) / 2;
      if (subtreeW) {
        node.hierNode.prelim = subtreeW.hierNode.prelim + separation2(node, subtreeW);
        node.hierNode.modifier = node.hierNode.prelim - midPoint;
      } else {
        node.hierNode.prelim = midPoint;
      }
    } else if (subtreeW) {
      node.hierNode.prelim = subtreeW.hierNode.prelim + separation2(node, subtreeW);
    }
    node.parentNode.hierNode.defaultAncestor = apportion(node, subtreeW, node.parentNode.hierNode.defaultAncestor || siblings[0], separation2);
  }
  function secondWalk(node) {
    var nodeX = node.hierNode.prelim + node.parentNode.hierNode.modifier;
    node.setLayout({
      x: nodeX
    }, true);
    node.hierNode.modifier += node.parentNode.hierNode.modifier;
  }
  function separation(cb) {
    return arguments.length ? cb : defaultSeparation;
  }
  function radialCoordinate(rad, r) {
    rad -= Math.PI / 2;
    return {
      x: r * Math.cos(rad),
      y: r * Math.sin(rad)
    };
  }
  function getViewRect2(seriesModel, api) {
    return getLayoutRect(seriesModel.getBoxLayoutParams(), {
      width: api.getWidth(),
      height: api.getHeight()
    });
  }
  function executeShifts(node) {
    var children = node.children;
    var n = children.length;
    var shift = 0;
    var change = 0;
    while (--n >= 0) {
      var child = children[n];
      child.hierNode.prelim += shift;
      child.hierNode.modifier += shift;
      change += child.hierNode.change;
      shift += child.hierNode.shift + change;
    }
  }
  function apportion(subtreeV, subtreeW, ancestor, separation2) {
    if (subtreeW) {
      var nodeOutRight = subtreeV;
      var nodeInRight = subtreeV;
      var nodeOutLeft = nodeInRight.parentNode.children[0];
      var nodeInLeft = subtreeW;
      var sumOutRight = nodeOutRight.hierNode.modifier;
      var sumInRight = nodeInRight.hierNode.modifier;
      var sumOutLeft = nodeOutLeft.hierNode.modifier;
      var sumInLeft = nodeInLeft.hierNode.modifier;
      while (nodeInLeft = nextRight(nodeInLeft), nodeInRight = nextLeft(nodeInRight), nodeInLeft && nodeInRight) {
        nodeOutRight = nextRight(nodeOutRight);
        nodeOutLeft = nextLeft(nodeOutLeft);
        nodeOutRight.hierNode.ancestor = subtreeV;
        var shift = nodeInLeft.hierNode.prelim + sumInLeft - nodeInRight.hierNode.prelim - sumInRight + separation2(nodeInLeft, nodeInRight);
        if (shift > 0) {
          moveSubtree(nextAncestor(nodeInLeft, subtreeV, ancestor), subtreeV, shift);
          sumInRight += shift;
          sumOutRight += shift;
        }
        sumInLeft += nodeInLeft.hierNode.modifier;
        sumInRight += nodeInRight.hierNode.modifier;
        sumOutRight += nodeOutRight.hierNode.modifier;
        sumOutLeft += nodeOutLeft.hierNode.modifier;
      }
      if (nodeInLeft && !nextRight(nodeOutRight)) {
        nodeOutRight.hierNode.thread = nodeInLeft;
        nodeOutRight.hierNode.modifier += sumInLeft - sumOutRight;
      }
      if (nodeInRight && !nextLeft(nodeOutLeft)) {
        nodeOutLeft.hierNode.thread = nodeInRight;
        nodeOutLeft.hierNode.modifier += sumInRight - sumOutLeft;
        ancestor = subtreeV;
      }
    }
    return ancestor;
  }
  function nextRight(node) {
    var children = node.children;
    return children.length && node.isExpand ? children[children.length - 1] : node.hierNode.thread;
  }
  function nextLeft(node) {
    var children = node.children;
    return children.length && node.isExpand ? children[0] : node.hierNode.thread;
  }
  function nextAncestor(nodeInLeft, node, ancestor) {
    return nodeInLeft.hierNode.ancestor.parentNode === node.parentNode ? nodeInLeft.hierNode.ancestor : ancestor;
  }
  function moveSubtree(wl, wr, shift) {
    var change = shift / (wr.hierNode.i - wl.hierNode.i);
    wr.hierNode.change -= change;
    wr.hierNode.shift += shift;
    wr.hierNode.modifier += shift;
    wr.hierNode.prelim += shift;
    wl.hierNode.change += change;
  }
  function defaultSeparation(node1, node2) {
    return node1.parentNode === node2.parentNode ? 1 : 2;
  }

  // node_modules/echarts/lib/chart/tree/TreeView.js
  var TreeEdgeShape = function() {
    function TreeEdgeShape2() {
      this.parentPoint = [];
      this.childPoints = [];
    }
    return TreeEdgeShape2;
  }();
  var TreePath = function(_super) {
    __extends(TreePath2, _super);
    function TreePath2(opts) {
      return _super.call(this, opts) || this;
    }
    TreePath2.prototype.getDefaultStyle = function() {
      return {
        stroke: "#000",
        fill: null
      };
    };
    TreePath2.prototype.getDefaultShape = function() {
      return new TreeEdgeShape();
    };
    TreePath2.prototype.buildPath = function(ctx, shape) {
      var childPoints = shape.childPoints;
      var childLen = childPoints.length;
      var parentPoint = shape.parentPoint;
      var firstChildPos = childPoints[0];
      var lastChildPos = childPoints[childLen - 1];
      if (childLen === 1) {
        ctx.moveTo(parentPoint[0], parentPoint[1]);
        ctx.lineTo(firstChildPos[0], firstChildPos[1]);
        return;
      }
      var orient = shape.orient;
      var forkDim = orient === "TB" || orient === "BT" ? 0 : 1;
      var otherDim = 1 - forkDim;
      var forkPosition = parsePercent2(shape.forkPosition, 1);
      var tmpPoint = [];
      tmpPoint[forkDim] = parentPoint[forkDim];
      tmpPoint[otherDim] = parentPoint[otherDim] + (lastChildPos[otherDim] - parentPoint[otherDim]) * forkPosition;
      ctx.moveTo(parentPoint[0], parentPoint[1]);
      ctx.lineTo(tmpPoint[0], tmpPoint[1]);
      ctx.moveTo(firstChildPos[0], firstChildPos[1]);
      tmpPoint[forkDim] = firstChildPos[forkDim];
      ctx.lineTo(tmpPoint[0], tmpPoint[1]);
      tmpPoint[forkDim] = lastChildPos[forkDim];
      ctx.lineTo(tmpPoint[0], tmpPoint[1]);
      ctx.lineTo(lastChildPos[0], lastChildPos[1]);
      for (var i = 1; i < childLen - 1; i++) {
        var point = childPoints[i];
        ctx.moveTo(point[0], point[1]);
        tmpPoint[forkDim] = point[forkDim];
        ctx.lineTo(tmpPoint[0], tmpPoint[1]);
      }
    };
    return TreePath2;
  }(Path_default);
  var TreeView = function(_super) {
    __extends(TreeView2, _super);
    function TreeView2() {
      var _this = _super !== null && _super.apply(this, arguments) || this;
      _this.type = TreeView2.type;
      _this._mainGroup = new Group_default();
      return _this;
    }
    TreeView2.prototype.init = function(ecModel, api) {
      this._controller = new RoamController_default(api.getZr());
      this._controllerHost = {
        target: this.group
      };
      this.group.add(this._mainGroup);
    };
    TreeView2.prototype.render = function(seriesModel, ecModel, api) {
      var data = seriesModel.getData();
      var layoutInfo = seriesModel.layoutInfo;
      var group = this._mainGroup;
      var layout5 = seriesModel.get("layout");
      if (layout5 === "radial") {
        group.x = layoutInfo.x + layoutInfo.width / 2;
        group.y = layoutInfo.y + layoutInfo.height / 2;
      } else {
        group.x = layoutInfo.x;
        group.y = layoutInfo.y;
      }
      this._updateViewCoordSys(seriesModel, api);
      this._updateController(seriesModel, ecModel, api);
      var oldData = this._data;
      data.diff(oldData).add(function(newIdx) {
        if (symbolNeedsDraw2(data, newIdx)) {
          updateNode(data, newIdx, null, group, seriesModel);
        }
      }).update(function(newIdx, oldIdx) {
        var symbolEl = oldData.getItemGraphicEl(oldIdx);
        if (!symbolNeedsDraw2(data, newIdx)) {
          symbolEl && removeNode(oldData, oldIdx, symbolEl, group, seriesModel);
          return;
        }
        updateNode(data, newIdx, symbolEl, group, seriesModel);
      }).remove(function(oldIdx) {
        var symbolEl = oldData.getItemGraphicEl(oldIdx);
        if (symbolEl) {
          removeNode(oldData, oldIdx, symbolEl, group, seriesModel);
        }
      }).execute();
      this._nodeScaleRatio = seriesModel.get("nodeScaleRatio");
      this._updateNodeAndLinkScale(seriesModel);
      if (seriesModel.get("expandAndCollapse") === true) {
        data.eachItemGraphicEl(function(el, dataIndex) {
          el.off("click").on("click", function() {
            api.dispatchAction({
              type: "treeExpandAndCollapse",
              seriesId: seriesModel.id,
              dataIndex
            });
          });
        });
      }
      this._data = data;
    };
    TreeView2.prototype._updateViewCoordSys = function(seriesModel, api) {
      var data = seriesModel.getData();
      var points4 = [];
      data.each(function(idx) {
        var layout5 = data.getItemLayout(idx);
        if (layout5 && !isNaN(layout5.x) && !isNaN(layout5.y)) {
          points4.push([+layout5.x, +layout5.y]);
        }
      });
      var min3 = [];
      var max3 = [];
      fromPoints(points4, min3, max3);
      var oldMin = this._min;
      var oldMax = this._max;
      if (max3[0] - min3[0] === 0) {
        min3[0] = oldMin ? oldMin[0] : min3[0] - 1;
        max3[0] = oldMax ? oldMax[0] : max3[0] + 1;
      }
      if (max3[1] - min3[1] === 0) {
        min3[1] = oldMin ? oldMin[1] : min3[1] - 1;
        max3[1] = oldMax ? oldMax[1] : max3[1] + 1;
      }
      var viewCoordSys = seriesModel.coordinateSystem = new View_default();
      viewCoordSys.zoomLimit = seriesModel.get("scaleLimit");
      viewCoordSys.setBoundingRect(min3[0], min3[1], max3[0] - min3[0], max3[1] - min3[1]);
      viewCoordSys.setCenter(seriesModel.get("center"), api);
      viewCoordSys.setZoom(seriesModel.get("zoom"));
      this.group.attr({
        x: viewCoordSys.x,
        y: viewCoordSys.y,
        scaleX: viewCoordSys.scaleX,
        scaleY: viewCoordSys.scaleY
      });
      this._min = min3;
      this._max = max3;
    };
    TreeView2.prototype._updateController = function(seriesModel, ecModel, api) {
      var _this = this;
      var controller = this._controller;
      var controllerHost = this._controllerHost;
      var group = this.group;
      controller.setPointerChecker(function(e2, x, y) {
        var rect = group.getBoundingRect();
        rect.applyTransform(group.transform);
        return rect.contain(x, y) && !onIrrelevantElement(e2, api, seriesModel);
      });
      controller.enable(seriesModel.get("roam"));
      controllerHost.zoomLimit = seriesModel.get("scaleLimit");
      controllerHost.zoom = seriesModel.coordinateSystem.getZoom();
      controller.off("pan").off("zoom").on("pan", function(e2) {
        updateViewOnPan(controllerHost, e2.dx, e2.dy);
        api.dispatchAction({
          seriesId: seriesModel.id,
          type: "treeRoam",
          dx: e2.dx,
          dy: e2.dy
        });
      }).on("zoom", function(e2) {
        updateViewOnZoom(controllerHost, e2.scale, e2.originX, e2.originY);
        api.dispatchAction({
          seriesId: seriesModel.id,
          type: "treeRoam",
          zoom: e2.scale,
          originX: e2.originX,
          originY: e2.originY
        });
        _this._updateNodeAndLinkScale(seriesModel);
        api.updateLabelLayout();
      });
    };
    TreeView2.prototype._updateNodeAndLinkScale = function(seriesModel) {
      var data = seriesModel.getData();
      var nodeScale = this._getNodeGlobalScale(seriesModel);
      data.eachItemGraphicEl(function(el, idx) {
        el.setSymbolScale(nodeScale);
      });
    };
    TreeView2.prototype._getNodeGlobalScale = function(seriesModel) {
      var coordSys = seriesModel.coordinateSystem;
      if (coordSys.type !== "view") {
        return 1;
      }
      var nodeScaleRatio = this._nodeScaleRatio;
      var groupZoom = coordSys.scaleX || 1;
      var roamZoom = coordSys.getZoom();
      var nodeScale = (roamZoom - 1) * nodeScaleRatio + 1;
      return nodeScale / groupZoom;
    };
    TreeView2.prototype.dispose = function() {
      this._controller && this._controller.dispose();
      this._controllerHost = null;
    };
    TreeView2.prototype.remove = function() {
      this._mainGroup.removeAll();
      this._data = null;
    };
    TreeView2.type = "tree";
    return TreeView2;
  }(Chart_default);
  function symbolNeedsDraw2(data, dataIndex) {
    var layout5 = data.getItemLayout(dataIndex);
    return layout5 && !isNaN(layout5.x) && !isNaN(layout5.y);
  }
  function updateNode(data, dataIndex, symbolEl, group, seriesModel) {
    var isInit = !symbolEl;
    var node = data.tree.getNodeByDataIndex(dataIndex);
    var itemModel = node.getModel();
    var visualColor = node.getVisual("style").fill;
    var symbolInnerColor = node.isExpand === false && node.children.length !== 0 ? visualColor : "#fff";
    var virtualRoot = data.tree.root;
    var source = node.parentNode === virtualRoot ? node : node.parentNode || node;
    var sourceSymbolEl = data.getItemGraphicEl(source.dataIndex);
    var sourceLayout = source.getLayout();
    var sourceOldLayout = sourceSymbolEl ? {
      x: sourceSymbolEl.__oldX,
      y: sourceSymbolEl.__oldY,
      rawX: sourceSymbolEl.__radialOldRawX,
      rawY: sourceSymbolEl.__radialOldRawY
    } : sourceLayout;
    var targetLayout = node.getLayout();
    if (isInit) {
      symbolEl = new Symbol_default(data, dataIndex, null, {
        symbolInnerColor,
        useNameLabel: true
      });
      symbolEl.x = sourceOldLayout.x;
      symbolEl.y = sourceOldLayout.y;
    } else {
      symbolEl.updateData(data, dataIndex, null, {
        symbolInnerColor,
        useNameLabel: true
      });
    }
    symbolEl.__radialOldRawX = symbolEl.__radialRawX;
    symbolEl.__radialOldRawY = symbolEl.__radialRawY;
    symbolEl.__radialRawX = targetLayout.rawX;
    symbolEl.__radialRawY = targetLayout.rawY;
    group.add(symbolEl);
    data.setItemGraphicEl(dataIndex, symbolEl);
    symbolEl.__oldX = symbolEl.x;
    symbolEl.__oldY = symbolEl.y;
    updateProps(symbolEl, {
      x: targetLayout.x,
      y: targetLayout.y
    }, seriesModel);
    var symbolPath = symbolEl.getSymbolPath();
    if (seriesModel.get("layout") === "radial") {
      var realRoot = virtualRoot.children[0];
      var rootLayout = realRoot.getLayout();
      var length_1 = realRoot.children.length;
      var rad = void 0;
      var isLeft = void 0;
      if (targetLayout.x === rootLayout.x && node.isExpand === true && realRoot.children.length) {
        var center3 = {
          x: (realRoot.children[0].getLayout().x + realRoot.children[length_1 - 1].getLayout().x) / 2,
          y: (realRoot.children[0].getLayout().y + realRoot.children[length_1 - 1].getLayout().y) / 2
        };
        rad = Math.atan2(center3.y - rootLayout.y, center3.x - rootLayout.x);
        if (rad < 0) {
          rad = Math.PI * 2 + rad;
        }
        isLeft = center3.x < rootLayout.x;
        if (isLeft) {
          rad = rad - Math.PI;
        }
      } else {
        rad = Math.atan2(targetLayout.y - rootLayout.y, targetLayout.x - rootLayout.x);
        if (rad < 0) {
          rad = Math.PI * 2 + rad;
        }
        if (node.children.length === 0 || node.children.length !== 0 && node.isExpand === false) {
          isLeft = targetLayout.x < rootLayout.x;
          if (isLeft) {
            rad = rad - Math.PI;
          }
        } else {
          isLeft = targetLayout.x > rootLayout.x;
          if (!isLeft) {
            rad = rad - Math.PI;
          }
        }
      }
      var textPosition = isLeft ? "left" : "right";
      var normalLabelModel = itemModel.getModel("label");
      var rotate2 = normalLabelModel.get("rotate");
      var labelRotateRadian = rotate2 * (Math.PI / 180);
      var textContent = symbolPath.getTextContent();
      if (textContent) {
        symbolPath.setTextConfig({
          position: normalLabelModel.get("position") || textPosition,
          rotation: rotate2 == null ? -rad : labelRotateRadian,
          origin: "center"
        });
        textContent.setStyle("verticalAlign", "middle");
      }
    }
    var focus = itemModel.get(["emphasis", "focus"]);
    var focusDataIndices = focus === "relative" ? concatArray(node.getAncestorsIndices(), node.getDescendantIndices()) : focus === "ancestor" ? node.getAncestorsIndices() : focus === "descendant" ? node.getDescendantIndices() : null;
    if (focusDataIndices) {
      getECData(symbolEl).focus = focusDataIndices;
    }
    drawEdge(seriesModel, node, virtualRoot, symbolEl, sourceOldLayout, sourceLayout, targetLayout, group);
    if (symbolEl.__edge) {
      symbolEl.onHoverStateChange = function(toState) {
        if (toState !== "blur") {
          var parentEl = node.parentNode && data.getItemGraphicEl(node.parentNode.dataIndex);
          if (!(parentEl && parentEl.hoverState === HOVER_STATE_BLUR)) {
            setStatesFlag(symbolEl.__edge, toState);
          }
        }
      };
    }
  }
  function drawEdge(seriesModel, node, virtualRoot, symbolEl, sourceOldLayout, sourceLayout, targetLayout, group) {
    var itemModel = node.getModel();
    var edgeShape = seriesModel.get("edgeShape");
    var layout5 = seriesModel.get("layout");
    var orient = seriesModel.getOrient();
    var curvature = seriesModel.get(["lineStyle", "curveness"]);
    var edgeForkPosition = seriesModel.get("edgeForkPosition");
    var lineStyle = itemModel.getModel("lineStyle").getLineStyle();
    var edge = symbolEl.__edge;
    if (edgeShape === "curve") {
      if (node.parentNode && node.parentNode !== virtualRoot) {
        if (!edge) {
          edge = symbolEl.__edge = new BezierCurve_default({
            shape: getEdgeShape(layout5, orient, curvature, sourceOldLayout, sourceOldLayout)
          });
        }
        updateProps(edge, {
          shape: getEdgeShape(layout5, orient, curvature, sourceLayout, targetLayout)
        }, seriesModel);
      }
    } else if (edgeShape === "polyline") {
      if (layout5 === "orthogonal") {
        if (node !== virtualRoot && node.children && node.children.length !== 0 && node.isExpand === true) {
          var children = node.children;
          var childPoints = [];
          for (var i = 0; i < children.length; i++) {
            var childLayout = children[i].getLayout();
            childPoints.push([childLayout.x, childLayout.y]);
          }
          if (!edge) {
            edge = symbolEl.__edge = new TreePath({
              shape: {
                parentPoint: [targetLayout.x, targetLayout.y],
                childPoints: [[targetLayout.x, targetLayout.y]],
                orient,
                forkPosition: edgeForkPosition
              }
            });
          }
          updateProps(edge, {
            shape: {
              parentPoint: [targetLayout.x, targetLayout.y],
              childPoints
            }
          }, seriesModel);
        }
      } else {
        if (true) {
          throw new Error("The polyline edgeShape can only be used in orthogonal layout");
        }
      }
    }
    if (edge && !(edgeShape === "polyline" && !node.isExpand)) {
      edge.useStyle(defaults({
        strokeNoScale: true,
        fill: null
      }, lineStyle));
      setStatesStylesFromModel(edge, itemModel, "lineStyle");
      setDefaultStateProxy(edge);
      group.add(edge);
    }
  }
  function removeNodeEdge(node, data, group, seriesModel, removeAnimationOpt) {
    var virtualRoot = data.tree.root;
    var _a2 = getSourceNode(virtualRoot, node), source = _a2.source, sourceLayout = _a2.sourceLayout;
    var symbolEl = data.getItemGraphicEl(node.dataIndex);
    if (!symbolEl) {
      return;
    }
    var sourceSymbolEl = data.getItemGraphicEl(source.dataIndex);
    var sourceEdge = sourceSymbolEl.__edge;
    var edge = symbolEl.__edge || (source.isExpand === false || source.children.length === 1 ? sourceEdge : void 0);
    var edgeShape = seriesModel.get("edgeShape");
    var layoutOpt = seriesModel.get("layout");
    var orient = seriesModel.get("orient");
    var curvature = seriesModel.get(["lineStyle", "curveness"]);
    if (edge) {
      if (edgeShape === "curve") {
        removeElement(edge, {
          shape: getEdgeShape(layoutOpt, orient, curvature, sourceLayout, sourceLayout),
          style: {
            opacity: 0
          }
        }, seriesModel, {
          cb: function() {
            group.remove(edge);
          },
          removeOpt: removeAnimationOpt
        });
      } else if (edgeShape === "polyline" && seriesModel.get("layout") === "orthogonal") {
        removeElement(edge, {
          shape: {
            parentPoint: [sourceLayout.x, sourceLayout.y],
            childPoints: [[sourceLayout.x, sourceLayout.y]]
          },
          style: {
            opacity: 0
          }
        }, seriesModel, {
          cb: function() {
            group.remove(edge);
          },
          removeOpt: removeAnimationOpt
        });
      }
    }
  }
  function getSourceNode(virtualRoot, node) {
    var source = node.parentNode === virtualRoot ? node : node.parentNode || node;
    var sourceLayout;
    while (sourceLayout = source.getLayout(), sourceLayout == null) {
      source = source.parentNode === virtualRoot ? source : source.parentNode || source;
    }
    return {
      source,
      sourceLayout
    };
  }
  function removeNode(data, dataIndex, symbolEl, group, seriesModel) {
    var node = data.tree.getNodeByDataIndex(dataIndex);
    var virtualRoot = data.tree.root;
    var sourceLayout = getSourceNode(virtualRoot, node).sourceLayout;
    var removeAnimationOpt = {
      duration: seriesModel.get("animationDurationUpdate"),
      easing: seriesModel.get("animationEasingUpdate")
    };
    removeElement(symbolEl, {
      x: sourceLayout.x + 1,
      y: sourceLayout.y + 1
    }, seriesModel, {
      cb: function() {
        group.remove(symbolEl);
        data.setItemGraphicEl(dataIndex, null);
      },
      removeOpt: removeAnimationOpt
    });
    symbolEl.fadeOut(null, data.hostModel, {
      fadeLabel: true,
      animation: removeAnimationOpt
    });
    node.children.forEach(function(childNode) {
      removeNodeEdge(childNode, data, group, seriesModel, removeAnimationOpt);
    });
    removeNodeEdge(node, data, group, seriesModel, removeAnimationOpt);
  }
  function getEdgeShape(layoutOpt, orient, curvature, sourceLayout, targetLayout) {
    var cpx1;
    var cpy1;
    var cpx2;
    var cpy2;
    var x1;
    var x2;
    var y1;
    var y2;
    if (layoutOpt === "radial") {
      x1 = sourceLayout.rawX;
      y1 = sourceLayout.rawY;
      x2 = targetLayout.rawX;
      y2 = targetLayout.rawY;
      var radialCoor1 = radialCoordinate(x1, y1);
      var radialCoor2 = radialCoordinate(x1, y1 + (y2 - y1) * curvature);
      var radialCoor3 = radialCoordinate(x2, y2 + (y1 - y2) * curvature);
      var radialCoor4 = radialCoordinate(x2, y2);
      return {
        x1: radialCoor1.x || 0,
        y1: radialCoor1.y || 0,
        x2: radialCoor4.x || 0,
        y2: radialCoor4.y || 0,
        cpx1: radialCoor2.x || 0,
        cpy1: radialCoor2.y || 0,
        cpx2: radialCoor3.x || 0,
        cpy2: radialCoor3.y || 0
      };
    } else {
      x1 = sourceLayout.x;
      y1 = sourceLayout.y;
      x2 = targetLayout.x;
      y2 = targetLayout.y;
      if (orient === "LR" || orient === "RL") {
        cpx1 = x1 + (x2 - x1) * curvature;
        cpy1 = y1;
        cpx2 = x2 + (x1 - x2) * curvature;
        cpy2 = y2;
      }
      if (orient === "TB" || orient === "BT") {
        cpx1 = x1;
        cpy1 = y1 + (y2 - y1) * curvature;
        cpx2 = x2;
        cpy2 = y2 + (y1 - y2) * curvature;
      }
    }
    return {
      x1,
      y1,
      x2,
      y2,
      cpx1,
      cpy1,
      cpx2,
      cpy2
    };
  }
  var TreeView_default = TreeView;

  // node_modules/echarts/lib/data/helper/linkSeriesData.js
  var inner8 = makeInner();
  function linkSeriesData(opt) {
    var mainData = opt.mainData;
    var datas = opt.datas;
    if (!datas) {
      datas = {
        main: mainData
      };
      opt.datasAttr = {
        main: "data"
      };
    }
    opt.datas = opt.mainData = null;
    linkAll(mainData, datas, opt);
    each(datas, function(data) {
      each(mainData.TRANSFERABLE_METHODS, function(methodName) {
        data.wrapMethod(methodName, curry(transferInjection, opt));
      });
    });
    mainData.wrapMethod("cloneShallow", curry(cloneShallowInjection, opt));
    each(mainData.CHANGABLE_METHODS, function(methodName) {
      mainData.wrapMethod(methodName, curry(changeInjection, opt));
    });
    assert(datas[mainData.dataType] === mainData);
  }
  function transferInjection(opt, res) {
    if (isMainData(this)) {
      var datas = extend({}, inner8(this).datas);
      datas[this.dataType] = res;
      linkAll(res, datas, opt);
    } else {
      linkSingle(res, this.dataType, inner8(this).mainData, opt);
    }
    return res;
  }
  function changeInjection(opt, res) {
    opt.struct && opt.struct.update();
    return res;
  }
  function cloneShallowInjection(opt, res) {
    each(inner8(res).datas, function(data, dataType) {
      data !== res && linkSingle(data.cloneShallow(), dataType, res, opt);
    });
    return res;
  }
  function getLinkedData(dataType) {
    var mainData = inner8(this).mainData;
    return dataType == null || mainData == null ? mainData : inner8(mainData).datas[dataType];
  }
  function getLinkedDataAll() {
    var mainData = inner8(this).mainData;
    return mainData == null ? [{
      data: mainData
    }] : map(keys(inner8(mainData).datas), function(type) {
      return {
        type,
        data: inner8(mainData).datas[type]
      };
    });
  }
  function isMainData(data) {
    return inner8(data).mainData === data;
  }
  function linkAll(mainData, datas, opt) {
    inner8(mainData).datas = {};
    each(datas, function(data, dataType) {
      linkSingle(data, dataType, mainData, opt);
    });
  }
  function linkSingle(data, dataType, mainData, opt) {
    inner8(mainData).datas[dataType] = data;
    inner8(data).mainData = mainData;
    data.dataType = dataType;
    if (opt.struct) {
      data[opt.structAttr] = opt.struct;
      opt.struct[opt.datasAttr[dataType]] = data;
    }
    data.getLinkedData = getLinkedData;
    data.getLinkedDataAll = getLinkedDataAll;
  }
  var linkSeriesData_default = linkSeriesData;

  // node_modules/echarts/lib/data/Tree.js
  var TreeNode = function() {
    function TreeNode2(name, hostTree) {
      this.depth = 0;
      this.height = 0;
      this.dataIndex = -1;
      this.children = [];
      this.viewChildren = [];
      this.isExpand = false;
      this.name = name || "";
      this.hostTree = hostTree;
    }
    TreeNode2.prototype.isRemoved = function() {
      return this.dataIndex < 0;
    };
    TreeNode2.prototype.eachNode = function(options, cb, context) {
      if (isFunction(options)) {
        context = cb;
        cb = options;
        options = null;
      }
      options = options || {};
      if (isString(options)) {
        options = {
          order: options
        };
      }
      var order = options.order || "preorder";
      var children = this[options.attr || "children"];
      var suppressVisitSub;
      order === "preorder" && (suppressVisitSub = cb.call(context, this));
      for (var i = 0; !suppressVisitSub && i < children.length; i++) {
        children[i].eachNode(options, cb, context);
      }
      order === "postorder" && cb.call(context, this);
    };
    TreeNode2.prototype.updateDepthAndHeight = function(depth) {
      var height = 0;
      this.depth = depth;
      for (var i = 0; i < this.children.length; i++) {
        var child = this.children[i];
        child.updateDepthAndHeight(depth + 1);
        if (child.height > height) {
          height = child.height;
        }
      }
      this.height = height + 1;
    };
    TreeNode2.prototype.getNodeById = function(id) {
      if (this.getId() === id) {
        return this;
      }
      for (var i = 0, children = this.children, len2 = children.length; i < len2; i++) {
        var res = children[i].getNodeById(id);
        if (res) {
          return res;
        }
      }
    };
    TreeNode2.prototype.contains = function(node) {
      if (node === this) {
        return true;
      }
      for (var i = 0, children = this.children, len2 = children.length; i < len2; i++) {
        var res = children[i].contains(node);
        if (res) {
          return res;
        }
      }
    };
    TreeNode2.prototype.getAncestors = function(includeSelf) {
      var ancestors = [];
      var node = includeSelf ? this : this.parentNode;
      while (node) {
        ancestors.push(node);
        node = node.parentNode;
      }
      ancestors.reverse();
      return ancestors;
    };
    TreeNode2.prototype.getAncestorsIndices = function() {
      var indices = [];
      var currNode = this;
      while (currNode) {
        indices.push(currNode.dataIndex);
        currNode = currNode.parentNode;
      }
      indices.reverse();
      return indices;
    };
    TreeNode2.prototype.getDescendantIndices = function() {
      var indices = [];
      this.eachNode(function(childNode) {
        indices.push(childNode.dataIndex);
      });
      return indices;
    };
    TreeNode2.prototype.getValue = function(dimension) {
      var data = this.hostTree.data;
      return data.getStore().get(data.getDimensionIndex(dimension || "value"), this.dataIndex);
    };
    TreeNode2.prototype.setLayout = function(layout5, merge2) {
      this.dataIndex >= 0 && this.hostTree.data.setItemLayout(this.dataIndex, layout5, merge2);
    };
    TreeNode2.prototype.getLayout = function() {
      return this.hostTree.data.getItemLayout(this.dataIndex);
    };
    TreeNode2.prototype.getModel = function(path) {
      if (this.dataIndex < 0) {
        return;
      }
      var hostTree = this.hostTree;
      var itemModel = hostTree.data.getItemModel(this.dataIndex);
      return itemModel.getModel(path);
    };
    TreeNode2.prototype.getLevelModel = function() {
      return (this.hostTree.levelModels || [])[this.depth];
    };
    TreeNode2.prototype.setVisual = function(key, value) {
      this.dataIndex >= 0 && this.hostTree.data.setItemVisual(this.dataIndex, key, value);
    };
    TreeNode2.prototype.getVisual = function(key) {
      return this.hostTree.data.getItemVisual(this.dataIndex, key);
    };
    TreeNode2.prototype.getRawIndex = function() {
      return this.hostTree.data.getRawIndex(this.dataIndex);
    };
    TreeNode2.prototype.getId = function() {
      return this.hostTree.data.getId(this.dataIndex);
    };
    TreeNode2.prototype.getChildIndex = function() {
      if (this.parentNode) {
        var children = this.parentNode.children;
        for (var i = 0; i < children.length; ++i) {
          if (children[i] === this) {
            return i;
          }
        }
        return -1;
      }
      return -1;
    };
    TreeNode2.prototype.isAncestorOf = function(node) {
      var parent = node.parentNode;
      while (parent) {
        if (parent === this) {
          return true;
        }
        parent = parent.parentNode;
      }
      return false;
    };
    TreeNode2.prototype.isDescendantOf = function(node) {
      return node !== this && node.isAncestorOf(this);
    };
    return TreeNode2;
  }();
  var Tree = function() {
    function Tree2(hostModel) {
      this.type = "tree";
      this._nodes = [];
      this.hostModel = hostModel;
    }
    Tree2.prototype.eachNode = function(options, cb, context) {
      this.root.eachNode(options, cb, context);
    };
    Tree2.prototype.getNodeByDataIndex = function(dataIndex) {
      var rawIndex = this.data.getRawIndex(dataIndex);
      return this._nodes[rawIndex];
    };
    Tree2.prototype.getNodeById = function(name) {
      return this.root.getNodeById(name);
    };
    Tree2.prototype.update = function() {
      var data = this.data;
      var nodes = this._nodes;
      for (var i = 0, len2 = nodes.length; i < len2; i++) {
        nodes[i].dataIndex = -1;
      }
      for (var i = 0, len2 = data.count(); i < len2; i++) {
        nodes[data.getRawIndex(i)].dataIndex = i;
      }
    };
    Tree2.prototype.clearLayouts = function() {
      this.data.clearItemLayouts();
    };
    Tree2.createTree = function(dataRoot, hostModel, beforeLink) {
      var tree = new Tree2(hostModel);
      var listData = [];
      var dimMax = 1;
      buildHierarchy(dataRoot);
      function buildHierarchy(dataNode, parentNode2) {
        var value = dataNode.value;
        dimMax = Math.max(dimMax, isArray(value) ? value.length : 1);
        listData.push(dataNode);
        var node = new TreeNode(convertOptionIdName(dataNode.name, ""), tree);
        parentNode2 ? addChild(node, parentNode2) : tree.root = node;
        tree._nodes.push(node);
        var children = dataNode.children;
        if (children) {
          for (var i = 0; i < children.length; i++) {
            buildHierarchy(children[i], node);
          }
        }
      }
      tree.root.updateDepthAndHeight(0);
      var dimensions = prepareSeriesDataSchema(listData, {
        coordDimensions: ["value"],
        dimensionsCount: dimMax
      }).dimensions;
      var list = new SeriesData_default(dimensions, hostModel);
      list.initData(listData);
      beforeLink && beforeLink(list);
      linkSeriesData_default({
        mainData: list,
        struct: tree,
        structAttr: "tree"
      });
      tree.update();
      return tree;
    };
    return Tree2;
  }();
  function addChild(child, node) {
    var children = node.children;
    if (child.parentNode === node) {
      return;
    }
    children.push(child);
    child.parentNode = node;
  }
  var Tree_default = Tree;

  // node_modules/echarts/lib/chart/helper/treeHelper.js
  function retrieveTargetInfo(payload, validPayloadTypes, seriesModel) {
    if (payload && indexOf(validPayloadTypes, payload.type) >= 0) {
      var root = seriesModel.getData().tree.root;
      var targetNode = payload.targetNode;
      if (isString(targetNode)) {
        targetNode = root.getNodeById(targetNode);
      }
      if (targetNode && root.contains(targetNode)) {
        return {
          node: targetNode
        };
      }
      var targetNodeId = payload.targetNodeId;
      if (targetNodeId != null && (targetNode = root.getNodeById(targetNodeId))) {
        return {
          node: targetNode
        };
      }
    }
  }
  function getPathToRoot(node) {
    var path = [];
    while (node) {
      node = node.parentNode;
      node && path.push(node);
    }
    return path.reverse();
  }
  function aboveViewRoot(viewRoot, node) {
    var viewPath = getPathToRoot(viewRoot);
    return indexOf(viewPath, node) >= 0;
  }
  function wrapTreePathInfo(node, seriesModel) {
    var treePathInfo = [];
    while (node) {
      var nodeDataIndex = node.dataIndex;
      treePathInfo.push({
        name: node.name,
        dataIndex: nodeDataIndex,
        value: seriesModel.getRawValue(nodeDataIndex)
      });
      node = node.parentNode;
    }
    treePathInfo.reverse();
    return treePathInfo;
  }

  // node_modules/echarts/lib/chart/tree/TreeSeries.js
  var TreeSeriesModel = function(_super) {
    __extends(TreeSeriesModel2, _super);
    function TreeSeriesModel2() {
      var _this = _super !== null && _super.apply(this, arguments) || this;
      _this.hasSymbolVisual = true;
      _this.ignoreStyleOnData = true;
      return _this;
    }
    TreeSeriesModel2.prototype.getInitialData = function(option) {
      var root = {
        name: option.name,
        children: option.data
      };
      var leaves = option.leaves || {};
      var leavesModel = new Model_default(leaves, this, this.ecModel);
      var tree = Tree_default.createTree(root, this, beforeLink);
      function beforeLink(nodeData) {
        nodeData.wrapMethod("getItemModel", function(model, idx) {
          var node = tree.getNodeByDataIndex(idx);
          if (!(node && node.children.length && node.isExpand)) {
            model.parentModel = leavesModel;
          }
          return model;
        });
      }
      var treeDepth = 0;
      tree.eachNode("preorder", function(node) {
        if (node.depth > treeDepth) {
          treeDepth = node.depth;
        }
      });
      var expandAndCollapse = option.expandAndCollapse;
      var expandTreeDepth = expandAndCollapse && option.initialTreeDepth >= 0 ? option.initialTreeDepth : treeDepth;
      tree.root.eachNode("preorder", function(node) {
        var item = node.hostTree.data.getRawDataItem(node.dataIndex);
        node.isExpand = item && item.collapsed != null ? !item.collapsed : node.depth <= expandTreeDepth;
      });
      return tree.data;
    };
    TreeSeriesModel2.prototype.getOrient = function() {
      var orient = this.get("orient");
      if (orient === "horizontal") {
        orient = "LR";
      } else if (orient === "vertical") {
        orient = "TB";
      }
      return orient;
    };
    TreeSeriesModel2.prototype.setZoom = function(zoom) {
      this.option.zoom = zoom;
    };
    TreeSeriesModel2.prototype.setCenter = function(center3) {
      this.option.center = center3;
    };
    TreeSeriesModel2.prototype.formatTooltip = function(dataIndex, multipleSeries, dataType) {
      var tree = this.getData().tree;
      var realRoot = tree.root.children[0];
      var node = tree.getNodeByDataIndex(dataIndex);
      var value = node.getValue();
      var name = node.name;
      while (node && node !== realRoot) {
        name = node.parentNode.name + "." + name;
        node = node.parentNode;
      }
      return createTooltipMarkup("nameValue", {
        name,
        value,
        noValue: isNaN(value) || value == null
      });
    };
    TreeSeriesModel2.prototype.getDataParams = function(dataIndex) {
      var params = _super.prototype.getDataParams.apply(this, arguments);
      var node = this.getData().tree.getNodeByDataIndex(dataIndex);
      params.treeAncestors = wrapTreePathInfo(node, this);
      params.collapsed = !node.isExpand;
      return params;
    };
    TreeSeriesModel2.type = "series.tree";
    TreeSeriesModel2.layoutMode = "box";
    TreeSeriesModel2.defaultOption = {
      z: 2,
      coordinateSystem: "view",
      left: "12%",
      top: "12%",
      right: "12%",
      bottom: "12%",
      layout: "orthogonal",
      edgeShape: "curve",
      edgeForkPosition: "50%",
      roam: false,
      nodeScaleRatio: 0.4,
      center: null,
      zoom: 1,
      orient: "LR",
      symbol: "emptyCircle",
      symbolSize: 7,
      expandAndCollapse: true,
      initialTreeDepth: 2,
      lineStyle: {
        color: "#ccc",
        width: 1.5,
        curveness: 0.5
      },
      itemStyle: {
        color: "lightsteelblue",
        borderWidth: 1.5
      },
      label: {
        show: true
      },
      animationEasing: "linear",
      animationDuration: 700,
      animationDurationUpdate: 500
    };
    return TreeSeriesModel2;
  }(Series_default);
  var TreeSeries_default = TreeSeriesModel;

  // node_modules/echarts/lib/chart/tree/traversalHelper.js
  function eachAfter(root, callback, separation2) {
    var nodes = [root];
    var next = [];
    var node;
    while (node = nodes.pop()) {
      next.push(node);
      if (node.isExpand) {
        var children = node.children;
        if (children.length) {
          for (var i = 0; i < children.length; i++) {
            nodes.push(children[i]);
          }
        }
      }
    }
    while (node = next.pop()) {
      callback(node, separation2);
    }
  }
  function eachBefore(root, callback) {
    var nodes = [root];
    var node;
    while (node = nodes.pop()) {
      callback(node);
      if (node.isExpand) {
        var children = node.children;
        if (children.length) {
          for (var i = children.length - 1; i >= 0; i--) {
            nodes.push(children[i]);
          }
        }
      }
    }
  }

  // node_modules/echarts/lib/chart/tree/treeLayout.js
  function treeLayout(ecModel, api) {
    ecModel.eachSeriesByType("tree", function(seriesModel) {
      commonLayout(seriesModel, api);
    });
  }
  function commonLayout(seriesModel, api) {
    var layoutInfo = getViewRect2(seriesModel, api);
    seriesModel.layoutInfo = layoutInfo;
    var layout5 = seriesModel.get("layout");
    var width = 0;
    var height = 0;
    var separation2 = null;
    if (layout5 === "radial") {
      width = 2 * Math.PI;
      height = Math.min(layoutInfo.height, layoutInfo.width) / 2;
      separation2 = separation(function(node1, node2) {
        return (node1.parentNode === node2.parentNode ? 1 : 2) / node1.depth;
      });
    } else {
      width = layoutInfo.width;
      height = layoutInfo.height;
      separation2 = separation();
    }
    var virtualRoot = seriesModel.getData().tree.root;
    var realRoot = virtualRoot.children[0];
    if (realRoot) {
      init3(virtualRoot);
      eachAfter(realRoot, firstWalk, separation2);
      virtualRoot.hierNode.modifier = -realRoot.hierNode.prelim;
      eachBefore(realRoot, secondWalk);
      var left_1 = realRoot;
      var right_1 = realRoot;
      var bottom_1 = realRoot;
      eachBefore(realRoot, function(node) {
        var x = node.getLayout().x;
        if (x < left_1.getLayout().x) {
          left_1 = node;
        }
        if (x > right_1.getLayout().x) {
          right_1 = node;
        }
        if (node.depth > bottom_1.depth) {
          bottom_1 = node;
        }
      });
      var delta = left_1 === right_1 ? 1 : separation2(left_1, right_1) / 2;
      var tx_1 = delta - left_1.getLayout().x;
      var kx_1 = 0;
      var ky_1 = 0;
      var coorX_1 = 0;
      var coorY_1 = 0;
      if (layout5 === "radial") {
        kx_1 = width / (right_1.getLayout().x + delta + tx_1);
        ky_1 = height / (bottom_1.depth - 1 || 1);
        eachBefore(realRoot, function(node) {
          coorX_1 = (node.getLayout().x + tx_1) * kx_1;
          coorY_1 = (node.depth - 1) * ky_1;
          var finalCoor = radialCoordinate(coorX_1, coorY_1);
          node.setLayout({
            x: finalCoor.x,
            y: finalCoor.y,
            rawX: coorX_1,
            rawY: coorY_1
          }, true);
        });
      } else {
        var orient_1 = seriesModel.getOrient();
        if (orient_1 === "RL" || orient_1 === "LR") {
          ky_1 = height / (right_1.getLayout().x + delta + tx_1);
          kx_1 = width / (bottom_1.depth - 1 || 1);
          eachBefore(realRoot, function(node) {
            coorY_1 = (node.getLayout().x + tx_1) * ky_1;
            coorX_1 = orient_1 === "LR" ? (node.depth - 1) * kx_1 : width - (node.depth - 1) * kx_1;
            node.setLayout({
              x: coorX_1,
              y: coorY_1
            }, true);
          });
        } else if (orient_1 === "TB" || orient_1 === "BT") {
          kx_1 = width / (right_1.getLayout().x + delta + tx_1);
          ky_1 = height / (bottom_1.depth - 1 || 1);
          eachBefore(realRoot, function(node) {
            coorX_1 = (node.getLayout().x + tx_1) * kx_1;
            coorY_1 = orient_1 === "TB" ? (node.depth - 1) * ky_1 : height - (node.depth - 1) * ky_1;
            node.setLayout({
              x: coorX_1,
              y: coorY_1
            }, true);
          });
        }
      }
    }
  }

  // node_modules/echarts/lib/chart/tree/treeVisual.js
  function treeVisual(ecModel) {
    ecModel.eachSeriesByType("tree", function(seriesModel) {
      var data = seriesModel.getData();
      var tree = data.tree;
      tree.eachNode(function(node) {
        var model = node.getModel();
        var style = model.getModel("itemStyle").getItemStyle();
        var existsStyle = data.ensureUniqueItemVisual(node.dataIndex, "style");
        extend(existsStyle, style);
      });
    });
  }

  // node_modules/echarts/lib/chart/tree/treeAction.js
  function installTreeAction(registers) {
    registers.registerAction({
      type: "treeExpandAndCollapse",
      event: "treeExpandAndCollapse",
      update: "update"
    }, function(payload, ecModel) {
      ecModel.eachComponent({
        mainType: "series",
        subType: "tree",
        query: payload
      }, function(seriesModel) {
        var dataIndex = payload.dataIndex;
        var tree = seriesModel.getData().tree;
        var node = tree.getNodeByDataIndex(dataIndex);
        node.isExpand = !node.isExpand;
      });
    });
    registers.registerAction({
      type: "treeRoam",
      event: "treeRoam",
      update: "none"
    }, function(payload, ecModel, api) {
      ecModel.eachComponent({
        mainType: "series",
        subType: "tree",
        query: payload
      }, function(seriesModel) {
        var coordSys = seriesModel.coordinateSystem;
        var res = updateCenterAndZoom(coordSys, payload, void 0, api);
        seriesModel.setCenter && seriesModel.setCenter(res.center);
        seriesModel.setZoom && seriesModel.setZoom(res.zoom);
      });
    });
  }

  // node_modules/echarts/lib/chart/tree/install.js
  function install12(registers) {
    registers.registerChartView(TreeView_default);
    registers.registerSeriesModel(TreeSeries_default);
    registers.registerLayout(treeLayout);
    registers.registerVisual(treeVisual);
    installTreeAction(registers);
  }

  // node_modules/echarts/lib/chart/treemap/treemapAction.js
  var actionTypes = ["treemapZoomToNode", "treemapRender", "treemapMove"];
  function installTreemapAction(registers) {
    for (var i = 0; i < actionTypes.length; i++) {
      registers.registerAction({
        type: actionTypes[i],
        update: "updateView"
      }, noop);
    }
    registers.registerAction({
      type: "treemapRootToNode",
      update: "updateView"
    }, function(payload, ecModel) {
      ecModel.eachComponent({
        mainType: "series",
        subType: "treemap",
        query: payload
      }, handleRootToNode);
      function handleRootToNode(model, index) {
        var types = ["treemapZoomToNode", "treemapRootToNode"];
        var targetInfo = retrieveTargetInfo(payload, types, model);
        if (targetInfo) {
          var originViewRoot = model.getViewRoot();
          if (originViewRoot) {
            payload.direction = aboveViewRoot(originViewRoot, targetInfo.node) ? "rollUp" : "drillDown";
          }
          model.resetViewRoot(targetInfo.node);
        }
      }
    });
  }

  // node_modules/echarts/lib/chart/helper/enableAriaDecalForTree.js
  function enableAriaDecalForTree(seriesModel) {
    var data = seriesModel.getData();
    var tree = data.tree;
    var decalPaletteScope2 = {};
    tree.eachNode(function(node) {
      var current = node;
      while (current && current.depth > 1) {
        current = current.parentNode;
      }
      var decal = getDecalFromPalette(seriesModel.ecModel, current.name || current.dataIndex + "", decalPaletteScope2);
      node.setVisual("decal", decal);
    });
  }

  // node_modules/echarts/lib/chart/treemap/TreemapSeries.js
  var TreemapSeriesModel = function(_super) {
    __extends(TreemapSeriesModel2, _super);
    function TreemapSeriesModel2() {
      var _this = _super !== null && _super.apply(this, arguments) || this;
      _this.type = TreemapSeriesModel2.type;
      _this.preventUsingHoverLayer = true;
      return _this;
    }
    TreemapSeriesModel2.prototype.getInitialData = function(option, ecModel) {
      var root = {
        name: option.name,
        children: option.data
      };
      completeTreeValue(root);
      var levels = option.levels || [];
      var designatedVisualItemStyle = this.designatedVisualItemStyle = {};
      var designatedVisualModel = new Model_default({
        itemStyle: designatedVisualItemStyle
      }, this, ecModel);
      levels = option.levels = setDefault(levels, ecModel);
      var levelModels = map(levels || [], function(levelDefine) {
        return new Model_default(levelDefine, designatedVisualModel, ecModel);
      }, this);
      var tree = Tree_default.createTree(root, this, beforeLink);
      function beforeLink(nodeData) {
        nodeData.wrapMethod("getItemModel", function(model, idx) {
          var node = tree.getNodeByDataIndex(idx);
          var levelModel = node ? levelModels[node.depth] : null;
          model.parentModel = levelModel || designatedVisualModel;
          return model;
        });
      }
      return tree.data;
    };
    TreemapSeriesModel2.prototype.optionUpdated = function() {
      this.resetViewRoot();
    };
    TreemapSeriesModel2.prototype.formatTooltip = function(dataIndex, multipleSeries, dataType) {
      var data = this.getData();
      var value = this.getRawValue(dataIndex);
      var name = data.getName(dataIndex);
      return createTooltipMarkup("nameValue", {
        name,
        value
      });
    };
    TreemapSeriesModel2.prototype.getDataParams = function(dataIndex) {
      var params = _super.prototype.getDataParams.apply(this, arguments);
      var node = this.getData().tree.getNodeByDataIndex(dataIndex);
      params.treeAncestors = wrapTreePathInfo(node, this);
      params.treePathInfo = params.treeAncestors;
      return params;
    };
    TreemapSeriesModel2.prototype.setLayoutInfo = function(layoutInfo) {
      this.layoutInfo = this.layoutInfo || {};
      extend(this.layoutInfo, layoutInfo);
    };
    TreemapSeriesModel2.prototype.mapIdToIndex = function(id) {
      var idIndexMap = this._idIndexMap;
      if (!idIndexMap) {
        idIndexMap = this._idIndexMap = createHashMap();
        this._idIndexMapCount = 0;
      }
      var index = idIndexMap.get(id);
      if (index == null) {
        idIndexMap.set(id, index = this._idIndexMapCount++);
      }
      return index;
    };
    TreemapSeriesModel2.prototype.getViewRoot = function() {
      return this._viewRoot;
    };
    TreemapSeriesModel2.prototype.resetViewRoot = function(viewRoot) {
      viewRoot ? this._viewRoot = viewRoot : viewRoot = this._viewRoot;
      var root = this.getRawData().tree.root;
      if (!viewRoot || viewRoot !== root && !root.contains(viewRoot)) {
        this._viewRoot = root;
      }
    };
    TreemapSeriesModel2.prototype.enableAriaDecal = function() {
      enableAriaDecalForTree(this);
    };
    TreemapSeriesModel2.type = "series.treemap";
    TreemapSeriesModel2.layoutMode = "box";
    TreemapSeriesModel2.defaultOption = {
      progressive: 0,
      left: "center",
      top: "middle",
      width: "80%",
      height: "80%",
      sort: true,
      clipWindow: "origin",
      squareRatio: 0.5 * (1 + Math.sqrt(5)),
      leafDepth: null,
      drillDownIcon: "▶",
      zoomToNodeRatio: 0.32 * 0.32,
      roam: true,
      nodeClick: "zoomToNode",
      animation: true,
      animationDurationUpdate: 900,
      animationEasing: "quinticInOut",
      breadcrumb: {
        show: true,
        height: 22,
        left: "center",
        top: "bottom",
        emptyItemWidth: 25,
        itemStyle: {
          color: "rgba(0,0,0,0.7)",
          textStyle: {
            color: "#fff"
          }
        }
      },
      label: {
        show: true,
        distance: 0,
        padding: 5,
        position: "inside",
        color: "#fff",
        overflow: "truncate"
      },
      upperLabel: {
        show: false,
        position: [0, "50%"],
        height: 20,
        overflow: "truncate",
        verticalAlign: "middle"
      },
      itemStyle: {
        color: null,
        colorAlpha: null,
        colorSaturation: null,
        borderWidth: 0,
        gapWidth: 0,
        borderColor: "#fff",
        borderColorSaturation: null
      },
      emphasis: {
        upperLabel: {
          show: true,
          position: [0, "50%"],
          overflow: "truncate",
          verticalAlign: "middle"
        }
      },
      visualDimension: 0,
      visualMin: null,
      visualMax: null,
      color: [],
      colorAlpha: null,
      colorSaturation: null,
      colorMappingBy: "index",
      visibleMin: 10,
      childrenVisibleMin: null,
      levels: []
    };
    return TreemapSeriesModel2;
  }(Series_default);
  function completeTreeValue(dataNode) {
    var sum2 = 0;
    each(dataNode.children, function(child) {
      completeTreeValue(child);
      var childValue = child.value;
      isArray(childValue) && (childValue = childValue[0]);
      sum2 += childValue;
    });
    var thisValue = dataNode.value;
    if (isArray(thisValue)) {
      thisValue = thisValue[0];
    }
    if (thisValue == null || isNaN(thisValue)) {
      thisValue = sum2;
    }
    if (thisValue < 0) {
      thisValue = 0;
    }
    isArray(dataNode.value) ? dataNode.value[0] = thisValue : dataNode.value = thisValue;
  }
  function setDefault(levels, ecModel) {
    var globalColorList = normalizeToArray(ecModel.get("color"));
    var globalDecalList = normalizeToArray(ecModel.get(["aria", "decal", "decals"]));
    if (!globalColorList) {
      return;
    }
    levels = levels || [];
    var hasColorDefine;
    var hasDecalDefine;
    each(levels, function(levelDefine) {
      var model = new Model_default(levelDefine);
      var modelColor = model.get("color");
      var modelDecal = model.get("decal");
      if (model.get(["itemStyle", "color"]) || modelColor && modelColor !== "none") {
        hasColorDefine = true;
      }
      if (model.get(["itemStyle", "decal"]) || modelDecal && modelDecal !== "none") {
        hasDecalDefine = true;
      }
    });
    var level0 = levels[0] || (levels[0] = {});
    if (!hasColorDefine) {
      level0.color = globalColorList.slice();
    }
    if (!hasDecalDefine && globalDecalList) {
      level0.decal = globalDecalList.slice();
    }
    return levels;
  }
  var TreemapSeries_default = TreemapSeriesModel;

  // node_modules/echarts/lib/chart/treemap/Breadcrumb.js
  var TEXT_PADDING = 8;
  var ITEM_GAP = 8;
  var ARRAY_LENGTH = 5;
  var Breadcrumb = function() {
    function Breadcrumb2(containerGroup) {
      this.group = new Group_default();
      containerGroup.add(this.group);
    }
    Breadcrumb2.prototype.render = function(seriesModel, api, targetNode, onSelect) {
      var model = seriesModel.getModel("breadcrumb");
      var thisGroup = this.group;
      thisGroup.removeAll();
      if (!model.get("show") || !targetNode) {
        return;
      }
      var normalStyleModel = model.getModel("itemStyle");
      var textStyleModel = normalStyleModel.getModel("textStyle");
      var layoutParam = {
        pos: {
          left: model.get("left"),
          right: model.get("right"),
          top: model.get("top"),
          bottom: model.get("bottom")
        },
        box: {
          width: api.getWidth(),
          height: api.getHeight()
        },
        emptyItemWidth: model.get("emptyItemWidth"),
        totalWidth: 0,
        renderList: []
      };
      this._prepare(targetNode, layoutParam, textStyleModel);
      this._renderContent(seriesModel, layoutParam, normalStyleModel, textStyleModel, onSelect);
      positionElement(thisGroup, layoutParam.pos, layoutParam.box);
    };
    Breadcrumb2.prototype._prepare = function(targetNode, layoutParam, textStyleModel) {
      for (var node = targetNode; node; node = node.parentNode) {
        var text = convertOptionIdName(node.getModel().get("name"), "");
        var textRect = textStyleModel.getTextRect(text);
        var itemWidth = Math.max(textRect.width + TEXT_PADDING * 2, layoutParam.emptyItemWidth);
        layoutParam.totalWidth += itemWidth + ITEM_GAP;
        layoutParam.renderList.push({
          node,
          text,
          width: itemWidth
        });
      }
    };
    Breadcrumb2.prototype._renderContent = function(seriesModel, layoutParam, normalStyleModel, textStyleModel, onSelect) {
      var lastX = 0;
      var emptyItemWidth = layoutParam.emptyItemWidth;
      var height = seriesModel.get(["breadcrumb", "height"]);
      var availableSize = getAvailableSize(layoutParam.pos, layoutParam.box);
      var totalWidth = layoutParam.totalWidth;
      var renderList = layoutParam.renderList;
      for (var i = renderList.length - 1; i >= 0; i--) {
        var item = renderList[i];
        var itemNode = item.node;
        var itemWidth = item.width;
        var text = item.text;
        if (totalWidth > availableSize.width) {
          totalWidth -= itemWidth - emptyItemWidth;
          itemWidth = emptyItemWidth;
          text = null;
        }
        var el = new Polygon_default({
          shape: {
            points: makeItemPoints(lastX, 0, itemWidth, height, i === renderList.length - 1, i === 0)
          },
          style: defaults(normalStyleModel.getItemStyle(), {
            lineJoin: "bevel"
          }),
          textContent: new Text_default({
            style: {
              text,
              fill: textStyleModel.getTextColor(),
              font: textStyleModel.getFont()
            }
          }),
          textConfig: {
            position: "inside"
          },
          z2: Z2_EMPHASIS_LIFT * 1e4,
          onclick: curry(onSelect, itemNode)
        });
        el.disableLabelAnimation = true;
        this.group.add(el);
        packEventData(el, seriesModel, itemNode);
        lastX += itemWidth + ITEM_GAP;
      }
    };
    Breadcrumb2.prototype.remove = function() {
      this.group.removeAll();
    };
    return Breadcrumb2;
  }();
  function makeItemPoints(x, y, itemWidth, itemHeight, head, tail) {
    var points4 = [[head ? x : x - ARRAY_LENGTH, y], [x + itemWidth, y], [x + itemWidth, y + itemHeight], [head ? x : x - ARRAY_LENGTH, y + itemHeight]];
    !tail && points4.splice(2, 0, [x + itemWidth + ARRAY_LENGTH, y + itemHeight / 2]);
    !head && points4.push([x, y + itemHeight / 2]);
    return points4;
  }
  function packEventData(el, seriesModel, itemNode) {
    getECData(el).eventData = {
      componentType: "series",
      componentSubType: "treemap",
      componentIndex: seriesModel.componentIndex,
      seriesIndex: seriesModel.seriesIndex,
      seriesName: seriesModel.name,
      seriesType: "treemap",
      selfType: "breadcrumb",
      nodeData: {
        dataIndex: itemNode && itemNode.dataIndex,
        name: itemNode && itemNode.name
      },
      treePathInfo: itemNode && wrapTreePathInfo(itemNode, seriesModel)
    };
  }
  var Breadcrumb_default = Breadcrumb;

  // node_modules/echarts/lib/util/animation.js
  var AnimationWrap = function() {
    function AnimationWrap2() {
      this._storage = [];
      this._elExistsMap = {};
    }
    AnimationWrap2.prototype.add = function(el, target, duration, delay, easing) {
      if (this._elExistsMap[el.id]) {
        return false;
      }
      this._elExistsMap[el.id] = true;
      this._storage.push({
        el,
        target,
        duration,
        delay,
        easing
      });
      return true;
    };
    AnimationWrap2.prototype.finished = function(callback) {
      this._finishedCallback = callback;
      return this;
    };
    AnimationWrap2.prototype.start = function() {
      var _this = this;
      var count2 = this._storage.length;
      var checkTerminate = function() {
        count2--;
        if (count2 <= 0) {
          _this._storage.length = 0;
          _this._elExistsMap = {};
          _this._finishedCallback && _this._finishedCallback();
        }
      };
      for (var i = 0, len2 = this._storage.length; i < len2; i++) {
        var item = this._storage[i];
        item.el.animateTo(item.target, {
          duration: item.duration,
          delay: item.delay,
          easing: item.easing,
          setToFinal: true,
          done: checkTerminate,
          aborted: checkTerminate
        });
      }
      return this;
    };
    return AnimationWrap2;
  }();
  function createWrap() {
    return new AnimationWrap();
  }

  // node_modules/echarts/lib/chart/treemap/TreemapView.js
  var Group2 = Group_default;
  var Rect2 = Rect_default;
  var DRAG_THRESHOLD = 3;
  var PATH_LABEL_NOAMAL = "label";
  var PATH_UPPERLABEL_NORMAL = "upperLabel";
  var Z2_BASE = Z2_EMPHASIS_LIFT * 10;
  var Z2_BG = Z2_EMPHASIS_LIFT * 2;
  var Z2_CONTENT = Z2_EMPHASIS_LIFT * 3;
  var getStateItemStyle = makeStyleMapper([
    ["fill", "color"],
    ["stroke", "strokeColor"],
    ["lineWidth", "strokeWidth"],
    ["shadowBlur"],
    ["shadowOffsetX"],
    ["shadowOffsetY"],
    ["shadowColor"]
  ]);
  var getItemStyleNormal = function(model) {
    var itemStyle = getStateItemStyle(model);
    itemStyle.stroke = itemStyle.fill = itemStyle.lineWidth = null;
    return itemStyle;
  };
  var inner9 = makeInner();
  var TreemapView = function(_super) {
    __extends(TreemapView2, _super);
    function TreemapView2() {
      var _this = _super !== null && _super.apply(this, arguments) || this;
      _this.type = TreemapView2.type;
      _this._state = "ready";
      _this._storage = createStorage();
      return _this;
    }
    TreemapView2.prototype.render = function(seriesModel, ecModel, api, payload) {
      var models = ecModel.findComponents({
        mainType: "series",
        subType: "treemap",
        query: payload
      });
      if (indexOf(models, seriesModel) < 0) {
        return;
      }
      this.seriesModel = seriesModel;
      this.api = api;
      this.ecModel = ecModel;
      var types = ["treemapZoomToNode", "treemapRootToNode"];
      var targetInfo = retrieveTargetInfo(payload, types, seriesModel);
      var payloadType = payload && payload.type;
      var layoutInfo = seriesModel.layoutInfo;
      var isInit = !this._oldTree;
      var thisStorage = this._storage;
      var reRoot = payloadType === "treemapRootToNode" && targetInfo && thisStorage ? {
        rootNodeGroup: thisStorage.nodeGroup[targetInfo.node.getRawIndex()],
        direction: payload.direction
      } : null;
      var containerGroup = this._giveContainerGroup(layoutInfo);
      var hasAnimation = seriesModel.get("animation");
      var renderResult = this._doRender(containerGroup, seriesModel, reRoot);
      hasAnimation && !isInit && (!payloadType || payloadType === "treemapZoomToNode" || payloadType === "treemapRootToNode") ? this._doAnimation(containerGroup, renderResult, seriesModel, reRoot) : renderResult.renderFinally();
      this._resetController(api);
      this._renderBreadcrumb(seriesModel, api, targetInfo);
    };
    TreemapView2.prototype._giveContainerGroup = function(layoutInfo) {
      var containerGroup = this._containerGroup;
      if (!containerGroup) {
        containerGroup = this._containerGroup = new Group2();
        this._initEvents(containerGroup);
        this.group.add(containerGroup);
      }
      containerGroup.x = layoutInfo.x;
      containerGroup.y = layoutInfo.y;
      return containerGroup;
    };
    TreemapView2.prototype._doRender = function(containerGroup, seriesModel, reRoot) {
      var thisTree = seriesModel.getData().tree;
      var oldTree = this._oldTree;
      var lastsForAnimation = createStorage();
      var thisStorage = createStorage();
      var oldStorage = this._storage;
      var willInvisibleEls = [];
      function doRenderNode(thisNode, oldNode, parentGroup, depth) {
        return renderNode(seriesModel, thisStorage, oldStorage, reRoot, lastsForAnimation, willInvisibleEls, thisNode, oldNode, parentGroup, depth);
      }
      dualTravel(thisTree.root ? [thisTree.root] : [], oldTree && oldTree.root ? [oldTree.root] : [], containerGroup, thisTree === oldTree || !oldTree, 0);
      var willDeleteEls = clearStorage(oldStorage);
      this._oldTree = thisTree;
      this._storage = thisStorage;
      return {
        lastsForAnimation,
        willDeleteEls,
        renderFinally
      };
      function dualTravel(thisViewChildren, oldViewChildren, parentGroup, sameTree, depth) {
        if (sameTree) {
          oldViewChildren = thisViewChildren;
          each(thisViewChildren, function(child, index) {
            !child.isRemoved() && processNode(index, index);
          });
        } else {
          new DataDiffer_default(oldViewChildren, thisViewChildren, getKey2, getKey2).add(processNode).update(processNode).remove(curry(processNode, null)).execute();
        }
        function getKey2(node) {
          return node.getId();
        }
        function processNode(newIndex, oldIndex) {
          var thisNode = newIndex != null ? thisViewChildren[newIndex] : null;
          var oldNode = oldIndex != null ? oldViewChildren[oldIndex] : null;
          var group = doRenderNode(thisNode, oldNode, parentGroup, depth);
          group && dualTravel(thisNode && thisNode.viewChildren || [], oldNode && oldNode.viewChildren || [], group, sameTree, depth + 1);
        }
      }
      function clearStorage(storage2) {
        var willDeleteEls2 = createStorage();
        storage2 && each(storage2, function(store, storageName) {
          var delEls = willDeleteEls2[storageName];
          each(store, function(el) {
            el && (delEls.push(el), inner9(el).willDelete = true);
          });
        });
        return willDeleteEls2;
      }
      function renderFinally() {
        each(willDeleteEls, function(els) {
          each(els, function(el) {
            el.parent && el.parent.remove(el);
          });
        });
        each(willInvisibleEls, function(el) {
          el.invisible = true;
          el.dirty();
        });
      }
    };
    TreemapView2.prototype._doAnimation = function(containerGroup, renderResult, seriesModel, reRoot) {
      var durationOption = seriesModel.get("animationDurationUpdate");
      var easingOption = seriesModel.get("animationEasing");
      var duration = (isFunction(durationOption) ? 0 : durationOption) || 0;
      var easing = (isFunction(easingOption) ? null : easingOption) || "cubicOut";
      var animationWrap = createWrap();
      each(renderResult.willDeleteEls, function(store, storageName) {
        each(store, function(el, rawIndex) {
          if (el.invisible) {
            return;
          }
          var parent = el.parent;
          var target;
          var innerStore = inner9(parent);
          if (reRoot && reRoot.direction === "drillDown") {
            target = parent === reRoot.rootNodeGroup ? {
              shape: {
                x: 0,
                y: 0,
                width: innerStore.nodeWidth,
                height: innerStore.nodeHeight
              },
              style: {
                opacity: 0
              }
            } : {
              style: {
                opacity: 0
              }
            };
          } else {
            var targetX = 0;
            var targetY = 0;
            if (!innerStore.willDelete) {
              targetX = innerStore.nodeWidth / 2;
              targetY = innerStore.nodeHeight / 2;
            }
            target = storageName === "nodeGroup" ? {
              x: targetX,
              y: targetY,
              style: {
                opacity: 0
              }
            } : {
              shape: {
                x: targetX,
                y: targetY,
                width: 0,
                height: 0
              },
              style: {
                opacity: 0
              }
            };
          }
          target && animationWrap.add(el, target, duration, 0, easing);
        });
      });
      each(this._storage, function(store, storageName) {
        each(store, function(el, rawIndex) {
          var last = renderResult.lastsForAnimation[storageName][rawIndex];
          var target = {};
          if (!last) {
            return;
          }
          if (el instanceof Group_default) {
            if (last.oldX != null) {
              target.x = el.x;
              target.y = el.y;
              el.x = last.oldX;
              el.y = last.oldY;
            }
          } else {
            if (last.oldShape) {
              target.shape = extend({}, el.shape);
              el.setShape(last.oldShape);
            }
            if (last.fadein) {
              el.setStyle("opacity", 0);
              target.style = {
                opacity: 1
              };
            } else if (el.style.opacity !== 1) {
              target.style = {
                opacity: 1
              };
            }
          }
          animationWrap.add(el, target, duration, 0, easing);
        });
      }, this);
      this._state = "animating";
      animationWrap.finished(bind(function() {
        this._state = "ready";
        renderResult.renderFinally();
      }, this)).start();
    };
    TreemapView2.prototype._resetController = function(api) {
      var controller = this._controller;
      if (!controller) {
        controller = this._controller = new RoamController_default(api.getZr());
        controller.enable(this.seriesModel.get("roam"));
        controller.on("pan", bind(this._onPan, this));
        controller.on("zoom", bind(this._onZoom, this));
      }
      var rect = new BoundingRect_default(0, 0, api.getWidth(), api.getHeight());
      controller.setPointerChecker(function(e2, x, y) {
        return rect.contain(x, y);
      });
    };
    TreemapView2.prototype._clearController = function() {
      var controller = this._controller;
      if (controller) {
        controller.dispose();
        controller = null;
      }
    };
    TreemapView2.prototype._onPan = function(e2) {
      if (this._state !== "animating" && (Math.abs(e2.dx) > DRAG_THRESHOLD || Math.abs(e2.dy) > DRAG_THRESHOLD)) {
        var root = this.seriesModel.getData().tree.root;
        if (!root) {
          return;
        }
        var rootLayout = root.getLayout();
        if (!rootLayout) {
          return;
        }
        this.api.dispatchAction({
          type: "treemapMove",
          from: this.uid,
          seriesId: this.seriesModel.id,
          rootRect: {
            x: rootLayout.x + e2.dx,
            y: rootLayout.y + e2.dy,
            width: rootLayout.width,
            height: rootLayout.height
          }
        });
      }
    };
    TreemapView2.prototype._onZoom = function(e2) {
      var mouseX = e2.originX;
      var mouseY = e2.originY;
      if (this._state !== "animating") {
        var root = this.seriesModel.getData().tree.root;
        if (!root) {
          return;
        }
        var rootLayout = root.getLayout();
        if (!rootLayout) {
          return;
        }
        var rect = new BoundingRect_default(rootLayout.x, rootLayout.y, rootLayout.width, rootLayout.height);
        var layoutInfo = this.seriesModel.layoutInfo;
        mouseX -= layoutInfo.x;
        mouseY -= layoutInfo.y;
        var m2 = create2();
        translate(m2, m2, [-mouseX, -mouseY]);
        scale2(m2, m2, [e2.scale, e2.scale]);
        translate(m2, m2, [mouseX, mouseY]);
        rect.applyTransform(m2);
        this.api.dispatchAction({
          type: "treemapRender",
          from: this.uid,
          seriesId: this.seriesModel.id,
          rootRect: {
            x: rect.x,
            y: rect.y,
            width: rect.width,
            height: rect.height
          }
        });
      }
    };
    TreemapView2.prototype._initEvents = function(containerGroup) {
      var _this = this;
      containerGroup.on("click", function(e2) {
        if (_this._state !== "ready") {
          return;
        }
        var nodeClick = _this.seriesModel.get("nodeClick", true);
        if (!nodeClick) {
          return;
        }
        var targetInfo = _this.findTarget(e2.offsetX, e2.offsetY);
        if (!targetInfo) {
          return;
        }
        var node = targetInfo.node;
        if (node.getLayout().isLeafRoot) {
          _this._rootToNode(targetInfo);
        } else {
          if (nodeClick === "zoomToNode") {
            _this._zoomToNode(targetInfo);
          } else if (nodeClick === "link") {
            var itemModel = node.hostTree.data.getItemModel(node.dataIndex);
            var link = itemModel.get("link", true);
            var linkTarget = itemModel.get("target", true) || "blank";
            link && windowOpen(link, linkTarget);
          }
        }
      }, this);
    };
    TreemapView2.prototype._renderBreadcrumb = function(seriesModel, api, targetInfo) {
      var _this = this;
      if (!targetInfo) {
        targetInfo = seriesModel.get("leafDepth", true) != null ? {
          node: seriesModel.getViewRoot()
        } : this.findTarget(api.getWidth() / 2, api.getHeight() / 2);
        if (!targetInfo) {
          targetInfo = {
            node: seriesModel.getData().tree.root
          };
        }
      }
      (this._breadcrumb || (this._breadcrumb = new Breadcrumb_default(this.group))).render(seriesModel, api, targetInfo.node, function(node) {
        if (_this._state !== "animating") {
          aboveViewRoot(seriesModel.getViewRoot(), node) ? _this._rootToNode({
            node
          }) : _this._zoomToNode({
            node
          });
        }
      });
    };
    TreemapView2.prototype.remove = function() {
      this._clearController();
      this._containerGroup && this._containerGroup.removeAll();
      this._storage = createStorage();
      this._state = "ready";
      this._breadcrumb && this._breadcrumb.remove();
    };
    TreemapView2.prototype.dispose = function() {
      this._clearController();
    };
    TreemapView2.prototype._zoomToNode = function(targetInfo) {
      this.api.dispatchAction({
        type: "treemapZoomToNode",
        from: this.uid,
        seriesId: this.seriesModel.id,
        targetNode: targetInfo.node
      });
    };
    TreemapView2.prototype._rootToNode = function(targetInfo) {
      this.api.dispatchAction({
        type: "treemapRootToNode",
        from: this.uid,
        seriesId: this.seriesModel.id,
        targetNode: targetInfo.node
      });
    };
    TreemapView2.prototype.findTarget = function(x, y) {
      var targetInfo;
      var viewRoot = this.seriesModel.getViewRoot();
      viewRoot.eachNode({
        attr: "viewChildren",
        order: "preorder"
      }, function(node) {
        var bgEl = this._storage.background[node.getRawIndex()];
        if (bgEl) {
          var point = bgEl.transformCoordToLocal(x, y);
          var shape = bgEl.shape;
          if (shape.x <= point[0] && point[0] <= shape.x + shape.width && shape.y <= point[1] && point[1] <= shape.y + shape.height) {
            targetInfo = {
              node,
              offsetX: point[0],
              offsetY: point[1]
            };
          } else {
            return false;
          }
        }
      }, this);
      return targetInfo;
    };
    TreemapView2.type = "treemap";
    return TreemapView2;
  }(Chart_default);
  function createStorage() {
    return {
      nodeGroup: [],
      background: [],
      content: []
    };
  }
  function renderNode(seriesModel, thisStorage, oldStorage, reRoot, lastsForAnimation, willInvisibleEls, thisNode, oldNode, parentGroup, depth) {
    if (!thisNode) {
      return;
    }
    var thisLayout = thisNode.getLayout();
    var data = seriesModel.getData();
    var nodeModel = thisNode.getModel();
    data.setItemGraphicEl(thisNode.dataIndex, null);
    if (!thisLayout || !thisLayout.isInView) {
      return;
    }
    var thisWidth = thisLayout.width;
    var thisHeight = thisLayout.height;
    var borderWidth = thisLayout.borderWidth;
    var thisInvisible = thisLayout.invisible;
    var thisRawIndex = thisNode.getRawIndex();
    var oldRawIndex = oldNode && oldNode.getRawIndex();
    var thisViewChildren = thisNode.viewChildren;
    var upperHeight = thisLayout.upperHeight;
    var isParent = thisViewChildren && thisViewChildren.length;
    var itemStyleNormalModel = nodeModel.getModel("itemStyle");
    var itemStyleEmphasisModel = nodeModel.getModel(["emphasis", "itemStyle"]);
    var itemStyleBlurModel = nodeModel.getModel(["blur", "itemStyle"]);
    var itemStyleSelectModel = nodeModel.getModel(["select", "itemStyle"]);
    var borderRadius = itemStyleNormalModel.get("borderRadius") || 0;
    var group = giveGraphic("nodeGroup", Group2);
    if (!group) {
      return;
    }
    parentGroup.add(group);
    group.x = thisLayout.x || 0;
    group.y = thisLayout.y || 0;
    group.markRedraw();
    inner9(group).nodeWidth = thisWidth;
    inner9(group).nodeHeight = thisHeight;
    if (thisLayout.isAboveViewRoot) {
      return group;
    }
    var bg = giveGraphic("background", Rect2, depth, Z2_BG);
    bg && renderBackground(group, bg, isParent && thisLayout.upperLabelHeight);
    var emphasisModel = nodeModel.getModel("emphasis");
    var focus = emphasisModel.get("focus");
    var blurScope = emphasisModel.get("blurScope");
    var isDisabled = emphasisModel.get("disabled");
    var focusOrIndices = focus === "ancestor" ? thisNode.getAncestorsIndices() : focus === "descendant" ? thisNode.getDescendantIndices() : focus;
    if (isParent) {
      if (isHighDownDispatcher(group)) {
        setAsHighDownDispatcher(group, false);
      }
      if (bg) {
        setAsHighDownDispatcher(bg, !isDisabled);
        data.setItemGraphicEl(thisNode.dataIndex, bg);
        enableHoverFocus(bg, focusOrIndices, blurScope);
      }
    } else {
      var content = giveGraphic("content", Rect2, depth, Z2_CONTENT);
      content && renderContent(group, content);
      bg.disableMorphing = true;
      if (bg && isHighDownDispatcher(bg)) {
        setAsHighDownDispatcher(bg, false);
      }
      setAsHighDownDispatcher(group, !isDisabled);
      data.setItemGraphicEl(thisNode.dataIndex, group);
      enableHoverFocus(group, focusOrIndices, blurScope);
    }
    return group;
    function renderBackground(group2, bg2, useUpperLabel) {
      var ecData = getECData(bg2);
      ecData.dataIndex = thisNode.dataIndex;
      ecData.seriesIndex = seriesModel.seriesIndex;
      bg2.setShape({
        x: 0,
        y: 0,
        width: thisWidth,
        height: thisHeight,
        r: borderRadius
      });
      if (thisInvisible) {
        processInvisible(bg2);
      } else {
        bg2.invisible = false;
        var style = thisNode.getVisual("style");
        var visualBorderColor = style.stroke;
        var normalStyle = getItemStyleNormal(itemStyleNormalModel);
        normalStyle.fill = visualBorderColor;
        var emphasisStyle = getStateItemStyle(itemStyleEmphasisModel);
        emphasisStyle.fill = itemStyleEmphasisModel.get("borderColor");
        var blurStyle = getStateItemStyle(itemStyleBlurModel);
        blurStyle.fill = itemStyleBlurModel.get("borderColor");
        var selectStyle = getStateItemStyle(itemStyleSelectModel);
        selectStyle.fill = itemStyleSelectModel.get("borderColor");
        if (useUpperLabel) {
          var upperLabelWidth = thisWidth - 2 * borderWidth;
          prepareText(bg2, visualBorderColor, style.opacity, {
            x: borderWidth,
            y: 0,
            width: upperLabelWidth,
            height: upperHeight
          });
        } else {
          bg2.removeTextContent();
        }
        bg2.setStyle(normalStyle);
        bg2.ensureState("emphasis").style = emphasisStyle;
        bg2.ensureState("blur").style = blurStyle;
        bg2.ensureState("select").style = selectStyle;
        setDefaultStateProxy(bg2);
      }
      group2.add(bg2);
    }
    function renderContent(group2, content2) {
      var ecData = getECData(content2);
      ecData.dataIndex = thisNode.dataIndex;
      ecData.seriesIndex = seriesModel.seriesIndex;
      var contentWidth = Math.max(thisWidth - 2 * borderWidth, 0);
      var contentHeight = Math.max(thisHeight - 2 * borderWidth, 0);
      content2.culling = true;
      content2.setShape({
        x: borderWidth,
        y: borderWidth,
        width: contentWidth,
        height: contentHeight,
        r: borderRadius
      });
      if (thisInvisible) {
        processInvisible(content2);
      } else {
        content2.invisible = false;
        var nodeStyle = thisNode.getVisual("style");
        var visualColor = nodeStyle.fill;
        var normalStyle = getItemStyleNormal(itemStyleNormalModel);
        normalStyle.fill = visualColor;
        normalStyle.decal = nodeStyle.decal;
        var emphasisStyle = getStateItemStyle(itemStyleEmphasisModel);
        var blurStyle = getStateItemStyle(itemStyleBlurModel);
        var selectStyle = getStateItemStyle(itemStyleSelectModel);
        prepareText(content2, visualColor, nodeStyle.opacity, null);
        content2.setStyle(normalStyle);
        content2.ensureState("emphasis").style = emphasisStyle;
        content2.ensureState("blur").style = blurStyle;
        content2.ensureState("select").style = selectStyle;
        setDefaultStateProxy(content2);
      }
      group2.add(content2);
    }
    function processInvisible(element) {
      !element.invisible && willInvisibleEls.push(element);
    }
    function prepareText(rectEl, visualColor, visualOpacity, upperLabelRect) {
      var normalLabelModel = nodeModel.getModel(upperLabelRect ? PATH_UPPERLABEL_NORMAL : PATH_LABEL_NOAMAL);
      var defaultText = convertOptionIdName(nodeModel.get("name"), null);
      var isShow = normalLabelModel.getShallow("show");
      setLabelStyle(rectEl, getLabelStatesModels(nodeModel, upperLabelRect ? PATH_UPPERLABEL_NORMAL : PATH_LABEL_NOAMAL), {
        defaultText: isShow ? defaultText : null,
        inheritColor: visualColor,
        defaultOpacity: visualOpacity,
        labelFetcher: seriesModel,
        labelDataIndex: thisNode.dataIndex
      });
      var textEl = rectEl.getTextContent();
      if (!textEl) {
        return;
      }
      var textStyle = textEl.style;
      var textPadding = normalizeCssArray(textStyle.padding || 0);
      if (upperLabelRect) {
        rectEl.setTextConfig({
          layoutRect: upperLabelRect
        });
        textEl.disableLabelLayout = true;
      }
      textEl.beforeUpdate = function() {
        var width = Math.max((upperLabelRect ? upperLabelRect.width : rectEl.shape.width) - textPadding[1] - textPadding[3], 0);
        var height = Math.max((upperLabelRect ? upperLabelRect.height : rectEl.shape.height) - textPadding[0] - textPadding[2], 0);
        if (textStyle.width !== width || textStyle.height !== height) {
          textEl.setStyle({
            width,
            height
          });
        }
      };
      textStyle.truncateMinChar = 2;
      textStyle.lineOverflow = "truncate";
      addDrillDownIcon(textStyle, upperLabelRect, thisLayout);
      var textEmphasisState = textEl.getState("emphasis");
      addDrillDownIcon(textEmphasisState ? textEmphasisState.style : null, upperLabelRect, thisLayout);
    }
    function addDrillDownIcon(style, upperLabelRect, thisLayout2) {
      var text = style ? style.text : null;
      if (!upperLabelRect && thisLayout2.isLeafRoot && text != null) {
        var iconChar = seriesModel.get("drillDownIcon", true);
        style.text = iconChar ? iconChar + " " + text : text;
      }
    }
    function giveGraphic(storageName, Ctor, depth2, z) {
      var element = oldRawIndex != null && oldStorage[storageName][oldRawIndex];
      var lasts = lastsForAnimation[storageName];
      if (element) {
        oldStorage[storageName][oldRawIndex] = null;
        prepareAnimationWhenHasOld(lasts, element);
      } else if (!thisInvisible) {
        element = new Ctor();
        if (element instanceof Displayable_default) {
          element.z2 = calculateZ2(depth2, z);
        }
        prepareAnimationWhenNoOld(lasts, element);
      }
      return thisStorage[storageName][thisRawIndex] = element;
    }
    function prepareAnimationWhenHasOld(lasts, element) {
      var lastCfg = lasts[thisRawIndex] = {};
      if (element instanceof Group2) {
        lastCfg.oldX = element.x;
        lastCfg.oldY = element.y;
      } else {
        lastCfg.oldShape = extend({}, element.shape);
      }
    }
    function prepareAnimationWhenNoOld(lasts, element) {
      var lastCfg = lasts[thisRawIndex] = {};
      var parentNode2 = thisNode.parentNode;
      var isGroup = element instanceof Group_default;
      if (parentNode2 && (!reRoot || reRoot.direction === "drillDown")) {
        var parentOldX = 0;
        var parentOldY = 0;
        var parentOldBg = lastsForAnimation.background[parentNode2.getRawIndex()];
        if (!reRoot && parentOldBg && parentOldBg.oldShape) {
          parentOldX = parentOldBg.oldShape.width;
          parentOldY = parentOldBg.oldShape.height;
        }
        if (isGroup) {
          lastCfg.oldX = 0;
          lastCfg.oldY = parentOldY;
        } else {
          lastCfg.oldShape = {
            x: parentOldX,
            y: parentOldY,
            width: 0,
            height: 0
          };
        }
      }
      lastCfg.fadein = !isGroup;
    }
  }
  function calculateZ2(depth, z2InLevel) {
    return depth * Z2_BASE + z2InLevel;
  }
  var TreemapView_default = TreemapView;

  // node_modules/echarts/lib/visual/VisualMapping.js
  var each4 = each;
  var isObject4 = isObject;
  var CATEGORY_DEFAULT_VISUAL_INDEX = -1;
  var VisualMapping = function() {
    function VisualMapping2(option) {
      var mappingMethod = option.mappingMethod;
      var visualType = option.type;
      var thisOption = this.option = clone(option);
      this.type = visualType;
      this.mappingMethod = mappingMethod;
      this._normalizeData = normalizers[mappingMethod];
      var visualHandler = VisualMapping2.visualHandlers[visualType];
      this.applyVisual = visualHandler.applyVisual;
      this.getColorMapper = visualHandler.getColorMapper;
      this._normalizedToVisual = visualHandler._normalizedToVisual[mappingMethod];
      if (mappingMethod === "piecewise") {
        normalizeVisualRange(thisOption);
        preprocessForPiecewise(thisOption);
      } else if (mappingMethod === "category") {
        thisOption.categories ? preprocessForSpecifiedCategory(thisOption) : normalizeVisualRange(thisOption, true);
      } else {
        assert(mappingMethod !== "linear" || thisOption.dataExtent);
        normalizeVisualRange(thisOption);
      }
    }
    VisualMapping2.prototype.mapValueToVisual = function(value) {
      var normalized = this._normalizeData(value);
      return this._normalizedToVisual(normalized, value);
    };
    VisualMapping2.prototype.getNormalizer = function() {
      return bind(this._normalizeData, this);
    };
    VisualMapping2.listVisualTypes = function() {
      return keys(VisualMapping2.visualHandlers);
    };
    VisualMapping2.isValidType = function(visualType) {
      return VisualMapping2.visualHandlers.hasOwnProperty(visualType);
    };
    VisualMapping2.eachVisual = function(visual, callback, context) {
      if (isObject(visual)) {
        each(visual, callback, context);
      } else {
        callback.call(context, visual);
      }
    };
    VisualMapping2.mapVisual = function(visual, callback, context) {
      var isPrimary;
      var newVisual = isArray(visual) ? [] : isObject(visual) ? {} : (isPrimary = true, null);
      VisualMapping2.eachVisual(visual, function(v, key) {
        var newVal = callback.call(context, v, key);
        isPrimary ? newVisual = newVal : newVisual[key] = newVal;
      });
      return newVisual;
    };
    VisualMapping2.retrieveVisuals = function(obj) {
      var ret = {};
      var hasVisual;
      obj && each4(VisualMapping2.visualHandlers, function(h, visualType) {
        if (obj.hasOwnProperty(visualType)) {
          ret[visualType] = obj[visualType];
          hasVisual = true;
        }
      });
      return hasVisual ? ret : null;
    };
    VisualMapping2.prepareVisualTypes = function(visualTypes) {
      if (isArray(visualTypes)) {
        visualTypes = visualTypes.slice();
      } else if (isObject4(visualTypes)) {
        var types_1 = [];
        each4(visualTypes, function(item, type) {
          types_1.push(type);
        });
        visualTypes = types_1;
      } else {
        return [];
      }
      visualTypes.sort(function(type1, type2) {
        return type2 === "color" && type1 !== "color" && type1.indexOf("color") === 0 ? 1 : -1;
      });
      return visualTypes;
    };
    VisualMapping2.dependsOn = function(visualType1, visualType2) {
      return visualType2 === "color" ? !!(visualType1 && visualType1.indexOf(visualType2) === 0) : visualType1 === visualType2;
    };
    VisualMapping2.findPieceIndex = function(value, pieceList, findClosestWhenOutside) {
      var possibleI;
      var abs2 = Infinity;
      for (var i = 0, len2 = pieceList.length; i < len2; i++) {
        var pieceValue = pieceList[i].value;
        if (pieceValue != null) {
          if (pieceValue === value || isString(pieceValue) && pieceValue === value + "") {
            return i;
          }
          findClosestWhenOutside && updatePossible(pieceValue, i);
        }
      }
      for (var i = 0, len2 = pieceList.length; i < len2; i++) {
        var piece = pieceList[i];
        var interval = piece.interval;
        var close_1 = piece.close;
        if (interval) {
          if (interval[0] === -Infinity) {
            if (littleThan(close_1[1], value, interval[1])) {
              return i;
            }
          } else if (interval[1] === Infinity) {
            if (littleThan(close_1[0], interval[0], value)) {
              return i;
            }
          } else if (littleThan(close_1[0], interval[0], value) && littleThan(close_1[1], value, interval[1])) {
            return i;
          }
          findClosestWhenOutside && updatePossible(interval[0], i);
          findClosestWhenOutside && updatePossible(interval[1], i);
        }
      }
      if (findClosestWhenOutside) {
        return value === Infinity ? pieceList.length - 1 : value === -Infinity ? 0 : possibleI;
      }
      function updatePossible(val, index) {
        var newAbs = Math.abs(val - value);
        if (newAbs < abs2) {
          abs2 = newAbs;
          possibleI = index;
        }
      }
    };
    VisualMapping2.visualHandlers = {
      color: {
        applyVisual: makeApplyVisual("color"),
        getColorMapper: function() {
          var thisOption = this.option;
          return bind(thisOption.mappingMethod === "category" ? function(value, isNormalized) {
            !isNormalized && (value = this._normalizeData(value));
            return doMapCategory.call(this, value);
          } : function(value, isNormalized, out2) {
            var returnRGBArray = !!out2;
            !isNormalized && (value = this._normalizeData(value));
            out2 = fastLerp(value, thisOption.parsedVisual, out2);
            return returnRGBArray ? out2 : stringify(out2, "rgba");
          }, this);
        },
        _normalizedToVisual: {
          linear: function(normalized) {
            return stringify(fastLerp(normalized, this.option.parsedVisual), "rgba");
          },
          category: doMapCategory,
          piecewise: function(normalized, value) {
            var result = getSpecifiedVisual.call(this, value);
            if (result == null) {
              result = stringify(fastLerp(normalized, this.option.parsedVisual), "rgba");
            }
            return result;
          },
          fixed: doMapFixed
        }
      },
      colorHue: makePartialColorVisualHandler(function(color, value) {
        return modifyHSL(color, value);
      }),
      colorSaturation: makePartialColorVisualHandler(function(color, value) {
        return modifyHSL(color, null, value);
      }),
      colorLightness: makePartialColorVisualHandler(function(color, value) {
        return modifyHSL(color, null, null, value);
      }),
      colorAlpha: makePartialColorVisualHandler(function(color, value) {
        return modifyAlpha(color, value);
      }),
      decal: {
        applyVisual: makeApplyVisual("decal"),
        _normalizedToVisual: {
          linear: null,
          category: doMapCategory,
          piecewise: null,
          fixed: null
        }
      },
      opacity: {
        applyVisual: makeApplyVisual("opacity"),
        _normalizedToVisual: createNormalizedToNumericVisual([0, 1])
      },
      liftZ: {
        applyVisual: makeApplyVisual("liftZ"),
        _normalizedToVisual: {
          linear: doMapFixed,
          category: doMapFixed,
          piecewise: doMapFixed,
          fixed: doMapFixed
        }
      },
      symbol: {
        applyVisual: function(value, getter, setter) {
          var symbolCfg = this.mapValueToVisual(value);
          setter("symbol", symbolCfg);
        },
        _normalizedToVisual: {
          linear: doMapToArray,
          category: doMapCategory,
          piecewise: function(normalized, value) {
            var result = getSpecifiedVisual.call(this, value);
            if (result == null) {
              result = doMapToArray.call(this, normalized);
            }
            return result;
          },
          fixed: doMapFixed
        }
      },
      symbolSize: {
        applyVisual: makeApplyVisual("symbolSize"),
        _normalizedToVisual: createNormalizedToNumericVisual([0, 1])
      }
    };
    return VisualMapping2;
  }();
  function preprocessForPiecewise(thisOption) {
    var pieceList = thisOption.pieceList;
    thisOption.hasSpecialVisual = false;
    each(pieceList, function(piece, index) {
      piece.originIndex = index;
      if (piece.visual != null) {
        thisOption.hasSpecialVisual = true;
      }
    });
  }
  function preprocessForSpecifiedCategory(thisOption) {
    var categories = thisOption.categories;
    var categoryMap = thisOption.categoryMap = {};
    var visual = thisOption.visual;
    each4(categories, function(cate, index) {
      categoryMap[cate] = index;
    });
    if (!isArray(visual)) {
      var visualArr_1 = [];
      if (isObject(visual)) {
        each4(visual, function(v, cate) {
          var index = categoryMap[cate];
          visualArr_1[index != null ? index : CATEGORY_DEFAULT_VISUAL_INDEX] = v;
        });
      } else {
        visualArr_1[CATEGORY_DEFAULT_VISUAL_INDEX] = visual;
      }
      visual = setVisualToOption(thisOption, visualArr_1);
    }
    for (var i = categories.length - 1; i >= 0; i--) {
      if (visual[i] == null) {
        delete categoryMap[categories[i]];
        categories.pop();
      }
    }
  }
  function normalizeVisualRange(thisOption, isCategory2) {
    var visual = thisOption.visual;
    var visualArr = [];
    if (isObject(visual)) {
      each4(visual, function(v) {
        visualArr.push(v);
      });
    } else if (visual != null) {
      visualArr.push(visual);
    }
    var doNotNeedPair = {
      color: 1,
      symbol: 1
    };
    if (!isCategory2 && visualArr.length === 1 && !doNotNeedPair.hasOwnProperty(thisOption.type)) {
      visualArr[1] = visualArr[0];
    }
    setVisualToOption(thisOption, visualArr);
  }
  function makePartialColorVisualHandler(applyValue) {
    return {
      applyVisual: function(value, getter, setter) {
        var colorChannel = this.mapValueToVisual(value);
        setter("color", applyValue(getter("color"), colorChannel));
      },
      _normalizedToVisual: createNormalizedToNumericVisual([0, 1])
    };
  }
  function doMapToArray(normalized) {
    var visual = this.option.visual;
    return visual[Math.round(linearMap(normalized, [0, 1], [0, visual.length - 1], true))] || {};
  }
  function makeApplyVisual(visualType) {
    return function(value, getter, setter) {
      setter(visualType, this.mapValueToVisual(value));
    };
  }
  function doMapCategory(normalized) {
    var visual = this.option.visual;
    return visual[this.option.loop && normalized !== CATEGORY_DEFAULT_VISUAL_INDEX ? normalized % visual.length : normalized];
  }
  function doMapFixed() {
    return this.option.visual[0];
  }
  function createNormalizedToNumericVisual(sourceExtent) {
    return {
      linear: function(normalized) {
        return linearMap(normalized, sourceExtent, this.option.visual, true);
      },
      category: doMapCategory,
      piecewise: function(normalized, value) {
        var result = getSpecifiedVisual.call(this, value);
        if (result == null) {
          result = linearMap(normalized, sourceExtent, this.option.visual, true);
        }
        return result;
      },
      fixed: doMapFixed
    };
  }
  function getSpecifiedVisual(value) {
    var thisOption = this.option;
    var pieceList = thisOption.pieceList;
    if (thisOption.hasSpecialVisual) {
      var pieceIndex = VisualMapping.findPieceIndex(value, pieceList);
      var piece = pieceList[pieceIndex];
      if (piece && piece.visual) {
        return piece.visual[this.type];
      }
    }
  }
  function setVisualToOption(thisOption, visualArr) {
    thisOption.visual = visualArr;
    if (thisOption.type === "color") {
      thisOption.parsedVisual = map(visualArr, function(item) {
        var color = parse(item);
        if (!color && true) {
          warn("'" + item + "' is an illegal color, fallback to '#000000'", true);
        }
        return color || [0, 0, 0, 1];
      });
    }
    return visualArr;
  }
  var normalizers = {
    linear: function(value) {
      return linearMap(value, this.option.dataExtent, [0, 1], true);
    },
    piecewise: function(value) {
      var pieceList = this.option.pieceList;
      var pieceIndex = VisualMapping.findPieceIndex(value, pieceList, true);
      if (pieceIndex != null) {
        return linearMap(pieceIndex, [0, pieceList.length - 1], [0, 1], true);
      }
    },
    category: function(value) {
      var index = this.option.categories ? this.option.categoryMap[value] : value;
      return index == null ? CATEGORY_DEFAULT_VISUAL_INDEX : index;
    },
    fixed: noop
  };
  function littleThan(close, a, b) {
    return close ? a <= b : a < b;
  }
  var VisualMapping_default = VisualMapping;

  // node_modules/echarts/lib/chart/treemap/treemapVisual.js
  var ITEM_STYLE_NORMAL = "itemStyle";
  var inner10 = makeInner();
  var treemapVisual_default = {
    seriesType: "treemap",
    reset: function(seriesModel) {
      var tree = seriesModel.getData().tree;
      var root = tree.root;
      if (root.isRemoved()) {
        return;
      }
      travelTree(root, {}, seriesModel.getViewRoot().getAncestors(), seriesModel);
    }
  };
  function travelTree(node, designatedVisual, viewRootAncestors, seriesModel) {
    var nodeModel = node.getModel();
    var nodeLayout = node.getLayout();
    var data = node.hostTree.data;
    if (!nodeLayout || nodeLayout.invisible || !nodeLayout.isInView) {
      return;
    }
    var nodeItemStyleModel = nodeModel.getModel(ITEM_STYLE_NORMAL);
    var visuals = buildVisuals(nodeItemStyleModel, designatedVisual, seriesModel);
    var existsStyle = data.ensureUniqueItemVisual(node.dataIndex, "style");
    var borderColor = nodeItemStyleModel.get("borderColor");
    var borderColorSaturation = nodeItemStyleModel.get("borderColorSaturation");
    var thisNodeColor;
    if (borderColorSaturation != null) {
      thisNodeColor = calculateColor(visuals);
      borderColor = calculateBorderColor(borderColorSaturation, thisNodeColor);
    }
    existsStyle.stroke = borderColor;
    var viewChildren = node.viewChildren;
    if (!viewChildren || !viewChildren.length) {
      thisNodeColor = calculateColor(visuals);
      existsStyle.fill = thisNodeColor;
    } else {
      var mapping_1 = buildVisualMapping(node, nodeModel, nodeLayout, nodeItemStyleModel, visuals, viewChildren);
      each(viewChildren, function(child, index) {
        if (child.depth >= viewRootAncestors.length || child === viewRootAncestors[child.depth]) {
          var childVisual = mapVisual(nodeModel, visuals, child, index, mapping_1, seriesModel);
          travelTree(child, childVisual, viewRootAncestors, seriesModel);
        }
      });
    }
  }
  function buildVisuals(nodeItemStyleModel, designatedVisual, seriesModel) {
    var visuals = extend({}, designatedVisual);
    var designatedVisualItemStyle = seriesModel.designatedVisualItemStyle;
    each(["color", "colorAlpha", "colorSaturation"], function(visualName) {
      designatedVisualItemStyle[visualName] = designatedVisual[visualName];
      var val = nodeItemStyleModel.get(visualName);
      designatedVisualItemStyle[visualName] = null;
      val != null && (visuals[visualName] = val);
    });
    return visuals;
  }
  function calculateColor(visuals) {
    var color = getValueVisualDefine(visuals, "color");
    if (color) {
      var colorAlpha = getValueVisualDefine(visuals, "colorAlpha");
      var colorSaturation = getValueVisualDefine(visuals, "colorSaturation");
      if (colorSaturation) {
        color = modifyHSL(color, null, null, colorSaturation);
      }
      if (colorAlpha) {
        color = modifyAlpha(color, colorAlpha);
      }
      return color;
    }
  }
  function calculateBorderColor(borderColorSaturation, thisNodeColor) {
    return thisNodeColor != null ? modifyHSL(thisNodeColor, null, null, borderColorSaturation) : null;
  }
  function getValueVisualDefine(visuals, name) {
    var value = visuals[name];
    if (value != null && value !== "none") {
      return value;
    }
  }
  function buildVisualMapping(node, nodeModel, nodeLayout, nodeItemStyleModel, visuals, viewChildren) {
    if (!viewChildren || !viewChildren.length) {
      return;
    }
    var rangeVisual = getRangeVisual(nodeModel, "color") || visuals.color != null && visuals.color !== "none" && (getRangeVisual(nodeModel, "colorAlpha") || getRangeVisual(nodeModel, "colorSaturation"));
    if (!rangeVisual) {
      return;
    }
    var visualMin = nodeModel.get("visualMin");
    var visualMax = nodeModel.get("visualMax");
    var dataExtent = nodeLayout.dataExtent.slice();
    visualMin != null && visualMin < dataExtent[0] && (dataExtent[0] = visualMin);
    visualMax != null && visualMax > dataExtent[1] && (dataExtent[1] = visualMax);
    var colorMappingBy = nodeModel.get("colorMappingBy");
    var opt = {
      type: rangeVisual.name,
      dataExtent,
      visual: rangeVisual.range
    };
    if (opt.type === "color" && (colorMappingBy === "index" || colorMappingBy === "id")) {
      opt.mappingMethod = "category";
      opt.loop = true;
    } else {
      opt.mappingMethod = "linear";
    }
    var mapping = new VisualMapping_default(opt);
    inner10(mapping).drColorMappingBy = colorMappingBy;
    return mapping;
  }
  function getRangeVisual(nodeModel, name) {
    var range = nodeModel.get(name);
    return isArray(range) && range.length ? {
      name,
      range
    } : null;
  }
  function mapVisual(nodeModel, visuals, child, index, mapping, seriesModel) {
    var childVisuals = extend({}, visuals);
    if (mapping) {
      var mappingType = mapping.type;
      var colorMappingBy = mappingType === "color" && inner10(mapping).drColorMappingBy;
      var value = colorMappingBy === "index" ? index : colorMappingBy === "id" ? seriesModel.mapIdToIndex(child.getId()) : child.getValue(nodeModel.get("visualDimension"));
      childVisuals[mappingType] = mapping.mapValueToVisual(value);
    }
    return childVisuals;
  }

  // node_modules/echarts/lib/chart/treemap/treemapLayout.js
  var mathMax8 = Math.max;
  var mathMin8 = Math.min;
  var retrieveValue = retrieve;
  var each5 = each;
  var PATH_BORDER_WIDTH = ["itemStyle", "borderWidth"];
  var PATH_GAP_WIDTH = ["itemStyle", "gapWidth"];
  var PATH_UPPER_LABEL_SHOW = ["upperLabel", "show"];
  var PATH_UPPER_LABEL_HEIGHT = ["upperLabel", "height"];
  var treemapLayout_default = {
    seriesType: "treemap",
    reset: function(seriesModel, ecModel, api, payload) {
      var ecWidth = api.getWidth();
      var ecHeight = api.getHeight();
      var seriesOption = seriesModel.option;
      var layoutInfo = getLayoutRect(seriesModel.getBoxLayoutParams(), {
        width: api.getWidth(),
        height: api.getHeight()
      });
      var size = seriesOption.size || [];
      var containerWidth = parsePercent2(retrieveValue(layoutInfo.width, size[0]), ecWidth);
      var containerHeight = parsePercent2(retrieveValue(layoutInfo.height, size[1]), ecHeight);
      var payloadType = payload && payload.type;
      var types = ["treemapZoomToNode", "treemapRootToNode"];
      var targetInfo = retrieveTargetInfo(payload, types, seriesModel);
      var rootRect = payloadType === "treemapRender" || payloadType === "treemapMove" ? payload.rootRect : null;
      var viewRoot = seriesModel.getViewRoot();
      var viewAbovePath = getPathToRoot(viewRoot);
      if (payloadType !== "treemapMove") {
        var rootSize = payloadType === "treemapZoomToNode" ? estimateRootSize(seriesModel, targetInfo, viewRoot, containerWidth, containerHeight) : rootRect ? [rootRect.width, rootRect.height] : [containerWidth, containerHeight];
        var sort_1 = seriesOption.sort;
        if (sort_1 && sort_1 !== "asc" && sort_1 !== "desc") {
          sort_1 = "desc";
        }
        var options = {
          squareRatio: seriesOption.squareRatio,
          sort: sort_1,
          leafDepth: seriesOption.leafDepth
        };
        viewRoot.hostTree.clearLayouts();
        var viewRootLayout_1 = {
          x: 0,
          y: 0,
          width: rootSize[0],
          height: rootSize[1],
          area: rootSize[0] * rootSize[1]
        };
        viewRoot.setLayout(viewRootLayout_1);
        squarify(viewRoot, options, false, 0);
        viewRootLayout_1 = viewRoot.getLayout();
        each5(viewAbovePath, function(node, index) {
          var childValue = (viewAbovePath[index + 1] || viewRoot).getValue();
          node.setLayout(extend({
            dataExtent: [childValue, childValue],
            borderWidth: 0,
            upperHeight: 0
          }, viewRootLayout_1));
        });
      }
      var treeRoot = seriesModel.getData().tree.root;
      treeRoot.setLayout(calculateRootPosition(layoutInfo, rootRect, targetInfo), true);
      seriesModel.setLayoutInfo(layoutInfo);
      prunning(treeRoot, new BoundingRect_default(-layoutInfo.x, -layoutInfo.y, ecWidth, ecHeight), viewAbovePath, viewRoot, 0);
    }
  };
  function squarify(node, options, hideChildren, depth) {
    var width;
    var height;
    if (node.isRemoved()) {
      return;
    }
    var thisLayout = node.getLayout();
    width = thisLayout.width;
    height = thisLayout.height;
    var nodeModel = node.getModel();
    var borderWidth = nodeModel.get(PATH_BORDER_WIDTH);
    var halfGapWidth = nodeModel.get(PATH_GAP_WIDTH) / 2;
    var upperLabelHeight = getUpperLabelHeight(nodeModel);
    var upperHeight = Math.max(borderWidth, upperLabelHeight);
    var layoutOffset = borderWidth - halfGapWidth;
    var layoutOffsetUpper = upperHeight - halfGapWidth;
    node.setLayout({
      borderWidth,
      upperHeight,
      upperLabelHeight
    }, true);
    width = mathMax8(width - 2 * layoutOffset, 0);
    height = mathMax8(height - layoutOffset - layoutOffsetUpper, 0);
    var totalArea = width * height;
    var viewChildren = initChildren(node, nodeModel, totalArea, options, hideChildren, depth);
    if (!viewChildren.length) {
      return;
    }
    var rect = {
      x: layoutOffset,
      y: layoutOffsetUpper,
      width,
      height
    };
    var rowFixedLength = mathMin8(width, height);
    var best = Infinity;
    var row = [];
    row.area = 0;
    for (var i = 0, len2 = viewChildren.length; i < len2; ) {
      var child = viewChildren[i];
      row.push(child);
      row.area += child.getLayout().area;
      var score = worst(row, rowFixedLength, options.squareRatio);
      if (score <= best) {
        i++;
        best = score;
      } else {
        row.area -= row.pop().getLayout().area;
        position(row, rowFixedLength, rect, halfGapWidth, false);
        rowFixedLength = mathMin8(rect.width, rect.height);
        row.length = row.area = 0;
        best = Infinity;
      }
    }
    if (row.length) {
      position(row, rowFixedLength, rect, halfGapWidth, true);
    }
    if (!hideChildren) {
      var childrenVisibleMin = nodeModel.get("childrenVisibleMin");
      if (childrenVisibleMin != null && totalArea < childrenVisibleMin) {
        hideChildren = true;
      }
    }
    for (var i = 0, len2 = viewChildren.length; i < len2; i++) {
      squarify(viewChildren[i], options, hideChildren, depth + 1);
    }
  }
  function initChildren(node, nodeModel, totalArea, options, hideChildren, depth) {
    var viewChildren = node.children || [];
    var orderBy = options.sort;
    orderBy !== "asc" && orderBy !== "desc" && (orderBy = null);
    var overLeafDepth = options.leafDepth != null && options.leafDepth <= depth;
    if (hideChildren && !overLeafDepth) {
      return node.viewChildren = [];
    }
    viewChildren = filter(viewChildren, function(child) {
      return !child.isRemoved();
    });
    sort2(viewChildren, orderBy);
    var info = statistic(nodeModel, viewChildren, orderBy);
    if (info.sum === 0) {
      return node.viewChildren = [];
    }
    info.sum = filterByThreshold(nodeModel, totalArea, info.sum, orderBy, viewChildren);
    if (info.sum === 0) {
      return node.viewChildren = [];
    }
    for (var i = 0, len2 = viewChildren.length; i < len2; i++) {
      var area = viewChildren[i].getValue() / info.sum * totalArea;
      viewChildren[i].setLayout({
        area
      });
    }
    if (overLeafDepth) {
      viewChildren.length && node.setLayout({
        isLeafRoot: true
      }, true);
      viewChildren.length = 0;
    }
    node.viewChildren = viewChildren;
    node.setLayout({
      dataExtent: info.dataExtent
    }, true);
    return viewChildren;
  }
  function filterByThreshold(nodeModel, totalArea, sum2, orderBy, orderedChildren) {
    if (!orderBy) {
      return sum2;
    }
    var visibleMin = nodeModel.get("visibleMin");
    var len2 = orderedChildren.length;
    var deletePoint = len2;
    for (var i = len2 - 1; i >= 0; i--) {
      var value = orderedChildren[orderBy === "asc" ? len2 - i - 1 : i].getValue();
      if (value / sum2 * totalArea < visibleMin) {
        deletePoint = i;
        sum2 -= value;
      }
    }
    orderBy === "asc" ? orderedChildren.splice(0, len2 - deletePoint) : orderedChildren.splice(deletePoint, len2 - deletePoint);
    return sum2;
  }
  function sort2(viewChildren, orderBy) {
    if (orderBy) {
      viewChildren.sort(function(a, b) {
        var diff = orderBy === "asc" ? a.getValue() - b.getValue() : b.getValue() - a.getValue();
        return diff === 0 ? orderBy === "asc" ? a.dataIndex - b.dataIndex : b.dataIndex - a.dataIndex : diff;
      });
    }
    return viewChildren;
  }
  function statistic(nodeModel, children, orderBy) {
    var sum2 = 0;
    for (var i = 0, len2 = children.length; i < len2; i++) {
      sum2 += children[i].getValue();
    }
    var dimension = nodeModel.get("visualDimension");
    var dataExtent;
    if (!children || !children.length) {
      dataExtent = [NaN, NaN];
    } else if (dimension === "value" && orderBy) {
      dataExtent = [children[children.length - 1].getValue(), children[0].getValue()];
      orderBy === "asc" && dataExtent.reverse();
    } else {
      dataExtent = [Infinity, -Infinity];
      each5(children, function(child) {
        var value = child.getValue(dimension);
        value < dataExtent[0] && (dataExtent[0] = value);
        value > dataExtent[1] && (dataExtent[1] = value);
      });
    }
    return {
      sum: sum2,
      dataExtent
    };
  }
  function worst(row, rowFixedLength, ratio) {
    var areaMax = 0;
    var areaMin = Infinity;
    for (var i = 0, area = void 0, len2 = row.length; i < len2; i++) {
      area = row[i].getLayout().area;
      if (area) {
        area < areaMin && (areaMin = area);
        area > areaMax && (areaMax = area);
      }
    }
    var squareArea = row.area * row.area;
    var f = rowFixedLength * rowFixedLength * ratio;
    return squareArea ? mathMax8(f * areaMax / squareArea, squareArea / (f * areaMin)) : Infinity;
  }
  function position(row, rowFixedLength, rect, halfGapWidth, flush) {
    var idx0WhenH = rowFixedLength === rect.width ? 0 : 1;
    var idx1WhenH = 1 - idx0WhenH;
    var xy = ["x", "y"];
    var wh = ["width", "height"];
    var last = rect[xy[idx0WhenH]];
    var rowOtherLength = rowFixedLength ? row.area / rowFixedLength : 0;
    if (flush || rowOtherLength > rect[wh[idx1WhenH]]) {
      rowOtherLength = rect[wh[idx1WhenH]];
    }
    for (var i = 0, rowLen = row.length; i < rowLen; i++) {
      var node = row[i];
      var nodeLayout = {};
      var step = rowOtherLength ? node.getLayout().area / rowOtherLength : 0;
      var wh1 = nodeLayout[wh[idx1WhenH]] = mathMax8(rowOtherLength - 2 * halfGapWidth, 0);
      var remain = rect[xy[idx0WhenH]] + rect[wh[idx0WhenH]] - last;
      var modWH = i === rowLen - 1 || remain < step ? remain : step;
      var wh0 = nodeLayout[wh[idx0WhenH]] = mathMax8(modWH - 2 * halfGapWidth, 0);
      nodeLayout[xy[idx1WhenH]] = rect[xy[idx1WhenH]] + mathMin8(halfGapWidth, wh1 / 2);
      nodeLayout[xy[idx0WhenH]] = last + mathMin8(halfGapWidth, wh0 / 2);
      last += modWH;
      node.setLayout(nodeLayout, true);
    }
    rect[xy[idx1WhenH]] += rowOtherLength;
    rect[wh[idx1WhenH]] -= rowOtherLength;
  }
  function estimateRootSize(seriesModel, targetInfo, viewRoot, containerWidth, containerHeight) {
    var currNode = (targetInfo || {}).node;
    var defaultSize = [containerWidth, containerHeight];
    if (!currNode || currNode === viewRoot) {
      return defaultSize;
    }
    var parent;
    var viewArea = containerWidth * containerHeight;
    var area = viewArea * seriesModel.option.zoomToNodeRatio;
    while (parent = currNode.parentNode) {
      var sum2 = 0;
      var siblings = parent.children;
      for (var i = 0, len2 = siblings.length; i < len2; i++) {
        sum2 += siblings[i].getValue();
      }
      var currNodeValue = currNode.getValue();
      if (currNodeValue === 0) {
        return defaultSize;
      }
      area *= sum2 / currNodeValue;
      var parentModel = parent.getModel();
      var borderWidth = parentModel.get(PATH_BORDER_WIDTH);
      var upperHeight = Math.max(borderWidth, getUpperLabelHeight(parentModel));
      area += 4 * borderWidth * borderWidth + (3 * borderWidth + upperHeight) * Math.pow(area, 0.5);
      area > MAX_SAFE_INTEGER && (area = MAX_SAFE_INTEGER);
      currNode = parent;
    }
    area < viewArea && (area = viewArea);
    var scale4 = Math.pow(area / viewArea, 0.5);
    return [containerWidth * scale4, containerHeight * scale4];
  }
  function calculateRootPosition(layoutInfo, rootRect, targetInfo) {
    if (rootRect) {
      return {
        x: rootRect.x,
        y: rootRect.y
      };
    }
    var defaultPosition = {
      x: 0,
      y: 0
    };
    if (!targetInfo) {
      return defaultPosition;
    }
    var targetNode = targetInfo.node;
    var layout5 = targetNode.getLayout();
    if (!layout5) {
      return defaultPosition;
    }
    var targetCenter = [layout5.width / 2, layout5.height / 2];
    var node = targetNode;
    while (node) {
      var nodeLayout = node.getLayout();
      targetCenter[0] += nodeLayout.x;
      targetCenter[1] += nodeLayout.y;
      node = node.parentNode;
    }
    return {
      x: layoutInfo.width / 2 - targetCenter[0],
      y: layoutInfo.height / 2 - targetCenter[1]
    };
  }
  function prunning(node, clipRect, viewAbovePath, viewRoot, depth) {
    var nodeLayout = node.getLayout();
    var nodeInViewAbovePath = viewAbovePath[depth];
    var isAboveViewRoot = nodeInViewAbovePath && nodeInViewAbovePath === node;
    if (nodeInViewAbovePath && !isAboveViewRoot || depth === viewAbovePath.length && node !== viewRoot) {
      return;
    }
    node.setLayout({
      isInView: true,
      invisible: !isAboveViewRoot && !clipRect.intersect(nodeLayout),
      isAboveViewRoot
    }, true);
    var childClipRect = new BoundingRect_default(clipRect.x - nodeLayout.x, clipRect.y - nodeLayout.y, clipRect.width, clipRect.height);
    each5(node.viewChildren || [], function(child) {
      prunning(child, childClipRect, viewAbovePath, viewRoot, depth + 1);
    });
  }
  function getUpperLabelHeight(model) {
    return model.get(PATH_UPPER_LABEL_SHOW) ? model.get(PATH_UPPER_LABEL_HEIGHT) : 0;
  }

  // node_modules/echarts/lib/chart/treemap/install.js
  function install13(registers) {
    registers.registerSeriesModel(TreemapSeries_default);
    registers.registerChartView(TreemapView_default);
    registers.registerVisual(treemapVisual_default);
    registers.registerLayout(treemapLayout_default);
    installTreemapAction(registers);
  }

  // node_modules/echarts/lib/chart/graph/categoryFilter.js
  function categoryFilter(ecModel) {
    var legendModels = ecModel.findComponents({
      mainType: "legend"
    });
    if (!legendModels || !legendModels.length) {
      return;
    }
    ecModel.eachSeriesByType("graph", function(graphSeries) {
      var categoriesData = graphSeries.getCategoriesData();
      var graph = graphSeries.getGraph();
      var data = graph.data;
      var categoryNames = categoriesData.mapArray(categoriesData.getName);
      data.filterSelf(function(idx) {
        var model = data.getItemModel(idx);
        var category = model.getShallow("category");
        if (category != null) {
          if (isNumber(category)) {
            category = categoryNames[category];
          }
          for (var i = 0; i < legendModels.length; i++) {
            if (!legendModels[i].isSelected(category)) {
              return false;
            }
          }
        }
        return true;
      });
    });
  }

  // node_modules/echarts/lib/chart/graph/categoryVisual.js
  function categoryVisual(ecModel) {
    var paletteScope = {};
    ecModel.eachSeriesByType("graph", function(seriesModel) {
      var categoriesData = seriesModel.getCategoriesData();
      var data = seriesModel.getData();
      var categoryNameIdxMap = {};
      categoriesData.each(function(idx) {
        var name = categoriesData.getName(idx);
        categoryNameIdxMap["ec-" + name] = idx;
        var itemModel = categoriesData.getItemModel(idx);
        var style = itemModel.getModel("itemStyle").getItemStyle();
        if (!style.fill) {
          style.fill = seriesModel.getColorFromPalette(name, paletteScope);
        }
        categoriesData.setItemVisual(idx, "style", style);
        var symbolVisualList = ["symbol", "symbolSize", "symbolKeepAspect"];
        for (var i = 0; i < symbolVisualList.length; i++) {
          var symbolVisual = itemModel.getShallow(symbolVisualList[i], true);
          if (symbolVisual != null) {
            categoriesData.setItemVisual(idx, symbolVisualList[i], symbolVisual);
          }
        }
      });
      if (categoriesData.count()) {
        data.each(function(idx) {
          var model = data.getItemModel(idx);
          var categoryIdx = model.getShallow("category");
          if (categoryIdx != null) {
            if (isString(categoryIdx)) {
              categoryIdx = categoryNameIdxMap["ec-" + categoryIdx];
            }
            var categoryStyle = categoriesData.getItemVisual(categoryIdx, "style");
            var style = data.ensureUniqueItemVisual(idx, "style");
            extend(style, categoryStyle);
            var visualList = ["symbol", "symbolSize", "symbolKeepAspect"];
            for (var i = 0; i < visualList.length; i++) {
              data.setItemVisual(idx, visualList[i], categoriesData.getItemVisual(categoryIdx, visualList[i]));
            }
          }
        });
      }
    });
  }

  // node_modules/echarts/lib/chart/graph/edgeVisual.js
  function normalize3(a) {
    if (!(a instanceof Array)) {
      a = [a, a];
    }
    return a;
  }
  function graphEdgeVisual(ecModel) {
    ecModel.eachSeriesByType("graph", function(seriesModel) {
      var graph = seriesModel.getGraph();
      var edgeData = seriesModel.getEdgeData();
      var symbolType = normalize3(seriesModel.get("edgeSymbol"));
      var symbolSize = normalize3(seriesModel.get("edgeSymbolSize"));
      edgeData.setVisual("fromSymbol", symbolType && symbolType[0]);
      edgeData.setVisual("toSymbol", symbolType && symbolType[1]);
      edgeData.setVisual("fromSymbolSize", symbolSize && symbolSize[0]);
      edgeData.setVisual("toSymbolSize", symbolSize && symbolSize[1]);
      edgeData.setVisual("style", seriesModel.getModel("lineStyle").getLineStyle());
      edgeData.each(function(idx) {
        var itemModel = edgeData.getItemModel(idx);
        var edge = graph.getEdgeByIndex(idx);
        var symbolType2 = normalize3(itemModel.getShallow("symbol", true));
        var symbolSize2 = normalize3(itemModel.getShallow("symbolSize", true));
        var style = itemModel.getModel("lineStyle").getLineStyle();
        var existsStyle = edgeData.ensureUniqueItemVisual(idx, "style");
        extend(existsStyle, style);
        switch (existsStyle.stroke) {
          case "source": {
            var nodeStyle = edge.node1.getVisual("style");
            existsStyle.stroke = nodeStyle && nodeStyle.fill;
            break;
          }
          case "target": {
            var nodeStyle = edge.node2.getVisual("style");
            existsStyle.stroke = nodeStyle && nodeStyle.fill;
            break;
          }
        }
        symbolType2[0] && edge.setVisual("fromSymbol", symbolType2[0]);
        symbolType2[1] && edge.setVisual("toSymbol", symbolType2[1]);
        symbolSize2[0] && edge.setVisual("fromSymbolSize", symbolSize2[0]);
        symbolSize2[1] && edge.setVisual("toSymbolSize", symbolSize2[1]);
      });
    });
  }

  // node_modules/echarts/lib/chart/helper/multipleGraphEdgeHelper.js
  var KEY_DELIMITER = "-->";
  var getAutoCurvenessParams = function(seriesModel) {
    return seriesModel.get("autoCurveness") || null;
  };
  var createCurveness = function(seriesModel, appendLength) {
    var autoCurvenessParmas = getAutoCurvenessParams(seriesModel);
    var length2 = 20;
    var curvenessList = [];
    if (isNumber(autoCurvenessParmas)) {
      length2 = autoCurvenessParmas;
    } else if (isArray(autoCurvenessParmas)) {
      seriesModel.__curvenessList = autoCurvenessParmas;
      return;
    }
    if (appendLength > length2) {
      length2 = appendLength;
    }
    var len2 = length2 % 2 ? length2 + 2 : length2 + 3;
    curvenessList = [];
    for (var i = 0; i < len2; i++) {
      curvenessList.push((i % 2 ? i + 1 : i) / 10 * (i % 2 ? -1 : 1));
    }
    seriesModel.__curvenessList = curvenessList;
  };
  var getKeyOfEdges = function(n1, n2, seriesModel) {
    var source = [n1.id, n1.dataIndex].join(".");
    var target = [n2.id, n2.dataIndex].join(".");
    return [seriesModel.uid, source, target].join(KEY_DELIMITER);
  };
  var getOppositeKey = function(key) {
    var keys2 = key.split(KEY_DELIMITER);
    return [keys2[0], keys2[2], keys2[1]].join(KEY_DELIMITER);
  };
  var getEdgeFromMap = function(edge, seriesModel) {
    var key = getKeyOfEdges(edge.node1, edge.node2, seriesModel);
    return seriesModel.__edgeMap[key];
  };
  var getTotalLengthBetweenNodes = function(edge, seriesModel) {
    var len2 = getEdgeMapLengthWithKey(getKeyOfEdges(edge.node1, edge.node2, seriesModel), seriesModel);
    var lenV = getEdgeMapLengthWithKey(getKeyOfEdges(edge.node2, edge.node1, seriesModel), seriesModel);
    return len2 + lenV;
  };
  var getEdgeMapLengthWithKey = function(key, seriesModel) {
    var edgeMap = seriesModel.__edgeMap;
    return edgeMap[key] ? edgeMap[key].length : 0;
  };
  function initCurvenessList(seriesModel) {
    if (!getAutoCurvenessParams(seriesModel)) {
      return;
    }
    seriesModel.__curvenessList = [];
    seriesModel.__edgeMap = {};
    createCurveness(seriesModel);
  }
  function createEdgeMapForCurveness(n1, n2, seriesModel, index) {
    if (!getAutoCurvenessParams(seriesModel)) {
      return;
    }
    var key = getKeyOfEdges(n1, n2, seriesModel);
    var edgeMap = seriesModel.__edgeMap;
    var oppositeEdges = edgeMap[getOppositeKey(key)];
    if (edgeMap[key] && !oppositeEdges) {
      edgeMap[key].isForward = true;
    } else if (oppositeEdges && edgeMap[key]) {
      oppositeEdges.isForward = true;
      edgeMap[key].isForward = false;
    }
    edgeMap[key] = edgeMap[key] || [];
    edgeMap[key].push(index);
  }
  function getCurvenessForEdge(edge, seriesModel, index, needReverse) {
    var autoCurvenessParams = getAutoCurvenessParams(seriesModel);
    var isArrayParam = isArray(autoCurvenessParams);
    if (!autoCurvenessParams) {
      return null;
    }
    var edgeArray = getEdgeFromMap(edge, seriesModel);
    if (!edgeArray) {
      return null;
    }
    var edgeIndex = -1;
    for (var i = 0; i < edgeArray.length; i++) {
      if (edgeArray[i] === index) {
        edgeIndex = i;
        break;
      }
    }
    var totalLen = getTotalLengthBetweenNodes(edge, seriesModel);
    createCurveness(seriesModel, totalLen);
    edge.lineStyle = edge.lineStyle || {};
    var curKey = getKeyOfEdges(edge.node1, edge.node2, seriesModel);
    var curvenessList = seriesModel.__curvenessList;
    var parityCorrection = isArrayParam ? 0 : totalLen % 2 ? 0 : 1;
    if (!edgeArray.isForward) {
      var oppositeKey = getOppositeKey(curKey);
      var len2 = getEdgeMapLengthWithKey(oppositeKey, seriesModel);
      var resValue = curvenessList[edgeIndex + len2 + parityCorrection];
      if (needReverse) {
        if (isArrayParam) {
          if (autoCurvenessParams && autoCurvenessParams[0] === 0) {
            return (len2 + parityCorrection) % 2 ? resValue : -resValue;
          } else {
            return ((len2 % 2 ? 0 : 1) + parityCorrection) % 2 ? resValue : -resValue;
          }
        } else {
          return (len2 + parityCorrection) % 2 ? resValue : -resValue;
        }
      } else {
        return curvenessList[edgeIndex + len2 + parityCorrection];
      }
    } else {
      return curvenessList[parityCorrection + edgeIndex];
    }
  }

  // node_modules/echarts/lib/chart/graph/simpleLayoutHelper.js
  function simpleLayout(seriesModel) {
    var coordSys = seriesModel.coordinateSystem;
    if (coordSys && coordSys.type !== "view") {
      return;
    }
    var graph = seriesModel.getGraph();
    graph.eachNode(function(node) {
      var model = node.getModel();
      node.setLayout([+model.get("x"), +model.get("y")]);
    });
    simpleLayoutEdge(graph, seriesModel);
  }
  function simpleLayoutEdge(graph, seriesModel) {
    graph.eachEdge(function(edge, index) {
      var curveness = retrieve3(edge.getModel().get(["lineStyle", "curveness"]), -getCurvenessForEdge(edge, seriesModel, index, true), 0);
      var p1 = clone2(edge.node1.getLayout());
      var p2 = clone2(edge.node2.getLayout());
      var points4 = [p1, p2];
      if (+curveness) {
        points4.push([(p1[0] + p2[0]) / 2 - (p1[1] - p2[1]) * curveness, (p1[1] + p2[1]) / 2 - (p2[0] - p1[0]) * curveness]);
      }
      edge.setLayout(points4);
    });
  }

  // node_modules/echarts/lib/chart/graph/simpleLayout.js
  function graphSimpleLayout(ecModel, api) {
    ecModel.eachSeriesByType("graph", function(seriesModel) {
      var layout5 = seriesModel.get("layout");
      var coordSys = seriesModel.coordinateSystem;
      if (coordSys && coordSys.type !== "view") {
        var data_1 = seriesModel.getData();
        var dimensions_1 = [];
        each(coordSys.dimensions, function(coordDim) {
          dimensions_1 = dimensions_1.concat(data_1.mapDimensionsAll(coordDim));
        });
        for (var dataIndex = 0; dataIndex < data_1.count(); dataIndex++) {
          var value = [];
          var hasValue = false;
          for (var i = 0; i < dimensions_1.length; i++) {
            var val = data_1.get(dimensions_1[i], dataIndex);
            if (!isNaN(val)) {
              hasValue = true;
            }
            value.push(val);
          }
          if (hasValue) {
            data_1.setItemLayout(dataIndex, coordSys.dataToPoint(value));
          } else {
            data_1.setItemLayout(dataIndex, [NaN, NaN]);
          }
        }
        simpleLayoutEdge(data_1.graph, seriesModel);
      } else if (!layout5 || layout5 === "none") {
        simpleLayout(seriesModel);
      }
    });
  }

  // node_modules/echarts/lib/chart/graph/graphHelper.js
  function getNodeGlobalScale(seriesModel) {
    var coordSys = seriesModel.coordinateSystem;
    if (coordSys.type !== "view") {
      return 1;
    }
    var nodeScaleRatio = seriesModel.option.nodeScaleRatio;
    var groupZoom = coordSys.scaleX;
    var roamZoom = coordSys.getZoom();
    var nodeScale = (roamZoom - 1) * nodeScaleRatio + 1;
    return nodeScale / groupZoom;
  }
  function getSymbolSize(node) {
    var symbolSize = node.getVisual("symbolSize");
    if (symbolSize instanceof Array) {
      symbolSize = (symbolSize[0] + symbolSize[1]) / 2;
    }
    return +symbolSize;
  }

  // node_modules/echarts/lib/chart/graph/circularLayoutHelper.js
  var PI8 = Math.PI;
  var _symbolRadiansHalf = [];
  function circularLayout(seriesModel, basedOn) {
    var coordSys = seriesModel.coordinateSystem;
    if (coordSys && coordSys.type !== "view") {
      return;
    }
    var rect = coordSys.getBoundingRect();
    var nodeData = seriesModel.getData();
    var graph = nodeData.graph;
    var cx = rect.width / 2 + rect.x;
    var cy = rect.height / 2 + rect.y;
    var r = Math.min(rect.width, rect.height) / 2;
    var count2 = nodeData.count();
    nodeData.setLayout({
      cx,
      cy
    });
    if (!count2) {
      return;
    }
    _layoutNodesBasedOn[basedOn](seriesModel, graph, nodeData, r, cx, cy, count2);
    graph.eachEdge(function(edge, index) {
      var curveness = retrieve3(edge.getModel().get(["lineStyle", "curveness"]), getCurvenessForEdge(edge, seriesModel, index), 0);
      var p1 = clone2(edge.node1.getLayout());
      var p2 = clone2(edge.node2.getLayout());
      var cp1;
      var x12 = (p1[0] + p2[0]) / 2;
      var y12 = (p1[1] + p2[1]) / 2;
      if (+curveness) {
        curveness *= 3;
        cp1 = [cx * curveness + x12 * (1 - curveness), cy * curveness + y12 * (1 - curveness)];
      }
      edge.setLayout([p1, p2, cp1]);
    });
  }
  var _layoutNodesBasedOn = {
    value: function(seriesModel, graph, nodeData, r, cx, cy, count2) {
      var angle = 0;
      var sum2 = nodeData.getSum("value");
      var unitAngle = Math.PI * 2 / (sum2 || count2);
      graph.eachNode(function(node) {
        var value = node.getValue("value");
        var radianHalf = unitAngle * (sum2 ? value : 1) / 2;
        angle += radianHalf;
        node.setLayout([r * Math.cos(angle) + cx, r * Math.sin(angle) + cy]);
        angle += radianHalf;
      });
    },
    symbolSize: function(seriesModel, graph, nodeData, r, cx, cy, count2) {
      var sumRadian = 0;
      _symbolRadiansHalf.length = count2;
      var nodeScale = getNodeGlobalScale(seriesModel);
      graph.eachNode(function(node) {
        var symbolSize = getSymbolSize(node);
        isNaN(symbolSize) && (symbolSize = 2);
        symbolSize < 0 && (symbolSize = 0);
        symbolSize *= nodeScale;
        var symbolRadianHalf = Math.asin(symbolSize / 2 / r);
        isNaN(symbolRadianHalf) && (symbolRadianHalf = PI8 / 2);
        _symbolRadiansHalf[node.dataIndex] = symbolRadianHalf;
        sumRadian += symbolRadianHalf * 2;
      });
      var halfRemainRadian = (2 * PI8 - sumRadian) / count2 / 2;
      var angle = 0;
      graph.eachNode(function(node) {
        var radianHalf = halfRemainRadian + _symbolRadiansHalf[node.dataIndex];
        angle += radianHalf;
        node.setLayout([r * Math.cos(angle) + cx, r * Math.sin(angle) + cy]);
        angle += radianHalf;
      });
    }
  };

  // node_modules/echarts/lib/chart/graph/circularLayout.js
  function graphCircularLayout(ecModel) {
    ecModel.eachSeriesByType("graph", function(seriesModel) {
      if (seriesModel.get("layout") === "circular") {
        circularLayout(seriesModel, "symbolSize");
      }
    });
  }

  // node_modules/echarts/lib/chart/graph/forceHelper.js
  var scaleAndAdd2 = scaleAndAdd;
  function forceLayout(inNodes, inEdges, opts) {
    var nodes = inNodes;
    var edges = inEdges;
    var rect = opts.rect;
    var width = rect.width;
    var height = rect.height;
    var center3 = [rect.x + width / 2, rect.y + height / 2];
    var gravity = opts.gravity == null ? 0.1 : opts.gravity;
    for (var i = 0; i < nodes.length; i++) {
      var n = nodes[i];
      if (!n.p) {
        n.p = create(width * (Math.random() - 0.5) + center3[0], height * (Math.random() - 0.5) + center3[1]);
      }
      n.pp = clone2(n.p);
      n.edges = null;
    }
    var initialFriction = opts.friction == null ? 0.6 : opts.friction;
    var friction = initialFriction;
    var beforeStepCallback;
    var afterStepCallback;
    return {
      warmUp: function() {
        friction = initialFriction * 0.8;
      },
      setFixed: function(idx) {
        nodes[idx].fixed = true;
      },
      setUnfixed: function(idx) {
        nodes[idx].fixed = false;
      },
      beforeStep: function(cb) {
        beforeStepCallback = cb;
      },
      afterStep: function(cb) {
        afterStepCallback = cb;
      },
      step: function(cb) {
        beforeStepCallback && beforeStepCallback(nodes, edges);
        var v12 = [];
        var nLen = nodes.length;
        for (var i2 = 0; i2 < edges.length; i2++) {
          var e2 = edges[i2];
          if (e2.ignoreForceLayout) {
            continue;
          }
          var n1 = e2.n1;
          var n2 = e2.n2;
          sub(v12, n2.p, n1.p);
          var d = len(v12) - e2.d;
          var w = n2.w / (n1.w + n2.w);
          if (isNaN(w)) {
            w = 0;
          }
          normalize(v12, v12);
          !n1.fixed && scaleAndAdd2(n1.p, n1.p, v12, w * d * friction);
          !n2.fixed && scaleAndAdd2(n2.p, n2.p, v12, -(1 - w) * d * friction);
        }
        for (var i2 = 0; i2 < nLen; i2++) {
          var n3 = nodes[i2];
          if (!n3.fixed) {
            sub(v12, center3, n3.p);
            scaleAndAdd2(n3.p, n3.p, v12, gravity * friction);
          }
        }
        for (var i2 = 0; i2 < nLen; i2++) {
          var n1 = nodes[i2];
          for (var j = i2 + 1; j < nLen; j++) {
            var n2 = nodes[j];
            sub(v12, n2.p, n1.p);
            var d = len(v12);
            if (d === 0) {
              set(v12, Math.random() - 0.5, Math.random() - 0.5);
              d = 1;
            }
            var repFact = (n1.rep + n2.rep) / d / d;
            !n1.fixed && scaleAndAdd2(n1.pp, n1.pp, v12, repFact);
            !n2.fixed && scaleAndAdd2(n2.pp, n2.pp, v12, -repFact);
          }
        }
        var v = [];
        for (var i2 = 0; i2 < nLen; i2++) {
          var n3 = nodes[i2];
          if (!n3.fixed) {
            sub(v, n3.p, n3.pp);
            scaleAndAdd2(n3.p, n3.p, v, friction);
            copy(n3.pp, n3.p);
          }
        }
        friction = friction * 0.992;
        var finished = friction < 0.01;
        afterStepCallback && afterStepCallback(nodes, edges, finished);
        cb && cb(finished);
      }
    };
  }

  // node_modules/echarts/lib/chart/graph/forceLayout.js
  function graphForceLayout(ecModel) {
    ecModel.eachSeriesByType("graph", function(graphSeries) {
      var coordSys = graphSeries.coordinateSystem;
      if (coordSys && coordSys.type !== "view") {
        return;
      }
      if (graphSeries.get("layout") === "force") {
        var preservedPoints_1 = graphSeries.preservedPoints || {};
        var graph_1 = graphSeries.getGraph();
        var nodeData_1 = graph_1.data;
        var edgeData = graph_1.edgeData;
        var forceModel = graphSeries.getModel("force");
        var initLayout = forceModel.get("initLayout");
        if (graphSeries.preservedPoints) {
          nodeData_1.each(function(idx) {
            var id = nodeData_1.getId(idx);
            nodeData_1.setItemLayout(idx, preservedPoints_1[id] || [NaN, NaN]);
          });
        } else if (!initLayout || initLayout === "none") {
          simpleLayout(graphSeries);
        } else if (initLayout === "circular") {
          circularLayout(graphSeries, "value");
        }
        var nodeDataExtent_1 = nodeData_1.getDataExtent("value");
        var edgeDataExtent_1 = edgeData.getDataExtent("value");
        var repulsion = forceModel.get("repulsion");
        var edgeLength = forceModel.get("edgeLength");
        var repulsionArr_1 = isArray(repulsion) ? repulsion : [repulsion, repulsion];
        var edgeLengthArr_1 = isArray(edgeLength) ? edgeLength : [edgeLength, edgeLength];
        edgeLengthArr_1 = [edgeLengthArr_1[1], edgeLengthArr_1[0]];
        var nodes_1 = nodeData_1.mapArray("value", function(value, idx) {
          var point = nodeData_1.getItemLayout(idx);
          var rep = linearMap(value, nodeDataExtent_1, repulsionArr_1);
          if (isNaN(rep)) {
            rep = (repulsionArr_1[0] + repulsionArr_1[1]) / 2;
          }
          return {
            w: rep,
            rep,
            fixed: nodeData_1.getItemModel(idx).get("fixed"),
            p: !point || isNaN(point[0]) || isNaN(point[1]) ? null : point
          };
        });
        var edges = edgeData.mapArray("value", function(value, idx) {
          var edge = graph_1.getEdgeByIndex(idx);
          var d = linearMap(value, edgeDataExtent_1, edgeLengthArr_1);
          if (isNaN(d)) {
            d = (edgeLengthArr_1[0] + edgeLengthArr_1[1]) / 2;
          }
          var edgeModel = edge.getModel();
          var curveness = retrieve3(edge.getModel().get(["lineStyle", "curveness"]), -getCurvenessForEdge(edge, graphSeries, idx, true), 0);
          return {
            n1: nodes_1[edge.node1.dataIndex],
            n2: nodes_1[edge.node2.dataIndex],
            d,
            curveness,
            ignoreForceLayout: edgeModel.get("ignoreForceLayout")
          };
        });
        var rect = coordSys.getBoundingRect();
        var forceInstance = forceLayout(nodes_1, edges, {
          rect,
          gravity: forceModel.get("gravity"),
          friction: forceModel.get("friction")
        });
        forceInstance.beforeStep(function(nodes, edges2) {
          for (var i = 0, l = nodes.length; i < l; i++) {
            if (nodes[i].fixed) {
              copy(nodes[i].p, graph_1.getNodeByIndex(i).getLayout());
            }
          }
        });
        forceInstance.afterStep(function(nodes, edges2, stopped) {
          for (var i = 0, l = nodes.length; i < l; i++) {
            if (!nodes[i].fixed) {
              graph_1.getNodeByIndex(i).setLayout(nodes[i].p);
            }
            preservedPoints_1[nodeData_1.getId(i)] = nodes[i].p;
          }
          for (var i = 0, l = edges2.length; i < l; i++) {
            var e2 = edges2[i];
            var edge = graph_1.getEdgeByIndex(i);
            var p1 = e2.n1.p;
            var p2 = e2.n2.p;
            var points4 = edge.getLayout();
            points4 = points4 ? points4.slice() : [];
            points4[0] = points4[0] || [];
            points4[1] = points4[1] || [];
            copy(points4[0], p1);
            copy(points4[1], p2);
            if (+e2.curveness) {
              points4[2] = [(p1[0] + p2[0]) / 2 - (p1[1] - p2[1]) * e2.curveness, (p1[1] + p2[1]) / 2 - (p2[0] - p1[0]) * e2.curveness];
            }
            edge.setLayout(points4);
          }
        });
        graphSeries.forceLayout = forceInstance;
        graphSeries.preservedPoints = preservedPoints_1;
        forceInstance.step();
      } else {
        graphSeries.forceLayout = null;
      }
    });
  }

  // node_modules/echarts/lib/chart/graph/createView.js
  function getViewRect3(seriesModel, api, aspect) {
    var option = extend(seriesModel.getBoxLayoutParams(), {
      aspect
    });
    return getLayoutRect(option, {
      width: api.getWidth(),
      height: api.getHeight()
    });
  }
  function createViewCoordSys(ecModel, api) {
    var viewList = [];
    ecModel.eachSeriesByType("graph", function(seriesModel) {
      var coordSysType = seriesModel.get("coordinateSystem");
      if (!coordSysType || coordSysType === "view") {
        var data_1 = seriesModel.getData();
        var positions = data_1.mapArray(function(idx) {
          var itemModel = data_1.getItemModel(idx);
          return [+itemModel.get("x"), +itemModel.get("y")];
        });
        var min3 = [];
        var max3 = [];
        fromPoints(positions, min3, max3);
        if (max3[0] - min3[0] === 0) {
          max3[0] += 1;
          min3[0] -= 1;
        }
        if (max3[1] - min3[1] === 0) {
          max3[1] += 1;
          min3[1] -= 1;
        }
        var aspect = (max3[0] - min3[0]) / (max3[1] - min3[1]);
        var viewRect2 = getViewRect3(seriesModel, api, aspect);
        if (isNaN(aspect)) {
          min3 = [viewRect2.x, viewRect2.y];
          max3 = [viewRect2.x + viewRect2.width, viewRect2.y + viewRect2.height];
        }
        var bbWidth = max3[0] - min3[0];
        var bbHeight = max3[1] - min3[1];
        var viewWidth = viewRect2.width;
        var viewHeight = viewRect2.height;
        var viewCoordSys = seriesModel.coordinateSystem = new View_default();
        viewCoordSys.zoomLimit = seriesModel.get("scaleLimit");
        viewCoordSys.setBoundingRect(min3[0], min3[1], bbWidth, bbHeight);
        viewCoordSys.setViewRect(viewRect2.x, viewRect2.y, viewWidth, viewHeight);
        viewCoordSys.setCenter(seriesModel.get("center"), api);
        viewCoordSys.setZoom(seriesModel.get("zoom"));
        viewList.push(viewCoordSys);
      }
    });
    return viewList;
  }

  // node_modules/echarts/lib/chart/helper/LinePath.js
  var straightLineProto = Line_default.prototype;
  var bezierCurveProto = BezierCurve_default.prototype;
  var StraightLineShape = function() {
    function StraightLineShape2() {
      this.x1 = 0;
      this.y1 = 0;
      this.x2 = 0;
      this.y2 = 0;
      this.percent = 1;
    }
    return StraightLineShape2;
  }();
  var CurveShape = function(_super) {
    __extends(CurveShape2, _super);
    function CurveShape2() {
      return _super !== null && _super.apply(this, arguments) || this;
    }
    return CurveShape2;
  }(StraightLineShape);
  function isStraightLine(shape) {
    return isNaN(+shape.cpx1) || isNaN(+shape.cpy1);
  }
  var ECLinePath = function(_super) {
    __extends(ECLinePath2, _super);
    function ECLinePath2(opts) {
      var _this = _super.call(this, opts) || this;
      _this.type = "ec-line";
      return _this;
    }
    ECLinePath2.prototype.getDefaultStyle = function() {
      return {
        stroke: "#000",
        fill: null
      };
    };
    ECLinePath2.prototype.getDefaultShape = function() {
      return new StraightLineShape();
    };
    ECLinePath2.prototype.buildPath = function(ctx, shape) {
      if (isStraightLine(shape)) {
        straightLineProto.buildPath.call(this, ctx, shape);
      } else {
        bezierCurveProto.buildPath.call(this, ctx, shape);
      }
    };
    ECLinePath2.prototype.pointAt = function(t) {
      if (isStraightLine(this.shape)) {
        return straightLineProto.pointAt.call(this, t);
      } else {
        return bezierCurveProto.pointAt.call(this, t);
      }
    };
    ECLinePath2.prototype.tangentAt = function(t) {
      var shape = this.shape;
      var p = isStraightLine(shape) ? [shape.x2 - shape.x1, shape.y2 - shape.y1] : bezierCurveProto.tangentAt.call(this, t);
      return normalize(p, p);
    };
    return ECLinePath2;
  }(Path_default);
  var LinePath_default = ECLinePath;

  // node_modules/echarts/lib/chart/helper/Line.js
  var SYMBOL_CATEGORIES = ["fromSymbol", "toSymbol"];
  function makeSymbolTypeKey(symbolCategory) {
    return "_" + symbolCategory + "Type";
  }
  function createSymbol2(name, lineData, idx) {
    var symbolType = lineData.getItemVisual(idx, name);
    if (!symbolType || symbolType === "none") {
      return;
    }
    var symbolSize = lineData.getItemVisual(idx, name + "Size");
    var symbolRotate = lineData.getItemVisual(idx, name + "Rotate");
    var symbolOffset = lineData.getItemVisual(idx, name + "Offset");
    var symbolKeepAspect = lineData.getItemVisual(idx, name + "KeepAspect");
    var symbolSizeArr = normalizeSymbolSize(symbolSize);
    var symbolOffsetArr = normalizeSymbolOffset(symbolOffset || 0, symbolSizeArr);
    var symbolPath = createSymbol(symbolType, -symbolSizeArr[0] / 2 + symbolOffsetArr[0], -symbolSizeArr[1] / 2 + symbolOffsetArr[1], symbolSizeArr[0], symbolSizeArr[1], null, symbolKeepAspect);
    symbolPath.__specifiedRotation = symbolRotate == null || isNaN(symbolRotate) ? void 0 : +symbolRotate * Math.PI / 180 || 0;
    symbolPath.name = name;
    return symbolPath;
  }
  function createLine(points4) {
    var line = new LinePath_default({
      name: "line",
      subPixelOptimize: true
    });
    setLinePoints(line.shape, points4);
    return line;
  }
  function setLinePoints(targetShape, points4) {
    targetShape.x1 = points4[0][0];
    targetShape.y1 = points4[0][1];
    targetShape.x2 = points4[1][0];
    targetShape.y2 = points4[1][1];
    targetShape.percent = 1;
    var cp1 = points4[2];
    if (cp1) {
      targetShape.cpx1 = cp1[0];
      targetShape.cpy1 = cp1[1];
    } else {
      targetShape.cpx1 = NaN;
      targetShape.cpy1 = NaN;
    }
  }
  var Line2 = function(_super) {
    __extends(Line3, _super);
    function Line3(lineData, idx, seriesScope) {
      var _this = _super.call(this) || this;
      _this._createLine(lineData, idx, seriesScope);
      return _this;
    }
    Line3.prototype._createLine = function(lineData, idx, seriesScope) {
      var seriesModel = lineData.hostModel;
      var linePoints = lineData.getItemLayout(idx);
      var line = createLine(linePoints);
      line.shape.percent = 0;
      initProps(line, {
        shape: {
          percent: 1
        }
      }, seriesModel, idx);
      this.add(line);
      each(SYMBOL_CATEGORIES, function(symbolCategory) {
        var symbol = createSymbol2(symbolCategory, lineData, idx);
        this.add(symbol);
        this[makeSymbolTypeKey(symbolCategory)] = lineData.getItemVisual(idx, symbolCategory);
      }, this);
      this._updateCommonStl(lineData, idx, seriesScope);
    };
    Line3.prototype.updateData = function(lineData, idx, seriesScope) {
      var seriesModel = lineData.hostModel;
      var line = this.childOfName("line");
      var linePoints = lineData.getItemLayout(idx);
      var target = {
        shape: {}
      };
      setLinePoints(target.shape, linePoints);
      updateProps(line, target, seriesModel, idx);
      each(SYMBOL_CATEGORIES, function(symbolCategory) {
        var symbolType = lineData.getItemVisual(idx, symbolCategory);
        var key = makeSymbolTypeKey(symbolCategory);
        if (this[key] !== symbolType) {
          this.remove(this.childOfName(symbolCategory));
          var symbol = createSymbol2(symbolCategory, lineData, idx);
          this.add(symbol);
        }
        this[key] = symbolType;
      }, this);
      this._updateCommonStl(lineData, idx, seriesScope);
    };
    ;
    Line3.prototype.getLinePath = function() {
      return this.childAt(0);
    };
    Line3.prototype._updateCommonStl = function(lineData, idx, seriesScope) {
      var seriesModel = lineData.hostModel;
      var line = this.childOfName("line");
      var emphasisLineStyle = seriesScope && seriesScope.emphasisLineStyle;
      var blurLineStyle = seriesScope && seriesScope.blurLineStyle;
      var selectLineStyle = seriesScope && seriesScope.selectLineStyle;
      var labelStatesModels = seriesScope && seriesScope.labelStatesModels;
      var emphasisDisabled = seriesScope && seriesScope.emphasisDisabled;
      var focus = seriesScope && seriesScope.focus;
      var blurScope = seriesScope && seriesScope.blurScope;
      if (!seriesScope || lineData.hasItemOption) {
        var itemModel = lineData.getItemModel(idx);
        var emphasisModel = itemModel.getModel("emphasis");
        emphasisLineStyle = emphasisModel.getModel("lineStyle").getLineStyle();
        blurLineStyle = itemModel.getModel(["blur", "lineStyle"]).getLineStyle();
        selectLineStyle = itemModel.getModel(["select", "lineStyle"]).getLineStyle();
        emphasisDisabled = emphasisModel.get("disabled");
        focus = emphasisModel.get("focus");
        blurScope = emphasisModel.get("blurScope");
        labelStatesModels = getLabelStatesModels(itemModel);
      }
      var lineStyle = lineData.getItemVisual(idx, "style");
      var visualColor = lineStyle.stroke;
      line.useStyle(lineStyle);
      line.style.fill = null;
      line.style.strokeNoScale = true;
      line.ensureState("emphasis").style = emphasisLineStyle;
      line.ensureState("blur").style = blurLineStyle;
      line.ensureState("select").style = selectLineStyle;
      each(SYMBOL_CATEGORIES, function(symbolCategory) {
        var symbol = this.childOfName(symbolCategory);
        if (symbol) {
          symbol.setColor(visualColor);
          symbol.style.opacity = lineStyle.opacity;
          for (var i = 0; i < SPECIAL_STATES.length; i++) {
            var stateName = SPECIAL_STATES[i];
            var lineState = line.getState(stateName);
            if (lineState) {
              var lineStateStyle = lineState.style || {};
              var state = symbol.ensureState(stateName);
              var stateStyle = state.style || (state.style = {});
              if (lineStateStyle.stroke != null) {
                stateStyle[symbol.__isEmptyBrush ? "stroke" : "fill"] = lineStateStyle.stroke;
              }
              if (lineStateStyle.opacity != null) {
                stateStyle.opacity = lineStateStyle.opacity;
              }
            }
          }
          symbol.markRedraw();
        }
      }, this);
      var rawVal = seriesModel.getRawValue(idx);
      setLabelStyle(this, labelStatesModels, {
        labelDataIndex: idx,
        labelFetcher: {
          getFormattedLabel: function(dataIndex, stateName) {
            return seriesModel.getFormattedLabel(dataIndex, stateName, lineData.dataType);
          }
        },
        inheritColor: visualColor || "#000",
        defaultOpacity: lineStyle.opacity,
        defaultText: (rawVal == null ? lineData.getName(idx) : isFinite(rawVal) ? round(rawVal) : rawVal) + ""
      });
      var label = this.getTextContent();
      if (label) {
        var labelNormalModel = labelStatesModels.normal;
        label.__align = label.style.align;
        label.__verticalAlign = label.style.verticalAlign;
        label.__position = labelNormalModel.get("position") || "middle";
        var distance2 = labelNormalModel.get("distance");
        if (!isArray(distance2)) {
          distance2 = [distance2, distance2];
        }
        label.__labelDistance = distance2;
      }
      this.setTextConfig({
        position: null,
        local: true,
        inside: false
      });
      toggleHoverEmphasis(this, focus, blurScope, emphasisDisabled);
    };
    Line3.prototype.highlight = function() {
      enterEmphasis(this);
    };
    Line3.prototype.downplay = function() {
      leaveEmphasis(this);
    };
    Line3.prototype.updateLayout = function(lineData, idx) {
      this.setLinePoints(lineData.getItemLayout(idx));
    };
    Line3.prototype.setLinePoints = function(points4) {
      var linePath = this.childOfName("line");
      setLinePoints(linePath.shape, points4);
      linePath.dirty();
    };
    Line3.prototype.beforeUpdate = function() {
      var lineGroup = this;
      var symbolFrom = lineGroup.childOfName("fromSymbol");
      var symbolTo = lineGroup.childOfName("toSymbol");
      var label = lineGroup.getTextContent();
      if (!symbolFrom && !symbolTo && (!label || label.ignore)) {
        return;
      }
      var invScale = 1;
      var parentNode2 = this.parent;
      while (parentNode2) {
        if (parentNode2.scaleX) {
          invScale /= parentNode2.scaleX;
        }
        parentNode2 = parentNode2.parent;
      }
      var line = lineGroup.childOfName("line");
      if (!this.__dirty && !line.__dirty) {
        return;
      }
      var percent = line.shape.percent;
      var fromPos = line.pointAt(0);
      var toPos = line.pointAt(percent);
      var d = sub([], toPos, fromPos);
      normalize(d, d);
      function setSymbolRotation(symbol, percent2) {
        var specifiedRotation = symbol.__specifiedRotation;
        if (specifiedRotation == null) {
          var tangent2 = line.tangentAt(percent2);
          symbol.attr("rotation", (percent2 === 1 ? -1 : 1) * Math.PI / 2 - Math.atan2(tangent2[1], tangent2[0]));
        } else {
          symbol.attr("rotation", specifiedRotation);
        }
      }
      if (symbolFrom) {
        symbolFrom.setPosition(fromPos);
        setSymbolRotation(symbolFrom, 0);
        symbolFrom.scaleX = symbolFrom.scaleY = invScale * percent;
        symbolFrom.markRedraw();
      }
      if (symbolTo) {
        symbolTo.setPosition(toPos);
        setSymbolRotation(symbolTo, 1);
        symbolTo.scaleX = symbolTo.scaleY = invScale * percent;
        symbolTo.markRedraw();
      }
      if (label && !label.ignore) {
        label.x = label.y = 0;
        label.originX = label.originY = 0;
        var textAlign = void 0;
        var textVerticalAlign = void 0;
        var distance2 = label.__labelDistance;
        var distanceX = distance2[0] * invScale;
        var distanceY = distance2[1] * invScale;
        var halfPercent = percent / 2;
        var tangent = line.tangentAt(halfPercent);
        var n = [tangent[1], -tangent[0]];
        var cp = line.pointAt(halfPercent);
        if (n[1] > 0) {
          n[0] = -n[0];
          n[1] = -n[1];
        }
        var dir3 = tangent[0] < 0 ? -1 : 1;
        if (label.__position !== "start" && label.__position !== "end") {
          var rotation = -Math.atan2(tangent[1], tangent[0]);
          if (toPos[0] < fromPos[0]) {
            rotation = Math.PI + rotation;
          }
          label.rotation = rotation;
        }
        var dy = void 0;
        switch (label.__position) {
          case "insideStartTop":
          case "insideMiddleTop":
          case "insideEndTop":
          case "middle":
            dy = -distanceY;
            textVerticalAlign = "bottom";
            break;
          case "insideStartBottom":
          case "insideMiddleBottom":
          case "insideEndBottom":
            dy = distanceY;
            textVerticalAlign = "top";
            break;
          default:
            dy = 0;
            textVerticalAlign = "middle";
        }
        switch (label.__position) {
          case "end":
            label.x = d[0] * distanceX + toPos[0];
            label.y = d[1] * distanceY + toPos[1];
            textAlign = d[0] > 0.8 ? "left" : d[0] < -0.8 ? "right" : "center";
            textVerticalAlign = d[1] > 0.8 ? "top" : d[1] < -0.8 ? "bottom" : "middle";
            break;
          case "start":
            label.x = -d[0] * distanceX + fromPos[0];
            label.y = -d[1] * distanceY + fromPos[1];
            textAlign = d[0] > 0.8 ? "right" : d[0] < -0.8 ? "left" : "center";
            textVerticalAlign = d[1] > 0.8 ? "bottom" : d[1] < -0.8 ? "top" : "middle";
            break;
          case "insideStartTop":
          case "insideStart":
          case "insideStartBottom":
            label.x = distanceX * dir3 + fromPos[0];
            label.y = fromPos[1] + dy;
            textAlign = tangent[0] < 0 ? "right" : "left";
            label.originX = -distanceX * dir3;
            label.originY = -dy;
            break;
          case "insideMiddleTop":
          case "insideMiddle":
          case "insideMiddleBottom":
          case "middle":
            label.x = cp[0];
            label.y = cp[1] + dy;
            textAlign = "center";
            label.originY = -dy;
            break;
          case "insideEndTop":
          case "insideEnd":
          case "insideEndBottom":
            label.x = -distanceX * dir3 + toPos[0];
            label.y = toPos[1] + dy;
            textAlign = tangent[0] >= 0 ? "right" : "left";
            label.originX = distanceX * dir3;
            label.originY = -dy;
            break;
        }
        label.scaleX = label.scaleY = invScale;
        label.setStyle({
          verticalAlign: label.__verticalAlign || textVerticalAlign,
          align: label.__align || textAlign
        });
      }
    };
    return Line3;
  }(Group_default);
  var Line_default2 = Line2;

  // node_modules/echarts/lib/chart/helper/LineDraw.js
  var LineDraw = function() {
    function LineDraw2(LineCtor) {
      this.group = new Group_default();
      this._LineCtor = LineCtor || Line_default2;
    }
    LineDraw2.prototype.updateData = function(lineData) {
      var _this = this;
      this._progressiveEls = null;
      var lineDraw = this;
      var group = lineDraw.group;
      var oldLineData = lineDraw._lineData;
      lineDraw._lineData = lineData;
      if (!oldLineData) {
        group.removeAll();
      }
      var seriesScope = makeSeriesScope2(lineData);
      lineData.diff(oldLineData).add(function(idx) {
        _this._doAdd(lineData, idx, seriesScope);
      }).update(function(newIdx, oldIdx) {
        _this._doUpdate(oldLineData, lineData, oldIdx, newIdx, seriesScope);
      }).remove(function(idx) {
        group.remove(oldLineData.getItemGraphicEl(idx));
      }).execute();
    };
    ;
    LineDraw2.prototype.updateLayout = function() {
      var lineData = this._lineData;
      if (!lineData) {
        return;
      }
      lineData.eachItemGraphicEl(function(el, idx) {
        el.updateLayout(lineData, idx);
      }, this);
    };
    ;
    LineDraw2.prototype.incrementalPrepareUpdate = function(lineData) {
      this._seriesScope = makeSeriesScope2(lineData);
      this._lineData = null;
      this.group.removeAll();
    };
    ;
    LineDraw2.prototype.incrementalUpdate = function(taskParams, lineData) {
      this._progressiveEls = [];
      function updateIncrementalAndHover(el2) {
        if (!el2.isGroup && !isEffectObject(el2)) {
          el2.incremental = true;
          el2.ensureState("emphasis").hoverLayer = true;
        }
      }
      for (var idx = taskParams.start; idx < taskParams.end; idx++) {
        var itemLayout = lineData.getItemLayout(idx);
        if (lineNeedsDraw(itemLayout)) {
          var el = new this._LineCtor(lineData, idx, this._seriesScope);
          el.traverse(updateIncrementalAndHover);
          this.group.add(el);
          lineData.setItemGraphicEl(idx, el);
          this._progressiveEls.push(el);
        }
      }
    };
    ;
    LineDraw2.prototype.remove = function() {
      this.group.removeAll();
    };
    ;
    LineDraw2.prototype.eachRendered = function(cb) {
      traverseElements(this._progressiveEls || this.group, cb);
    };
    LineDraw2.prototype._doAdd = function(lineData, idx, seriesScope) {
      var itemLayout = lineData.getItemLayout(idx);
      if (!lineNeedsDraw(itemLayout)) {
        return;
      }
      var el = new this._LineCtor(lineData, idx, seriesScope);
      lineData.setItemGraphicEl(idx, el);
      this.group.add(el);
    };
    LineDraw2.prototype._doUpdate = function(oldLineData, newLineData, oldIdx, newIdx, seriesScope) {
      var itemEl = oldLineData.getItemGraphicEl(oldIdx);
      if (!lineNeedsDraw(newLineData.getItemLayout(newIdx))) {
        this.group.remove(itemEl);
        return;
      }
      if (!itemEl) {
        itemEl = new this._LineCtor(newLineData, newIdx, seriesScope);
      } else {
        itemEl.updateData(newLineData, newIdx, seriesScope);
      }
      newLineData.setItemGraphicEl(newIdx, itemEl);
      this.group.add(itemEl);
    };
    return LineDraw2;
  }();
  function isEffectObject(el) {
    return el.animators && el.animators.length > 0;
  }
  function makeSeriesScope2(lineData) {
    var hostModel = lineData.hostModel;
    var emphasisModel = hostModel.getModel("emphasis");
    return {
      lineStyle: hostModel.getModel("lineStyle").getLineStyle(),
      emphasisLineStyle: emphasisModel.getModel(["lineStyle"]).getLineStyle(),
      blurLineStyle: hostModel.getModel(["blur", "lineStyle"]).getLineStyle(),
      selectLineStyle: hostModel.getModel(["select", "lineStyle"]).getLineStyle(),
      emphasisDisabled: emphasisModel.get("disabled"),
      blurScope: emphasisModel.get("blurScope"),
      focus: emphasisModel.get("focus"),
      labelStatesModels: getLabelStatesModels(hostModel)
    };
  }
  function isPointNaN(pt) {
    return isNaN(pt[0]) || isNaN(pt[1]);
  }
  function lineNeedsDraw(pts) {
    return pts && !isPointNaN(pts[0]) && !isPointNaN(pts[1]);
  }
  var LineDraw_default = LineDraw;

  // node_modules/echarts/lib/chart/graph/adjustEdge.js
  var v1 = [];
  var v2 = [];
  var v3 = [];
  var quadraticAt2 = quadraticAt;
  var v2DistSquare = distSquare;
  var mathAbs3 = Math.abs;
  function intersectCurveCircle(curvePoints, center3, radius) {
    var p0 = curvePoints[0];
    var p1 = curvePoints[1];
    var p2 = curvePoints[2];
    var d = Infinity;
    var t;
    var radiusSquare = radius * radius;
    var interval = 0.1;
    for (var _t = 0.1; _t <= 0.9; _t += 0.1) {
      v1[0] = quadraticAt2(p0[0], p1[0], p2[0], _t);
      v1[1] = quadraticAt2(p0[1], p1[1], p2[1], _t);
      var diff = mathAbs3(v2DistSquare(v1, center3) - radiusSquare);
      if (diff < d) {
        d = diff;
        t = _t;
      }
    }
    for (var i = 0; i < 32; i++) {
      var next = t + interval;
      v2[0] = quadraticAt2(p0[0], p1[0], p2[0], t);
      v2[1] = quadraticAt2(p0[1], p1[1], p2[1], t);
      v3[0] = quadraticAt2(p0[0], p1[0], p2[0], next);
      v3[1] = quadraticAt2(p0[1], p1[1], p2[1], next);
      var diff = v2DistSquare(v2, center3) - radiusSquare;
      if (mathAbs3(diff) < 0.01) {
        break;
      }
      var nextDiff = v2DistSquare(v3, center3) - radiusSquare;
      interval /= 2;
      if (diff < 0) {
        if (nextDiff >= 0) {
          t = t + interval;
        } else {
          t = t - interval;
        }
      } else {
        if (nextDiff >= 0) {
          t = t - interval;
        } else {
          t = t + interval;
        }
      }
    }
    return t;
  }
  function adjustEdge(graph, scale4) {
    var tmp0 = [];
    var quadraticSubdivide2 = quadraticSubdivide;
    var pts = [[], [], []];
    var pts2 = [[], []];
    var v = [];
    scale4 /= 2;
    graph.eachEdge(function(edge, idx) {
      var linePoints = edge.getLayout();
      var fromSymbol = edge.getVisual("fromSymbol");
      var toSymbol = edge.getVisual("toSymbol");
      if (!linePoints.__original) {
        linePoints.__original = [clone2(linePoints[0]), clone2(linePoints[1])];
        if (linePoints[2]) {
          linePoints.__original.push(clone2(linePoints[2]));
        }
      }
      var originalPoints = linePoints.__original;
      if (linePoints[2] != null) {
        copy(pts[0], originalPoints[0]);
        copy(pts[1], originalPoints[2]);
        copy(pts[2], originalPoints[1]);
        if (fromSymbol && fromSymbol !== "none") {
          var symbolSize = getSymbolSize(edge.node1);
          var t = intersectCurveCircle(pts, originalPoints[0], symbolSize * scale4);
          quadraticSubdivide2(pts[0][0], pts[1][0], pts[2][0], t, tmp0);
          pts[0][0] = tmp0[3];
          pts[1][0] = tmp0[4];
          quadraticSubdivide2(pts[0][1], pts[1][1], pts[2][1], t, tmp0);
          pts[0][1] = tmp0[3];
          pts[1][1] = tmp0[4];
        }
        if (toSymbol && toSymbol !== "none") {
          var symbolSize = getSymbolSize(edge.node2);
          var t = intersectCurveCircle(pts, originalPoints[1], symbolSize * scale4);
          quadraticSubdivide2(pts[0][0], pts[1][0], pts[2][0], t, tmp0);
          pts[1][0] = tmp0[1];
          pts[2][0] = tmp0[2];
          quadraticSubdivide2(pts[0][1], pts[1][1], pts[2][1], t, tmp0);
          pts[1][1] = tmp0[1];
          pts[2][1] = tmp0[2];
        }
        copy(linePoints[0], pts[0]);
        copy(linePoints[1], pts[2]);
        copy(linePoints[2], pts[1]);
      } else {
        copy(pts2[0], originalPoints[0]);
        copy(pts2[1], originalPoints[1]);
        sub(v, pts2[1], pts2[0]);
        normalize(v, v);
        if (fromSymbol && fromSymbol !== "none") {
          var symbolSize = getSymbolSize(edge.node1);
          scaleAndAdd(pts2[0], pts2[0], v, symbolSize * scale4);
        }
        if (toSymbol && toSymbol !== "none") {
          var symbolSize = getSymbolSize(edge.node2);
          scaleAndAdd(pts2[1], pts2[1], v, -symbolSize * scale4);
        }
        copy(linePoints[0], pts2[0]);
        copy(linePoints[1], pts2[1]);
      }
    });
  }

  // node_modules/echarts/lib/chart/graph/GraphView.js
  function isViewCoordSys(coordSys) {
    return coordSys.type === "view";
  }
  var GraphView = function(_super) {
    __extends(GraphView2, _super);
    function GraphView2() {
      var _this = _super !== null && _super.apply(this, arguments) || this;
      _this.type = GraphView2.type;
      return _this;
    }
    GraphView2.prototype.init = function(ecModel, api) {
      var symbolDraw = new SymbolDraw_default();
      var lineDraw = new LineDraw_default();
      var group = this.group;
      this._controller = new RoamController_default(api.getZr());
      this._controllerHost = {
        target: group
      };
      group.add(symbolDraw.group);
      group.add(lineDraw.group);
      this._symbolDraw = symbolDraw;
      this._lineDraw = lineDraw;
      this._firstRender = true;
    };
    GraphView2.prototype.render = function(seriesModel, ecModel, api) {
      var _this = this;
      var coordSys = seriesModel.coordinateSystem;
      this._model = seriesModel;
      var symbolDraw = this._symbolDraw;
      var lineDraw = this._lineDraw;
      var group = this.group;
      if (isViewCoordSys(coordSys)) {
        var groupNewProp = {
          x: coordSys.x,
          y: coordSys.y,
          scaleX: coordSys.scaleX,
          scaleY: coordSys.scaleY
        };
        if (this._firstRender) {
          group.attr(groupNewProp);
        } else {
          updateProps(group, groupNewProp, seriesModel);
        }
      }
      adjustEdge(seriesModel.getGraph(), getNodeGlobalScale(seriesModel));
      var data = seriesModel.getData();
      symbolDraw.updateData(data);
      var edgeData = seriesModel.getEdgeData();
      lineDraw.updateData(edgeData);
      this._updateNodeAndLinkScale();
      this._updateController(seriesModel, ecModel, api);
      clearTimeout(this._layoutTimeout);
      var forceLayout2 = seriesModel.forceLayout;
      var layoutAnimation = seriesModel.get(["force", "layoutAnimation"]);
      if (forceLayout2) {
        this._startForceLayoutIteration(forceLayout2, layoutAnimation);
      }
      data.graph.eachNode(function(node) {
        var idx = node.dataIndex;
        var el = node.getGraphicEl();
        var itemModel = node.getModel();
        if (!el) {
          return;
        }
        el.off("drag").off("dragend");
        var draggable = itemModel.get("draggable");
        if (draggable) {
          el.on("drag", function() {
            if (forceLayout2) {
              forceLayout2.warmUp();
              !_this._layouting && _this._startForceLayoutIteration(forceLayout2, layoutAnimation);
              forceLayout2.setFixed(idx);
              data.setItemLayout(idx, [el.x, el.y]);
            }
          }).on("dragend", function() {
            if (forceLayout2) {
              forceLayout2.setUnfixed(idx);
            }
          });
        }
        el.setDraggable(draggable && !!forceLayout2, !!itemModel.get("cursor"));
        var focus = itemModel.get(["emphasis", "focus"]);
        if (focus === "adjacency") {
          getECData(el).focus = node.getAdjacentDataIndices();
        }
      });
      data.graph.eachEdge(function(edge) {
        var el = edge.getGraphicEl();
        var focus = edge.getModel().get(["emphasis", "focus"]);
        if (!el) {
          return;
        }
        if (focus === "adjacency") {
          getECData(el).focus = {
            edge: [edge.dataIndex],
            node: [edge.node1.dataIndex, edge.node2.dataIndex]
          };
        }
      });
      var circularRotateLabel = seriesModel.get("layout") === "circular" && seriesModel.get(["circular", "rotateLabel"]);
      var cx = data.getLayout("cx");
      var cy = data.getLayout("cy");
      data.eachItemGraphicEl(function(el, idx) {
        var itemModel = data.getItemModel(idx);
        var labelRotate = itemModel.get(["label", "rotate"]) || 0;
        var symbolPath = el.getSymbolPath();
        if (circularRotateLabel) {
          var pos = data.getItemLayout(idx);
          var rad = Math.atan2(pos[1] - cy, pos[0] - cx);
          if (rad < 0) {
            rad = Math.PI * 2 + rad;
          }
          var isLeft = pos[0] < cx;
          if (isLeft) {
            rad = rad - Math.PI;
          }
          var textPosition = isLeft ? "left" : "right";
          symbolPath.setTextConfig({
            rotation: -rad,
            position: textPosition,
            origin: "center"
          });
          var emphasisState = symbolPath.ensureState("emphasis");
          extend(emphasisState.textConfig || (emphasisState.textConfig = {}), {
            position: textPosition
          });
        } else {
          symbolPath.setTextConfig({
            rotation: labelRotate *= Math.PI / 180
          });
        }
      });
      this._firstRender = false;
    };
    GraphView2.prototype.dispose = function() {
      this._controller && this._controller.dispose();
      this._controllerHost = null;
    };
    GraphView2.prototype._startForceLayoutIteration = function(forceLayout2, layoutAnimation) {
      var self2 = this;
      (function step() {
        forceLayout2.step(function(stopped) {
          self2.updateLayout(self2._model);
          (self2._layouting = !stopped) && (layoutAnimation ? self2._layoutTimeout = setTimeout(step, 16) : step());
        });
      })();
    };
    GraphView2.prototype._updateController = function(seriesModel, ecModel, api) {
      var _this = this;
      var controller = this._controller;
      var controllerHost = this._controllerHost;
      var group = this.group;
      controller.setPointerChecker(function(e2, x, y) {
        var rect = group.getBoundingRect();
        rect.applyTransform(group.transform);
        return rect.contain(x, y) && !onIrrelevantElement(e2, api, seriesModel);
      });
      if (!isViewCoordSys(seriesModel.coordinateSystem)) {
        controller.disable();
        return;
      }
      controller.enable(seriesModel.get("roam"));
      controllerHost.zoomLimit = seriesModel.get("scaleLimit");
      controllerHost.zoom = seriesModel.coordinateSystem.getZoom();
      controller.off("pan").off("zoom").on("pan", function(e2) {
        updateViewOnPan(controllerHost, e2.dx, e2.dy);
        api.dispatchAction({
          seriesId: seriesModel.id,
          type: "graphRoam",
          dx: e2.dx,
          dy: e2.dy
        });
      }).on("zoom", function(e2) {
        updateViewOnZoom(controllerHost, e2.scale, e2.originX, e2.originY);
        api.dispatchAction({
          seriesId: seriesModel.id,
          type: "graphRoam",
          zoom: e2.scale,
          originX: e2.originX,
          originY: e2.originY
        });
        _this._updateNodeAndLinkScale();
        adjustEdge(seriesModel.getGraph(), getNodeGlobalScale(seriesModel));
        _this._lineDraw.updateLayout();
        api.updateLabelLayout();
      });
    };
    GraphView2.prototype._updateNodeAndLinkScale = function() {
      var seriesModel = this._model;
      var data = seriesModel.getData();
      var nodeScale = getNodeGlobalScale(seriesModel);
      data.eachItemGraphicEl(function(el, idx) {
        el && el.setSymbolScale(nodeScale);
      });
    };
    GraphView2.prototype.updateLayout = function(seriesModel) {
      adjustEdge(seriesModel.getGraph(), getNodeGlobalScale(seriesModel));
      this._symbolDraw.updateLayout();
      this._lineDraw.updateLayout();
    };
    GraphView2.prototype.remove = function(ecModel, api) {
      this._symbolDraw && this._symbolDraw.remove();
      this._lineDraw && this._lineDraw.remove();
    };
    GraphView2.type = "graph";
    return GraphView2;
  }(Chart_default);
  var GraphView_default = GraphView;

  // node_modules/echarts/lib/data/Graph.js
  function generateNodeKey(id) {
    return "_EC_" + id;
  }
  var Graph = function() {
    function Graph2(directed) {
      this.type = "graph";
      this.nodes = [];
      this.edges = [];
      this._nodesMap = {};
      this._edgesMap = {};
      this._directed = directed || false;
    }
    Graph2.prototype.isDirected = function() {
      return this._directed;
    };
    ;
    Graph2.prototype.addNode = function(id, dataIndex) {
      id = id == null ? "" + dataIndex : "" + id;
      var nodesMap = this._nodesMap;
      if (nodesMap[generateNodeKey(id)]) {
        if (true) {
          console.error("Graph nodes have duplicate name or id");
        }
        return;
      }
      var node = new GraphNode(id, dataIndex);
      node.hostGraph = this;
      this.nodes.push(node);
      nodesMap[generateNodeKey(id)] = node;
      return node;
    };
    ;
    Graph2.prototype.getNodeByIndex = function(dataIndex) {
      var rawIdx = this.data.getRawIndex(dataIndex);
      return this.nodes[rawIdx];
    };
    ;
    Graph2.prototype.getNodeById = function(id) {
      return this._nodesMap[generateNodeKey(id)];
    };
    ;
    Graph2.prototype.addEdge = function(n1, n2, dataIndex) {
      var nodesMap = this._nodesMap;
      var edgesMap = this._edgesMap;
      if (isNumber(n1)) {
        n1 = this.nodes[n1];
      }
      if (isNumber(n2)) {
        n2 = this.nodes[n2];
      }
      if (!(n1 instanceof GraphNode)) {
        n1 = nodesMap[generateNodeKey(n1)];
      }
      if (!(n2 instanceof GraphNode)) {
        n2 = nodesMap[generateNodeKey(n2)];
      }
      if (!n1 || !n2) {
        return;
      }
      var key = n1.id + "-" + n2.id;
      var edge = new GraphEdge(n1, n2, dataIndex);
      edge.hostGraph = this;
      if (this._directed) {
        n1.outEdges.push(edge);
        n2.inEdges.push(edge);
      }
      n1.edges.push(edge);
      if (n1 !== n2) {
        n2.edges.push(edge);
      }
      this.edges.push(edge);
      edgesMap[key] = edge;
      return edge;
    };
    ;
    Graph2.prototype.getEdgeByIndex = function(dataIndex) {
      var rawIdx = this.edgeData.getRawIndex(dataIndex);
      return this.edges[rawIdx];
    };
    ;
    Graph2.prototype.getEdge = function(n1, n2) {
      if (n1 instanceof GraphNode) {
        n1 = n1.id;
      }
      if (n2 instanceof GraphNode) {
        n2 = n2.id;
      }
      var edgesMap = this._edgesMap;
      if (this._directed) {
        return edgesMap[n1 + "-" + n2];
      } else {
        return edgesMap[n1 + "-" + n2] || edgesMap[n2 + "-" + n1];
      }
    };
    ;
    Graph2.prototype.eachNode = function(cb, context) {
      var nodes = this.nodes;
      var len2 = nodes.length;
      for (var i = 0; i < len2; i++) {
        if (nodes[i].dataIndex >= 0) {
          cb.call(context, nodes[i], i);
        }
      }
    };
    ;
    Graph2.prototype.eachEdge = function(cb, context) {
      var edges = this.edges;
      var len2 = edges.length;
      for (var i = 0; i < len2; i++) {
        if (edges[i].dataIndex >= 0 && edges[i].node1.dataIndex >= 0 && edges[i].node2.dataIndex >= 0) {
          cb.call(context, edges[i], i);
        }
      }
    };
    ;
    Graph2.prototype.breadthFirstTraverse = function(cb, startNode, direction, context) {
      if (!(startNode instanceof GraphNode)) {
        startNode = this._nodesMap[generateNodeKey(startNode)];
      }
      if (!startNode) {
        return;
      }
      var edgeType = direction === "out" ? "outEdges" : direction === "in" ? "inEdges" : "edges";
      for (var i = 0; i < this.nodes.length; i++) {
        this.nodes[i].__visited = false;
      }
      if (cb.call(context, startNode, null)) {
        return;
      }
      var queue = [startNode];
      while (queue.length) {
        var currentNode = queue.shift();
        var edges = currentNode[edgeType];
        for (var i = 0; i < edges.length; i++) {
          var e2 = edges[i];
          var otherNode = e2.node1 === currentNode ? e2.node2 : e2.node1;
          if (!otherNode.__visited) {
            if (cb.call(context, otherNode, currentNode)) {
              return;
            }
            queue.push(otherNode);
            otherNode.__visited = true;
          }
        }
      }
    };
    ;
    Graph2.prototype.update = function() {
      var data = this.data;
      var edgeData = this.edgeData;
      var nodes = this.nodes;
      var edges = this.edges;
      for (var i = 0, len2 = nodes.length; i < len2; i++) {
        nodes[i].dataIndex = -1;
      }
      for (var i = 0, len2 = data.count(); i < len2; i++) {
        nodes[data.getRawIndex(i)].dataIndex = i;
      }
      edgeData.filterSelf(function(idx) {
        var edge = edges[edgeData.getRawIndex(idx)];
        return edge.node1.dataIndex >= 0 && edge.node2.dataIndex >= 0;
      });
      for (var i = 0, len2 = edges.length; i < len2; i++) {
        edges[i].dataIndex = -1;
      }
      for (var i = 0, len2 = edgeData.count(); i < len2; i++) {
        edges[edgeData.getRawIndex(i)].dataIndex = i;
      }
    };
    ;
    Graph2.prototype.clone = function() {
      var graph = new Graph2(this._directed);
      var nodes = this.nodes;
      var edges = this.edges;
      for (var i = 0; i < nodes.length; i++) {
        graph.addNode(nodes[i].id, nodes[i].dataIndex);
      }
      for (var i = 0; i < edges.length; i++) {
        var e2 = edges[i];
        graph.addEdge(e2.node1.id, e2.node2.id, e2.dataIndex);
      }
      return graph;
    };
    ;
    return Graph2;
  }();
  var GraphNode = function() {
    function GraphNode2(id, dataIndex) {
      this.inEdges = [];
      this.outEdges = [];
      this.edges = [];
      this.dataIndex = -1;
      this.id = id == null ? "" : id;
      this.dataIndex = dataIndex == null ? -1 : dataIndex;
    }
    GraphNode2.prototype.degree = function() {
      return this.edges.length;
    };
    GraphNode2.prototype.inDegree = function() {
      return this.inEdges.length;
    };
    GraphNode2.prototype.outDegree = function() {
      return this.outEdges.length;
    };
    GraphNode2.prototype.getModel = function(path) {
      if (this.dataIndex < 0) {
        return;
      }
      var graph = this.hostGraph;
      var itemModel = graph.data.getItemModel(this.dataIndex);
      return itemModel.getModel(path);
    };
    GraphNode2.prototype.getAdjacentDataIndices = function() {
      var dataIndices = {
        edge: [],
        node: []
      };
      for (var i = 0; i < this.edges.length; i++) {
        var adjacentEdge = this.edges[i];
        if (adjacentEdge.dataIndex < 0) {
          continue;
        }
        dataIndices.edge.push(adjacentEdge.dataIndex);
        dataIndices.node.push(adjacentEdge.node1.dataIndex, adjacentEdge.node2.dataIndex);
      }
      return dataIndices;
    };
    return GraphNode2;
  }();
  var GraphEdge = function() {
    function GraphEdge2(n1, n2, dataIndex) {
      this.dataIndex = -1;
      this.node1 = n1;
      this.node2 = n2;
      this.dataIndex = dataIndex == null ? -1 : dataIndex;
    }
    GraphEdge2.prototype.getModel = function(path) {
      if (this.dataIndex < 0) {
        return;
      }
      var graph = this.hostGraph;
      var itemModel = graph.edgeData.getItemModel(this.dataIndex);
      return itemModel.getModel(path);
    };
    GraphEdge2.prototype.getAdjacentDataIndices = function() {
      return {
        edge: [this.dataIndex],
        node: [this.node1.dataIndex, this.node2.dataIndex]
      };
    };
    return GraphEdge2;
  }();
  function createGraphDataProxyMixin(hostName, dataName) {
    return {
      getValue: function(dimension) {
        var data = this[hostName][dataName];
        return data.getStore().get(data.getDimensionIndex(dimension || "value"), this.dataIndex);
      },
      setVisual: function(key, value) {
        this.dataIndex >= 0 && this[hostName][dataName].setItemVisual(this.dataIndex, key, value);
      },
      getVisual: function(key) {
        return this[hostName][dataName].getItemVisual(this.dataIndex, key);
      },
      setLayout: function(layout5, merge2) {
        this.dataIndex >= 0 && this[hostName][dataName].setItemLayout(this.dataIndex, layout5, merge2);
      },
      getLayout: function() {
        return this[hostName][dataName].getItemLayout(this.dataIndex);
      },
      getGraphicEl: function() {
        return this[hostName][dataName].getItemGraphicEl(this.dataIndex);
      },
      getRawIndex: function() {
        return this[hostName][dataName].getRawIndex(this.dataIndex);
      }
    };
  }
  mixin(GraphNode, createGraphDataProxyMixin("hostGraph", "data"));
  mixin(GraphEdge, createGraphDataProxyMixin("hostGraph", "edgeData"));
  var Graph_default = Graph;

  // node_modules/echarts/lib/chart/helper/createGraphFromNodeEdge.js
  function createGraphFromNodeEdge(nodes, edges, seriesModel, directed, beforeLink) {
    var graph = new Graph_default(directed);
    for (var i = 0; i < nodes.length; i++) {
      graph.addNode(retrieve(nodes[i].id, nodes[i].name, i), i);
    }
    var linkNameList = [];
    var validEdges = [];
    var linkCount = 0;
    for (var i = 0; i < edges.length; i++) {
      var link = edges[i];
      var source = link.source;
      var target = link.target;
      if (graph.addEdge(source, target, linkCount)) {
        validEdges.push(link);
        linkNameList.push(retrieve(convertOptionIdName(link.id, null), source + " > " + target));
        linkCount++;
      }
    }
    var coordSys = seriesModel.get("coordinateSystem");
    var nodeData;
    if (coordSys === "cartesian2d" || coordSys === "polar") {
      nodeData = createSeriesData_default(nodes, seriesModel);
    } else {
      var coordSysCtor = CoordinateSystem_default.get(coordSys);
      var coordDimensions = coordSysCtor ? coordSysCtor.dimensions || [] : [];
      if (indexOf(coordDimensions, "value") < 0) {
        coordDimensions.concat(["value"]);
      }
      var dimensions = prepareSeriesDataSchema(nodes, {
        coordDimensions,
        encodeDefine: seriesModel.getEncode()
      }).dimensions;
      nodeData = new SeriesData_default(dimensions, seriesModel);
      nodeData.initData(nodes);
    }
    var edgeData = new SeriesData_default(["value"], seriesModel);
    edgeData.initData(validEdges, linkNameList);
    beforeLink && beforeLink(nodeData, edgeData);
    linkSeriesData_default({
      mainData: nodeData,
      struct: graph,
      structAttr: "graph",
      datas: {
        node: nodeData,
        edge: edgeData
      },
      datasAttr: {
        node: "data",
        edge: "edgeData"
      }
    });
    graph.update();
    return graph;
  }

  // node_modules/echarts/lib/chart/graph/GraphSeries.js
  var GraphSeriesModel = function(_super) {
    __extends(GraphSeriesModel2, _super);
    function GraphSeriesModel2() {
      var _this = _super !== null && _super.apply(this, arguments) || this;
      _this.type = GraphSeriesModel2.type;
      _this.hasSymbolVisual = true;
      return _this;
    }
    GraphSeriesModel2.prototype.init = function(option) {
      _super.prototype.init.apply(this, arguments);
      var self2 = this;
      function getCategoriesData() {
        return self2._categoriesData;
      }
      this.legendVisualProvider = new LegendVisualProvider_default(getCategoriesData, getCategoriesData);
      this.fillDataTextStyle(option.edges || option.links);
      this._updateCategoriesData();
    };
    GraphSeriesModel2.prototype.mergeOption = function(option) {
      _super.prototype.mergeOption.apply(this, arguments);
      this.fillDataTextStyle(option.edges || option.links);
      this._updateCategoriesData();
    };
    GraphSeriesModel2.prototype.mergeDefaultAndTheme = function(option) {
      _super.prototype.mergeDefaultAndTheme.apply(this, arguments);
      defaultEmphasis(option, "edgeLabel", ["show"]);
    };
    GraphSeriesModel2.prototype.getInitialData = function(option, ecModel) {
      var edges = option.edges || option.links || [];
      var nodes = option.data || option.nodes || [];
      var self2 = this;
      if (nodes && edges) {
        initCurvenessList(this);
        var graph = createGraphFromNodeEdge(nodes, edges, this, true, beforeLink);
        each(graph.edges, function(edge) {
          createEdgeMapForCurveness(edge.node1, edge.node2, this, edge.dataIndex);
        }, this);
        return graph.data;
      }
      function beforeLink(nodeData, edgeData) {
        nodeData.wrapMethod("getItemModel", function(model) {
          var categoriesModels = self2._categoriesModels;
          var categoryIdx = model.getShallow("category");
          var categoryModel = categoriesModels[categoryIdx];
          if (categoryModel) {
            categoryModel.parentModel = model.parentModel;
            model.parentModel = categoryModel;
          }
          return model;
        });
        var oldGetModel = Model_default.prototype.getModel;
        function newGetModel(path, parentModel) {
          var model = oldGetModel.call(this, path, parentModel);
          model.resolveParentPath = resolveParentPath;
          return model;
        }
        edgeData.wrapMethod("getItemModel", function(model) {
          model.resolveParentPath = resolveParentPath;
          model.getModel = newGetModel;
          return model;
        });
        function resolveParentPath(pathArr) {
          if (pathArr && (pathArr[0] === "label" || pathArr[1] === "label")) {
            var newPathArr = pathArr.slice();
            if (pathArr[0] === "label") {
              newPathArr[0] = "edgeLabel";
            } else if (pathArr[1] === "label") {
              newPathArr[1] = "edgeLabel";
            }
            return newPathArr;
          }
          return pathArr;
        }
      }
    };
    GraphSeriesModel2.prototype.getGraph = function() {
      return this.getData().graph;
    };
    GraphSeriesModel2.prototype.getEdgeData = function() {
      return this.getGraph().edgeData;
    };
    GraphSeriesModel2.prototype.getCategoriesData = function() {
      return this._categoriesData;
    };
    GraphSeriesModel2.prototype.formatTooltip = function(dataIndex, multipleSeries, dataType) {
      if (dataType === "edge") {
        var nodeData = this.getData();
        var params = this.getDataParams(dataIndex, dataType);
        var edge = nodeData.graph.getEdgeByIndex(dataIndex);
        var sourceName = nodeData.getName(edge.node1.dataIndex);
        var targetName = nodeData.getName(edge.node2.dataIndex);
        var nameArr = [];
        sourceName != null && nameArr.push(sourceName);
        targetName != null && nameArr.push(targetName);
        return createTooltipMarkup("nameValue", {
          name: nameArr.join(" > "),
          value: params.value,
          noValue: params.value == null
        });
      }
      var nodeMarkup = defaultSeriesFormatTooltip({
        series: this,
        dataIndex,
        multipleSeries
      });
      return nodeMarkup;
    };
    GraphSeriesModel2.prototype._updateCategoriesData = function() {
      var categories = map(this.option.categories || [], function(category) {
        return category.value != null ? category : extend({
          value: 0
        }, category);
      });
      var categoriesData = new SeriesData_default(["value"], this);
      categoriesData.initData(categories);
      this._categoriesData = categoriesData;
      this._categoriesModels = categoriesData.mapArray(function(idx) {
        return categoriesData.getItemModel(idx);
      });
    };
    GraphSeriesModel2.prototype.setZoom = function(zoom) {
      this.option.zoom = zoom;
    };
    GraphSeriesModel2.prototype.setCenter = function(center3) {
      this.option.center = center3;
    };
    GraphSeriesModel2.prototype.isAnimationEnabled = function() {
      return _super.prototype.isAnimationEnabled.call(this) && !(this.get("layout") === "force" && this.get(["force", "layoutAnimation"]));
    };
    GraphSeriesModel2.type = "series.graph";
    GraphSeriesModel2.dependencies = ["grid", "polar", "geo", "singleAxis", "calendar"];
    GraphSeriesModel2.defaultOption = {
      z: 2,
      coordinateSystem: "view",
      legendHoverLink: true,
      layout: null,
      circular: {
        rotateLabel: false
      },
      force: {
        initLayout: null,
        repulsion: [0, 50],
        gravity: 0.1,
        friction: 0.6,
        edgeLength: 30,
        layoutAnimation: true
      },
      left: "center",
      top: "center",
      symbol: "circle",
      symbolSize: 10,
      edgeSymbol: ["none", "none"],
      edgeSymbolSize: 10,
      edgeLabel: {
        position: "middle",
        distance: 5
      },
      draggable: false,
      roam: false,
      center: null,
      zoom: 1,
      nodeScaleRatio: 0.6,
      label: {
        show: false,
        formatter: "{b}"
      },
      itemStyle: {},
      lineStyle: {
        color: "#aaa",
        width: 1,
        opacity: 0.5
      },
      emphasis: {
        scale: true,
        label: {
          show: true
        }
      },
      select: {
        itemStyle: {
          borderColor: "#212121"
        }
      }
    };
    return GraphSeriesModel2;
  }(Series_default);
  var GraphSeries_default = GraphSeriesModel;

  // node_modules/echarts/lib/chart/graph/install.js
  var actionInfo = {
    type: "graphRoam",
    event: "graphRoam",
    update: "none"
  };
  function install14(registers) {
    registers.registerChartView(GraphView_default);
    registers.registerSeriesModel(GraphSeries_default);
    registers.registerProcessor(categoryFilter);
    registers.registerVisual(categoryVisual);
    registers.registerVisual(graphEdgeVisual);
    registers.registerLayout(graphSimpleLayout);
    registers.registerLayout(registers.PRIORITY.VISUAL.POST_CHART_LAYOUT, graphCircularLayout);
    registers.registerLayout(graphForceLayout);
    registers.registerCoordinateSystem("graphView", {
      dimensions: View_default.dimensions,
      create: createViewCoordSys
    });
    registers.registerAction({
      type: "focusNodeAdjacency",
      event: "focusNodeAdjacency",
      update: "series:focusNodeAdjacency"
    }, noop);
    registers.registerAction({
      type: "unfocusNodeAdjacency",
      event: "unfocusNodeAdjacency",
      update: "series:unfocusNodeAdjacency"
    }, noop);
    registers.registerAction(actionInfo, function(payload, ecModel, api) {
      ecModel.eachComponent({
        mainType: "series",
        query: payload
      }, function(seriesModel) {
        var coordSys = seriesModel.coordinateSystem;
        var res = updateCenterAndZoom(coordSys, payload, void 0, api);
        seriesModel.setCenter && seriesModel.setCenter(res.center);
        seriesModel.setZoom && seriesModel.setZoom(res.zoom);
      });
    });
  }

  // node_modules/echarts/lib/chart/gauge/PointerPath.js
  var PointerShape = function() {
    function PointerShape2() {
      this.angle = 0;
      this.width = 10;
      this.r = 10;
      this.x = 0;
      this.y = 0;
    }
    return PointerShape2;
  }();
  var PointerPath = function(_super) {
    __extends(PointerPath2, _super);
    function PointerPath2(opts) {
      var _this = _super.call(this, opts) || this;
      _this.type = "pointer";
      return _this;
    }
    PointerPath2.prototype.getDefaultShape = function() {
      return new PointerShape();
    };
    PointerPath2.prototype.buildPath = function(ctx, shape) {
      var mathCos6 = Math.cos;
      var mathSin6 = Math.sin;
      var r = shape.r;
      var width = shape.width;
      var angle = shape.angle;
      var x = shape.x - mathCos6(angle) * width * (width >= r / 3 ? 1 : 2);
      var y = shape.y - mathSin6(angle) * width * (width >= r / 3 ? 1 : 2);
      angle = shape.angle - Math.PI / 2;
      ctx.moveTo(x, y);
      ctx.lineTo(shape.x + mathCos6(angle) * width, shape.y + mathSin6(angle) * width);
      ctx.lineTo(shape.x + mathCos6(shape.angle) * r, shape.y + mathSin6(shape.angle) * r);
      ctx.lineTo(shape.x - mathCos6(angle) * width, shape.y - mathSin6(angle) * width);
      ctx.lineTo(x, y);
    };
    return PointerPath2;
  }(Path_default);
  var PointerPath_default = PointerPath;

  // node_modules/echarts/lib/chart/gauge/GaugeView.js
  function parsePosition(seriesModel, api) {
    var center3 = seriesModel.get("center");
    var width = api.getWidth();
    var height = api.getHeight();
    var size = Math.min(width, height);
    var cx = parsePercent2(center3[0], api.getWidth());
    var cy = parsePercent2(center3[1], api.getHeight());
    var r = parsePercent2(seriesModel.get("radius"), size / 2);
    return {
      cx,
      cy,
      r
    };
  }
  function formatLabel(value, labelFormatter) {
    var label = value == null ? "" : value + "";
    if (labelFormatter) {
      if (isString(labelFormatter)) {
        label = labelFormatter.replace("{value}", label);
      } else if (isFunction(labelFormatter)) {
        label = labelFormatter(value);
      }
    }
    return label;
  }
  var GaugeView = function(_super) {
    __extends(GaugeView2, _super);
    function GaugeView2() {
      var _this = _super !== null && _super.apply(this, arguments) || this;
      _this.type = GaugeView2.type;
      return _this;
    }
    GaugeView2.prototype.render = function(seriesModel, ecModel, api) {
      this.group.removeAll();
      var colorList = seriesModel.get(["axisLine", "lineStyle", "color"]);
      var posInfo = parsePosition(seriesModel, api);
      this._renderMain(seriesModel, ecModel, api, colorList, posInfo);
      this._data = seriesModel.getData();
    };
    GaugeView2.prototype.dispose = function() {
    };
    GaugeView2.prototype._renderMain = function(seriesModel, ecModel, api, colorList, posInfo) {
      var group = this.group;
      var clockwise = seriesModel.get("clockwise");
      var startAngle = -seriesModel.get("startAngle") / 180 * Math.PI;
      var endAngle = -seriesModel.get("endAngle") / 180 * Math.PI;
      var axisLineModel = seriesModel.getModel("axisLine");
      var roundCap = axisLineModel.get("roundCap");
      var MainPath = roundCap ? sausage_default : Sector_default;
      var showAxis = axisLineModel.get("show");
      var lineStyleModel = axisLineModel.getModel("lineStyle");
      var axisLineWidth = lineStyleModel.get("width");
      var angles = [startAngle, endAngle];
      normalizeArcAngles(angles, !clockwise);
      startAngle = angles[0];
      endAngle = angles[1];
      var angleRangeSpan = endAngle - startAngle;
      var prevEndAngle = startAngle;
      for (var i = 0; showAxis && i < colorList.length; i++) {
        var percent = Math.min(Math.max(colorList[i][0], 0), 1);
        endAngle = startAngle + angleRangeSpan * percent;
        var sector = new MainPath({
          shape: {
            startAngle: prevEndAngle,
            endAngle,
            cx: posInfo.cx,
            cy: posInfo.cy,
            clockwise,
            r0: posInfo.r - axisLineWidth,
            r: posInfo.r
          },
          silent: true
        });
        sector.setStyle({
          fill: colorList[i][1]
        });
        sector.setStyle(lineStyleModel.getLineStyle(["color", "width"]));
        group.add(sector);
        prevEndAngle = endAngle;
      }
      var getColor = function(percent2) {
        if (percent2 <= 0) {
          return colorList[0][1];
        }
        var i2;
        for (i2 = 0; i2 < colorList.length; i2++) {
          if (colorList[i2][0] >= percent2 && (i2 === 0 ? 0 : colorList[i2 - 1][0]) < percent2) {
            return colorList[i2][1];
          }
        }
        return colorList[i2 - 1][1];
      };
      this._renderTicks(seriesModel, ecModel, api, getColor, posInfo, startAngle, endAngle, clockwise, axisLineWidth);
      this._renderTitleAndDetail(seriesModel, ecModel, api, getColor, posInfo);
      this._renderAnchor(seriesModel, posInfo);
      this._renderPointer(seriesModel, ecModel, api, getColor, posInfo, startAngle, endAngle, clockwise, axisLineWidth);
    };
    GaugeView2.prototype._renderTicks = function(seriesModel, ecModel, api, getColor, posInfo, startAngle, endAngle, clockwise, axisLineWidth) {
      var group = this.group;
      var cx = posInfo.cx;
      var cy = posInfo.cy;
      var r = posInfo.r;
      var minVal = +seriesModel.get("min");
      var maxVal = +seriesModel.get("max");
      var splitLineModel = seriesModel.getModel("splitLine");
      var tickModel = seriesModel.getModel("axisTick");
      var labelModel = seriesModel.getModel("axisLabel");
      var splitNumber = seriesModel.get("splitNumber");
      var subSplitNumber = tickModel.get("splitNumber");
      var splitLineLen = parsePercent2(splitLineModel.get("length"), r);
      var tickLen = parsePercent2(tickModel.get("length"), r);
      var angle = startAngle;
      var step = (endAngle - startAngle) / splitNumber;
      var subStep = step / subSplitNumber;
      var splitLineStyle = splitLineModel.getModel("lineStyle").getLineStyle();
      var tickLineStyle = tickModel.getModel("lineStyle").getLineStyle();
      var splitLineDistance = splitLineModel.get("distance");
      var unitX;
      var unitY;
      for (var i = 0; i <= splitNumber; i++) {
        unitX = Math.cos(angle);
        unitY = Math.sin(angle);
        if (splitLineModel.get("show")) {
          var distance2 = splitLineDistance ? splitLineDistance + axisLineWidth : axisLineWidth;
          var splitLine = new Line_default({
            shape: {
              x1: unitX * (r - distance2) + cx,
              y1: unitY * (r - distance2) + cy,
              x2: unitX * (r - splitLineLen - distance2) + cx,
              y2: unitY * (r - splitLineLen - distance2) + cy
            },
            style: splitLineStyle,
            silent: true
          });
          if (splitLineStyle.stroke === "auto") {
            splitLine.setStyle({
              stroke: getColor(i / splitNumber)
            });
          }
          group.add(splitLine);
        }
        if (labelModel.get("show")) {
          var distance2 = labelModel.get("distance") + splitLineDistance;
          var label = formatLabel(round(i / splitNumber * (maxVal - minVal) + minVal), labelModel.get("formatter"));
          var autoColor = getColor(i / splitNumber);
          group.add(new Text_default({
            style: createTextStyle(labelModel, {
              text: label,
              x: unitX * (r - splitLineLen - distance2) + cx,
              y: unitY * (r - splitLineLen - distance2) + cy,
              verticalAlign: unitY < -0.8 ? "top" : unitY > 0.8 ? "bottom" : "middle",
              align: unitX < -0.4 ? "left" : unitX > 0.4 ? "right" : "center"
            }, {
              inheritColor: autoColor
            }),
            silent: true
          }));
        }
        if (tickModel.get("show") && i !== splitNumber) {
          var distance2 = tickModel.get("distance");
          distance2 = distance2 ? distance2 + axisLineWidth : axisLineWidth;
          for (var j = 0; j <= subSplitNumber; j++) {
            unitX = Math.cos(angle);
            unitY = Math.sin(angle);
            var tickLine = new Line_default({
              shape: {
                x1: unitX * (r - distance2) + cx,
                y1: unitY * (r - distance2) + cy,
                x2: unitX * (r - tickLen - distance2) + cx,
                y2: unitY * (r - tickLen - distance2) + cy
              },
              silent: true,
              style: tickLineStyle
            });
            if (tickLineStyle.stroke === "auto") {
              tickLine.setStyle({
                stroke: getColor((i + j / subSplitNumber) / splitNumber)
              });
            }
            group.add(tickLine);
            angle += subStep;
          }
          angle -= subStep;
        } else {
          angle += step;
        }
      }
    };
    GaugeView2.prototype._renderPointer = function(seriesModel, ecModel, api, getColor, posInfo, startAngle, endAngle, clockwise, axisLineWidth) {
      var group = this.group;
      var oldData = this._data;
      var oldProgressData = this._progressEls;
      var progressList = [];
      var showPointer2 = seriesModel.get(["pointer", "show"]);
      var progressModel = seriesModel.getModel("progress");
      var showProgress = progressModel.get("show");
      var data = seriesModel.getData();
      var valueDim = data.mapDimension("value");
      var minVal = +seriesModel.get("min");
      var maxVal = +seriesModel.get("max");
      var valueExtent = [minVal, maxVal];
      var angleExtent = [startAngle, endAngle];
      function createPointer(idx, angle) {
        var itemModel = data.getItemModel(idx);
        var pointerModel = itemModel.getModel("pointer");
        var pointerWidth = parsePercent2(pointerModel.get("width"), posInfo.r);
        var pointerLength = parsePercent2(pointerModel.get("length"), posInfo.r);
        var pointerStr = seriesModel.get(["pointer", "icon"]);
        var pointerOffset = pointerModel.get("offsetCenter");
        var pointerOffsetX = parsePercent2(pointerOffset[0], posInfo.r);
        var pointerOffsetY = parsePercent2(pointerOffset[1], posInfo.r);
        var pointerKeepAspect = pointerModel.get("keepAspect");
        var pointer;
        if (pointerStr) {
          pointer = createSymbol(pointerStr, pointerOffsetX - pointerWidth / 2, pointerOffsetY - pointerLength, pointerWidth, pointerLength, null, pointerKeepAspect);
        } else {
          pointer = new PointerPath_default({
            shape: {
              angle: -Math.PI / 2,
              width: pointerWidth,
              r: pointerLength,
              x: pointerOffsetX,
              y: pointerOffsetY
            }
          });
        }
        pointer.rotation = -(angle + Math.PI / 2);
        pointer.x = posInfo.cx;
        pointer.y = posInfo.cy;
        return pointer;
      }
      function createProgress(idx, endAngle2) {
        var roundCap = progressModel.get("roundCap");
        var ProgressPath = roundCap ? sausage_default : Sector_default;
        var isOverlap = progressModel.get("overlap");
        var progressWidth = isOverlap ? progressModel.get("width") : axisLineWidth / data.count();
        var r0 = isOverlap ? posInfo.r - progressWidth : posInfo.r - (idx + 1) * progressWidth;
        var r = isOverlap ? posInfo.r : posInfo.r - idx * progressWidth;
        var progress = new ProgressPath({
          shape: {
            startAngle,
            endAngle: endAngle2,
            cx: posInfo.cx,
            cy: posInfo.cy,
            clockwise,
            r0,
            r
          }
        });
        isOverlap && (progress.z2 = maxVal - data.get(valueDim, idx) % maxVal);
        return progress;
      }
      if (showProgress || showPointer2) {
        data.diff(oldData).add(function(idx) {
          var val = data.get(valueDim, idx);
          if (showPointer2) {
            var pointer = createPointer(idx, startAngle);
            initProps(pointer, {
              rotation: -((isNaN(+val) ? angleExtent[0] : linearMap(val, valueExtent, angleExtent, true)) + Math.PI / 2)
            }, seriesModel);
            group.add(pointer);
            data.setItemGraphicEl(idx, pointer);
          }
          if (showProgress) {
            var progress = createProgress(idx, startAngle);
            var isClip = progressModel.get("clip");
            initProps(progress, {
              shape: {
                endAngle: linearMap(val, valueExtent, angleExtent, isClip)
              }
            }, seriesModel);
            group.add(progress);
            setCommonECData(seriesModel.seriesIndex, data.dataType, idx, progress);
            progressList[idx] = progress;
          }
        }).update(function(newIdx, oldIdx) {
          var val = data.get(valueDim, newIdx);
          if (showPointer2) {
            var previousPointer = oldData.getItemGraphicEl(oldIdx);
            var previousRotate = previousPointer ? previousPointer.rotation : startAngle;
            var pointer = createPointer(newIdx, previousRotate);
            pointer.rotation = previousRotate;
            updateProps(pointer, {
              rotation: -((isNaN(+val) ? angleExtent[0] : linearMap(val, valueExtent, angleExtent, true)) + Math.PI / 2)
            }, seriesModel);
            group.add(pointer);
            data.setItemGraphicEl(newIdx, pointer);
          }
          if (showProgress) {
            var previousProgress = oldProgressData[oldIdx];
            var previousEndAngle = previousProgress ? previousProgress.shape.endAngle : startAngle;
            var progress = createProgress(newIdx, previousEndAngle);
            var isClip = progressModel.get("clip");
            updateProps(progress, {
              shape: {
                endAngle: linearMap(val, valueExtent, angleExtent, isClip)
              }
            }, seriesModel);
            group.add(progress);
            setCommonECData(seriesModel.seriesIndex, data.dataType, newIdx, progress);
            progressList[newIdx] = progress;
          }
        }).execute();
        data.each(function(idx) {
          var itemModel = data.getItemModel(idx);
          var emphasisModel = itemModel.getModel("emphasis");
          var focus = emphasisModel.get("focus");
          var blurScope = emphasisModel.get("blurScope");
          var emphasisDisabled = emphasisModel.get("disabled");
          if (showPointer2) {
            var pointer = data.getItemGraphicEl(idx);
            var symbolStyle = data.getItemVisual(idx, "style");
            var visualColor = symbolStyle.fill;
            if (pointer instanceof Image_default) {
              var pathStyle = pointer.style;
              pointer.useStyle(extend({
                image: pathStyle.image,
                x: pathStyle.x,
                y: pathStyle.y,
                width: pathStyle.width,
                height: pathStyle.height
              }, symbolStyle));
            } else {
              pointer.useStyle(symbolStyle);
              pointer.type !== "pointer" && pointer.setColor(visualColor);
            }
            pointer.setStyle(itemModel.getModel(["pointer", "itemStyle"]).getItemStyle());
            if (pointer.style.fill === "auto") {
              pointer.setStyle("fill", getColor(linearMap(data.get(valueDim, idx), valueExtent, [0, 1], true)));
            }
            pointer.z2EmphasisLift = 0;
            setStatesStylesFromModel(pointer, itemModel);
            toggleHoverEmphasis(pointer, focus, blurScope, emphasisDisabled);
          }
          if (showProgress) {
            var progress = progressList[idx];
            progress.useStyle(data.getItemVisual(idx, "style"));
            progress.setStyle(itemModel.getModel(["progress", "itemStyle"]).getItemStyle());
            progress.z2EmphasisLift = 0;
            setStatesStylesFromModel(progress, itemModel);
            toggleHoverEmphasis(progress, focus, blurScope, emphasisDisabled);
          }
        });
        this._progressEls = progressList;
      }
    };
    GaugeView2.prototype._renderAnchor = function(seriesModel, posInfo) {
      var anchorModel = seriesModel.getModel("anchor");
      var showAnchor = anchorModel.get("show");
      if (showAnchor) {
        var anchorSize = anchorModel.get("size");
        var anchorType = anchorModel.get("icon");
        var offsetCenter = anchorModel.get("offsetCenter");
        var anchorKeepAspect = anchorModel.get("keepAspect");
        var anchor = createSymbol(anchorType, posInfo.cx - anchorSize / 2 + parsePercent2(offsetCenter[0], posInfo.r), posInfo.cy - anchorSize / 2 + parsePercent2(offsetCenter[1], posInfo.r), anchorSize, anchorSize, null, anchorKeepAspect);
        anchor.z2 = anchorModel.get("showAbove") ? 1 : 0;
        anchor.setStyle(anchorModel.getModel("itemStyle").getItemStyle());
        this.group.add(anchor);
      }
    };
    GaugeView2.prototype._renderTitleAndDetail = function(seriesModel, ecModel, api, getColor, posInfo) {
      var _this = this;
      var data = seriesModel.getData();
      var valueDim = data.mapDimension("value");
      var minVal = +seriesModel.get("min");
      var maxVal = +seriesModel.get("max");
      var contentGroup = new Group_default();
      var newTitleEls = [];
      var newDetailEls = [];
      var hasAnimation = seriesModel.isAnimationEnabled();
      var showPointerAbove = seriesModel.get(["pointer", "showAbove"]);
      data.diff(this._data).add(function(idx) {
        newTitleEls[idx] = new Text_default({
          silent: true
        });
        newDetailEls[idx] = new Text_default({
          silent: true
        });
      }).update(function(idx, oldIdx) {
        newTitleEls[idx] = _this._titleEls[oldIdx];
        newDetailEls[idx] = _this._detailEls[oldIdx];
      }).execute();
      data.each(function(idx) {
        var itemModel = data.getItemModel(idx);
        var value = data.get(valueDim, idx);
        var itemGroup = new Group_default();
        var autoColor = getColor(linearMap(value, [minVal, maxVal], [0, 1], true));
        var itemTitleModel = itemModel.getModel("title");
        if (itemTitleModel.get("show")) {
          var titleOffsetCenter = itemTitleModel.get("offsetCenter");
          var titleX = posInfo.cx + parsePercent2(titleOffsetCenter[0], posInfo.r);
          var titleY = posInfo.cy + parsePercent2(titleOffsetCenter[1], posInfo.r);
          var labelEl = newTitleEls[idx];
          labelEl.attr({
            z2: showPointerAbove ? 0 : 2,
            style: createTextStyle(itemTitleModel, {
              x: titleX,
              y: titleY,
              text: data.getName(idx),
              align: "center",
              verticalAlign: "middle"
            }, {
              inheritColor: autoColor
            })
          });
          itemGroup.add(labelEl);
        }
        var itemDetailModel = itemModel.getModel("detail");
        if (itemDetailModel.get("show")) {
          var detailOffsetCenter = itemDetailModel.get("offsetCenter");
          var detailX = posInfo.cx + parsePercent2(detailOffsetCenter[0], posInfo.r);
          var detailY = posInfo.cy + parsePercent2(detailOffsetCenter[1], posInfo.r);
          var width = parsePercent2(itemDetailModel.get("width"), posInfo.r);
          var height = parsePercent2(itemDetailModel.get("height"), posInfo.r);
          var detailColor = seriesModel.get(["progress", "show"]) ? data.getItemVisual(idx, "style").fill : autoColor;
          var labelEl = newDetailEls[idx];
          var formatter_1 = itemDetailModel.get("formatter");
          labelEl.attr({
            z2: showPointerAbove ? 0 : 2,
            style: createTextStyle(itemDetailModel, {
              x: detailX,
              y: detailY,
              text: formatLabel(value, formatter_1),
              width: isNaN(width) ? null : width,
              height: isNaN(height) ? null : height,
              align: "center",
              verticalAlign: "middle"
            }, {
              inheritColor: detailColor
            })
          });
          setLabelValueAnimation(labelEl, {
            normal: itemDetailModel
          }, value, function(value2) {
            return formatLabel(value2, formatter_1);
          });
          hasAnimation && animateLabelValue(labelEl, idx, data, seriesModel, {
            getFormattedLabel: function(labelDataIndex, status, dataType, labelDimIndex, fmt, extendParams) {
              return formatLabel(extendParams ? extendParams.interpolatedValue : value, formatter_1);
            }
          });
          itemGroup.add(labelEl);
        }
        contentGroup.add(itemGroup);
      });
      this.group.add(contentGroup);
      this._titleEls = newTitleEls;
      this._detailEls = newDetailEls;
    };
    GaugeView2.type = "gauge";
    return GaugeView2;
  }(Chart_default);
  var GaugeView_default = GaugeView;

  // node_modules/echarts/lib/chart/gauge/GaugeSeries.js
  var GaugeSeriesModel = function(_super) {
    __extends(GaugeSeriesModel2, _super);
    function GaugeSeriesModel2() {
      var _this = _super !== null && _super.apply(this, arguments) || this;
      _this.type = GaugeSeriesModel2.type;
      _this.visualStyleAccessPath = "itemStyle";
      return _this;
    }
    GaugeSeriesModel2.prototype.getInitialData = function(option, ecModel) {
      return createSeriesDataSimply(this, ["value"]);
    };
    GaugeSeriesModel2.type = "series.gauge";
    GaugeSeriesModel2.defaultOption = {
      z: 2,
      colorBy: "data",
      center: ["50%", "50%"],
      legendHoverLink: true,
      radius: "75%",
      startAngle: 225,
      endAngle: -45,
      clockwise: true,
      min: 0,
      max: 100,
      splitNumber: 10,
      axisLine: {
        show: true,
        roundCap: false,
        lineStyle: {
          color: [[1, "#E6EBF8"]],
          width: 10
        }
      },
      progress: {
        show: false,
        overlap: true,
        width: 10,
        roundCap: false,
        clip: true
      },
      splitLine: {
        show: true,
        length: 10,
        distance: 10,
        lineStyle: {
          color: "#63677A",
          width: 3,
          type: "solid"
        }
      },
      axisTick: {
        show: true,
        splitNumber: 5,
        length: 6,
        distance: 10,
        lineStyle: {
          color: "#63677A",
          width: 1,
          type: "solid"
        }
      },
      axisLabel: {
        show: true,
        distance: 15,
        color: "#464646",
        fontSize: 12
      },
      pointer: {
        icon: null,
        offsetCenter: [0, 0],
        show: true,
        showAbove: true,
        length: "60%",
        width: 6,
        keepAspect: false
      },
      anchor: {
        show: false,
        showAbove: false,
        size: 6,
        icon: "circle",
        offsetCenter: [0, 0],
        keepAspect: false,
        itemStyle: {
          color: "#fff",
          borderWidth: 0,
          borderColor: "#5470c6"
        }
      },
      title: {
        show: true,
        offsetCenter: [0, "20%"],
        color: "#464646",
        fontSize: 16,
        valueAnimation: false
      },
      detail: {
        show: true,
        backgroundColor: "rgba(0,0,0,0)",
        borderWidth: 0,
        borderColor: "#ccc",
        width: 100,
        height: null,
        padding: [5, 10],
        offsetCenter: [0, "40%"],
        color: "#464646",
        fontSize: 30,
        fontWeight: "bold",
        lineHeight: 30,
        valueAnimation: false
      }
    };
    return GaugeSeriesModel2;
  }(Series_default);
  var GaugeSeries_default = GaugeSeriesModel;

  // node_modules/echarts/lib/chart/gauge/install.js
  function install15(registers) {
    registers.registerChartView(GaugeView_default);
    registers.registerSeriesModel(GaugeSeries_default);
  }

  // node_modules/echarts/lib/chart/funnel/FunnelView.js
  var opacityAccessPath = ["itemStyle", "opacity"];
  var FunnelPiece = function(_super) {
    __extends(FunnelPiece2, _super);
    function FunnelPiece2(data, idx) {
      var _this = _super.call(this) || this;
      var polygon = _this;
      var labelLine = new Polyline_default();
      var text = new Text_default();
      polygon.setTextContent(text);
      _this.setTextGuideLine(labelLine);
      _this.updateData(data, idx, true);
      return _this;
    }
    FunnelPiece2.prototype.updateData = function(data, idx, firstCreate) {
      var polygon = this;
      var seriesModel = data.hostModel;
      var itemModel = data.getItemModel(idx);
      var layout5 = data.getItemLayout(idx);
      var emphasisModel = itemModel.getModel("emphasis");
      var opacity = itemModel.get(opacityAccessPath);
      opacity = opacity == null ? 1 : opacity;
      if (!firstCreate) {
        saveOldStyle(polygon);
      }
      polygon.useStyle(data.getItemVisual(idx, "style"));
      polygon.style.lineJoin = "round";
      if (firstCreate) {
        polygon.setShape({
          points: layout5.points
        });
        polygon.style.opacity = 0;
        initProps(polygon, {
          style: {
            opacity
          }
        }, seriesModel, idx);
      } else {
        updateProps(polygon, {
          style: {
            opacity
          },
          shape: {
            points: layout5.points
          }
        }, seriesModel, idx);
      }
      setStatesStylesFromModel(polygon, itemModel);
      this._updateLabel(data, idx);
      toggleHoverEmphasis(this, emphasisModel.get("focus"), emphasisModel.get("blurScope"), emphasisModel.get("disabled"));
    };
    FunnelPiece2.prototype._updateLabel = function(data, idx) {
      var polygon = this;
      var labelLine = this.getTextGuideLine();
      var labelText = polygon.getTextContent();
      var seriesModel = data.hostModel;
      var itemModel = data.getItemModel(idx);
      var layout5 = data.getItemLayout(idx);
      var labelLayout2 = layout5.label;
      var style = data.getItemVisual(idx, "style");
      var visualColor = style.fill;
      setLabelStyle(labelText, getLabelStatesModels(itemModel), {
        labelFetcher: data.hostModel,
        labelDataIndex: idx,
        defaultOpacity: style.opacity,
        defaultText: data.getName(idx)
      }, {
        normal: {
          align: labelLayout2.textAlign,
          verticalAlign: labelLayout2.verticalAlign
        }
      });
      polygon.setTextConfig({
        local: true,
        inside: !!labelLayout2.inside,
        insideStroke: visualColor,
        outsideFill: visualColor
      });
      var linePoints = labelLayout2.linePoints;
      labelLine.setShape({
        points: linePoints
      });
      polygon.textGuideLineConfig = {
        anchor: linePoints ? new Point_default(linePoints[0][0], linePoints[0][1]) : null
      };
      updateProps(labelText, {
        style: {
          x: labelLayout2.x,
          y: labelLayout2.y
        }
      }, seriesModel, idx);
      labelText.attr({
        rotation: labelLayout2.rotation,
        originX: labelLayout2.x,
        originY: labelLayout2.y,
        z2: 10
      });
      setLabelLineStyle(polygon, getLabelLineStatesModels(itemModel), {
        stroke: visualColor
      });
    };
    return FunnelPiece2;
  }(Polygon_default);
  var FunnelView = function(_super) {
    __extends(FunnelView2, _super);
    function FunnelView2() {
      var _this = _super !== null && _super.apply(this, arguments) || this;
      _this.type = FunnelView2.type;
      _this.ignoreLabelLineUpdate = true;
      return _this;
    }
    FunnelView2.prototype.render = function(seriesModel, ecModel, api) {
      var data = seriesModel.getData();
      var oldData = this._data;
      var group = this.group;
      data.diff(oldData).add(function(idx) {
        var funnelPiece = new FunnelPiece(data, idx);
        data.setItemGraphicEl(idx, funnelPiece);
        group.add(funnelPiece);
      }).update(function(newIdx, oldIdx) {
        var piece = oldData.getItemGraphicEl(oldIdx);
        piece.updateData(data, newIdx);
        group.add(piece);
        data.setItemGraphicEl(newIdx, piece);
      }).remove(function(idx) {
        var piece = oldData.getItemGraphicEl(idx);
        removeElementWithFadeOut(piece, seriesModel, idx);
      }).execute();
      this._data = data;
    };
    FunnelView2.prototype.remove = function() {
      this.group.removeAll();
      this._data = null;
    };
    FunnelView2.prototype.dispose = function() {
    };
    FunnelView2.type = "funnel";
    return FunnelView2;
  }(Chart_default);
  var FunnelView_default = FunnelView;

  // node_modules/echarts/lib/chart/funnel/FunnelSeries.js
  var FunnelSeriesModel = function(_super) {
    __extends(FunnelSeriesModel2, _super);
    function FunnelSeriesModel2() {
      var _this = _super !== null && _super.apply(this, arguments) || this;
      _this.type = FunnelSeriesModel2.type;
      return _this;
    }
    FunnelSeriesModel2.prototype.init = function(option) {
      _super.prototype.init.apply(this, arguments);
      this.legendVisualProvider = new LegendVisualProvider_default(bind(this.getData, this), bind(this.getRawData, this));
      this._defaultLabelLine(option);
    };
    FunnelSeriesModel2.prototype.getInitialData = function(option, ecModel) {
      return createSeriesDataSimply(this, {
        coordDimensions: ["value"],
        encodeDefaulter: curry(makeSeriesEncodeForNameBased, this)
      });
    };
    FunnelSeriesModel2.prototype._defaultLabelLine = function(option) {
      defaultEmphasis(option, "labelLine", ["show"]);
      var labelLineNormalOpt = option.labelLine;
      var labelLineEmphasisOpt = option.emphasis.labelLine;
      labelLineNormalOpt.show = labelLineNormalOpt.show && option.label.show;
      labelLineEmphasisOpt.show = labelLineEmphasisOpt.show && option.emphasis.label.show;
    };
    FunnelSeriesModel2.prototype.getDataParams = function(dataIndex) {
      var data = this.getData();
      var params = _super.prototype.getDataParams.call(this, dataIndex);
      var valueDim = data.mapDimension("value");
      var sum2 = data.getSum(valueDim);
      params.percent = !sum2 ? 0 : +(data.get(valueDim, dataIndex) / sum2 * 100).toFixed(2);
      params.$vars.push("percent");
      return params;
    };
    FunnelSeriesModel2.type = "series.funnel";
    FunnelSeriesModel2.defaultOption = {
      z: 2,
      legendHoverLink: true,
      colorBy: "data",
      left: 80,
      top: 60,
      right: 80,
      bottom: 60,
      minSize: "0%",
      maxSize: "100%",
      sort: "descending",
      orient: "vertical",
      gap: 0,
      funnelAlign: "center",
      label: {
        show: true,
        position: "outer"
      },
      labelLine: {
        show: true,
        length: 20,
        lineStyle: {
          width: 1
        }
      },
      itemStyle: {
        borderColor: "#fff",
        borderWidth: 1
      },
      emphasis: {
        label: {
          show: true
        }
      },
      select: {
        itemStyle: {
          borderColor: "#212121"
        }
      }
    };
    return FunnelSeriesModel2;
  }(Series_default);
  var FunnelSeries_default = FunnelSeriesModel;

  // node_modules/echarts/lib/chart/funnel/funnelLayout.js
  function getViewRect4(seriesModel, api) {
    return getLayoutRect(seriesModel.getBoxLayoutParams(), {
      width: api.getWidth(),
      height: api.getHeight()
    });
  }
  function getSortedIndices(data, sort4) {
    var valueDim = data.mapDimension("value");
    var valueArr = data.mapArray(valueDim, function(val) {
      return val;
    });
    var indices = [];
    var isAscending = sort4 === "ascending";
    for (var i = 0, len2 = data.count(); i < len2; i++) {
      indices[i] = i;
    }
    if (isFunction(sort4)) {
      indices.sort(sort4);
    } else if (sort4 !== "none") {
      indices.sort(function(a, b) {
        return isAscending ? valueArr[a] - valueArr[b] : valueArr[b] - valueArr[a];
      });
    }
    return indices;
  }
  function labelLayout(data) {
    var seriesModel = data.hostModel;
    var orient = seriesModel.get("orient");
    data.each(function(idx) {
      var itemModel = data.getItemModel(idx);
      var labelModel = itemModel.getModel("label");
      var labelPosition = labelModel.get("position");
      var labelLineModel = itemModel.getModel("labelLine");
      var layout5 = data.getItemLayout(idx);
      var points4 = layout5.points;
      var isLabelInside = labelPosition === "inner" || labelPosition === "inside" || labelPosition === "center" || labelPosition === "insideLeft" || labelPosition === "insideRight";
      var textAlign;
      var textX;
      var textY;
      var linePoints;
      if (isLabelInside) {
        if (labelPosition === "insideLeft") {
          textX = (points4[0][0] + points4[3][0]) / 2 + 5;
          textY = (points4[0][1] + points4[3][1]) / 2;
          textAlign = "left";
        } else if (labelPosition === "insideRight") {
          textX = (points4[1][0] + points4[2][0]) / 2 - 5;
          textY = (points4[1][1] + points4[2][1]) / 2;
          textAlign = "right";
        } else {
          textX = (points4[0][0] + points4[1][0] + points4[2][0] + points4[3][0]) / 4;
          textY = (points4[0][1] + points4[1][1] + points4[2][1] + points4[3][1]) / 4;
          textAlign = "center";
        }
        linePoints = [[textX, textY], [textX, textY]];
      } else {
        var x1 = void 0;
        var y1 = void 0;
        var x2 = void 0;
        var y2 = void 0;
        var labelLineLen = labelLineModel.get("length");
        if (true) {
          if (orient === "vertical" && ["top", "bottom"].indexOf(labelPosition) > -1) {
            labelPosition = "left";
            console.warn("Position error: Funnel chart on vertical orient dose not support top and bottom.");
          }
          if (orient === "horizontal" && ["left", "right"].indexOf(labelPosition) > -1) {
            labelPosition = "bottom";
            console.warn("Position error: Funnel chart on horizontal orient dose not support left and right.");
          }
        }
        if (labelPosition === "left") {
          x1 = (points4[3][0] + points4[0][0]) / 2;
          y1 = (points4[3][1] + points4[0][1]) / 2;
          x2 = x1 - labelLineLen;
          textX = x2 - 5;
          textAlign = "right";
        } else if (labelPosition === "right") {
          x1 = (points4[1][0] + points4[2][0]) / 2;
          y1 = (points4[1][1] + points4[2][1]) / 2;
          x2 = x1 + labelLineLen;
          textX = x2 + 5;
          textAlign = "left";
        } else if (labelPosition === "top") {
          x1 = (points4[3][0] + points4[0][0]) / 2;
          y1 = (points4[3][1] + points4[0][1]) / 2;
          y2 = y1 - labelLineLen;
          textY = y2 - 5;
          textAlign = "center";
        } else if (labelPosition === "bottom") {
          x1 = (points4[1][0] + points4[2][0]) / 2;
          y1 = (points4[1][1] + points4[2][1]) / 2;
          y2 = y1 + labelLineLen;
          textY = y2 + 5;
          textAlign = "center";
        } else if (labelPosition === "rightTop") {
          x1 = orient === "horizontal" ? points4[3][0] : points4[1][0];
          y1 = orient === "horizontal" ? points4[3][1] : points4[1][1];
          if (orient === "horizontal") {
            y2 = y1 - labelLineLen;
            textY = y2 - 5;
            textAlign = "center";
          } else {
            x2 = x1 + labelLineLen;
            textX = x2 + 5;
            textAlign = "top";
          }
        } else if (labelPosition === "rightBottom") {
          x1 = points4[2][0];
          y1 = points4[2][1];
          if (orient === "horizontal") {
            y2 = y1 + labelLineLen;
            textY = y2 + 5;
            textAlign = "center";
          } else {
            x2 = x1 + labelLineLen;
            textX = x2 + 5;
            textAlign = "bottom";
          }
        } else if (labelPosition === "leftTop") {
          x1 = points4[0][0];
          y1 = orient === "horizontal" ? points4[0][1] : points4[1][1];
          if (orient === "horizontal") {
            y2 = y1 - labelLineLen;
            textY = y2 - 5;
            textAlign = "center";
          } else {
            x2 = x1 - labelLineLen;
            textX = x2 - 5;
            textAlign = "right";
          }
        } else if (labelPosition === "leftBottom") {
          x1 = orient === "horizontal" ? points4[1][0] : points4[3][0];
          y1 = orient === "horizontal" ? points4[1][1] : points4[2][1];
          if (orient === "horizontal") {
            y2 = y1 + labelLineLen;
            textY = y2 + 5;
            textAlign = "center";
          } else {
            x2 = x1 - labelLineLen;
            textX = x2 - 5;
            textAlign = "right";
          }
        } else {
          x1 = (points4[1][0] + points4[2][0]) / 2;
          y1 = (points4[1][1] + points4[2][1]) / 2;
          if (orient === "horizontal") {
            y2 = y1 + labelLineLen;
            textY = y2 + 5;
            textAlign = "center";
          } else {
            x2 = x1 + labelLineLen;
            textX = x2 + 5;
            textAlign = "left";
          }
        }
        if (orient === "horizontal") {
          x2 = x1;
          textX = x2;
        } else {
          y2 = y1;
          textY = y2;
        }
        linePoints = [[x1, y1], [x2, y2]];
      }
      layout5.label = {
        linePoints,
        x: textX,
        y: textY,
        verticalAlign: "middle",
        textAlign,
        inside: isLabelInside
      };
    });
  }
  function funnelLayout(ecModel, api) {
    ecModel.eachSeriesByType("funnel", function(seriesModel) {
      var data = seriesModel.getData();
      var valueDim = data.mapDimension("value");
      var sort4 = seriesModel.get("sort");
      var viewRect2 = getViewRect4(seriesModel, api);
      var orient = seriesModel.get("orient");
      var viewWidth = viewRect2.width;
      var viewHeight = viewRect2.height;
      var indices = getSortedIndices(data, sort4);
      var x = viewRect2.x;
      var y = viewRect2.y;
      var sizeExtent = orient === "horizontal" ? [parsePercent2(seriesModel.get("minSize"), viewHeight), parsePercent2(seriesModel.get("maxSize"), viewHeight)] : [parsePercent2(seriesModel.get("minSize"), viewWidth), parsePercent2(seriesModel.get("maxSize"), viewWidth)];
      var dataExtent = data.getDataExtent(valueDim);
      var min3 = seriesModel.get("min");
      var max3 = seriesModel.get("max");
      if (min3 == null) {
        min3 = Math.min(dataExtent[0], 0);
      }
      if (max3 == null) {
        max3 = dataExtent[1];
      }
      var funnelAlign = seriesModel.get("funnelAlign");
      var gap = seriesModel.get("gap");
      var viewSize = orient === "horizontal" ? viewWidth : viewHeight;
      var itemSize = (viewSize - gap * (data.count() - 1)) / data.count();
      var getLinePoints = function(idx2, offset) {
        if (orient === "horizontal") {
          var val_1 = data.get(valueDim, idx2) || 0;
          var itemHeight = linearMap(val_1, [min3, max3], sizeExtent, true);
          var y0 = void 0;
          switch (funnelAlign) {
            case "top":
              y0 = y;
              break;
            case "center":
              y0 = y + (viewHeight - itemHeight) / 2;
              break;
            case "bottom":
              y0 = y + (viewHeight - itemHeight);
              break;
          }
          return [[offset, y0], [offset, y0 + itemHeight]];
        }
        var val = data.get(valueDim, idx2) || 0;
        var itemWidth = linearMap(val, [min3, max3], sizeExtent, true);
        var x0;
        switch (funnelAlign) {
          case "left":
            x0 = x;
            break;
          case "center":
            x0 = x + (viewWidth - itemWidth) / 2;
            break;
          case "right":
            x0 = x + viewWidth - itemWidth;
            break;
        }
        return [[x0, offset], [x0 + itemWidth, offset]];
      };
      if (sort4 === "ascending") {
        itemSize = -itemSize;
        gap = -gap;
        if (orient === "horizontal") {
          x += viewWidth;
        } else {
          y += viewHeight;
        }
        indices = indices.reverse();
      }
      for (var i = 0; i < indices.length; i++) {
        var idx = indices[i];
        var nextIdx = indices[i + 1];
        var itemModel = data.getItemModel(idx);
        if (orient === "horizontal") {
          var width = itemModel.get(["itemStyle", "width"]);
          if (width == null) {
            width = itemSize;
          } else {
            width = parsePercent2(width, viewWidth);
            if (sort4 === "ascending") {
              width = -width;
            }
          }
          var start2 = getLinePoints(idx, x);
          var end2 = getLinePoints(nextIdx, x + width);
          x += width + gap;
          data.setItemLayout(idx, {
            points: start2.concat(end2.slice().reverse())
          });
        } else {
          var height = itemModel.get(["itemStyle", "height"]);
          if (height == null) {
            height = itemSize;
          } else {
            height = parsePercent2(height, viewHeight);
            if (sort4 === "ascending") {
              height = -height;
            }
          }
          var start2 = getLinePoints(idx, y);
          var end2 = getLinePoints(nextIdx, y + height);
          y += height + gap;
          data.setItemLayout(idx, {
            points: start2.concat(end2.slice().reverse())
          });
        }
      }
      labelLayout(data);
    });
  }

  // node_modules/echarts/lib/chart/funnel/install.js
  function install16(registers) {
    registers.registerChartView(FunnelView_default);
    registers.registerSeriesModel(FunnelSeries_default);
    registers.registerLayout(funnelLayout);
    registers.registerProcessor(dataFilter("funnel"));
  }

  // node_modules/echarts/lib/chart/parallel/ParallelView.js
  var DEFAULT_SMOOTH = 0.3;
  var ParallelView = function(_super) {
    __extends(ParallelView3, _super);
    function ParallelView3() {
      var _this = _super !== null && _super.apply(this, arguments) || this;
      _this.type = ParallelView3.type;
      _this._dataGroup = new Group_default();
      _this._initialized = false;
      return _this;
    }
    ParallelView3.prototype.init = function() {
      this.group.add(this._dataGroup);
    };
    ParallelView3.prototype.render = function(seriesModel, ecModel, api, payload) {
      this._progressiveEls = null;
      var dataGroup = this._dataGroup;
      var data = seriesModel.getData();
      var oldData = this._data;
      var coordSys = seriesModel.coordinateSystem;
      var dimensions = coordSys.dimensions;
      var seriesScope = makeSeriesScope3(seriesModel);
      data.diff(oldData).add(add2).update(update).remove(remove).execute();
      function add2(newDataIndex) {
        var line = addEl(data, dataGroup, newDataIndex, dimensions, coordSys);
        updateElCommon(line, data, newDataIndex, seriesScope);
      }
      function update(newDataIndex, oldDataIndex) {
        var line = oldData.getItemGraphicEl(oldDataIndex);
        var points4 = createLinePoints(data, newDataIndex, dimensions, coordSys);
        data.setItemGraphicEl(newDataIndex, line);
        updateProps(line, {
          shape: {
            points: points4
          }
        }, seriesModel, newDataIndex);
        saveOldStyle(line);
        updateElCommon(line, data, newDataIndex, seriesScope);
      }
      function remove(oldDataIndex) {
        var line = oldData.getItemGraphicEl(oldDataIndex);
        dataGroup.remove(line);
      }
      if (!this._initialized) {
        this._initialized = true;
        var clipPath = createGridClipShape(coordSys, seriesModel, function() {
          setTimeout(function() {
            dataGroup.removeClipPath();
          });
        });
        dataGroup.setClipPath(clipPath);
      }
      this._data = data;
    };
    ParallelView3.prototype.incrementalPrepareRender = function(seriesModel, ecModel, api) {
      this._initialized = true;
      this._data = null;
      this._dataGroup.removeAll();
    };
    ParallelView3.prototype.incrementalRender = function(taskParams, seriesModel, ecModel) {
      var data = seriesModel.getData();
      var coordSys = seriesModel.coordinateSystem;
      var dimensions = coordSys.dimensions;
      var seriesScope = makeSeriesScope3(seriesModel);
      var progressiveEls = this._progressiveEls = [];
      for (var dataIndex = taskParams.start; dataIndex < taskParams.end; dataIndex++) {
        var line = addEl(data, this._dataGroup, dataIndex, dimensions, coordSys);
        line.incremental = true;
        updateElCommon(line, data, dataIndex, seriesScope);
        progressiveEls.push(line);
      }
    };
    ParallelView3.prototype.remove = function() {
      this._dataGroup && this._dataGroup.removeAll();
      this._data = null;
    };
    ParallelView3.type = "parallel";
    return ParallelView3;
  }(Chart_default);
  function createGridClipShape(coordSys, seriesModel, cb) {
    var parallelModel = coordSys.model;
    var rect = coordSys.getRect();
    var rectEl = new Rect_default({
      shape: {
        x: rect.x,
        y: rect.y,
        width: rect.width,
        height: rect.height
      }
    });
    var dim = parallelModel.get("layout") === "horizontal" ? "width" : "height";
    rectEl.setShape(dim, 0);
    initProps(rectEl, {
      shape: {
        width: rect.width,
        height: rect.height
      }
    }, seriesModel, cb);
    return rectEl;
  }
  function createLinePoints(data, dataIndex, dimensions, coordSys) {
    var points4 = [];
    for (var i = 0; i < dimensions.length; i++) {
      var dimName = dimensions[i];
      var value = data.get(data.mapDimension(dimName), dataIndex);
      if (!isEmptyValue(value, coordSys.getAxis(dimName).type)) {
        points4.push(coordSys.dataToPoint(value, dimName));
      }
    }
    return points4;
  }
  function addEl(data, dataGroup, dataIndex, dimensions, coordSys) {
    var points4 = createLinePoints(data, dataIndex, dimensions, coordSys);
    var line = new Polyline_default({
      shape: {
        points: points4
      },
      z2: 10
    });
    dataGroup.add(line);
    data.setItemGraphicEl(dataIndex, line);
    return line;
  }
  function makeSeriesScope3(seriesModel) {
    var smooth = seriesModel.get("smooth", true);
    smooth === true && (smooth = DEFAULT_SMOOTH);
    smooth = numericToNumber(smooth);
    eqNaN(smooth) && (smooth = 0);
    return {
      smooth
    };
  }
  function updateElCommon(el, data, dataIndex, seriesScope) {
    el.useStyle(data.getItemVisual(dataIndex, "style"));
    el.style.fill = null;
    el.setShape("smooth", seriesScope.smooth);
    var itemModel = data.getItemModel(dataIndex);
    var emphasisModel = itemModel.getModel("emphasis");
    setStatesStylesFromModel(el, itemModel, "lineStyle");
    toggleHoverEmphasis(el, emphasisModel.get("focus"), emphasisModel.get("blurScope"), emphasisModel.get("disabled"));
  }
  function isEmptyValue(val, axisType) {
    return axisType === "category" ? val == null : val == null || isNaN(val);
  }
  var ParallelView_default = ParallelView;

  // node_modules/echarts/lib/chart/parallel/ParallelSeries.js
  var ParallelSeriesModel = function(_super) {
    __extends(ParallelSeriesModel2, _super);
    function ParallelSeriesModel2() {
      var _this = _super !== null && _super.apply(this, arguments) || this;
      _this.type = ParallelSeriesModel2.type;
      _this.visualStyleAccessPath = "lineStyle";
      _this.visualDrawType = "stroke";
      return _this;
    }
    ParallelSeriesModel2.prototype.getInitialData = function(option, ecModel) {
      return createSeriesData_default(null, this, {
        useEncodeDefaulter: bind(makeDefaultEncode, null, this)
      });
    };
    ParallelSeriesModel2.prototype.getRawIndicesByActiveState = function(activeState) {
      var coordSys = this.coordinateSystem;
      var data = this.getData();
      var indices = [];
      coordSys.eachActiveState(data, function(theActiveState, dataIndex) {
        if (activeState === theActiveState) {
          indices.push(data.getRawIndex(dataIndex));
        }
      });
      return indices;
    };
    ParallelSeriesModel2.type = "series.parallel";
    ParallelSeriesModel2.dependencies = ["parallel"];
    ParallelSeriesModel2.defaultOption = {
      z: 2,
      coordinateSystem: "parallel",
      parallelIndex: 0,
      label: {
        show: false
      },
      inactiveOpacity: 0.05,
      activeOpacity: 1,
      lineStyle: {
        width: 1,
        opacity: 0.45,
        type: "solid"
      },
      emphasis: {
        label: {
          show: false
        }
      },
      progressive: 500,
      smooth: false,
      animationEasing: "linear"
    };
    return ParallelSeriesModel2;
  }(Series_default);
  function makeDefaultEncode(seriesModel) {
    var parallelModel = seriesModel.ecModel.getComponent("parallel", seriesModel.get("parallelIndex"));
    if (!parallelModel) {
      return;
    }
    var encodeDefine = {};
    each(parallelModel.dimensions, function(axisDim) {
      var dataDimIndex = convertDimNameToNumber(axisDim);
      encodeDefine[axisDim] = dataDimIndex;
    });
    return encodeDefine;
  }
  function convertDimNameToNumber(dimName) {
    return +dimName.replace("dim", "");
  }
  var ParallelSeries_default = ParallelSeriesModel;

  // node_modules/echarts/lib/chart/parallel/parallelVisual.js
  var opacityAccessPath2 = ["lineStyle", "opacity"];
  var parallelVisual = {
    seriesType: "parallel",
    reset: function(seriesModel, ecModel) {
      var coordSys = seriesModel.coordinateSystem;
      var opacityMap = {
        normal: seriesModel.get(["lineStyle", "opacity"]),
        active: seriesModel.get("activeOpacity"),
        inactive: seriesModel.get("inactiveOpacity")
      };
      return {
        progress: function(params, data) {
          coordSys.eachActiveState(data, function(activeState, dataIndex) {
            var opacity = opacityMap[activeState];
            if (activeState === "normal" && data.hasItemOption) {
              var itemOpacity = data.getItemModel(dataIndex).get(opacityAccessPath2, true);
              itemOpacity != null && (opacity = itemOpacity);
            }
            var existsStyle = data.ensureUniqueItemVisual(dataIndex, "style");
            existsStyle.opacity = opacity;
          }, params.start, params.end);
        }
      };
    }
  };
  var parallelVisual_default = parallelVisual;

  // node_modules/echarts/lib/coord/parallel/parallelPreprocessor.js
  function parallelPreprocessor(option) {
    createParallelIfNeeded(option);
    mergeAxisOptionFromParallel(option);
  }
  function createParallelIfNeeded(option) {
    if (option.parallel) {
      return;
    }
    var hasParallelSeries = false;
    each(option.series, function(seriesOpt) {
      if (seriesOpt && seriesOpt.type === "parallel") {
        hasParallelSeries = true;
      }
    });
    if (hasParallelSeries) {
      option.parallel = [{}];
    }
  }
  function mergeAxisOptionFromParallel(option) {
    var axes = normalizeToArray(option.parallelAxis);
    each(axes, function(axisOption) {
      if (!isObject(axisOption)) {
        return;
      }
      var parallelIndex = axisOption.parallelIndex || 0;
      var parallelOption = normalizeToArray(option.parallel)[parallelIndex];
      if (parallelOption && parallelOption.parallelAxisDefault) {
        merge(axisOption, parallelOption.parallelAxisDefault, false);
      }
    });
  }

  // node_modules/echarts/lib/component/parallel/ParallelView.js
  var CLICK_THRESHOLD = 5;
  var ParallelView2 = function(_super) {
    __extends(ParallelView3, _super);
    function ParallelView3() {
      var _this = _super !== null && _super.apply(this, arguments) || this;
      _this.type = ParallelView3.type;
      return _this;
    }
    ParallelView3.prototype.render = function(parallelModel, ecModel, api) {
      this._model = parallelModel;
      this._api = api;
      if (!this._handlers) {
        this._handlers = {};
        each(handlers, function(handler, eventName) {
          api.getZr().on(eventName, this._handlers[eventName] = bind(handler, this));
        }, this);
      }
      createOrUpdate(this, "_throttledDispatchExpand", parallelModel.get("axisExpandRate"), "fixRate");
    };
    ParallelView3.prototype.dispose = function(ecModel, api) {
      clear(this, "_throttledDispatchExpand");
      each(this._handlers, function(handler, eventName) {
        api.getZr().off(eventName, handler);
      });
      this._handlers = null;
    };
    ParallelView3.prototype._throttledDispatchExpand = function(opt) {
      this._dispatchExpand(opt);
    };
    ParallelView3.prototype._dispatchExpand = function(opt) {
      opt && this._api.dispatchAction(extend({
        type: "parallelAxisExpand"
      }, opt));
    };
    ParallelView3.type = "parallel";
    return ParallelView3;
  }(Component_default2);
  var handlers = {
    mousedown: function(e2) {
      if (checkTrigger(this, "click")) {
        this._mouseDownPoint = [e2.offsetX, e2.offsetY];
      }
    },
    mouseup: function(e2) {
      var mouseDownPoint = this._mouseDownPoint;
      if (checkTrigger(this, "click") && mouseDownPoint) {
        var point = [e2.offsetX, e2.offsetY];
        var dist3 = Math.pow(mouseDownPoint[0] - point[0], 2) + Math.pow(mouseDownPoint[1] - point[1], 2);
        if (dist3 > CLICK_THRESHOLD) {
          return;
        }
        var result = this._model.coordinateSystem.getSlidedAxisExpandWindow([e2.offsetX, e2.offsetY]);
        result.behavior !== "none" && this._dispatchExpand({
          axisExpandWindow: result.axisExpandWindow
        });
      }
      this._mouseDownPoint = null;
    },
    mousemove: function(e2) {
      if (this._mouseDownPoint || !checkTrigger(this, "mousemove")) {
        return;
      }
      var model = this._model;
      var result = model.coordinateSystem.getSlidedAxisExpandWindow([e2.offsetX, e2.offsetY]);
      var behavior = result.behavior;
      behavior === "jump" && this._throttledDispatchExpand.debounceNextCall(model.get("axisExpandDebounce"));
      this._throttledDispatchExpand(behavior === "none" ? null : {
        axisExpandWindow: result.axisExpandWindow,
        animation: behavior === "jump" ? null : {
          duration: 0
        }
      });
    }
  };
  function checkTrigger(view, triggerOn) {
    var model = view._model;
    return model.get("axisExpandable") && model.get("axisExpandTriggerOn") === triggerOn;
  }
  var ParallelView_default2 = ParallelView2;

  // node_modules/echarts/lib/coord/parallel/ParallelModel.js
  var ParallelModel = function(_super) {
    __extends(ParallelModel2, _super);
    function ParallelModel2() {
      var _this = _super !== null && _super.apply(this, arguments) || this;
      _this.type = ParallelModel2.type;
      return _this;
    }
    ParallelModel2.prototype.init = function() {
      _super.prototype.init.apply(this, arguments);
      this.mergeOption({});
    };
    ParallelModel2.prototype.mergeOption = function(newOption) {
      var thisOption = this.option;
      newOption && merge(thisOption, newOption, true);
      this._initDimensions();
    };
    ParallelModel2.prototype.contains = function(model, ecModel) {
      var parallelIndex = model.get("parallelIndex");
      return parallelIndex != null && ecModel.getComponent("parallel", parallelIndex) === this;
    };
    ParallelModel2.prototype.setAxisExpand = function(opt) {
      each(["axisExpandable", "axisExpandCenter", "axisExpandCount", "axisExpandWidth", "axisExpandWindow"], function(name) {
        if (opt.hasOwnProperty(name)) {
          this.option[name] = opt[name];
        }
      }, this);
    };
    ParallelModel2.prototype._initDimensions = function() {
      var dimensions = this.dimensions = [];
      var parallelAxisIndex = this.parallelAxisIndex = [];
      var axisModels = filter(this.ecModel.queryComponents({
        mainType: "parallelAxis"
      }), function(axisModel) {
        return (axisModel.get("parallelIndex") || 0) === this.componentIndex;
      }, this);
      each(axisModels, function(axisModel) {
        dimensions.push("dim" + axisModel.get("dim"));
        parallelAxisIndex.push(axisModel.componentIndex);
      });
    };
    ParallelModel2.type = "parallel";
    ParallelModel2.dependencies = ["parallelAxis"];
    ParallelModel2.layoutMode = "box";
    ParallelModel2.defaultOption = {
      z: 0,
      left: 80,
      top: 60,
      right: 80,
      bottom: 60,
      layout: "horizontal",
      axisExpandable: false,
      axisExpandCenter: null,
      axisExpandCount: 0,
      axisExpandWidth: 50,
      axisExpandRate: 17,
      axisExpandDebounce: 50,
      axisExpandSlideTriggerArea: [-0.15, 0.05, 0.4],
      axisExpandTriggerOn: "click",
      parallelAxisDefault: null
    };
    return ParallelModel2;
  }(Component_default);
  var ParallelModel_default = ParallelModel;

  // node_modules/echarts/lib/coord/parallel/ParallelAxis.js
  var ParallelAxis = function(_super) {
    __extends(ParallelAxis2, _super);
    function ParallelAxis2(dim, scale4, coordExtent, axisType, axisIndex) {
      var _this = _super.call(this, dim, scale4, coordExtent) || this;
      _this.type = axisType || "value";
      _this.axisIndex = axisIndex;
      return _this;
    }
    ParallelAxis2.prototype.isHorizontal = function() {
      return this.coordinateSystem.getModel().get("layout") !== "horizontal";
    };
    return ParallelAxis2;
  }(Axis_default);
  var ParallelAxis_default = ParallelAxis;

  // node_modules/echarts/lib/component/helper/sliderMove.js
  function sliderMove(delta, handleEnds, extent3, handleIndex, minSpan, maxSpan) {
    delta = delta || 0;
    var extentSpan = extent3[1] - extent3[0];
    if (minSpan != null) {
      minSpan = restrict(minSpan, [0, extentSpan]);
    }
    if (maxSpan != null) {
      maxSpan = Math.max(maxSpan, minSpan != null ? minSpan : 0);
    }
    if (handleIndex === "all") {
      var handleSpan = Math.abs(handleEnds[1] - handleEnds[0]);
      handleSpan = restrict(handleSpan, [0, extentSpan]);
      minSpan = maxSpan = restrict(handleSpan, [minSpan, maxSpan]);
      handleIndex = 0;
    }
    handleEnds[0] = restrict(handleEnds[0], extent3);
    handleEnds[1] = restrict(handleEnds[1], extent3);
    var originalDistSign = getSpanSign(handleEnds, handleIndex);
    handleEnds[handleIndex] += delta;
    var extentMinSpan = minSpan || 0;
    var realExtent = extent3.slice();
    originalDistSign.sign < 0 ? realExtent[0] += extentMinSpan : realExtent[1] -= extentMinSpan;
    handleEnds[handleIndex] = restrict(handleEnds[handleIndex], realExtent);
    var currDistSign;
    currDistSign = getSpanSign(handleEnds, handleIndex);
    if (minSpan != null && (currDistSign.sign !== originalDistSign.sign || currDistSign.span < minSpan)) {
      handleEnds[1 - handleIndex] = handleEnds[handleIndex] + originalDistSign.sign * minSpan;
    }
    currDistSign = getSpanSign(handleEnds, handleIndex);
    if (maxSpan != null && currDistSign.span > maxSpan) {
      handleEnds[1 - handleIndex] = handleEnds[handleIndex] + currDistSign.sign * maxSpan;
    }
    return handleEnds;
  }
  function getSpanSign(handleEnds, handleIndex) {
    var dist3 = handleEnds[handleIndex] - handleEnds[1 - handleIndex];
    return {
      span: Math.abs(dist3),
      sign: dist3 > 0 ? -1 : dist3 < 0 ? 1 : handleIndex ? -1 : 1
    };
  }
  function restrict(value, extend2) {
    return Math.min(extend2[1] != null ? extend2[1] : Infinity, Math.max(extend2[0] != null ? extend2[0] : -Infinity, value));
  }

  // node_modules/echarts/lib/coord/parallel/Parallel.js
  var each6 = each;
  var mathMin9 = Math.min;
  var mathMax9 = Math.max;
  var mathFloor2 = Math.floor;
  var mathCeil2 = Math.ceil;
  var round6 = round;
  var PI9 = Math.PI;
  var Parallel = function() {
    function Parallel2(parallelModel, ecModel, api) {
      this.type = "parallel";
      this._axesMap = createHashMap();
      this._axesLayout = {};
      this.dimensions = parallelModel.dimensions;
      this._model = parallelModel;
      this._init(parallelModel, ecModel, api);
    }
    Parallel2.prototype._init = function(parallelModel, ecModel, api) {
      var dimensions = parallelModel.dimensions;
      var parallelAxisIndex = parallelModel.parallelAxisIndex;
      each6(dimensions, function(dim, idx) {
        var axisIndex = parallelAxisIndex[idx];
        var axisModel = ecModel.getComponent("parallelAxis", axisIndex);
        var axis = this._axesMap.set(dim, new ParallelAxis_default(dim, createScaleByModel(axisModel), [0, 0], axisModel.get("type"), axisIndex));
        var isCategory2 = axis.type === "category";
        axis.onBand = isCategory2 && axisModel.get("boundaryGap");
        axis.inverse = axisModel.get("inverse");
        axisModel.axis = axis;
        axis.model = axisModel;
        axis.coordinateSystem = axisModel.coordinateSystem = this;
      }, this);
    };
    Parallel2.prototype.update = function(ecModel, api) {
      this._updateAxesFromSeries(this._model, ecModel);
    };
    Parallel2.prototype.containPoint = function(point) {
      var layoutInfo = this._makeLayoutInfo();
      var axisBase = layoutInfo.axisBase;
      var layoutBase = layoutInfo.layoutBase;
      var pixelDimIndex = layoutInfo.pixelDimIndex;
      var pAxis = point[1 - pixelDimIndex];
      var pLayout = point[pixelDimIndex];
      return pAxis >= axisBase && pAxis <= axisBase + layoutInfo.axisLength && pLayout >= layoutBase && pLayout <= layoutBase + layoutInfo.layoutLength;
    };
    Parallel2.prototype.getModel = function() {
      return this._model;
    };
    Parallel2.prototype._updateAxesFromSeries = function(parallelModel, ecModel) {
      ecModel.eachSeries(function(seriesModel) {
        if (!parallelModel.contains(seriesModel, ecModel)) {
          return;
        }
        var data = seriesModel.getData();
        each6(this.dimensions, function(dim) {
          var axis = this._axesMap.get(dim);
          axis.scale.unionExtentFromData(data, data.mapDimension(dim));
          niceScaleExtent(axis.scale, axis.model);
        }, this);
      }, this);
    };
    Parallel2.prototype.resize = function(parallelModel, api) {
      this._rect = getLayoutRect(parallelModel.getBoxLayoutParams(), {
        width: api.getWidth(),
        height: api.getHeight()
      });
      this._layoutAxes();
    };
    Parallel2.prototype.getRect = function() {
      return this._rect;
    };
    Parallel2.prototype._makeLayoutInfo = function() {
      var parallelModel = this._model;
      var rect = this._rect;
      var xy = ["x", "y"];
      var wh = ["width", "height"];
      var layout5 = parallelModel.get("layout");
      var pixelDimIndex = layout5 === "horizontal" ? 0 : 1;
      var layoutLength = rect[wh[pixelDimIndex]];
      var layoutExtent = [0, layoutLength];
      var axisCount = this.dimensions.length;
      var axisExpandWidth = restrict2(parallelModel.get("axisExpandWidth"), layoutExtent);
      var axisExpandCount = restrict2(parallelModel.get("axisExpandCount") || 0, [0, axisCount]);
      var axisExpandable = parallelModel.get("axisExpandable") && axisCount > 3 && axisCount > axisExpandCount && axisExpandCount > 1 && axisExpandWidth > 0 && layoutLength > 0;
      var axisExpandWindow = parallelModel.get("axisExpandWindow");
      var winSize;
      if (!axisExpandWindow) {
        winSize = restrict2(axisExpandWidth * (axisExpandCount - 1), layoutExtent);
        var axisExpandCenter = parallelModel.get("axisExpandCenter") || mathFloor2(axisCount / 2);
        axisExpandWindow = [axisExpandWidth * axisExpandCenter - winSize / 2];
        axisExpandWindow[1] = axisExpandWindow[0] + winSize;
      } else {
        winSize = restrict2(axisExpandWindow[1] - axisExpandWindow[0], layoutExtent);
        axisExpandWindow[1] = axisExpandWindow[0] + winSize;
      }
      var axisCollapseWidth = (layoutLength - winSize) / (axisCount - axisExpandCount);
      axisCollapseWidth < 3 && (axisCollapseWidth = 0);
      var winInnerIndices = [mathFloor2(round6(axisExpandWindow[0] / axisExpandWidth, 1)) + 1, mathCeil2(round6(axisExpandWindow[1] / axisExpandWidth, 1)) - 1];
      var axisExpandWindow0Pos = axisCollapseWidth / axisExpandWidth * axisExpandWindow[0];
      return {
        layout: layout5,
        pixelDimIndex,
        layoutBase: rect[xy[pixelDimIndex]],
        layoutLength,
        axisBase: rect[xy[1 - pixelDimIndex]],
        axisLength: rect[wh[1 - pixelDimIndex]],
        axisExpandable,
        axisExpandWidth,
        axisCollapseWidth,
        axisExpandWindow,
        axisCount,
        winInnerIndices,
        axisExpandWindow0Pos
      };
    };
    Parallel2.prototype._layoutAxes = function() {
      var rect = this._rect;
      var axes = this._axesMap;
      var dimensions = this.dimensions;
      var layoutInfo = this._makeLayoutInfo();
      var layout5 = layoutInfo.layout;
      axes.each(function(axis) {
        var axisExtent = [0, layoutInfo.axisLength];
        var idx = axis.inverse ? 1 : 0;
        axis.setExtent(axisExtent[idx], axisExtent[1 - idx]);
      });
      each6(dimensions, function(dim, idx) {
        var posInfo = (layoutInfo.axisExpandable ? layoutAxisWithExpand : layoutAxisWithoutExpand)(idx, layoutInfo);
        var positionTable = {
          horizontal: {
            x: posInfo.position,
            y: layoutInfo.axisLength
          },
          vertical: {
            x: 0,
            y: posInfo.position
          }
        };
        var rotationTable = {
          horizontal: PI9 / 2,
          vertical: 0
        };
        var position2 = [positionTable[layout5].x + rect.x, positionTable[layout5].y + rect.y];
        var rotation = rotationTable[layout5];
        var transform2 = create2();
        rotate(transform2, transform2, rotation);
        translate(transform2, transform2, position2);
        this._axesLayout[dim] = {
          position: position2,
          rotation,
          transform: transform2,
          axisNameAvailableWidth: posInfo.axisNameAvailableWidth,
          axisLabelShow: posInfo.axisLabelShow,
          nameTruncateMaxWidth: posInfo.nameTruncateMaxWidth,
          tickDirection: 1,
          labelDirection: 1
        };
      }, this);
    };
    Parallel2.prototype.getAxis = function(dim) {
      return this._axesMap.get(dim);
    };
    Parallel2.prototype.dataToPoint = function(value, dim) {
      return this.axisCoordToPoint(this._axesMap.get(dim).dataToCoord(value), dim);
    };
    Parallel2.prototype.eachActiveState = function(data, callback, start2, end2) {
      start2 == null && (start2 = 0);
      end2 == null && (end2 = data.count());
      var axesMap = this._axesMap;
      var dimensions = this.dimensions;
      var dataDimensions = [];
      var axisModels = [];
      each(dimensions, function(axisDim) {
        dataDimensions.push(data.mapDimension(axisDim));
        axisModels.push(axesMap.get(axisDim).model);
      });
      var hasActiveSet = this.hasAxisBrushed();
      for (var dataIndex = start2; dataIndex < end2; dataIndex++) {
        var activeState = void 0;
        if (!hasActiveSet) {
          activeState = "normal";
        } else {
          activeState = "active";
          var values = data.getValues(dataDimensions, dataIndex);
          for (var j = 0, lenj = dimensions.length; j < lenj; j++) {
            var state = axisModels[j].getActiveState(values[j]);
            if (state === "inactive") {
              activeState = "inactive";
              break;
            }
          }
        }
        callback(activeState, dataIndex);
      }
    };
    Parallel2.prototype.hasAxisBrushed = function() {
      var dimensions = this.dimensions;
      var axesMap = this._axesMap;
      var hasActiveSet = false;
      for (var j = 0, lenj = dimensions.length; j < lenj; j++) {
        if (axesMap.get(dimensions[j]).model.getActiveState() !== "normal") {
          hasActiveSet = true;
        }
      }
      return hasActiveSet;
    };
    Parallel2.prototype.axisCoordToPoint = function(coord, dim) {
      var axisLayout = this._axesLayout[dim];
      return applyTransform2([coord, 0], axisLayout.transform);
    };
    Parallel2.prototype.getAxisLayout = function(dim) {
      return clone(this._axesLayout[dim]);
    };
    Parallel2.prototype.getSlidedAxisExpandWindow = function(point) {
      var layoutInfo = this._makeLayoutInfo();
      var pixelDimIndex = layoutInfo.pixelDimIndex;
      var axisExpandWindow = layoutInfo.axisExpandWindow.slice();
      var winSize = axisExpandWindow[1] - axisExpandWindow[0];
      var extent3 = [0, layoutInfo.axisExpandWidth * (layoutInfo.axisCount - 1)];
      if (!this.containPoint(point)) {
        return {
          behavior: "none",
          axisExpandWindow
        };
      }
      var pointCoord = point[pixelDimIndex] - layoutInfo.layoutBase - layoutInfo.axisExpandWindow0Pos;
      var delta;
      var behavior = "slide";
      var axisCollapseWidth = layoutInfo.axisCollapseWidth;
      var triggerArea = this._model.get("axisExpandSlideTriggerArea");
      var useJump = triggerArea[0] != null;
      if (axisCollapseWidth) {
        if (useJump && axisCollapseWidth && pointCoord < winSize * triggerArea[0]) {
          behavior = "jump";
          delta = pointCoord - winSize * triggerArea[2];
        } else if (useJump && axisCollapseWidth && pointCoord > winSize * (1 - triggerArea[0])) {
          behavior = "jump";
          delta = pointCoord - winSize * (1 - triggerArea[2]);
        } else {
          (delta = pointCoord - winSize * triggerArea[1]) >= 0 && (delta = pointCoord - winSize * (1 - triggerArea[1])) <= 0 && (delta = 0);
        }
        delta *= layoutInfo.axisExpandWidth / axisCollapseWidth;
        delta ? sliderMove(delta, axisExpandWindow, extent3, "all") : behavior = "none";
      } else {
        var winSize2 = axisExpandWindow[1] - axisExpandWindow[0];
        var pos = extent3[1] * pointCoord / winSize2;
        axisExpandWindow = [mathMax9(0, pos - winSize2 / 2)];
        axisExpandWindow[1] = mathMin9(extent3[1], axisExpandWindow[0] + winSize2);
        axisExpandWindow[0] = axisExpandWindow[1] - winSize2;
      }
      return {
        axisExpandWindow,
        behavior
      };
    };
    return Parallel2;
  }();
  function restrict2(len2, extent3) {
    return mathMin9(mathMax9(len2, extent3[0]), extent3[1]);
  }
  function layoutAxisWithoutExpand(axisIndex, layoutInfo) {
    var step = layoutInfo.layoutLength / (layoutInfo.axisCount - 1);
    return {
      position: step * axisIndex,
      axisNameAvailableWidth: step,
      axisLabelShow: true
    };
  }
  function layoutAxisWithExpand(axisIndex, layoutInfo) {
    var layoutLength = layoutInfo.layoutLength;
    var axisExpandWidth = layoutInfo.axisExpandWidth;
    var axisCount = layoutInfo.axisCount;
    var axisCollapseWidth = layoutInfo.axisCollapseWidth;
    var winInnerIndices = layoutInfo.winInnerIndices;
    var position2;
    var axisNameAvailableWidth = axisCollapseWidth;
    var axisLabelShow = false;
    var nameTruncateMaxWidth;
    if (axisIndex < winInnerIndices[0]) {
      position2 = axisIndex * axisCollapseWidth;
      nameTruncateMaxWidth = axisCollapseWidth;
    } else if (axisIndex <= winInnerIndices[1]) {
      position2 = layoutInfo.axisExpandWindow0Pos + axisIndex * axisExpandWidth - layoutInfo.axisExpandWindow[0];
      axisNameAvailableWidth = axisExpandWidth;
      axisLabelShow = true;
    } else {
      position2 = layoutLength - (axisCount - 1 - axisIndex) * axisCollapseWidth;
      nameTruncateMaxWidth = axisCollapseWidth;
    }
    return {
      position: position2,
      axisNameAvailableWidth,
      axisLabelShow,
      nameTruncateMaxWidth
    };
  }
  var Parallel_default = Parallel;

  // node_modules/echarts/lib/coord/parallel/parallelCreator.js
  function createParallelCoordSys(ecModel, api) {
    var coordSysList = [];
    ecModel.eachComponent("parallel", function(parallelModel, idx) {
      var coordSys = new Parallel_default(parallelModel, ecModel, api);
      coordSys.name = "parallel_" + idx;
      coordSys.resize(parallelModel, api);
      parallelModel.coordinateSystem = coordSys;
      coordSys.model = parallelModel;
      coordSysList.push(coordSys);
    });
    ecModel.eachSeries(function(seriesModel) {
      if (seriesModel.get("coordinateSystem") === "parallel") {
        var parallelModel = seriesModel.getReferringComponents("parallel", SINGLE_REFERRING).models[0];
        seriesModel.coordinateSystem = parallelModel.coordinateSystem;
      }
    });
    return coordSysList;
  }
  var parallelCoordSysCreator = {
    create: createParallelCoordSys
  };
  var parallelCreator_default = parallelCoordSysCreator;

  // node_modules/echarts/lib/coord/parallel/AxisModel.js
  var ParallelAxisModel = function(_super) {
    __extends(ParallelAxisModel2, _super);
    function ParallelAxisModel2() {
      var _this = _super !== null && _super.apply(this, arguments) || this;
      _this.type = ParallelAxisModel2.type;
      _this.activeIntervals = [];
      return _this;
    }
    ParallelAxisModel2.prototype.getAreaSelectStyle = function() {
      return makeStyleMapper([
        ["fill", "color"],
        ["lineWidth", "borderWidth"],
        ["stroke", "borderColor"],
        ["width", "width"],
        ["opacity", "opacity"]
      ])(this.getModel("areaSelectStyle"));
    };
    ParallelAxisModel2.prototype.setActiveIntervals = function(intervals) {
      var activeIntervals = this.activeIntervals = clone(intervals);
      if (activeIntervals) {
        for (var i = activeIntervals.length - 1; i >= 0; i--) {
          asc(activeIntervals[i]);
        }
      }
    };
    ParallelAxisModel2.prototype.getActiveState = function(value) {
      var activeIntervals = this.activeIntervals;
      if (!activeIntervals.length) {
        return "normal";
      }
      if (value == null || isNaN(+value)) {
        return "inactive";
      }
      if (activeIntervals.length === 1) {
        var interval = activeIntervals[0];
        if (interval[0] <= value && value <= interval[1]) {
          return "active";
        }
      } else {
        for (var i = 0, len2 = activeIntervals.length; i < len2; i++) {
          if (activeIntervals[i][0] <= value && value <= activeIntervals[i][1]) {
            return "active";
          }
        }
      }
      return "inactive";
    };
    return ParallelAxisModel2;
  }(Component_default);
  mixin(ParallelAxisModel, AxisModelCommonMixin);
  var AxisModel_default = ParallelAxisModel;

  // node_modules/echarts/lib/component/helper/BrushController.js
  var BRUSH_PANEL_GLOBAL = true;
  var mathMin10 = Math.min;
  var mathMax10 = Math.max;
  var mathPow3 = Math.pow;
  var COVER_Z = 1e4;
  var UNSELECT_THRESHOLD = 6;
  var MIN_RESIZE_LINE_WIDTH = 6;
  var MUTEX_RESOURCE_KEY = "globalPan";
  var DIRECTION_MAP = {
    w: [0, 0],
    e: [0, 1],
    n: [1, 0],
    s: [1, 1]
  };
  var CURSOR_MAP = {
    w: "ew",
    e: "ew",
    n: "ns",
    s: "ns",
    ne: "nesw",
    sw: "nesw",
    nw: "nwse",
    se: "nwse"
  };
  var DEFAULT_BRUSH_OPT = {
    brushStyle: {
      lineWidth: 2,
      stroke: "rgba(210,219,238,0.3)",
      fill: "#D2DBEE"
    },
    transformable: true,
    brushMode: "single",
    removeOnClick: false
  };
  var baseUID = 0;
  var BrushController = function(_super) {
    __extends(BrushController2, _super);
    function BrushController2(zr) {
      var _this = _super.call(this) || this;
      _this._track = [];
      _this._covers = [];
      _this._handlers = {};
      if (true) {
        assert(zr);
      }
      _this._zr = zr;
      _this.group = new Group_default();
      _this._uid = "brushController_" + baseUID++;
      each(pointerHandlers, function(handler, eventName) {
        this._handlers[eventName] = bind(handler, this);
      }, _this);
      return _this;
    }
    BrushController2.prototype.enableBrush = function(brushOption) {
      if (true) {
        assert(this._mounted);
      }
      this._brushType && this._doDisableBrush();
      brushOption.brushType && this._doEnableBrush(brushOption);
      return this;
    };
    BrushController2.prototype._doEnableBrush = function(brushOption) {
      var zr = this._zr;
      if (!this._enableGlobalPan) {
        take(zr, MUTEX_RESOURCE_KEY, this._uid);
      }
      each(this._handlers, function(handler, eventName) {
        zr.on(eventName, handler);
      });
      this._brushType = brushOption.brushType;
      this._brushOption = merge(clone(DEFAULT_BRUSH_OPT), brushOption, true);
    };
    BrushController2.prototype._doDisableBrush = function() {
      var zr = this._zr;
      release(zr, MUTEX_RESOURCE_KEY, this._uid);
      each(this._handlers, function(handler, eventName) {
        zr.off(eventName, handler);
      });
      this._brushType = this._brushOption = null;
    };
    BrushController2.prototype.setPanels = function(panelOpts) {
      if (panelOpts && panelOpts.length) {
        var panels_1 = this._panels = {};
        each(panelOpts, function(panelOpts2) {
          panels_1[panelOpts2.panelId] = clone(panelOpts2);
        });
      } else {
        this._panels = null;
      }
      return this;
    };
    BrushController2.prototype.mount = function(opt) {
      opt = opt || {};
      if (true) {
        this._mounted = true;
      }
      this._enableGlobalPan = opt.enableGlobalPan;
      var thisGroup = this.group;
      this._zr.add(thisGroup);
      thisGroup.attr({
        x: opt.x || 0,
        y: opt.y || 0,
        rotation: opt.rotation || 0,
        scaleX: opt.scaleX || 1,
        scaleY: opt.scaleY || 1
      });
      this._transform = thisGroup.getLocalTransform();
      return this;
    };
    BrushController2.prototype.updateCovers = function(coverConfigList) {
      if (true) {
        assert(this._mounted);
      }
      coverConfigList = map(coverConfigList, function(coverConfig) {
        return merge(clone(DEFAULT_BRUSH_OPT), coverConfig, true);
      });
      var tmpIdPrefix = "\0-brush-index-";
      var oldCovers = this._covers;
      var newCovers = this._covers = [];
      var controller = this;
      var creatingCover = this._creatingCover;
      new DataDiffer_default(oldCovers, coverConfigList, oldGetKey, getKey2).add(addOrUpdate).update(addOrUpdate).remove(remove).execute();
      return this;
      function getKey2(brushOption, index) {
        return (brushOption.id != null ? brushOption.id : tmpIdPrefix + index) + "-" + brushOption.brushType;
      }
      function oldGetKey(cover, index) {
        return getKey2(cover.__brushOption, index);
      }
      function addOrUpdate(newIndex, oldIndex) {
        var newBrushInternal = coverConfigList[newIndex];
        if (oldIndex != null && oldCovers[oldIndex] === creatingCover) {
          newCovers[newIndex] = oldCovers[oldIndex];
        } else {
          var cover = newCovers[newIndex] = oldIndex != null ? (oldCovers[oldIndex].__brushOption = newBrushInternal, oldCovers[oldIndex]) : endCreating(controller, createCover(controller, newBrushInternal));
          updateCoverAfterCreation(controller, cover);
        }
      }
      function remove(oldIndex) {
        if (oldCovers[oldIndex] !== creatingCover) {
          controller.group.remove(oldCovers[oldIndex]);
        }
      }
    };
    BrushController2.prototype.unmount = function() {
      if (true) {
        if (!this._mounted) {
          return;
        }
      }
      this.enableBrush(false);
      clearCovers(this);
      this._zr.remove(this.group);
      if (true) {
        this._mounted = false;
      }
      return this;
    };
    BrushController2.prototype.dispose = function() {
      this.unmount();
      this.off();
    };
    return BrushController2;
  }(Eventful_default);
  function createCover(controller, brushOption) {
    var cover = coverRenderers[brushOption.brushType].createCover(controller, brushOption);
    cover.__brushOption = brushOption;
    updateZ(cover, brushOption);
    controller.group.add(cover);
    return cover;
  }
  function endCreating(controller, creatingCover) {
    var coverRenderer = getCoverRenderer(creatingCover);
    if (coverRenderer.endCreating) {
      coverRenderer.endCreating(controller, creatingCover);
      updateZ(creatingCover, creatingCover.__brushOption);
    }
    return creatingCover;
  }
  function updateCoverShape(controller, cover) {
    var brushOption = cover.__brushOption;
    getCoverRenderer(cover).updateCoverShape(controller, cover, brushOption.range, brushOption);
  }
  function updateZ(cover, brushOption) {
    var z = brushOption.z;
    z == null && (z = COVER_Z);
    cover.traverse(function(el) {
      el.z = z;
      el.z2 = z;
    });
  }
  function updateCoverAfterCreation(controller, cover) {
    getCoverRenderer(cover).updateCommon(controller, cover);
    updateCoverShape(controller, cover);
  }
  function getCoverRenderer(cover) {
    return coverRenderers[cover.__brushOption.brushType];
  }
  function getPanelByPoint(controller, e2, localCursorPoint) {
    var panels = controller._panels;
    if (!panels) {
      return BRUSH_PANEL_GLOBAL;
    }
    var panel;
    var transform2 = controller._transform;
    each(panels, function(pn) {
      pn.isTargetByCursor(e2, localCursorPoint, transform2) && (panel = pn);
    });
    return panel;
  }
  function getPanelByCover(controller, cover) {
    var panels = controller._panels;
    if (!panels) {
      return BRUSH_PANEL_GLOBAL;
    }
    var panelId = cover.__brushOption.panelId;
    return panelId != null ? panels[panelId] : BRUSH_PANEL_GLOBAL;
  }
  function clearCovers(controller) {
    var covers = controller._covers;
    var originalLength = covers.length;
    each(covers, function(cover) {
      controller.group.remove(cover);
    }, controller);
    covers.length = 0;
    return !!originalLength;
  }
  function trigger2(controller, opt) {
    var areas = map(controller._covers, function(cover) {
      var brushOption = cover.__brushOption;
      var range = clone(brushOption.range);
      return {
        brushType: brushOption.brushType,
        panelId: brushOption.panelId,
        range
      };
    });
    controller.trigger("brush", {
      areas,
      isEnd: !!opt.isEnd,
      removeOnClick: !!opt.removeOnClick
    });
  }
  function shouldShowCover(controller) {
    var track = controller._track;
    if (!track.length) {
      return false;
    }
    var p2 = track[track.length - 1];
    var p1 = track[0];
    var dx = p2[0] - p1[0];
    var dy = p2[1] - p1[1];
    var dist3 = mathPow3(dx * dx + dy * dy, 0.5);
    return dist3 > UNSELECT_THRESHOLD;
  }
  function getTrackEnds(track) {
    var tail = track.length - 1;
    tail < 0 && (tail = 0);
    return [track[0], track[tail]];
  }
  function createBaseRectCover(rectRangeConverter, controller, brushOption, edgeNameSequences) {
    var cover = new Group_default();
    cover.add(new Rect_default({
      name: "main",
      style: makeStyle(brushOption),
      silent: true,
      draggable: true,
      cursor: "move",
      drift: curry(driftRect, rectRangeConverter, controller, cover, ["n", "s", "w", "e"]),
      ondragend: curry(trigger2, controller, {
        isEnd: true
      })
    }));
    each(edgeNameSequences, function(nameSequence) {
      cover.add(new Rect_default({
        name: nameSequence.join(""),
        style: {
          opacity: 0
        },
        draggable: true,
        silent: true,
        invisible: true,
        drift: curry(driftRect, rectRangeConverter, controller, cover, nameSequence),
        ondragend: curry(trigger2, controller, {
          isEnd: true
        })
      }));
    });
    return cover;
  }
  function updateBaseRect(controller, cover, localRange, brushOption) {
    var lineWidth = brushOption.brushStyle.lineWidth || 0;
    var handleSize = mathMax10(lineWidth, MIN_RESIZE_LINE_WIDTH);
    var x = localRange[0][0];
    var y = localRange[1][0];
    var xa = x - lineWidth / 2;
    var ya = y - lineWidth / 2;
    var x2 = localRange[0][1];
    var y2 = localRange[1][1];
    var x2a = x2 - handleSize + lineWidth / 2;
    var y2a = y2 - handleSize + lineWidth / 2;
    var width = x2 - x;
    var height = y2 - y;
    var widtha = width + lineWidth;
    var heighta = height + lineWidth;
    updateRectShape(controller, cover, "main", x, y, width, height);
    if (brushOption.transformable) {
      updateRectShape(controller, cover, "w", xa, ya, handleSize, heighta);
      updateRectShape(controller, cover, "e", x2a, ya, handleSize, heighta);
      updateRectShape(controller, cover, "n", xa, ya, widtha, handleSize);
      updateRectShape(controller, cover, "s", xa, y2a, widtha, handleSize);
      updateRectShape(controller, cover, "nw", xa, ya, handleSize, handleSize);
      updateRectShape(controller, cover, "ne", x2a, ya, handleSize, handleSize);
      updateRectShape(controller, cover, "sw", xa, y2a, handleSize, handleSize);
      updateRectShape(controller, cover, "se", x2a, y2a, handleSize, handleSize);
    }
  }
  function updateCommon(controller, cover) {
    var brushOption = cover.__brushOption;
    var transformable = brushOption.transformable;
    var mainEl = cover.childAt(0);
    mainEl.useStyle(makeStyle(brushOption));
    mainEl.attr({
      silent: !transformable,
      cursor: transformable ? "move" : "default"
    });
    each([["w"], ["e"], ["n"], ["s"], ["s", "e"], ["s", "w"], ["n", "e"], ["n", "w"]], function(nameSequence) {
      var el = cover.childOfName(nameSequence.join(""));
      var globalDir = nameSequence.length === 1 ? getGlobalDirection1(controller, nameSequence[0]) : getGlobalDirection2(controller, nameSequence);
      el && el.attr({
        silent: !transformable,
        invisible: !transformable,
        cursor: transformable ? CURSOR_MAP[globalDir] + "-resize" : null
      });
    });
  }
  function updateRectShape(controller, cover, name, x, y, w, h) {
    var el = cover.childOfName(name);
    el && el.setShape(pointsToRect(clipByPanel(controller, cover, [[x, y], [x + w, y + h]])));
  }
  function makeStyle(brushOption) {
    return defaults({
      strokeNoScale: true
    }, brushOption.brushStyle);
  }
  function formatRectRange(x, y, x2, y2) {
    var min3 = [mathMin10(x, x2), mathMin10(y, y2)];
    var max3 = [mathMax10(x, x2), mathMax10(y, y2)];
    return [
      [min3[0], max3[0]],
      [min3[1], max3[1]]
    ];
  }
  function getTransform2(controller) {
    return getTransform(controller.group);
  }
  function getGlobalDirection1(controller, localDirName) {
    var map3 = {
      w: "left",
      e: "right",
      n: "top",
      s: "bottom"
    };
    var inverseMap = {
      left: "w",
      right: "e",
      top: "n",
      bottom: "s"
    };
    var dir3 = transformDirection(map3[localDirName], getTransform2(controller));
    return inverseMap[dir3];
  }
  function getGlobalDirection2(controller, localDirNameSeq) {
    var globalDir = [getGlobalDirection1(controller, localDirNameSeq[0]), getGlobalDirection1(controller, localDirNameSeq[1])];
    (globalDir[0] === "e" || globalDir[0] === "w") && globalDir.reverse();
    return globalDir.join("");
  }
  function driftRect(rectRangeConverter, controller, cover, dirNameSequence, dx, dy) {
    var brushOption = cover.__brushOption;
    var rectRange = rectRangeConverter.toRectRange(brushOption.range);
    var localDelta = toLocalDelta(controller, dx, dy);
    each(dirNameSequence, function(dirName) {
      var ind = DIRECTION_MAP[dirName];
      rectRange[ind[0]][ind[1]] += localDelta[ind[0]];
    });
    brushOption.range = rectRangeConverter.fromRectRange(formatRectRange(rectRange[0][0], rectRange[1][0], rectRange[0][1], rectRange[1][1]));
    updateCoverAfterCreation(controller, cover);
    trigger2(controller, {
      isEnd: false
    });
  }
  function driftPolygon(controller, cover, dx, dy) {
    var range = cover.__brushOption.range;
    var localDelta = toLocalDelta(controller, dx, dy);
    each(range, function(point) {
      point[0] += localDelta[0];
      point[1] += localDelta[1];
    });
    updateCoverAfterCreation(controller, cover);
    trigger2(controller, {
      isEnd: false
    });
  }
  function toLocalDelta(controller, dx, dy) {
    var thisGroup = controller.group;
    var localD = thisGroup.transformCoordToLocal(dx, dy);
    var localZero = thisGroup.transformCoordToLocal(0, 0);
    return [localD[0] - localZero[0], localD[1] - localZero[1]];
  }
  function clipByPanel(controller, cover, data) {
    var panel = getPanelByCover(controller, cover);
    return panel && panel !== BRUSH_PANEL_GLOBAL ? panel.clipPath(data, controller._transform) : clone(data);
  }
  function pointsToRect(points4) {
    var xmin = mathMin10(points4[0][0], points4[1][0]);
    var ymin = mathMin10(points4[0][1], points4[1][1]);
    var xmax = mathMax10(points4[0][0], points4[1][0]);
    var ymax = mathMax10(points4[0][1], points4[1][1]);
    return {
      x: xmin,
      y: ymin,
      width: xmax - xmin,
      height: ymax - ymin
    };
  }
  function resetCursor(controller, e2, localCursorPoint) {
    if (!controller._brushType || isOutsideZrArea(controller, e2.offsetX, e2.offsetY)) {
      return;
    }
    var zr = controller._zr;
    var covers = controller._covers;
    var currPanel = getPanelByPoint(controller, e2, localCursorPoint);
    if (!controller._dragging) {
      for (var i = 0; i < covers.length; i++) {
        var brushOption = covers[i].__brushOption;
        if (currPanel && (currPanel === BRUSH_PANEL_GLOBAL || brushOption.panelId === currPanel.panelId) && coverRenderers[brushOption.brushType].contain(covers[i], localCursorPoint[0], localCursorPoint[1])) {
          return;
        }
      }
    }
    currPanel && zr.setCursorStyle("crosshair");
  }
  function preventDefault(e2) {
    var rawE = e2.event;
    rawE.preventDefault && rawE.preventDefault();
  }
  function mainShapeContain(cover, x, y) {
    return cover.childOfName("main").contain(x, y);
  }
  function updateCoverByMouse(controller, e2, localCursorPoint, isEnd) {
    var creatingCover = controller._creatingCover;
    var panel = controller._creatingPanel;
    var thisBrushOption = controller._brushOption;
    var eventParams;
    controller._track.push(localCursorPoint.slice());
    if (shouldShowCover(controller) || creatingCover) {
      if (panel && !creatingCover) {
        thisBrushOption.brushMode === "single" && clearCovers(controller);
        var brushOption = clone(thisBrushOption);
        brushOption.brushType = determineBrushType(brushOption.brushType, panel);
        brushOption.panelId = panel === BRUSH_PANEL_GLOBAL ? null : panel.panelId;
        creatingCover = controller._creatingCover = createCover(controller, brushOption);
        controller._covers.push(creatingCover);
      }
      if (creatingCover) {
        var coverRenderer = coverRenderers[determineBrushType(controller._brushType, panel)];
        var coverBrushOption = creatingCover.__brushOption;
        coverBrushOption.range = coverRenderer.getCreatingRange(clipByPanel(controller, creatingCover, controller._track));
        if (isEnd) {
          endCreating(controller, creatingCover);
          coverRenderer.updateCommon(controller, creatingCover);
        }
        updateCoverShape(controller, creatingCover);
        eventParams = {
          isEnd
        };
      }
    } else if (isEnd && thisBrushOption.brushMode === "single" && thisBrushOption.removeOnClick) {
      if (getPanelByPoint(controller, e2, localCursorPoint) && clearCovers(controller)) {
        eventParams = {
          isEnd,
          removeOnClick: true
        };
      }
    }
    return eventParams;
  }
  function determineBrushType(brushType, panel) {
    if (brushType === "auto") {
      if (true) {
        assert(panel && panel.defaultBrushType, 'MUST have defaultBrushType when brushType is "atuo"');
      }
      return panel.defaultBrushType;
    }
    return brushType;
  }
  var pointerHandlers = {
    mousedown: function(e2) {
      if (this._dragging) {
        handleDragEnd(this, e2);
      } else if (!e2.target || !e2.target.draggable) {
        preventDefault(e2);
        var localCursorPoint = this.group.transformCoordToLocal(e2.offsetX, e2.offsetY);
        this._creatingCover = null;
        var panel = this._creatingPanel = getPanelByPoint(this, e2, localCursorPoint);
        if (panel) {
          this._dragging = true;
          this._track = [localCursorPoint.slice()];
        }
      }
    },
    mousemove: function(e2) {
      var x = e2.offsetX;
      var y = e2.offsetY;
      var localCursorPoint = this.group.transformCoordToLocal(x, y);
      resetCursor(this, e2, localCursorPoint);
      if (this._dragging) {
        preventDefault(e2);
        var eventParams = updateCoverByMouse(this, e2, localCursorPoint, false);
        eventParams && trigger2(this, eventParams);
      }
    },
    mouseup: function(e2) {
      handleDragEnd(this, e2);
    }
  };
  function handleDragEnd(controller, e2) {
    if (controller._dragging) {
      preventDefault(e2);
      var x = e2.offsetX;
      var y = e2.offsetY;
      var localCursorPoint = controller.group.transformCoordToLocal(x, y);
      var eventParams = updateCoverByMouse(controller, e2, localCursorPoint, true);
      controller._dragging = false;
      controller._track = [];
      controller._creatingCover = null;
      eventParams && trigger2(controller, eventParams);
    }
  }
  function isOutsideZrArea(controller, x, y) {
    var zr = controller._zr;
    return x < 0 || x > zr.getWidth() || y < 0 || y > zr.getHeight();
  }
  var coverRenderers = {
    lineX: getLineRenderer(0),
    lineY: getLineRenderer(1),
    rect: {
      createCover: function(controller, brushOption) {
        function returnInput(range) {
          return range;
        }
        return createBaseRectCover({
          toRectRange: returnInput,
          fromRectRange: returnInput
        }, controller, brushOption, [["w"], ["e"], ["n"], ["s"], ["s", "e"], ["s", "w"], ["n", "e"], ["n", "w"]]);
      },
      getCreatingRange: function(localTrack) {
        var ends = getTrackEnds(localTrack);
        return formatRectRange(ends[1][0], ends[1][1], ends[0][0], ends[0][1]);
      },
      updateCoverShape: function(controller, cover, localRange, brushOption) {
        updateBaseRect(controller, cover, localRange, brushOption);
      },
      updateCommon,
      contain: mainShapeContain
    },
    polygon: {
      createCover: function(controller, brushOption) {
        var cover = new Group_default();
        cover.add(new Polyline_default({
          name: "main",
          style: makeStyle(brushOption),
          silent: true
        }));
        return cover;
      },
      getCreatingRange: function(localTrack) {
        return localTrack;
      },
      endCreating: function(controller, cover) {
        cover.remove(cover.childAt(0));
        cover.add(new Polygon_default({
          name: "main",
          draggable: true,
          drift: curry(driftPolygon, controller, cover),
          ondragend: curry(trigger2, controller, {
            isEnd: true
          })
        }));
      },
      updateCoverShape: function(controller, cover, localRange, brushOption) {
        cover.childAt(0).setShape({
          points: clipByPanel(controller, cover, localRange)
        });
      },
      updateCommon,
      contain: mainShapeContain
    }
  };
  function getLineRenderer(xyIndex) {
    return {
      createCover: function(controller, brushOption) {
        return createBaseRectCover({
          toRectRange: function(range) {
            var rectRange = [range, [0, 100]];
            xyIndex && rectRange.reverse();
            return rectRange;
          },
          fromRectRange: function(rectRange) {
            return rectRange[xyIndex];
          }
        }, controller, brushOption, [[["w"], ["e"]], [["n"], ["s"]]][xyIndex]);
      },
      getCreatingRange: function(localTrack) {
        var ends = getTrackEnds(localTrack);
        var min3 = mathMin10(ends[0][xyIndex], ends[1][xyIndex]);
        var max3 = mathMax10(ends[0][xyIndex], ends[1][xyIndex]);
        return [min3, max3];
      },
      updateCoverShape: function(controller, cover, localRange, brushOption) {
        var otherExtent;
        var panel = getPanelByCover(controller, cover);
        if (panel !== BRUSH_PANEL_GLOBAL && panel.getLinearBrushOtherExtent) {
          otherExtent = panel.getLinearBrushOtherExtent(xyIndex);
        } else {
          var zr = controller._zr;
          otherExtent = [0, [zr.getWidth(), zr.getHeight()][1 - xyIndex]];
        }
        var rectRange = [localRange, otherExtent];
        xyIndex && rectRange.reverse();
        updateBaseRect(controller, cover, rectRange, brushOption);
      },
      updateCommon,
      contain: mainShapeContain
    };
  }
  var BrushController_default = BrushController;

  // node_modules/echarts/lib/component/helper/brushHelper.js
  function makeRectPanelClipPath(rect) {
    rect = normalizeRect(rect);
    return function(localPoints) {
      return clipPointsByRect(localPoints, rect);
    };
  }
  function makeLinearBrushOtherExtent(rect, specifiedXYIndex) {
    rect = normalizeRect(rect);
    return function(xyIndex) {
      var idx = specifiedXYIndex != null ? specifiedXYIndex : xyIndex;
      var brushWidth = idx ? rect.width : rect.height;
      var base2 = idx ? rect.x : rect.y;
      return [base2, base2 + (brushWidth || 0)];
    };
  }
  function makeRectIsTargetByCursor(rect, api, targetModel) {
    var boundingRect = normalizeRect(rect);
    return function(e2, localCursorPoint) {
      return boundingRect.contain(localCursorPoint[0], localCursorPoint[1]) && !onIrrelevantElement(e2, api, targetModel);
    };
  }
  function normalizeRect(rect) {
    return BoundingRect_default.create(rect);
  }

  // node_modules/echarts/lib/component/axis/ParallelAxisView.js
  var elementList = ["axisLine", "axisTickLabel", "axisName"];
  var ParallelAxisView = function(_super) {
    __extends(ParallelAxisView2, _super);
    function ParallelAxisView2() {
      var _this = _super !== null && _super.apply(this, arguments) || this;
      _this.type = ParallelAxisView2.type;
      return _this;
    }
    ParallelAxisView2.prototype.init = function(ecModel, api) {
      _super.prototype.init.apply(this, arguments);
      (this._brushController = new BrushController_default(api.getZr())).on("brush", bind(this._onBrush, this));
    };
    ParallelAxisView2.prototype.render = function(axisModel, ecModel, api, payload) {
      if (fromAxisAreaSelect(axisModel, ecModel, payload)) {
        return;
      }
      this.axisModel = axisModel;
      this.api = api;
      this.group.removeAll();
      var oldAxisGroup = this._axisGroup;
      this._axisGroup = new Group_default();
      this.group.add(this._axisGroup);
      if (!axisModel.get("show")) {
        return;
      }
      var coordSysModel = getCoordSysModel(axisModel, ecModel);
      var coordSys = coordSysModel.coordinateSystem;
      var areaSelectStyle = axisModel.getAreaSelectStyle();
      var areaWidth = areaSelectStyle.width;
      var dim = axisModel.axis.dim;
      var axisLayout = coordSys.getAxisLayout(dim);
      var builderOpt = extend({
        strokeContainThreshold: areaWidth
      }, axisLayout);
      var axisBuilder = new AxisBuilder_default(axisModel, builderOpt);
      each(elementList, axisBuilder.add, axisBuilder);
      this._axisGroup.add(axisBuilder.getGroup());
      this._refreshBrushController(builderOpt, areaSelectStyle, axisModel, coordSysModel, areaWidth, api);
      groupTransition(oldAxisGroup, this._axisGroup, axisModel);
    };
    ParallelAxisView2.prototype._refreshBrushController = function(builderOpt, areaSelectStyle, axisModel, coordSysModel, areaWidth, api) {
      var extent3 = axisModel.axis.getExtent();
      var extentLen = extent3[1] - extent3[0];
      var extra = Math.min(30, Math.abs(extentLen) * 0.1);
      var rect = BoundingRect_default.create({
        x: extent3[0],
        y: -areaWidth / 2,
        width: extentLen,
        height: areaWidth
      });
      rect.x -= extra;
      rect.width += 2 * extra;
      this._brushController.mount({
        enableGlobalPan: true,
        rotation: builderOpt.rotation,
        x: builderOpt.position[0],
        y: builderOpt.position[1]
      }).setPanels([{
        panelId: "pl",
        clipPath: makeRectPanelClipPath(rect),
        isTargetByCursor: makeRectIsTargetByCursor(rect, api, coordSysModel),
        getLinearBrushOtherExtent: makeLinearBrushOtherExtent(rect, 0)
      }]).enableBrush({
        brushType: "lineX",
        brushStyle: areaSelectStyle,
        removeOnClick: true
      }).updateCovers(getCoverInfoList(axisModel));
    };
    ParallelAxisView2.prototype._onBrush = function(eventParam) {
      var coverInfoList = eventParam.areas;
      var axisModel = this.axisModel;
      var axis = axisModel.axis;
      var intervals = map(coverInfoList, function(coverInfo) {
        return [axis.coordToData(coverInfo.range[0], true), axis.coordToData(coverInfo.range[1], true)];
      });
      if (!axisModel.option.realtime === eventParam.isEnd || eventParam.removeOnClick) {
        this.api.dispatchAction({
          type: "axisAreaSelect",
          parallelAxisId: axisModel.id,
          intervals
        });
      }
    };
    ParallelAxisView2.prototype.dispose = function() {
      this._brushController.dispose();
    };
    ParallelAxisView2.type = "parallelAxis";
    return ParallelAxisView2;
  }(Component_default2);
  function fromAxisAreaSelect(axisModel, ecModel, payload) {
    return payload && payload.type === "axisAreaSelect" && ecModel.findComponents({
      mainType: "parallelAxis",
      query: payload
    })[0] === axisModel;
  }
  function getCoverInfoList(axisModel) {
    var axis = axisModel.axis;
    return map(axisModel.activeIntervals, function(interval) {
      return {
        brushType: "lineX",
        panelId: "pl",
        range: [axis.dataToCoord(interval[0], true), axis.dataToCoord(interval[1], true)]
      };
    });
  }
  function getCoordSysModel(axisModel, ecModel) {
    return ecModel.getComponent("parallel", axisModel.get("parallelIndex"));
  }
  var ParallelAxisView_default = ParallelAxisView;

  // node_modules/echarts/lib/component/axis/parallelAxisAction.js
  var actionInfo2 = {
    type: "axisAreaSelect",
    event: "axisAreaSelected"
  };
  function installParallelActions(registers) {
    registers.registerAction(actionInfo2, function(payload, ecModel) {
      ecModel.eachComponent({
        mainType: "parallelAxis",
        query: payload
      }, function(parallelAxisModel) {
        parallelAxisModel.axis.model.setActiveIntervals(payload.intervals);
      });
    });
    registers.registerAction("parallelAxisExpand", function(payload, ecModel) {
      ecModel.eachComponent({
        mainType: "parallel",
        query: payload
      }, function(parallelModel) {
        parallelModel.setAxisExpand(payload);
      });
    });
  }

  // node_modules/echarts/lib/component/parallel/install.js
  var defaultAxisOption = {
    type: "value",
    areaSelectStyle: {
      width: 20,
      borderWidth: 1,
      borderColor: "rgba(160,197,232)",
      color: "rgba(160,197,232)",
      opacity: 0.3
    },
    realtime: true,
    z: 10
  };
  function install17(registers) {
    registers.registerComponentView(ParallelView_default2);
    registers.registerComponentModel(ParallelModel_default);
    registers.registerCoordinateSystem("parallel", parallelCreator_default);
    registers.registerPreprocessor(parallelPreprocessor);
    registers.registerComponentModel(AxisModel_default);
    registers.registerComponentView(ParallelAxisView_default);
    axisModelCreator(registers, "parallel", AxisModel_default, defaultAxisOption);
    installParallelActions(registers);
  }

  // node_modules/echarts/lib/chart/parallel/install.js
  function install18(registers) {
    use(install17);
    registers.registerChartView(ParallelView_default);
    registers.registerSeriesModel(ParallelSeries_default);
    registers.registerVisual(registers.PRIORITY.VISUAL.BRUSH, parallelVisual_default);
  }

  // node_modules/echarts/lib/chart/sankey/SankeyView.js
  var SankeyPathShape = function() {
    function SankeyPathShape2() {
      this.x1 = 0;
      this.y1 = 0;
      this.x2 = 0;
      this.y2 = 0;
      this.cpx1 = 0;
      this.cpy1 = 0;
      this.cpx2 = 0;
      this.cpy2 = 0;
      this.extent = 0;
    }
    return SankeyPathShape2;
  }();
  var SankeyPath = function(_super) {
    __extends(SankeyPath2, _super);
    function SankeyPath2(opts) {
      return _super.call(this, opts) || this;
    }
    SankeyPath2.prototype.getDefaultShape = function() {
      return new SankeyPathShape();
    };
    SankeyPath2.prototype.buildPath = function(ctx, shape) {
      var extent3 = shape.extent;
      ctx.moveTo(shape.x1, shape.y1);
      ctx.bezierCurveTo(shape.cpx1, shape.cpy1, shape.cpx2, shape.cpy2, shape.x2, shape.y2);
      if (shape.orient === "vertical") {
        ctx.lineTo(shape.x2 + extent3, shape.y2);
        ctx.bezierCurveTo(shape.cpx2 + extent3, shape.cpy2, shape.cpx1 + extent3, shape.cpy1, shape.x1 + extent3, shape.y1);
      } else {
        ctx.lineTo(shape.x2, shape.y2 + extent3);
        ctx.bezierCurveTo(shape.cpx2, shape.cpy2 + extent3, shape.cpx1, shape.cpy1 + extent3, shape.x1, shape.y1 + extent3);
      }
      ctx.closePath();
    };
    SankeyPath2.prototype.highlight = function() {
      enterEmphasis(this);
    };
    SankeyPath2.prototype.downplay = function() {
      leaveEmphasis(this);
    };
    return SankeyPath2;
  }(Path_default);
  var SankeyView = function(_super) {
    __extends(SankeyView2, _super);
    function SankeyView2() {
      var _this = _super !== null && _super.apply(this, arguments) || this;
      _this.type = SankeyView2.type;
      _this._focusAdjacencyDisabled = false;
      return _this;
    }
    SankeyView2.prototype.render = function(seriesModel, ecModel, api) {
      var sankeyView = this;
      var graph = seriesModel.getGraph();
      var group = this.group;
      var layoutInfo = seriesModel.layoutInfo;
      var width = layoutInfo.width;
      var height = layoutInfo.height;
      var nodeData = seriesModel.getData();
      var edgeData = seriesModel.getData("edge");
      var orient = seriesModel.get("orient");
      this._model = seriesModel;
      group.removeAll();
      group.x = layoutInfo.x;
      group.y = layoutInfo.y;
      graph.eachEdge(function(edge) {
        var curve = new SankeyPath();
        var ecData = getECData(curve);
        ecData.dataIndex = edge.dataIndex;
        ecData.seriesIndex = seriesModel.seriesIndex;
        ecData.dataType = "edge";
        var edgeModel = edge.getModel();
        var lineStyleModel = edgeModel.getModel("lineStyle");
        var curvature = lineStyleModel.get("curveness");
        var n1Layout = edge.node1.getLayout();
        var node1Model = edge.node1.getModel();
        var dragX1 = node1Model.get("localX");
        var dragY1 = node1Model.get("localY");
        var n2Layout = edge.node2.getLayout();
        var node2Model = edge.node2.getModel();
        var dragX2 = node2Model.get("localX");
        var dragY2 = node2Model.get("localY");
        var edgeLayout = edge.getLayout();
        var x1;
        var y1;
        var x2;
        var y2;
        var cpx1;
        var cpy1;
        var cpx2;
        var cpy2;
        curve.shape.extent = Math.max(1, edgeLayout.dy);
        curve.shape.orient = orient;
        if (orient === "vertical") {
          x1 = (dragX1 != null ? dragX1 * width : n1Layout.x) + edgeLayout.sy;
          y1 = (dragY1 != null ? dragY1 * height : n1Layout.y) + n1Layout.dy;
          x2 = (dragX2 != null ? dragX2 * width : n2Layout.x) + edgeLayout.ty;
          y2 = dragY2 != null ? dragY2 * height : n2Layout.y;
          cpx1 = x1;
          cpy1 = y1 * (1 - curvature) + y2 * curvature;
          cpx2 = x2;
          cpy2 = y1 * curvature + y2 * (1 - curvature);
        } else {
          x1 = (dragX1 != null ? dragX1 * width : n1Layout.x) + n1Layout.dx;
          y1 = (dragY1 != null ? dragY1 * height : n1Layout.y) + edgeLayout.sy;
          x2 = dragX2 != null ? dragX2 * width : n2Layout.x;
          y2 = (dragY2 != null ? dragY2 * height : n2Layout.y) + edgeLayout.ty;
          cpx1 = x1 * (1 - curvature) + x2 * curvature;
          cpy1 = y1;
          cpx2 = x1 * curvature + x2 * (1 - curvature);
          cpy2 = y2;
        }
        curve.setShape({
          x1,
          y1,
          x2,
          y2,
          cpx1,
          cpy1,
          cpx2,
          cpy2
        });
        curve.useStyle(lineStyleModel.getItemStyle());
        switch (curve.style.fill) {
          case "source":
            curve.style.fill = edge.node1.getVisual("color");
            curve.style.decal = edge.node1.getVisual("style").decal;
            break;
          case "target":
            curve.style.fill = edge.node2.getVisual("color");
            curve.style.decal = edge.node2.getVisual("style").decal;
            break;
          case "gradient":
            var sourceColor = edge.node1.getVisual("color");
            var targetColor = edge.node2.getVisual("color");
            if (isString(sourceColor) && isString(targetColor)) {
              curve.style.fill = new LinearGradient_default(0, 0, +(orient === "horizontal"), +(orient === "vertical"), [{
                color: sourceColor,
                offset: 0
              }, {
                color: targetColor,
                offset: 1
              }]);
            }
        }
        var emphasisModel = edgeModel.getModel("emphasis");
        setStatesStylesFromModel(curve, edgeModel, "lineStyle", function(model) {
          return model.getItemStyle();
        });
        group.add(curve);
        edgeData.setItemGraphicEl(edge.dataIndex, curve);
        var focus = emphasisModel.get("focus");
        toggleHoverEmphasis(curve, focus === "adjacency" ? edge.getAdjacentDataIndices() : focus, emphasisModel.get("blurScope"), emphasisModel.get("disabled"));
        getECData(curve).dataType = "edge";
      });
      graph.eachNode(function(node) {
        var layout5 = node.getLayout();
        var itemModel = node.getModel();
        var dragX = itemModel.get("localX");
        var dragY = itemModel.get("localY");
        var emphasisModel = itemModel.getModel("emphasis");
        var rect = new Rect_default({
          shape: {
            x: dragX != null ? dragX * width : layout5.x,
            y: dragY != null ? dragY * height : layout5.y,
            width: layout5.dx,
            height: layout5.dy
          },
          style: itemModel.getModel("itemStyle").getItemStyle(),
          z2: 10
        });
        setLabelStyle(rect, getLabelStatesModels(itemModel), {
          labelFetcher: seriesModel,
          labelDataIndex: node.dataIndex,
          defaultText: node.id
        });
        rect.disableLabelAnimation = true;
        rect.setStyle("fill", node.getVisual("color"));
        rect.setStyle("decal", node.getVisual("style").decal);
        setStatesStylesFromModel(rect, itemModel);
        group.add(rect);
        nodeData.setItemGraphicEl(node.dataIndex, rect);
        getECData(rect).dataType = "node";
        var focus = emphasisModel.get("focus");
        toggleHoverEmphasis(rect, focus === "adjacency" ? node.getAdjacentDataIndices() : focus, emphasisModel.get("blurScope"), emphasisModel.get("disabled"));
      });
      nodeData.eachItemGraphicEl(function(el, dataIndex) {
        var itemModel = nodeData.getItemModel(dataIndex);
        if (itemModel.get("draggable")) {
          el.drift = function(dx, dy) {
            sankeyView._focusAdjacencyDisabled = true;
            this.shape.x += dx;
            this.shape.y += dy;
            this.dirty();
            api.dispatchAction({
              type: "dragNode",
              seriesId: seriesModel.id,
              dataIndex: nodeData.getRawIndex(dataIndex),
              localX: this.shape.x / width,
              localY: this.shape.y / height
            });
          };
          el.ondragend = function() {
            sankeyView._focusAdjacencyDisabled = false;
          };
          el.draggable = true;
          el.cursor = "move";
        }
      });
      if (!this._data && seriesModel.isAnimationEnabled()) {
        group.setClipPath(createGridClipShape2(group.getBoundingRect(), seriesModel, function() {
          group.removeClipPath();
        }));
      }
      this._data = seriesModel.getData();
    };
    SankeyView2.prototype.dispose = function() {
    };
    SankeyView2.type = "sankey";
    return SankeyView2;
  }(Chart_default);
  function createGridClipShape2(rect, seriesModel, cb) {
    var rectEl = new Rect_default({
      shape: {
        x: rect.x - 10,
        y: rect.y - 10,
        width: 0,
        height: rect.height + 20
      }
    });
    initProps(rectEl, {
      shape: {
        width: rect.width + 20
      }
    }, seriesModel, cb);
    return rectEl;
  }
  var SankeyView_default = SankeyView;

  // node_modules/echarts/lib/chart/sankey/SankeySeries.js
  var SankeySeriesModel = function(_super) {
    __extends(SankeySeriesModel2, _super);
    function SankeySeriesModel2() {
      var _this = _super !== null && _super.apply(this, arguments) || this;
      _this.type = SankeySeriesModel2.type;
      return _this;
    }
    SankeySeriesModel2.prototype.getInitialData = function(option, ecModel) {
      var links = option.edges || option.links;
      var nodes = option.data || option.nodes;
      var levels = option.levels;
      this.levelModels = [];
      var levelModels = this.levelModels;
      for (var i = 0; i < levels.length; i++) {
        if (levels[i].depth != null && levels[i].depth >= 0) {
          levelModels[levels[i].depth] = new Model_default(levels[i], this, ecModel);
        } else {
          if (true) {
            throw new Error("levels[i].depth is mandatory and should be natural number");
          }
        }
      }
      if (nodes && links) {
        var graph = createGraphFromNodeEdge(nodes, links, this, true, beforeLink);
        return graph.data;
      }
      function beforeLink(nodeData, edgeData) {
        nodeData.wrapMethod("getItemModel", function(model, idx) {
          var seriesModel = model.parentModel;
          var layout5 = seriesModel.getData().getItemLayout(idx);
          if (layout5) {
            var nodeDepth = layout5.depth;
            var levelModel = seriesModel.levelModels[nodeDepth];
            if (levelModel) {
              model.parentModel = levelModel;
            }
          }
          return model;
        });
        edgeData.wrapMethod("getItemModel", function(model, idx) {
          var seriesModel = model.parentModel;
          var edge = seriesModel.getGraph().getEdgeByIndex(idx);
          var layout5 = edge.node1.getLayout();
          if (layout5) {
            var depth = layout5.depth;
            var levelModel = seriesModel.levelModels[depth];
            if (levelModel) {
              model.parentModel = levelModel;
            }
          }
          return model;
        });
      }
    };
    SankeySeriesModel2.prototype.setNodePosition = function(dataIndex, localPosition) {
      var nodes = this.option.data || this.option.nodes;
      var dataItem = nodes[dataIndex];
      dataItem.localX = localPosition[0];
      dataItem.localY = localPosition[1];
    };
    SankeySeriesModel2.prototype.getGraph = function() {
      return this.getData().graph;
    };
    SankeySeriesModel2.prototype.getEdgeData = function() {
      return this.getGraph().edgeData;
    };
    SankeySeriesModel2.prototype.formatTooltip = function(dataIndex, multipleSeries, dataType) {
      function noValue(val) {
        return isNaN(val) || val == null;
      }
      if (dataType === "edge") {
        var params = this.getDataParams(dataIndex, dataType);
        var rawDataOpt = params.data;
        var edgeValue = params.value;
        var edgeName = rawDataOpt.source + " -- " + rawDataOpt.target;
        return createTooltipMarkup("nameValue", {
          name: edgeName,
          value: edgeValue,
          noValue: noValue(edgeValue)
        });
      } else {
        var node = this.getGraph().getNodeByIndex(dataIndex);
        var value = node.getLayout().value;
        var name_1 = this.getDataParams(dataIndex, dataType).data.name;
        return createTooltipMarkup("nameValue", {
          name: name_1 != null ? name_1 + "" : null,
          value,
          noValue: noValue(value)
        });
      }
    };
    SankeySeriesModel2.prototype.optionUpdated = function() {
    };
    SankeySeriesModel2.prototype.getDataParams = function(dataIndex, dataType) {
      var params = _super.prototype.getDataParams.call(this, dataIndex, dataType);
      if (params.value == null && dataType === "node") {
        var node = this.getGraph().getNodeByIndex(dataIndex);
        var nodeValue = node.getLayout().value;
        params.value = nodeValue;
      }
      return params;
    };
    SankeySeriesModel2.type = "series.sankey";
    SankeySeriesModel2.defaultOption = {
      z: 2,
      coordinateSystem: "view",
      left: "5%",
      top: "5%",
      right: "20%",
      bottom: "5%",
      orient: "horizontal",
      nodeWidth: 20,
      nodeGap: 8,
      draggable: true,
      layoutIterations: 32,
      label: {
        show: true,
        position: "right",
        fontSize: 12
      },
      levels: [],
      nodeAlign: "justify",
      lineStyle: {
        color: "#314656",
        opacity: 0.2,
        curveness: 0.5
      },
      emphasis: {
        label: {
          show: true
        },
        lineStyle: {
          opacity: 0.5
        }
      },
      select: {
        itemStyle: {
          borderColor: "#212121"
        }
      },
      animationEasing: "linear",
      animationDuration: 1e3
    };
    return SankeySeriesModel2;
  }(Series_default);
  var SankeySeries_default = SankeySeriesModel;

  // node_modules/echarts/lib/chart/sankey/sankeyLayout.js
  function sankeyLayout(ecModel, api) {
    ecModel.eachSeriesByType("sankey", function(seriesModel) {
      var nodeWidth = seriesModel.get("nodeWidth");
      var nodeGap = seriesModel.get("nodeGap");
      var layoutInfo = getViewRect5(seriesModel, api);
      seriesModel.layoutInfo = layoutInfo;
      var width = layoutInfo.width;
      var height = layoutInfo.height;
      var graph = seriesModel.getGraph();
      var nodes = graph.nodes;
      var edges = graph.edges;
      computeNodeValues(nodes);
      var filteredNodes = filter(nodes, function(node) {
        return node.getLayout().value === 0;
      });
      var iterations = filteredNodes.length !== 0 ? 0 : seriesModel.get("layoutIterations");
      var orient = seriesModel.get("orient");
      var nodeAlign = seriesModel.get("nodeAlign");
      layoutSankey(nodes, edges, nodeWidth, nodeGap, width, height, iterations, orient, nodeAlign);
    });
  }
  function getViewRect5(seriesModel, api) {
    return getLayoutRect(seriesModel.getBoxLayoutParams(), {
      width: api.getWidth(),
      height: api.getHeight()
    });
  }
  function layoutSankey(nodes, edges, nodeWidth, nodeGap, width, height, iterations, orient, nodeAlign) {
    computeNodeBreadths(nodes, edges, nodeWidth, width, height, orient, nodeAlign);
    computeNodeDepths(nodes, edges, height, width, nodeGap, iterations, orient);
    computeEdgeDepths(nodes, orient);
  }
  function computeNodeValues(nodes) {
    each(nodes, function(node) {
      var value1 = sum(node.outEdges, getEdgeValue);
      var value2 = sum(node.inEdges, getEdgeValue);
      var nodeRawValue = node.getValue() || 0;
      var value = Math.max(value1, value2, nodeRawValue);
      node.setLayout({
        value
      }, true);
    });
  }
  function computeNodeBreadths(nodes, edges, nodeWidth, width, height, orient, nodeAlign) {
    var remainEdges = [];
    var indegreeArr = [];
    var zeroIndegrees = [];
    var nextTargetNode = [];
    var x = 0;
    for (var i = 0; i < edges.length; i++) {
      remainEdges[i] = 1;
    }
    for (var i = 0; i < nodes.length; i++) {
      indegreeArr[i] = nodes[i].inEdges.length;
      if (indegreeArr[i] === 0) {
        zeroIndegrees.push(nodes[i]);
      }
    }
    var maxNodeDepth = -1;
    while (zeroIndegrees.length) {
      for (var idx = 0; idx < zeroIndegrees.length; idx++) {
        var node = zeroIndegrees[idx];
        var item = node.hostGraph.data.getRawDataItem(node.dataIndex);
        var isItemDepth = item.depth != null && item.depth >= 0;
        if (isItemDepth && item.depth > maxNodeDepth) {
          maxNodeDepth = item.depth;
        }
        node.setLayout({
          depth: isItemDepth ? item.depth : x
        }, true);
        orient === "vertical" ? node.setLayout({
          dy: nodeWidth
        }, true) : node.setLayout({
          dx: nodeWidth
        }, true);
        for (var edgeIdx = 0; edgeIdx < node.outEdges.length; edgeIdx++) {
          var edge = node.outEdges[edgeIdx];
          var indexEdge = edges.indexOf(edge);
          remainEdges[indexEdge] = 0;
          var targetNode = edge.node2;
          var nodeIndex = nodes.indexOf(targetNode);
          if (--indegreeArr[nodeIndex] === 0 && nextTargetNode.indexOf(targetNode) < 0) {
            nextTargetNode.push(targetNode);
          }
        }
      }
      ++x;
      zeroIndegrees = nextTargetNode;
      nextTargetNode = [];
    }
    for (var i = 0; i < remainEdges.length; i++) {
      if (remainEdges[i] === 1) {
        throw new Error("Sankey is a DAG, the original data has cycle!");
      }
    }
    var maxDepth = maxNodeDepth > x - 1 ? maxNodeDepth : x - 1;
    if (nodeAlign && nodeAlign !== "left") {
      adjustNodeWithNodeAlign(nodes, nodeAlign, orient, maxDepth);
    }
    var kx = orient === "vertical" ? (height - nodeWidth) / maxDepth : (width - nodeWidth) / maxDepth;
    scaleNodeBreadths(nodes, kx, orient);
  }
  function isNodeDepth(node) {
    var item = node.hostGraph.data.getRawDataItem(node.dataIndex);
    return item.depth != null && item.depth >= 0;
  }
  function adjustNodeWithNodeAlign(nodes, nodeAlign, orient, maxDepth) {
    if (nodeAlign === "right") {
      var nextSourceNode = [];
      var remainNodes = nodes;
      var nodeHeight = 0;
      while (remainNodes.length) {
        for (var i = 0; i < remainNodes.length; i++) {
          var node = remainNodes[i];
          node.setLayout({
            skNodeHeight: nodeHeight
          }, true);
          for (var j = 0; j < node.inEdges.length; j++) {
            var edge = node.inEdges[j];
            if (nextSourceNode.indexOf(edge.node1) < 0) {
              nextSourceNode.push(edge.node1);
            }
          }
        }
        remainNodes = nextSourceNode;
        nextSourceNode = [];
        ++nodeHeight;
      }
      each(nodes, function(node2) {
        if (!isNodeDepth(node2)) {
          node2.setLayout({
            depth: Math.max(0, maxDepth - node2.getLayout().skNodeHeight)
          }, true);
        }
      });
    } else if (nodeAlign === "justify") {
      moveSinksRight(nodes, maxDepth);
    }
  }
  function moveSinksRight(nodes, maxDepth) {
    each(nodes, function(node) {
      if (!isNodeDepth(node) && !node.outEdges.length) {
        node.setLayout({
          depth: maxDepth
        }, true);
      }
    });
  }
  function scaleNodeBreadths(nodes, kx, orient) {
    each(nodes, function(node) {
      var nodeDepth = node.getLayout().depth * kx;
      orient === "vertical" ? node.setLayout({
        y: nodeDepth
      }, true) : node.setLayout({
        x: nodeDepth
      }, true);
    });
  }
  function computeNodeDepths(nodes, edges, height, width, nodeGap, iterations, orient) {
    var nodesByBreadth = prepareNodesByBreadth(nodes, orient);
    initializeNodeDepth(nodesByBreadth, edges, height, width, nodeGap, orient);
    resolveCollisions(nodesByBreadth, nodeGap, height, width, orient);
    for (var alpha = 1; iterations > 0; iterations--) {
      alpha *= 0.99;
      relaxRightToLeft(nodesByBreadth, alpha, orient);
      resolveCollisions(nodesByBreadth, nodeGap, height, width, orient);
      relaxLeftToRight(nodesByBreadth, alpha, orient);
      resolveCollisions(nodesByBreadth, nodeGap, height, width, orient);
    }
  }
  function prepareNodesByBreadth(nodes, orient) {
    var nodesByBreadth = [];
    var keyAttr = orient === "vertical" ? "y" : "x";
    var groupResult = groupData(nodes, function(node) {
      return node.getLayout()[keyAttr];
    });
    groupResult.keys.sort(function(a, b) {
      return a - b;
    });
    each(groupResult.keys, function(key) {
      nodesByBreadth.push(groupResult.buckets.get(key));
    });
    return nodesByBreadth;
  }
  function initializeNodeDepth(nodesByBreadth, edges, height, width, nodeGap, orient) {
    var minKy = Infinity;
    each(nodesByBreadth, function(nodes) {
      var n = nodes.length;
      var sum2 = 0;
      each(nodes, function(node) {
        sum2 += node.getLayout().value;
      });
      var ky = orient === "vertical" ? (width - (n - 1) * nodeGap) / sum2 : (height - (n - 1) * nodeGap) / sum2;
      if (ky < minKy) {
        minKy = ky;
      }
    });
    each(nodesByBreadth, function(nodes) {
      each(nodes, function(node, i) {
        var nodeDy = node.getLayout().value * minKy;
        if (orient === "vertical") {
          node.setLayout({
            x: i
          }, true);
          node.setLayout({
            dx: nodeDy
          }, true);
        } else {
          node.setLayout({
            y: i
          }, true);
          node.setLayout({
            dy: nodeDy
          }, true);
        }
      });
    });
    each(edges, function(edge) {
      var edgeDy = +edge.getValue() * minKy;
      edge.setLayout({
        dy: edgeDy
      }, true);
    });
  }
  function resolveCollisions(nodesByBreadth, nodeGap, height, width, orient) {
    var keyAttr = orient === "vertical" ? "x" : "y";
    each(nodesByBreadth, function(nodes) {
      nodes.sort(function(a, b) {
        return a.getLayout()[keyAttr] - b.getLayout()[keyAttr];
      });
      var nodeX;
      var node;
      var dy;
      var y0 = 0;
      var n = nodes.length;
      var nodeDyAttr = orient === "vertical" ? "dx" : "dy";
      for (var i = 0; i < n; i++) {
        node = nodes[i];
        dy = y0 - node.getLayout()[keyAttr];
        if (dy > 0) {
          nodeX = node.getLayout()[keyAttr] + dy;
          orient === "vertical" ? node.setLayout({
            x: nodeX
          }, true) : node.setLayout({
            y: nodeX
          }, true);
        }
        y0 = node.getLayout()[keyAttr] + node.getLayout()[nodeDyAttr] + nodeGap;
      }
      var viewWidth = orient === "vertical" ? width : height;
      dy = y0 - nodeGap - viewWidth;
      if (dy > 0) {
        nodeX = node.getLayout()[keyAttr] - dy;
        orient === "vertical" ? node.setLayout({
          x: nodeX
        }, true) : node.setLayout({
          y: nodeX
        }, true);
        y0 = nodeX;
        for (var i = n - 2; i >= 0; --i) {
          node = nodes[i];
          dy = node.getLayout()[keyAttr] + node.getLayout()[nodeDyAttr] + nodeGap - y0;
          if (dy > 0) {
            nodeX = node.getLayout()[keyAttr] - dy;
            orient === "vertical" ? node.setLayout({
              x: nodeX
            }, true) : node.setLayout({
              y: nodeX
            }, true);
          }
          y0 = node.getLayout()[keyAttr];
        }
      }
    });
  }
  function relaxRightToLeft(nodesByBreadth, alpha, orient) {
    each(nodesByBreadth.slice().reverse(), function(nodes) {
      each(nodes, function(node) {
        if (node.outEdges.length) {
          var y = sum(node.outEdges, weightedTarget, orient) / sum(node.outEdges, getEdgeValue);
          if (isNaN(y)) {
            var len2 = node.outEdges.length;
            y = len2 ? sum(node.outEdges, centerTarget, orient) / len2 : 0;
          }
          if (orient === "vertical") {
            var nodeX = node.getLayout().x + (y - center2(node, orient)) * alpha;
            node.setLayout({
              x: nodeX
            }, true);
          } else {
            var nodeY = node.getLayout().y + (y - center2(node, orient)) * alpha;
            node.setLayout({
              y: nodeY
            }, true);
          }
        }
      });
    });
  }
  function weightedTarget(edge, orient) {
    return center2(edge.node2, orient) * edge.getValue();
  }
  function centerTarget(edge, orient) {
    return center2(edge.node2, orient);
  }
  function weightedSource(edge, orient) {
    return center2(edge.node1, orient) * edge.getValue();
  }
  function centerSource(edge, orient) {
    return center2(edge.node1, orient);
  }
  function center2(node, orient) {
    return orient === "vertical" ? node.getLayout().x + node.getLayout().dx / 2 : node.getLayout().y + node.getLayout().dy / 2;
  }
  function getEdgeValue(edge) {
    return edge.getValue();
  }
  function sum(array, cb, orient) {
    var sum2 = 0;
    var len2 = array.length;
    var i = -1;
    while (++i < len2) {
      var value = +cb(array[i], orient);
      if (!isNaN(value)) {
        sum2 += value;
      }
    }
    return sum2;
  }
  function relaxLeftToRight(nodesByBreadth, alpha, orient) {
    each(nodesByBreadth, function(nodes) {
      each(nodes, function(node) {
        if (node.inEdges.length) {
          var y = sum(node.inEdges, weightedSource, orient) / sum(node.inEdges, getEdgeValue);
          if (isNaN(y)) {
            var len2 = node.inEdges.length;
            y = len2 ? sum(node.inEdges, centerSource, orient) / len2 : 0;
          }
          if (orient === "vertical") {
            var nodeX = node.getLayout().x + (y - center2(node, orient)) * alpha;
            node.setLayout({
              x: nodeX
            }, true);
          } else {
            var nodeY = node.getLayout().y + (y - center2(node, orient)) * alpha;
            node.setLayout({
              y: nodeY
            }, true);
          }
        }
      });
    });
  }
  function computeEdgeDepths(nodes, orient) {
    var keyAttr = orient === "vertical" ? "x" : "y";
    each(nodes, function(node) {
      node.outEdges.sort(function(a, b) {
        return a.node2.getLayout()[keyAttr] - b.node2.getLayout()[keyAttr];
      });
      node.inEdges.sort(function(a, b) {
        return a.node1.getLayout()[keyAttr] - b.node1.getLayout()[keyAttr];
      });
    });
    each(nodes, function(node) {
      var sy = 0;
      var ty = 0;
      each(node.outEdges, function(edge) {
        edge.setLayout({
          sy
        }, true);
        sy += edge.getLayout().dy;
      });
      each(node.inEdges, function(edge) {
        edge.setLayout({
          ty
        }, true);
        ty += edge.getLayout().dy;
      });
    });
  }

  // node_modules/echarts/lib/chart/sankey/sankeyVisual.js
  function sankeyVisual(ecModel) {
    ecModel.eachSeriesByType("sankey", function(seriesModel) {
      var graph = seriesModel.getGraph();
      var nodes = graph.nodes;
      if (nodes.length) {
        var minValue_1 = Infinity;
        var maxValue_1 = -Infinity;
        each(nodes, function(node) {
          var nodeValue = node.getLayout().value;
          if (nodeValue < minValue_1) {
            minValue_1 = nodeValue;
          }
          if (nodeValue > maxValue_1) {
            maxValue_1 = nodeValue;
          }
        });
        each(nodes, function(node) {
          var mapping = new VisualMapping_default({
            type: "color",
            mappingMethod: "linear",
            dataExtent: [minValue_1, maxValue_1],
            visual: seriesModel.get("color")
          });
          var mapValueToColor = mapping.mapValueToVisual(node.getLayout().value);
          var customColor = node.getModel().get(["itemStyle", "color"]);
          if (customColor != null) {
            node.setVisual("color", customColor);
            node.setVisual("style", {
              fill: customColor
            });
          } else {
            node.setVisual("color", mapValueToColor);
            node.setVisual("style", {
              fill: mapValueToColor
            });
          }
        });
      }
    });
  }

  // node_modules/echarts/lib/chart/sankey/install.js
  function install19(registers) {
    registers.registerChartView(SankeyView_default);
    registers.registerSeriesModel(SankeySeries_default);
    registers.registerLayout(sankeyLayout);
    registers.registerVisual(sankeyVisual);
    registers.registerAction({
      type: "dragNode",
      event: "dragnode",
      update: "update"
    }, function(payload, ecModel) {
      ecModel.eachComponent({
        mainType: "series",
        subType: "sankey",
        query: payload
      }, function(seriesModel) {
        seriesModel.setNodePosition(payload.dataIndex, [payload.localX, payload.localY]);
      });
    });
  }

  // node_modules/echarts/lib/chart/helper/whiskerBoxCommon.js
  var WhiskerBoxCommonMixin = function() {
    function WhiskerBoxCommonMixin2() {
    }
    WhiskerBoxCommonMixin2.prototype.getInitialData = function(option, ecModel) {
      var ordinalMeta;
      var xAxisModel = ecModel.getComponent("xAxis", this.get("xAxisIndex"));
      var yAxisModel = ecModel.getComponent("yAxis", this.get("yAxisIndex"));
      var xAxisType = xAxisModel.get("type");
      var yAxisType = yAxisModel.get("type");
      var addOrdinal;
      if (xAxisType === "category") {
        option.layout = "horizontal";
        ordinalMeta = xAxisModel.getOrdinalMeta();
        addOrdinal = true;
      } else if (yAxisType === "category") {
        option.layout = "vertical";
        ordinalMeta = yAxisModel.getOrdinalMeta();
        addOrdinal = true;
      } else {
        option.layout = option.layout || "horizontal";
      }
      var coordDims = ["x", "y"];
      var baseAxisDimIndex = option.layout === "horizontal" ? 0 : 1;
      var baseAxisDim = this._baseAxisDim = coordDims[baseAxisDimIndex];
      var otherAxisDim = coordDims[1 - baseAxisDimIndex];
      var axisModels = [xAxisModel, yAxisModel];
      var baseAxisType = axisModels[baseAxisDimIndex].get("type");
      var otherAxisType = axisModels[1 - baseAxisDimIndex].get("type");
      var data = option.data;
      if (data && addOrdinal) {
        var newOptionData_1 = [];
        each(data, function(item, index) {
          var newItem;
          if (isArray(item)) {
            newItem = item.slice();
            item.unshift(index);
          } else if (isArray(item.value)) {
            newItem = extend({}, item);
            newItem.value = newItem.value.slice();
            item.value.unshift(index);
          } else {
            newItem = item;
          }
          newOptionData_1.push(newItem);
        });
        option.data = newOptionData_1;
      }
      var defaultValueDimensions = this.defaultValueDimensions;
      var coordDimensions = [{
        name: baseAxisDim,
        type: getDimensionTypeByAxis(baseAxisType),
        ordinalMeta,
        otherDims: {
          tooltip: false,
          itemName: 0
        },
        dimsDef: ["base"]
      }, {
        name: otherAxisDim,
        type: getDimensionTypeByAxis(otherAxisType),
        dimsDef: defaultValueDimensions.slice()
      }];
      return createSeriesDataSimply(this, {
        coordDimensions,
        dimensionsCount: defaultValueDimensions.length + 1,
        encodeDefaulter: curry(makeSeriesEncodeForAxisCoordSys, coordDimensions, this)
      });
    };
    WhiskerBoxCommonMixin2.prototype.getBaseAxis = function() {
      var dim = this._baseAxisDim;
      return this.ecModel.getComponent(dim + "Axis", this.get(dim + "AxisIndex")).axis;
    };
    return WhiskerBoxCommonMixin2;
  }();

  // node_modules/echarts/lib/chart/boxplot/BoxplotSeries.js
  var BoxplotSeriesModel = function(_super) {
    __extends(BoxplotSeriesModel2, _super);
    function BoxplotSeriesModel2() {
      var _this = _super !== null && _super.apply(this, arguments) || this;
      _this.type = BoxplotSeriesModel2.type;
      _this.defaultValueDimensions = [{
        name: "min",
        defaultTooltip: true
      }, {
        name: "Q1",
        defaultTooltip: true
      }, {
        name: "median",
        defaultTooltip: true
      }, {
        name: "Q3",
        defaultTooltip: true
      }, {
        name: "max",
        defaultTooltip: true
      }];
      _this.visualDrawType = "stroke";
      return _this;
    }
    BoxplotSeriesModel2.type = "series.boxplot";
    BoxplotSeriesModel2.dependencies = ["xAxis", "yAxis", "grid"];
    BoxplotSeriesModel2.defaultOption = {
      z: 2,
      coordinateSystem: "cartesian2d",
      legendHoverLink: true,
      layout: null,
      boxWidth: [7, 50],
      itemStyle: {
        color: "#fff",
        borderWidth: 1
      },
      emphasis: {
        scale: true,
        itemStyle: {
          borderWidth: 2,
          shadowBlur: 5,
          shadowOffsetX: 1,
          shadowOffsetY: 1,
          shadowColor: "rgba(0,0,0,0.2)"
        }
      },
      animationDuration: 800
    };
    return BoxplotSeriesModel2;
  }(Series_default);
  mixin(BoxplotSeriesModel, WhiskerBoxCommonMixin, true);
  var BoxplotSeries_default = BoxplotSeriesModel;

  // node_modules/echarts/lib/chart/boxplot/BoxplotView.js
  var BoxplotView = function(_super) {
    __extends(BoxplotView2, _super);
    function BoxplotView2() {
      var _this = _super !== null && _super.apply(this, arguments) || this;
      _this.type = BoxplotView2.type;
      return _this;
    }
    BoxplotView2.prototype.render = function(seriesModel, ecModel, api) {
      var data = seriesModel.getData();
      var group = this.group;
      var oldData = this._data;
      if (!this._data) {
        group.removeAll();
      }
      var constDim = seriesModel.get("layout") === "horizontal" ? 1 : 0;
      data.diff(oldData).add(function(newIdx) {
        if (data.hasValue(newIdx)) {
          var itemLayout = data.getItemLayout(newIdx);
          var symbolEl = createNormalBox(itemLayout, data, newIdx, constDim, true);
          data.setItemGraphicEl(newIdx, symbolEl);
          group.add(symbolEl);
        }
      }).update(function(newIdx, oldIdx) {
        var symbolEl = oldData.getItemGraphicEl(oldIdx);
        if (!data.hasValue(newIdx)) {
          group.remove(symbolEl);
          return;
        }
        var itemLayout = data.getItemLayout(newIdx);
        if (!symbolEl) {
          symbolEl = createNormalBox(itemLayout, data, newIdx, constDim);
        } else {
          saveOldStyle(symbolEl);
          updateNormalBoxData(itemLayout, symbolEl, data, newIdx);
        }
        group.add(symbolEl);
        data.setItemGraphicEl(newIdx, symbolEl);
      }).remove(function(oldIdx) {
        var el = oldData.getItemGraphicEl(oldIdx);
        el && group.remove(el);
      }).execute();
      this._data = data;
    };
    BoxplotView2.prototype.remove = function(ecModel) {
      var group = this.group;
      var data = this._data;
      this._data = null;
      data && data.eachItemGraphicEl(function(el) {
        el && group.remove(el);
      });
    };
    BoxplotView2.type = "boxplot";
    return BoxplotView2;
  }(Chart_default);
  var BoxPathShape = function() {
    function BoxPathShape2() {
    }
    return BoxPathShape2;
  }();
  var BoxPath = function(_super) {
    __extends(BoxPath2, _super);
    function BoxPath2(opts) {
      var _this = _super.call(this, opts) || this;
      _this.type = "boxplotBoxPath";
      return _this;
    }
    BoxPath2.prototype.getDefaultShape = function() {
      return new BoxPathShape();
    };
    BoxPath2.prototype.buildPath = function(ctx, shape) {
      var ends = shape.points;
      var i = 0;
      ctx.moveTo(ends[i][0], ends[i][1]);
      i++;
      for (; i < 4; i++) {
        ctx.lineTo(ends[i][0], ends[i][1]);
      }
      ctx.closePath();
      for (; i < ends.length; i++) {
        ctx.moveTo(ends[i][0], ends[i][1]);
        i++;
        ctx.lineTo(ends[i][0], ends[i][1]);
      }
    };
    return BoxPath2;
  }(Path_default);
  function createNormalBox(itemLayout, data, dataIndex, constDim, isInit) {
    var ends = itemLayout.ends;
    var el = new BoxPath({
      shape: {
        points: isInit ? transInit(ends, constDim, itemLayout) : ends
      }
    });
    updateNormalBoxData(itemLayout, el, data, dataIndex, isInit);
    return el;
  }
  function updateNormalBoxData(itemLayout, el, data, dataIndex, isInit) {
    var seriesModel = data.hostModel;
    var updateMethod = graphic_exports[isInit ? "initProps" : "updateProps"];
    updateMethod(el, {
      shape: {
        points: itemLayout.ends
      }
    }, seriesModel, dataIndex);
    el.useStyle(data.getItemVisual(dataIndex, "style"));
    el.style.strokeNoScale = true;
    el.z2 = 100;
    var itemModel = data.getItemModel(dataIndex);
    var emphasisModel = itemModel.getModel("emphasis");
    setStatesStylesFromModel(el, itemModel);
    toggleHoverEmphasis(el, emphasisModel.get("focus"), emphasisModel.get("blurScope"), emphasisModel.get("disabled"));
  }
  function transInit(points4, dim, itemLayout) {
    return map(points4, function(point) {
      point = point.slice();
      point[dim] = itemLayout.initBaseline;
      return point;
    });
  }
  var BoxplotView_default = BoxplotView;

  // node_modules/echarts/lib/chart/boxplot/boxplotVisual.js
  function boxplotVisual(ecModel, api) {
  }

  // node_modules/echarts/lib/chart/boxplot/boxplotLayout.js
  var each7 = each;
  function boxplotLayout(ecModel) {
    var groupResult = groupSeriesByAxis(ecModel);
    each7(groupResult, function(groupItem) {
      var seriesModels = groupItem.seriesModels;
      if (!seriesModels.length) {
        return;
      }
      calculateBase(groupItem);
      each7(seriesModels, function(seriesModel, idx) {
        layoutSingleSeries(seriesModel, groupItem.boxOffsetList[idx], groupItem.boxWidthList[idx]);
      });
    });
  }
  function groupSeriesByAxis(ecModel) {
    var result = [];
    var axisList = [];
    ecModel.eachSeriesByType("boxplot", function(seriesModel) {
      var baseAxis = seriesModel.getBaseAxis();
      var idx = indexOf(axisList, baseAxis);
      if (idx < 0) {
        idx = axisList.length;
        axisList[idx] = baseAxis;
        result[idx] = {
          axis: baseAxis,
          seriesModels: []
        };
      }
      result[idx].seriesModels.push(seriesModel);
    });
    return result;
  }
  function calculateBase(groupItem) {
    var baseAxis = groupItem.axis;
    var seriesModels = groupItem.seriesModels;
    var seriesCount = seriesModels.length;
    var boxWidthList = groupItem.boxWidthList = [];
    var boxOffsetList = groupItem.boxOffsetList = [];
    var boundList = [];
    var bandWidth;
    if (baseAxis.type === "category") {
      bandWidth = baseAxis.getBandWidth();
    } else {
      var maxDataCount_1 = 0;
      each7(seriesModels, function(seriesModel) {
        maxDataCount_1 = Math.max(maxDataCount_1, seriesModel.getData().count());
      });
      var extent3 = baseAxis.getExtent();
      bandWidth = Math.abs(extent3[1] - extent3[0]) / maxDataCount_1;
    }
    each7(seriesModels, function(seriesModel) {
      var boxWidthBound = seriesModel.get("boxWidth");
      if (!isArray(boxWidthBound)) {
        boxWidthBound = [boxWidthBound, boxWidthBound];
      }
      boundList.push([parsePercent2(boxWidthBound[0], bandWidth) || 0, parsePercent2(boxWidthBound[1], bandWidth) || 0]);
    });
    var availableWidth = bandWidth * 0.8 - 2;
    var boxGap = availableWidth / seriesCount * 0.3;
    var boxWidth = (availableWidth - boxGap * (seriesCount - 1)) / seriesCount;
    var base2 = boxWidth / 2 - availableWidth / 2;
    each7(seriesModels, function(seriesModel, idx) {
      boxOffsetList.push(base2);
      base2 += boxGap + boxWidth;
      boxWidthList.push(Math.min(Math.max(boxWidth, boundList[idx][0]), boundList[idx][1]));
    });
  }
  function layoutSingleSeries(seriesModel, offset, boxWidth) {
    var coordSys = seriesModel.coordinateSystem;
    var data = seriesModel.getData();
    var halfWidth = boxWidth / 2;
    var cDimIdx = seriesModel.get("layout") === "horizontal" ? 0 : 1;
    var vDimIdx = 1 - cDimIdx;
    var coordDims = ["x", "y"];
    var cDim = data.mapDimension(coordDims[cDimIdx]);
    var vDims = data.mapDimensionsAll(coordDims[vDimIdx]);
    if (cDim == null || vDims.length < 5) {
      return;
    }
    for (var dataIndex = 0; dataIndex < data.count(); dataIndex++) {
      var axisDimVal = data.get(cDim, dataIndex);
      var median = getPoint(axisDimVal, vDims[2], dataIndex);
      var end1 = getPoint(axisDimVal, vDims[0], dataIndex);
      var end2 = getPoint(axisDimVal, vDims[1], dataIndex);
      var end4 = getPoint(axisDimVal, vDims[3], dataIndex);
      var end5 = getPoint(axisDimVal, vDims[4], dataIndex);
      var ends = [];
      addBodyEnd(ends, end2, false);
      addBodyEnd(ends, end4, true);
      ends.push(end1, end2, end5, end4);
      layEndLine(ends, end1);
      layEndLine(ends, end5);
      layEndLine(ends, median);
      data.setItemLayout(dataIndex, {
        initBaseline: median[vDimIdx],
        ends
      });
    }
    function getPoint(axisDimVal2, dim, dataIndex2) {
      var val = data.get(dim, dataIndex2);
      var p = [];
      p[cDimIdx] = axisDimVal2;
      p[vDimIdx] = val;
      var point;
      if (isNaN(axisDimVal2) || isNaN(val)) {
        point = [NaN, NaN];
      } else {
        point = coordSys.dataToPoint(p);
        point[cDimIdx] += offset;
      }
      return point;
    }
    function addBodyEnd(ends2, point, start2) {
      var point1 = point.slice();
      var point2 = point.slice();
      point1[cDimIdx] += halfWidth;
      point2[cDimIdx] -= halfWidth;
      start2 ? ends2.push(point1, point2) : ends2.push(point2, point1);
    }
    function layEndLine(ends2, endCenter) {
      var from = endCenter.slice();
      var to = endCenter.slice();
      from[cDimIdx] -= halfWidth;
      to[cDimIdx] += halfWidth;
      ends2.push(from, to);
    }
  }

  // node_modules/echarts/lib/chart/boxplot/prepareBoxplotData.js
  function prepareBoxplotData(rawData, opt) {
    opt = opt || {};
    var boxData = [];
    var outliers = [];
    var boundIQR = opt.boundIQR;
    var useExtreme = boundIQR === "none" || boundIQR === 0;
    for (var i = 0; i < rawData.length; i++) {
      var ascList = asc(rawData[i].slice());
      var Q1 = quantile(ascList, 0.25);
      var Q2 = quantile(ascList, 0.5);
      var Q3 = quantile(ascList, 0.75);
      var min3 = ascList[0];
      var max3 = ascList[ascList.length - 1];
      var bound = (boundIQR == null ? 1.5 : boundIQR) * (Q3 - Q1);
      var low = useExtreme ? min3 : Math.max(min3, Q1 - bound);
      var high = useExtreme ? max3 : Math.min(max3, Q3 + bound);
      var itemNameFormatter = opt.itemNameFormatter;
      var itemName = isFunction(itemNameFormatter) ? itemNameFormatter({
        value: i
      }) : isString(itemNameFormatter) ? itemNameFormatter.replace("{value}", i + "") : i + "";
      boxData.push([itemName, low, Q1, Q2, Q3, high]);
      for (var j = 0; j < ascList.length; j++) {
        var dataItem = ascList[j];
        if (dataItem < low || dataItem > high) {
          var outlier = [itemName, dataItem];
          outliers.push(outlier);
        }
      }
    }
    return {
      boxData,
      outliers
    };
  }

  // node_modules/echarts/lib/chart/boxplot/boxplotTransform.js
  var boxplotTransform = {
    type: "echarts:boxplot",
    transform: function transform(params) {
      var upstream = params.upstream;
      if (upstream.sourceFormat !== SOURCE_FORMAT_ARRAY_ROWS) {
        var errMsg = "";
        if (true) {
          errMsg = makePrintable("source data is not applicable for this boxplot transform. Expect number[][].");
        }
        throwError(errMsg);
      }
      var result = prepareBoxplotData(upstream.getRawData(), params.config);
      return [{
        dimensions: ["ItemName", "Low", "Q1", "Q2", "Q3", "High"],
        data: result.boxData
      }, {
        data: result.outliers
      }];
    }
  };

  // node_modules/echarts/lib/chart/boxplot/install.js
  function install20(registers) {
    registers.registerSeriesModel(BoxplotSeries_default);
    registers.registerChartView(BoxplotView_default);
    registers.registerVisual(boxplotVisual);
    registers.registerLayout(boxplotLayout);
    registers.registerTransform(boxplotTransform);
  }

  // node_modules/echarts/lib/chart/candlestick/CandlestickView.js
  var SKIP_PROPS = ["color", "borderColor"];
  var CandlestickView = function(_super) {
    __extends(CandlestickView2, _super);
    function CandlestickView2() {
      var _this = _super !== null && _super.apply(this, arguments) || this;
      _this.type = CandlestickView2.type;
      return _this;
    }
    CandlestickView2.prototype.render = function(seriesModel, ecModel, api) {
      this.group.removeClipPath();
      this._progressiveEls = null;
      this._updateDrawMode(seriesModel);
      this._isLargeDraw ? this._renderLarge(seriesModel) : this._renderNormal(seriesModel);
    };
    CandlestickView2.prototype.incrementalPrepareRender = function(seriesModel, ecModel, api) {
      this._clear();
      this._updateDrawMode(seriesModel);
    };
    CandlestickView2.prototype.incrementalRender = function(params, seriesModel, ecModel, api) {
      this._progressiveEls = [];
      this._isLargeDraw ? this._incrementalRenderLarge(params, seriesModel) : this._incrementalRenderNormal(params, seriesModel);
    };
    CandlestickView2.prototype.eachRendered = function(cb) {
      traverseElements(this._progressiveEls || this.group, cb);
    };
    CandlestickView2.prototype._updateDrawMode = function(seriesModel) {
      var isLargeDraw = seriesModel.pipelineContext.large;
      if (this._isLargeDraw == null || isLargeDraw !== this._isLargeDraw) {
        this._isLargeDraw = isLargeDraw;
        this._clear();
      }
    };
    CandlestickView2.prototype._renderNormal = function(seriesModel) {
      var data = seriesModel.getData();
      var oldData = this._data;
      var group = this.group;
      var isSimpleBox = data.getLayout("isSimpleBox");
      var needsClip = seriesModel.get("clip", true);
      var coord = seriesModel.coordinateSystem;
      var clipArea = coord.getArea && coord.getArea();
      if (!this._data) {
        group.removeAll();
      }
      data.diff(oldData).add(function(newIdx) {
        if (data.hasValue(newIdx)) {
          var itemLayout = data.getItemLayout(newIdx);
          if (needsClip && isNormalBoxClipped(clipArea, itemLayout)) {
            return;
          }
          var el = createNormalBox2(itemLayout, newIdx, true);
          initProps(el, {
            shape: {
              points: itemLayout.ends
            }
          }, seriesModel, newIdx);
          setBoxCommon(el, data, newIdx, isSimpleBox);
          group.add(el);
          data.setItemGraphicEl(newIdx, el);
        }
      }).update(function(newIdx, oldIdx) {
        var el = oldData.getItemGraphicEl(oldIdx);
        if (!data.hasValue(newIdx)) {
          group.remove(el);
          return;
        }
        var itemLayout = data.getItemLayout(newIdx);
        if (needsClip && isNormalBoxClipped(clipArea, itemLayout)) {
          group.remove(el);
          return;
        }
        if (!el) {
          el = createNormalBox2(itemLayout, newIdx);
        } else {
          updateProps(el, {
            shape: {
              points: itemLayout.ends
            }
          }, seriesModel, newIdx);
          saveOldStyle(el);
        }
        setBoxCommon(el, data, newIdx, isSimpleBox);
        group.add(el);
        data.setItemGraphicEl(newIdx, el);
      }).remove(function(oldIdx) {
        var el = oldData.getItemGraphicEl(oldIdx);
        el && group.remove(el);
      }).execute();
      this._data = data;
    };
    CandlestickView2.prototype._renderLarge = function(seriesModel) {
      this._clear();
      createLarge2(seriesModel, this.group);
      var clipPath = seriesModel.get("clip", true) ? createClipPath(seriesModel.coordinateSystem, false, seriesModel) : null;
      if (clipPath) {
        this.group.setClipPath(clipPath);
      } else {
        this.group.removeClipPath();
      }
    };
    CandlestickView2.prototype._incrementalRenderNormal = function(params, seriesModel) {
      var data = seriesModel.getData();
      var isSimpleBox = data.getLayout("isSimpleBox");
      var dataIndex;
      while ((dataIndex = params.next()) != null) {
        var itemLayout = data.getItemLayout(dataIndex);
        var el = createNormalBox2(itemLayout, dataIndex);
        setBoxCommon(el, data, dataIndex, isSimpleBox);
        el.incremental = true;
        this.group.add(el);
        this._progressiveEls.push(el);
      }
    };
    CandlestickView2.prototype._incrementalRenderLarge = function(params, seriesModel) {
      createLarge2(seriesModel, this.group, this._progressiveEls, true);
    };
    CandlestickView2.prototype.remove = function(ecModel) {
      this._clear();
    };
    CandlestickView2.prototype._clear = function() {
      this.group.removeAll();
      this._data = null;
    };
    CandlestickView2.type = "candlestick";
    return CandlestickView2;
  }(Chart_default);
  var NormalBoxPathShape = function() {
    function NormalBoxPathShape2() {
    }
    return NormalBoxPathShape2;
  }();
  var NormalBoxPath = function(_super) {
    __extends(NormalBoxPath2, _super);
    function NormalBoxPath2(opts) {
      var _this = _super.call(this, opts) || this;
      _this.type = "normalCandlestickBox";
      return _this;
    }
    NormalBoxPath2.prototype.getDefaultShape = function() {
      return new NormalBoxPathShape();
    };
    NormalBoxPath2.prototype.buildPath = function(ctx, shape) {
      var ends = shape.points;
      if (this.__simpleBox) {
        ctx.moveTo(ends[4][0], ends[4][1]);
        ctx.lineTo(ends[6][0], ends[6][1]);
      } else {
        ctx.moveTo(ends[0][0], ends[0][1]);
        ctx.lineTo(ends[1][0], ends[1][1]);
        ctx.lineTo(ends[2][0], ends[2][1]);
        ctx.lineTo(ends[3][0], ends[3][1]);
        ctx.closePath();
        ctx.moveTo(ends[4][0], ends[4][1]);
        ctx.lineTo(ends[5][0], ends[5][1]);
        ctx.moveTo(ends[6][0], ends[6][1]);
        ctx.lineTo(ends[7][0], ends[7][1]);
      }
    };
    return NormalBoxPath2;
  }(Path_default);
  function createNormalBox2(itemLayout, dataIndex, isInit) {
    var ends = itemLayout.ends;
    return new NormalBoxPath({
      shape: {
        points: isInit ? transInit2(ends, itemLayout) : ends
      },
      z2: 100
    });
  }
  function isNormalBoxClipped(clipArea, itemLayout) {
    var clipped = true;
    for (var i = 0; i < itemLayout.ends.length; i++) {
      if (clipArea.contain(itemLayout.ends[i][0], itemLayout.ends[i][1])) {
        clipped = false;
        break;
      }
    }
    return clipped;
  }
  function setBoxCommon(el, data, dataIndex, isSimpleBox) {
    var itemModel = data.getItemModel(dataIndex);
    el.useStyle(data.getItemVisual(dataIndex, "style"));
    el.style.strokeNoScale = true;
    el.__simpleBox = isSimpleBox;
    setStatesStylesFromModel(el, itemModel);
  }
  function transInit2(points4, itemLayout) {
    return map(points4, function(point) {
      point = point.slice();
      point[1] = itemLayout.initBaseline;
      return point;
    });
  }
  var LargeBoxPathShape = function() {
    function LargeBoxPathShape2() {
    }
    return LargeBoxPathShape2;
  }();
  var LargeBoxPath = function(_super) {
    __extends(LargeBoxPath2, _super);
    function LargeBoxPath2(opts) {
      var _this = _super.call(this, opts) || this;
      _this.type = "largeCandlestickBox";
      return _this;
    }
    LargeBoxPath2.prototype.getDefaultShape = function() {
      return new LargeBoxPathShape();
    };
    LargeBoxPath2.prototype.buildPath = function(ctx, shape) {
      var points4 = shape.points;
      for (var i = 0; i < points4.length; ) {
        if (this.__sign === points4[i++]) {
          var x = points4[i++];
          ctx.moveTo(x, points4[i++]);
          ctx.lineTo(x, points4[i++]);
        } else {
          i += 3;
        }
      }
    };
    return LargeBoxPath2;
  }(Path_default);
  function createLarge2(seriesModel, group, progressiveEls, incremental) {
    var data = seriesModel.getData();
    var largePoints = data.getLayout("largePoints");
    var elP = new LargeBoxPath({
      shape: {
        points: largePoints
      },
      __sign: 1
    });
    group.add(elP);
    var elN = new LargeBoxPath({
      shape: {
        points: largePoints
      },
      __sign: -1
    });
    group.add(elN);
    setLargeStyle(1, elP, seriesModel, data);
    setLargeStyle(-1, elN, seriesModel, data);
    if (incremental) {
      elP.incremental = true;
      elN.incremental = true;
    }
    if (progressiveEls) {
      progressiveEls.push(elP, elN);
    }
  }
  function setLargeStyle(sign, el, seriesModel, data) {
    var borderColor = seriesModel.get(["itemStyle", sign > 0 ? "borderColor" : "borderColor0"]) || seriesModel.get(["itemStyle", sign > 0 ? "color" : "color0"]);
    var itemStyle = seriesModel.getModel("itemStyle").getItemStyle(SKIP_PROPS);
    el.useStyle(itemStyle);
    el.style.fill = null;
    el.style.stroke = borderColor;
  }
  var CandlestickView_default = CandlestickView;

  // node_modules/echarts/lib/chart/candlestick/CandlestickSeries.js
  var CandlestickSeriesModel = function(_super) {
    __extends(CandlestickSeriesModel2, _super);
    function CandlestickSeriesModel2() {
      var _this = _super !== null && _super.apply(this, arguments) || this;
      _this.type = CandlestickSeriesModel2.type;
      _this.defaultValueDimensions = [{
        name: "open",
        defaultTooltip: true
      }, {
        name: "close",
        defaultTooltip: true
      }, {
        name: "lowest",
        defaultTooltip: true
      }, {
        name: "highest",
        defaultTooltip: true
      }];
      return _this;
    }
    CandlestickSeriesModel2.prototype.getShadowDim = function() {
      return "open";
    };
    CandlestickSeriesModel2.prototype.brushSelector = function(dataIndex, data, selectors) {
      var itemLayout = data.getItemLayout(dataIndex);
      return itemLayout && selectors.rect(itemLayout.brushRect);
    };
    CandlestickSeriesModel2.type = "series.candlestick";
    CandlestickSeriesModel2.dependencies = ["xAxis", "yAxis", "grid"];
    CandlestickSeriesModel2.defaultOption = {
      z: 2,
      coordinateSystem: "cartesian2d",
      legendHoverLink: true,
      layout: null,
      clip: true,
      itemStyle: {
        color: "#eb5454",
        color0: "#47b262",
        borderColor: "#eb5454",
        borderColor0: "#47b262",
        borderWidth: 1
      },
      emphasis: {
        scale: true,
        itemStyle: {
          borderWidth: 2
        }
      },
      barMaxWidth: null,
      barMinWidth: null,
      barWidth: null,
      large: true,
      largeThreshold: 600,
      progressive: 3e3,
      progressiveThreshold: 1e4,
      progressiveChunkMode: "mod",
      animationEasing: "linear",
      animationDuration: 300
    };
    return CandlestickSeriesModel2;
  }(Series_default);
  mixin(CandlestickSeriesModel, WhiskerBoxCommonMixin, true);
  var CandlestickSeries_default = CandlestickSeriesModel;

  // node_modules/echarts/lib/chart/candlestick/preprocessor.js
  function candlestickPreprocessor(option) {
    if (!option || !isArray(option.series)) {
      return;
    }
    each(option.series, function(seriesItem) {
      if (isObject(seriesItem) && seriesItem.type === "k") {
        seriesItem.type = "candlestick";
      }
    });
  }

  // node_modules/echarts/lib/chart/candlestick/candlestickVisual.js
  var positiveBorderColorQuery = ["itemStyle", "borderColor"];
  var negativeBorderColorQuery = ["itemStyle", "borderColor0"];
  var positiveColorQuery = ["itemStyle", "color"];
  var negativeColorQuery = ["itemStyle", "color0"];
  var candlestickVisual = {
    seriesType: "candlestick",
    plan: createRenderPlanner(),
    performRawSeries: true,
    reset: function(seriesModel, ecModel) {
      function getColor(sign, model) {
        return model.get(sign > 0 ? positiveColorQuery : negativeColorQuery);
      }
      function getBorderColor(sign, model) {
        return model.get(sign > 0 ? positiveBorderColorQuery : negativeBorderColorQuery);
      }
      if (ecModel.isSeriesFiltered(seriesModel)) {
        return;
      }
      var isLargeRender = seriesModel.pipelineContext.large;
      return !isLargeRender && {
        progress: function(params, data) {
          var dataIndex;
          while ((dataIndex = params.next()) != null) {
            var itemModel = data.getItemModel(dataIndex);
            var sign = data.getItemLayout(dataIndex).sign;
            var style = itemModel.getItemStyle();
            style.fill = getColor(sign, itemModel);
            style.stroke = getBorderColor(sign, itemModel) || style.fill;
            var existsStyle = data.ensureUniqueItemVisual(dataIndex, "style");
            extend(existsStyle, style);
          }
        }
      };
    }
  };
  var candlestickVisual_default = candlestickVisual;

  // node_modules/echarts/lib/chart/candlestick/candlestickLayout.js
  var candlestickLayout = {
    seriesType: "candlestick",
    plan: createRenderPlanner(),
    reset: function(seriesModel) {
      var coordSys = seriesModel.coordinateSystem;
      var data = seriesModel.getData();
      var candleWidth = calculateCandleWidth(seriesModel, data);
      var cDimIdx = 0;
      var vDimIdx = 1;
      var coordDims = ["x", "y"];
      var cDimI = data.getDimensionIndex(data.mapDimension(coordDims[cDimIdx]));
      var vDimsI = map(data.mapDimensionsAll(coordDims[vDimIdx]), data.getDimensionIndex, data);
      var openDimI = vDimsI[0];
      var closeDimI = vDimsI[1];
      var lowestDimI = vDimsI[2];
      var highestDimI = vDimsI[3];
      data.setLayout({
        candleWidth,
        isSimpleBox: candleWidth <= 1.3
      });
      if (cDimI < 0 || vDimsI.length < 4) {
        return;
      }
      return {
        progress: seriesModel.pipelineContext.large ? largeProgress : normalProgress
      };
      function normalProgress(params, data2) {
        var dataIndex;
        var store = data2.getStore();
        while ((dataIndex = params.next()) != null) {
          var axisDimVal = store.get(cDimI, dataIndex);
          var openVal = store.get(openDimI, dataIndex);
          var closeVal = store.get(closeDimI, dataIndex);
          var lowestVal = store.get(lowestDimI, dataIndex);
          var highestVal = store.get(highestDimI, dataIndex);
          var ocLow = Math.min(openVal, closeVal);
          var ocHigh = Math.max(openVal, closeVal);
          var ocLowPoint = getPoint(ocLow, axisDimVal);
          var ocHighPoint = getPoint(ocHigh, axisDimVal);
          var lowestPoint = getPoint(lowestVal, axisDimVal);
          var highestPoint = getPoint(highestVal, axisDimVal);
          var ends = [];
          addBodyEnd(ends, ocHighPoint, 0);
          addBodyEnd(ends, ocLowPoint, 1);
          ends.push(subPixelOptimizePoint(highestPoint), subPixelOptimizePoint(ocHighPoint), subPixelOptimizePoint(lowestPoint), subPixelOptimizePoint(ocLowPoint));
          data2.setItemLayout(dataIndex, {
            sign: getSign(store, dataIndex, openVal, closeVal, closeDimI),
            initBaseline: openVal > closeVal ? ocHighPoint[vDimIdx] : ocLowPoint[vDimIdx],
            ends,
            brushRect: makeBrushRect(lowestVal, highestVal, axisDimVal)
          });
        }
        function getPoint(val, axisDimVal2) {
          var p = [];
          p[cDimIdx] = axisDimVal2;
          p[vDimIdx] = val;
          return isNaN(axisDimVal2) || isNaN(val) ? [NaN, NaN] : coordSys.dataToPoint(p);
        }
        function addBodyEnd(ends2, point, start2) {
          var point1 = point.slice();
          var point2 = point.slice();
          point1[cDimIdx] = subPixelOptimize2(point1[cDimIdx] + candleWidth / 2, 1, false);
          point2[cDimIdx] = subPixelOptimize2(point2[cDimIdx] - candleWidth / 2, 1, true);
          start2 ? ends2.push(point1, point2) : ends2.push(point2, point1);
        }
        function makeBrushRect(lowestVal2, highestVal2, axisDimVal2) {
          var pmin = getPoint(lowestVal2, axisDimVal2);
          var pmax = getPoint(highestVal2, axisDimVal2);
          pmin[cDimIdx] -= candleWidth / 2;
          pmax[cDimIdx] -= candleWidth / 2;
          return {
            x: pmin[0],
            y: pmin[1],
            width: vDimIdx ? candleWidth : pmax[0] - pmin[0],
            height: vDimIdx ? pmax[1] - pmin[1] : candleWidth
          };
        }
        function subPixelOptimizePoint(point) {
          point[cDimIdx] = subPixelOptimize2(point[cDimIdx], 1);
          return point;
        }
      }
      function largeProgress(params, data2) {
        var points4 = createFloat32Array(params.count * 4);
        var offset = 0;
        var point;
        var tmpIn = [];
        var tmpOut = [];
        var dataIndex;
        var store = data2.getStore();
        while ((dataIndex = params.next()) != null) {
          var axisDimVal = store.get(cDimI, dataIndex);
          var openVal = store.get(openDimI, dataIndex);
          var closeVal = store.get(closeDimI, dataIndex);
          var lowestVal = store.get(lowestDimI, dataIndex);
          var highestVal = store.get(highestDimI, dataIndex);
          if (isNaN(axisDimVal) || isNaN(lowestVal) || isNaN(highestVal)) {
            points4[offset++] = NaN;
            offset += 3;
            continue;
          }
          points4[offset++] = getSign(store, dataIndex, openVal, closeVal, closeDimI);
          tmpIn[cDimIdx] = axisDimVal;
          tmpIn[vDimIdx] = lowestVal;
          point = coordSys.dataToPoint(tmpIn, null, tmpOut);
          points4[offset++] = point ? point[0] : NaN;
          points4[offset++] = point ? point[1] : NaN;
          tmpIn[vDimIdx] = highestVal;
          point = coordSys.dataToPoint(tmpIn, null, tmpOut);
          points4[offset++] = point ? point[1] : NaN;
        }
        data2.setLayout("largePoints", points4);
      }
    }
  };
  function getSign(store, dataIndex, openVal, closeVal, closeDimI) {
    var sign;
    if (openVal > closeVal) {
      sign = -1;
    } else if (openVal < closeVal) {
      sign = 1;
    } else {
      sign = dataIndex > 0 ? store.get(closeDimI, dataIndex - 1) <= closeVal ? 1 : -1 : 1;
    }
    return sign;
  }
  function calculateCandleWidth(seriesModel, data) {
    var baseAxis = seriesModel.getBaseAxis();
    var extent3;
    var bandWidth = baseAxis.type === "category" ? baseAxis.getBandWidth() : (extent3 = baseAxis.getExtent(), Math.abs(extent3[1] - extent3[0]) / data.count());
    var barMaxWidth = parsePercent2(retrieve2(seriesModel.get("barMaxWidth"), bandWidth), bandWidth);
    var barMinWidth = parsePercent2(retrieve2(seriesModel.get("barMinWidth"), 1), bandWidth);
    var barWidth = seriesModel.get("barWidth");
    return barWidth != null ? parsePercent2(barWidth, bandWidth) : Math.max(Math.min(bandWidth / 2, barMaxWidth), barMinWidth);
  }
  var candlestickLayout_default = candlestickLayout;

  // node_modules/echarts/lib/chart/candlestick/install.js
  function install21(registers) {
    registers.registerChartView(CandlestickView_default);
    registers.registerSeriesModel(CandlestickSeries_default);
    registers.registerPreprocessor(candlestickPreprocessor);
    registers.registerVisual(candlestickVisual_default);
    registers.registerLayout(candlestickLayout_default);
  }

  // node_modules/echarts/lib/chart/helper/EffectSymbol.js
  function updateRipplePath(rippleGroup, effectCfg) {
    var color = effectCfg.rippleEffectColor || effectCfg.color;
    rippleGroup.eachChild(function(ripplePath) {
      ripplePath.attr({
        z: effectCfg.z,
        zlevel: effectCfg.zlevel,
        style: {
          stroke: effectCfg.brushType === "stroke" ? color : null,
          fill: effectCfg.brushType === "fill" ? color : null
        }
      });
    });
  }
  var EffectSymbol = function(_super) {
    __extends(EffectSymbol2, _super);
    function EffectSymbol2(data, idx) {
      var _this = _super.call(this) || this;
      var symbol = new Symbol_default(data, idx);
      var rippleGroup = new Group_default();
      _this.add(symbol);
      _this.add(rippleGroup);
      _this.updateData(data, idx);
      return _this;
    }
    EffectSymbol2.prototype.stopEffectAnimation = function() {
      this.childAt(1).removeAll();
    };
    EffectSymbol2.prototype.startEffectAnimation = function(effectCfg) {
      var symbolType = effectCfg.symbolType;
      var color = effectCfg.color;
      var rippleNumber = effectCfg.rippleNumber;
      var rippleGroup = this.childAt(1);
      for (var i = 0; i < rippleNumber; i++) {
        var ripplePath = createSymbol(symbolType, -1, -1, 2, 2, color);
        ripplePath.attr({
          style: {
            strokeNoScale: true
          },
          z2: 99,
          silent: true,
          scaleX: 0.5,
          scaleY: 0.5
        });
        var delay = -i / rippleNumber * effectCfg.period + effectCfg.effectOffset;
        ripplePath.animate("", true).when(effectCfg.period, {
          scaleX: effectCfg.rippleScale / 2,
          scaleY: effectCfg.rippleScale / 2
        }).delay(delay).start();
        ripplePath.animateStyle(true).when(effectCfg.period, {
          opacity: 0
        }).delay(delay).start();
        rippleGroup.add(ripplePath);
      }
      updateRipplePath(rippleGroup, effectCfg);
    };
    EffectSymbol2.prototype.updateEffectAnimation = function(effectCfg) {
      var oldEffectCfg = this._effectCfg;
      var rippleGroup = this.childAt(1);
      var DIFFICULT_PROPS = ["symbolType", "period", "rippleScale", "rippleNumber"];
      for (var i = 0; i < DIFFICULT_PROPS.length; i++) {
        var propName = DIFFICULT_PROPS[i];
        if (oldEffectCfg[propName] !== effectCfg[propName]) {
          this.stopEffectAnimation();
          this.startEffectAnimation(effectCfg);
          return;
        }
      }
      updateRipplePath(rippleGroup, effectCfg);
    };
    EffectSymbol2.prototype.highlight = function() {
      enterEmphasis(this);
    };
    EffectSymbol2.prototype.downplay = function() {
      leaveEmphasis(this);
    };
    EffectSymbol2.prototype.getSymbolType = function() {
      var symbol = this.childAt(0);
      return symbol && symbol.getSymbolType();
    };
    EffectSymbol2.prototype.updateData = function(data, idx) {
      var _this = this;
      var seriesModel = data.hostModel;
      this.childAt(0).updateData(data, idx);
      var rippleGroup = this.childAt(1);
      var itemModel = data.getItemModel(idx);
      var symbolType = data.getItemVisual(idx, "symbol");
      var symbolSize = normalizeSymbolSize(data.getItemVisual(idx, "symbolSize"));
      var symbolStyle = data.getItemVisual(idx, "style");
      var color = symbolStyle && symbolStyle.fill;
      var emphasisModel = itemModel.getModel("emphasis");
      rippleGroup.setScale(symbolSize);
      rippleGroup.traverse(function(ripplePath) {
        ripplePath.setStyle("fill", color);
      });
      var symbolOffset = normalizeSymbolOffset(data.getItemVisual(idx, "symbolOffset"), symbolSize);
      if (symbolOffset) {
        rippleGroup.x = symbolOffset[0];
        rippleGroup.y = symbolOffset[1];
      }
      var symbolRotate = data.getItemVisual(idx, "symbolRotate");
      rippleGroup.rotation = (symbolRotate || 0) * Math.PI / 180 || 0;
      var effectCfg = {};
      effectCfg.showEffectOn = seriesModel.get("showEffectOn");
      effectCfg.rippleScale = itemModel.get(["rippleEffect", "scale"]);
      effectCfg.brushType = itemModel.get(["rippleEffect", "brushType"]);
      effectCfg.period = itemModel.get(["rippleEffect", "period"]) * 1e3;
      effectCfg.effectOffset = idx / data.count();
      effectCfg.z = seriesModel.getShallow("z") || 0;
      effectCfg.zlevel = seriesModel.getShallow("zlevel") || 0;
      effectCfg.symbolType = symbolType;
      effectCfg.color = color;
      effectCfg.rippleEffectColor = itemModel.get(["rippleEffect", "color"]);
      effectCfg.rippleNumber = itemModel.get(["rippleEffect", "number"]);
      if (effectCfg.showEffectOn === "render") {
        this._effectCfg ? this.updateEffectAnimation(effectCfg) : this.startEffectAnimation(effectCfg);
        this._effectCfg = effectCfg;
      } else {
        this._effectCfg = null;
        this.stopEffectAnimation();
        this.onHoverStateChange = function(toState) {
          if (toState === "emphasis") {
            if (effectCfg.showEffectOn !== "render") {
              _this.startEffectAnimation(effectCfg);
            }
          } else if (toState === "normal") {
            if (effectCfg.showEffectOn !== "render") {
              _this.stopEffectAnimation();
            }
          }
        };
      }
      this._effectCfg = effectCfg;
      toggleHoverEmphasis(this, emphasisModel.get("focus"), emphasisModel.get("blurScope"), emphasisModel.get("disabled"));
    };
    ;
    EffectSymbol2.prototype.fadeOut = function(cb) {
      cb && cb();
    };
    ;
    return EffectSymbol2;
  }(Group_default);
  var EffectSymbol_default = EffectSymbol;

  // node_modules/echarts/lib/chart/effectScatter/EffectScatterView.js
  var EffectScatterView = function(_super) {
    __extends(EffectScatterView2, _super);
    function EffectScatterView2() {
      var _this = _super !== null && _super.apply(this, arguments) || this;
      _this.type = EffectScatterView2.type;
      return _this;
    }
    EffectScatterView2.prototype.init = function() {
      this._symbolDraw = new SymbolDraw_default(EffectSymbol_default);
    };
    EffectScatterView2.prototype.render = function(seriesModel, ecModel, api) {
      var data = seriesModel.getData();
      var effectSymbolDraw = this._symbolDraw;
      effectSymbolDraw.updateData(data, {
        clipShape: this._getClipShape(seriesModel)
      });
      this.group.add(effectSymbolDraw.group);
    };
    EffectScatterView2.prototype._getClipShape = function(seriesModel) {
      var coordSys = seriesModel.coordinateSystem;
      var clipArea = coordSys && coordSys.getArea && coordSys.getArea();
      return seriesModel.get("clip", true) ? clipArea : null;
    };
    EffectScatterView2.prototype.updateTransform = function(seriesModel, ecModel, api) {
      var data = seriesModel.getData();
      this.group.dirty();
      var res = pointsLayout("").reset(seriesModel, ecModel, api);
      if (res.progress) {
        res.progress({
          start: 0,
          end: data.count(),
          count: data.count()
        }, data);
      }
      this._symbolDraw.updateLayout();
    };
    EffectScatterView2.prototype._updateGroupTransform = function(seriesModel) {
      var coordSys = seriesModel.coordinateSystem;
      if (coordSys && coordSys.getRoamTransform) {
        this.group.transform = clone3(coordSys.getRoamTransform());
        this.group.decomposeTransform();
      }
    };
    EffectScatterView2.prototype.remove = function(ecModel, api) {
      this._symbolDraw && this._symbolDraw.remove(true);
    };
    EffectScatterView2.type = "effectScatter";
    return EffectScatterView2;
  }(Chart_default);
  var EffectScatterView_default = EffectScatterView;

  // node_modules/echarts/lib/chart/effectScatter/EffectScatterSeries.js
  var EffectScatterSeriesModel = function(_super) {
    __extends(EffectScatterSeriesModel2, _super);
    function EffectScatterSeriesModel2() {
      var _this = _super !== null && _super.apply(this, arguments) || this;
      _this.type = EffectScatterSeriesModel2.type;
      _this.hasSymbolVisual = true;
      return _this;
    }
    EffectScatterSeriesModel2.prototype.getInitialData = function(option, ecModel) {
      return createSeriesData_default(null, this, {
        useEncodeDefaulter: true
      });
    };
    EffectScatterSeriesModel2.prototype.brushSelector = function(dataIndex, data, selectors) {
      return selectors.point(data.getItemLayout(dataIndex));
    };
    EffectScatterSeriesModel2.type = "series.effectScatter";
    EffectScatterSeriesModel2.dependencies = ["grid", "polar"];
    EffectScatterSeriesModel2.defaultOption = {
      coordinateSystem: "cartesian2d",
      z: 2,
      legendHoverLink: true,
      effectType: "ripple",
      progressive: 0,
      showEffectOn: "render",
      clip: true,
      rippleEffect: {
        period: 4,
        scale: 2.5,
        brushType: "fill",
        number: 3
      },
      universalTransition: {
        divideShape: "clone"
      },
      symbolSize: 10
    };
    return EffectScatterSeriesModel2;
  }(Series_default);
  var EffectScatterSeries_default = EffectScatterSeriesModel;

  // node_modules/echarts/lib/chart/effectScatter/install.js
  function install22(registers) {
    registers.registerChartView(EffectScatterView_default);
    registers.registerSeriesModel(EffectScatterSeries_default);
    registers.registerLayout(pointsLayout("effectScatter"));
  }

  // node_modules/echarts/lib/chart/helper/EffectLine.js
  var EffectLine = function(_super) {
    __extends(EffectLine2, _super);
    function EffectLine2(lineData, idx, seriesScope) {
      var _this = _super.call(this) || this;
      _this.add(_this.createLine(lineData, idx, seriesScope));
      _this._updateEffectSymbol(lineData, idx);
      return _this;
    }
    EffectLine2.prototype.createLine = function(lineData, idx, seriesScope) {
      return new Line_default2(lineData, idx, seriesScope);
    };
    EffectLine2.prototype._updateEffectSymbol = function(lineData, idx) {
      var itemModel = lineData.getItemModel(idx);
      var effectModel = itemModel.getModel("effect");
      var size = effectModel.get("symbolSize");
      var symbolType = effectModel.get("symbol");
      if (!isArray(size)) {
        size = [size, size];
      }
      var lineStyle = lineData.getItemVisual(idx, "style");
      var color = effectModel.get("color") || lineStyle && lineStyle.stroke;
      var symbol = this.childAt(1);
      if (this._symbolType !== symbolType) {
        this.remove(symbol);
        symbol = createSymbol(symbolType, -0.5, -0.5, 1, 1, color);
        symbol.z2 = 100;
        symbol.culling = true;
        this.add(symbol);
      }
      if (!symbol) {
        return;
      }
      symbol.setStyle("shadowColor", color);
      symbol.setStyle(effectModel.getItemStyle(["color"]));
      symbol.scaleX = size[0];
      symbol.scaleY = size[1];
      symbol.setColor(color);
      this._symbolType = symbolType;
      this._symbolScale = size;
      this._updateEffectAnimation(lineData, effectModel, idx);
    };
    EffectLine2.prototype._updateEffectAnimation = function(lineData, effectModel, idx) {
      var symbol = this.childAt(1);
      if (!symbol) {
        return;
      }
      var points4 = lineData.getItemLayout(idx);
      var period = effectModel.get("period") * 1e3;
      var loop = effectModel.get("loop");
      var constantSpeed = effectModel.get("constantSpeed");
      var delayExpr = retrieve(effectModel.get("delay"), function(idx2) {
        return idx2 / lineData.count() * period / 3;
      });
      symbol.ignore = true;
      this._updateAnimationPoints(symbol, points4);
      if (constantSpeed > 0) {
        period = this._getLineLength(symbol) / constantSpeed * 1e3;
      }
      if (period !== this._period || loop !== this._loop) {
        symbol.stopAnimation();
        var delayNum = void 0;
        if (isFunction(delayExpr)) {
          delayNum = delayExpr(idx);
        } else {
          delayNum = delayExpr;
        }
        if (symbol.__t > 0) {
          delayNum = -period * symbol.__t;
        }
        this._animateSymbol(symbol, period, delayNum, loop);
      }
      this._period = period;
      this._loop = loop;
    };
    EffectLine2.prototype._animateSymbol = function(symbol, period, delayNum, loop) {
      if (period > 0) {
        symbol.__t = 0;
        var self_1 = this;
        var animator = symbol.animate("", loop).when(period, {
          __t: 1
        }).delay(delayNum).during(function() {
          self_1._updateSymbolPosition(symbol);
        });
        if (!loop) {
          animator.done(function() {
            self_1.remove(symbol);
          });
        }
        animator.start();
      }
    };
    EffectLine2.prototype._getLineLength = function(symbol) {
      return dist(symbol.__p1, symbol.__cp1) + dist(symbol.__cp1, symbol.__p2);
    };
    EffectLine2.prototype._updateAnimationPoints = function(symbol, points4) {
      symbol.__p1 = points4[0];
      symbol.__p2 = points4[1];
      symbol.__cp1 = points4[2] || [(points4[0][0] + points4[1][0]) / 2, (points4[0][1] + points4[1][1]) / 2];
    };
    EffectLine2.prototype.updateData = function(lineData, idx, seriesScope) {
      this.childAt(0).updateData(lineData, idx, seriesScope);
      this._updateEffectSymbol(lineData, idx);
    };
    EffectLine2.prototype._updateSymbolPosition = function(symbol) {
      var p1 = symbol.__p1;
      var p2 = symbol.__p2;
      var cp1 = symbol.__cp1;
      var t = symbol.__t;
      var pos = [symbol.x, symbol.y];
      var lastPos = pos.slice();
      var quadraticAt3 = quadraticAt;
      var quadraticDerivativeAt2 = quadraticDerivativeAt;
      pos[0] = quadraticAt3(p1[0], cp1[0], p2[0], t);
      pos[1] = quadraticAt3(p1[1], cp1[1], p2[1], t);
      var tx = quadraticDerivativeAt2(p1[0], cp1[0], p2[0], t);
      var ty = quadraticDerivativeAt2(p1[1], cp1[1], p2[1], t);
      symbol.rotation = -Math.atan2(ty, tx) - Math.PI / 2;
      if (this._symbolType === "line" || this._symbolType === "rect" || this._symbolType === "roundRect") {
        if (symbol.__lastT !== void 0 && symbol.__lastT < symbol.__t) {
          symbol.scaleY = dist(lastPos, pos) * 1.05;
          if (t === 1) {
            pos[0] = lastPos[0] + (pos[0] - lastPos[0]) / 2;
            pos[1] = lastPos[1] + (pos[1] - lastPos[1]) / 2;
          }
        } else if (symbol.__lastT === 1) {
          symbol.scaleY = 2 * dist(p1, pos);
        } else {
          symbol.scaleY = this._symbolScale[1];
        }
      }
      symbol.__lastT = symbol.__t;
      symbol.ignore = false;
      symbol.x = pos[0];
      symbol.y = pos[1];
    };
    EffectLine2.prototype.updateLayout = function(lineData, idx) {
      this.childAt(0).updateLayout(lineData, idx);
      var effectModel = lineData.getItemModel(idx).getModel("effect");
      this._updateEffectAnimation(lineData, effectModel, idx);
    };
    return EffectLine2;
  }(Group_default);
  var EffectLine_default = EffectLine;

  // node_modules/echarts/lib/chart/helper/Polyline.js
  var Polyline2 = function(_super) {
    __extends(Polyline3, _super);
    function Polyline3(lineData, idx, seriesScope) {
      var _this = _super.call(this) || this;
      _this._createPolyline(lineData, idx, seriesScope);
      return _this;
    }
    Polyline3.prototype._createPolyline = function(lineData, idx, seriesScope) {
      var points4 = lineData.getItemLayout(idx);
      var line = new Polyline_default({
        shape: {
          points: points4
        }
      });
      this.add(line);
      this._updateCommonStl(lineData, idx, seriesScope);
    };
    ;
    Polyline3.prototype.updateData = function(lineData, idx, seriesScope) {
      var seriesModel = lineData.hostModel;
      var line = this.childAt(0);
      var target = {
        shape: {
          points: lineData.getItemLayout(idx)
        }
      };
      updateProps(line, target, seriesModel, idx);
      this._updateCommonStl(lineData, idx, seriesScope);
    };
    ;
    Polyline3.prototype._updateCommonStl = function(lineData, idx, seriesScope) {
      var line = this.childAt(0);
      var itemModel = lineData.getItemModel(idx);
      var emphasisLineStyle = seriesScope && seriesScope.emphasisLineStyle;
      var focus = seriesScope && seriesScope.focus;
      var blurScope = seriesScope && seriesScope.blurScope;
      var emphasisDisabled = seriesScope && seriesScope.emphasisDisabled;
      if (!seriesScope || lineData.hasItemOption) {
        var emphasisModel = itemModel.getModel("emphasis");
        emphasisLineStyle = emphasisModel.getModel("lineStyle").getLineStyle();
        emphasisDisabled = emphasisModel.get("disabled");
        focus = emphasisModel.get("focus");
        blurScope = emphasisModel.get("blurScope");
      }
      line.useStyle(lineData.getItemVisual(idx, "style"));
      line.style.fill = null;
      line.style.strokeNoScale = true;
      var lineEmphasisState = line.ensureState("emphasis");
      lineEmphasisState.style = emphasisLineStyle;
      toggleHoverEmphasis(this, focus, blurScope, emphasisDisabled);
    };
    ;
    Polyline3.prototype.updateLayout = function(lineData, idx) {
      var polyline = this.childAt(0);
      polyline.setShape("points", lineData.getItemLayout(idx));
    };
    ;
    return Polyline3;
  }(Group_default);
  var Polyline_default2 = Polyline2;

  // node_modules/echarts/lib/chart/helper/EffectPolyline.js
  var EffectPolyline = function(_super) {
    __extends(EffectPolyline2, _super);
    function EffectPolyline2() {
      var _this = _super !== null && _super.apply(this, arguments) || this;
      _this._lastFrame = 0;
      _this._lastFramePercent = 0;
      return _this;
    }
    EffectPolyline2.prototype.createLine = function(lineData, idx, seriesScope) {
      return new Polyline_default2(lineData, idx, seriesScope);
    };
    ;
    EffectPolyline2.prototype._updateAnimationPoints = function(symbol, points4) {
      this._points = points4;
      var accLenArr = [0];
      var len2 = 0;
      for (var i = 1; i < points4.length; i++) {
        var p1 = points4[i - 1];
        var p2 = points4[i];
        len2 += dist(p1, p2);
        accLenArr.push(len2);
      }
      if (len2 === 0) {
        this._length = 0;
        return;
      }
      for (var i = 0; i < accLenArr.length; i++) {
        accLenArr[i] /= len2;
      }
      this._offsets = accLenArr;
      this._length = len2;
    };
    ;
    EffectPolyline2.prototype._getLineLength = function() {
      return this._length;
    };
    ;
    EffectPolyline2.prototype._updateSymbolPosition = function(symbol) {
      var t = symbol.__t;
      var points4 = this._points;
      var offsets = this._offsets;
      var len2 = points4.length;
      if (!offsets) {
        return;
      }
      var lastFrame = this._lastFrame;
      var frame;
      if (t < this._lastFramePercent) {
        var start2 = Math.min(lastFrame + 1, len2 - 1);
        for (frame = start2; frame >= 0; frame--) {
          if (offsets[frame] <= t) {
            break;
          }
        }
        frame = Math.min(frame, len2 - 2);
      } else {
        for (frame = lastFrame; frame < len2; frame++) {
          if (offsets[frame] > t) {
            break;
          }
        }
        frame = Math.min(frame - 1, len2 - 2);
      }
      var p = (t - offsets[frame]) / (offsets[frame + 1] - offsets[frame]);
      var p0 = points4[frame];
      var p1 = points4[frame + 1];
      symbol.x = p0[0] * (1 - p) + p * p1[0];
      symbol.y = p0[1] * (1 - p) + p * p1[1];
      var tx = p1[0] - p0[0];
      var ty = p1[1] - p0[1];
      symbol.rotation = -Math.atan2(ty, tx) - Math.PI / 2;
      this._lastFrame = frame;
      this._lastFramePercent = t;
      symbol.ignore = false;
    };
    ;
    return EffectPolyline2;
  }(EffectLine_default);
  var EffectPolyline_default = EffectPolyline;

  // node_modules/echarts/lib/chart/helper/LargeLineDraw.js
  var LargeLinesPathShape = function() {
    function LargeLinesPathShape2() {
      this.polyline = false;
      this.curveness = 0;
      this.segs = [];
    }
    return LargeLinesPathShape2;
  }();
  var LargeLinesPath = function(_super) {
    __extends(LargeLinesPath2, _super);
    function LargeLinesPath2(opts) {
      var _this = _super.call(this, opts) || this;
      _this._off = 0;
      _this.hoverDataIdx = -1;
      return _this;
    }
    LargeLinesPath2.prototype.reset = function() {
      this.notClear = false;
      this._off = 0;
    };
    LargeLinesPath2.prototype.getDefaultStyle = function() {
      return {
        stroke: "#000",
        fill: null
      };
    };
    LargeLinesPath2.prototype.getDefaultShape = function() {
      return new LargeLinesPathShape();
    };
    LargeLinesPath2.prototype.buildPath = function(ctx, shape) {
      var segs = shape.segs;
      var curveness = shape.curveness;
      var i;
      if (shape.polyline) {
        for (i = this._off; i < segs.length; ) {
          var count2 = segs[i++];
          if (count2 > 0) {
            ctx.moveTo(segs[i++], segs[i++]);
            for (var k = 1; k < count2; k++) {
              ctx.lineTo(segs[i++], segs[i++]);
            }
          }
        }
      } else {
        for (i = this._off; i < segs.length; ) {
          var x0 = segs[i++];
          var y0 = segs[i++];
          var x1 = segs[i++];
          var y1 = segs[i++];
          ctx.moveTo(x0, y0);
          if (curveness > 0) {
            var x2 = (x0 + x1) / 2 - (y0 - y1) * curveness;
            var y2 = (y0 + y1) / 2 - (x1 - x0) * curveness;
            ctx.quadraticCurveTo(x2, y2, x1, y1);
          } else {
            ctx.lineTo(x1, y1);
          }
        }
      }
      if (this.incremental) {
        this._off = i;
        this.notClear = true;
      }
    };
    LargeLinesPath2.prototype.findDataIndex = function(x, y) {
      var shape = this.shape;
      var segs = shape.segs;
      var curveness = shape.curveness;
      var lineWidth = this.style.lineWidth;
      if (shape.polyline) {
        var dataIndex = 0;
        for (var i = 0; i < segs.length; ) {
          var count2 = segs[i++];
          if (count2 > 0) {
            var x0 = segs[i++];
            var y0 = segs[i++];
            for (var k = 1; k < count2; k++) {
              var x1 = segs[i++];
              var y1 = segs[i++];
              if (containStroke(x0, y0, x1, y1, lineWidth, x, y)) {
                return dataIndex;
              }
            }
          }
          dataIndex++;
        }
      } else {
        var dataIndex = 0;
        for (var i = 0; i < segs.length; ) {
          var x0 = segs[i++];
          var y0 = segs[i++];
          var x1 = segs[i++];
          var y1 = segs[i++];
          if (curveness > 0) {
            var x2 = (x0 + x1) / 2 - (y0 - y1) * curveness;
            var y2 = (y0 + y1) / 2 - (x1 - x0) * curveness;
            if (containStroke3(x0, y0, x2, y2, x1, y1, lineWidth, x, y)) {
              return dataIndex;
            }
          } else {
            if (containStroke(x0, y0, x1, y1, lineWidth, x, y)) {
              return dataIndex;
            }
          }
          dataIndex++;
        }
      }
      return -1;
    };
    LargeLinesPath2.prototype.contain = function(x, y) {
      var localPos = this.transformCoordToLocal(x, y);
      var rect = this.getBoundingRect();
      x = localPos[0];
      y = localPos[1];
      if (rect.contain(x, y)) {
        var dataIdx = this.hoverDataIdx = this.findDataIndex(x, y);
        return dataIdx >= 0;
      }
      this.hoverDataIdx = -1;
      return false;
    };
    LargeLinesPath2.prototype.getBoundingRect = function() {
      var rect = this._rect;
      if (!rect) {
        var shape = this.shape;
        var points4 = shape.segs;
        var minX = Infinity;
        var minY = Infinity;
        var maxX = -Infinity;
        var maxY = -Infinity;
        for (var i = 0; i < points4.length; ) {
          var x = points4[i++];
          var y = points4[i++];
          minX = Math.min(x, minX);
          maxX = Math.max(x, maxX);
          minY = Math.min(y, minY);
          maxY = Math.max(y, maxY);
        }
        rect = this._rect = new BoundingRect_default(minX, minY, maxX, maxY);
      }
      return rect;
    };
    return LargeLinesPath2;
  }(Path_default);
  var LargeLineDraw = function() {
    function LargeLineDraw2() {
      this.group = new Group_default();
    }
    LargeLineDraw2.prototype.updateData = function(data) {
      this._clear();
      var lineEl = this._create();
      lineEl.setShape({
        segs: data.getLayout("linesPoints")
      });
      this._setCommon(lineEl, data);
    };
    ;
    LargeLineDraw2.prototype.incrementalPrepareUpdate = function(data) {
      this.group.removeAll();
      this._clear();
    };
    ;
    LargeLineDraw2.prototype.incrementalUpdate = function(taskParams, data) {
      var lastAdded = this._newAdded[0];
      var linePoints = data.getLayout("linesPoints");
      var oldSegs = lastAdded && lastAdded.shape.segs;
      if (oldSegs && oldSegs.length < 2e4) {
        var oldLen = oldSegs.length;
        var newSegs = new Float32Array(oldLen + linePoints.length);
        newSegs.set(oldSegs);
        newSegs.set(linePoints, oldLen);
        lastAdded.setShape({
          segs: newSegs
        });
      } else {
        this._newAdded = [];
        var lineEl = this._create();
        lineEl.incremental = true;
        lineEl.setShape({
          segs: linePoints
        });
        this._setCommon(lineEl, data);
        lineEl.__startIndex = taskParams.start;
      }
    };
    LargeLineDraw2.prototype.remove = function() {
      this._clear();
    };
    LargeLineDraw2.prototype.eachRendered = function(cb) {
      this._newAdded[0] && cb(this._newAdded[0]);
    };
    LargeLineDraw2.prototype._create = function() {
      var lineEl = new LargeLinesPath({
        cursor: "default"
      });
      this._newAdded.push(lineEl);
      this.group.add(lineEl);
      return lineEl;
    };
    LargeLineDraw2.prototype._setCommon = function(lineEl, data, isIncremental) {
      var hostModel = data.hostModel;
      lineEl.setShape({
        polyline: hostModel.get("polyline"),
        curveness: hostModel.get(["lineStyle", "curveness"])
      });
      lineEl.useStyle(hostModel.getModel("lineStyle").getLineStyle());
      lineEl.style.strokeNoScale = true;
      var style = data.getVisual("style");
      if (style && style.stroke) {
        lineEl.setStyle("stroke", style.stroke);
      }
      lineEl.setStyle("fill", null);
      var ecData = getECData(lineEl);
      ecData.seriesIndex = hostModel.seriesIndex;
      lineEl.on("mousemove", function(e2) {
        ecData.dataIndex = null;
        var dataIndex = lineEl.hoverDataIdx;
        if (dataIndex > 0) {
          ecData.dataIndex = dataIndex + lineEl.__startIndex;
        }
      });
    };
    ;
    LargeLineDraw2.prototype._clear = function() {
      this._newAdded = [];
      this.group.removeAll();
    };
    ;
    return LargeLineDraw2;
  }();
  var LargeLineDraw_default = LargeLineDraw;

  // node_modules/echarts/lib/chart/lines/linesLayout.js
  var linesLayout = {
    seriesType: "lines",
    plan: createRenderPlanner(),
    reset: function(seriesModel) {
      var coordSys = seriesModel.coordinateSystem;
      if (!coordSys) {
        if (true) {
          error("The lines series must have a coordinate system.");
        }
        return;
      }
      var isPolyline = seriesModel.get("polyline");
      var isLarge = seriesModel.pipelineContext.large;
      return {
        progress: function(params, lineData) {
          var lineCoords = [];
          if (isLarge) {
            var points4 = void 0;
            var segCount = params.end - params.start;
            if (isPolyline) {
              var totalCoordsCount = 0;
              for (var i = params.start; i < params.end; i++) {
                totalCoordsCount += seriesModel.getLineCoordsCount(i);
              }
              points4 = new Float32Array(segCount + totalCoordsCount * 2);
            } else {
              points4 = new Float32Array(segCount * 4);
            }
            var offset = 0;
            var pt = [];
            for (var i = params.start; i < params.end; i++) {
              var len2 = seriesModel.getLineCoords(i, lineCoords);
              if (isPolyline) {
                points4[offset++] = len2;
              }
              for (var k = 0; k < len2; k++) {
                pt = coordSys.dataToPoint(lineCoords[k], false, pt);
                points4[offset++] = pt[0];
                points4[offset++] = pt[1];
              }
            }
            lineData.setLayout("linesPoints", points4);
          } else {
            for (var i = params.start; i < params.end; i++) {
              var itemModel = lineData.getItemModel(i);
              var len2 = seriesModel.getLineCoords(i, lineCoords);
              var pts = [];
              if (isPolyline) {
                for (var j = 0; j < len2; j++) {
                  pts.push(coordSys.dataToPoint(lineCoords[j]));
                }
              } else {
                pts[0] = coordSys.dataToPoint(lineCoords[0]);
                pts[1] = coordSys.dataToPoint(lineCoords[1]);
                var curveness = itemModel.get(["lineStyle", "curveness"]);
                if (+curveness) {
                  pts[2] = [(pts[0][0] + pts[1][0]) / 2 - (pts[0][1] - pts[1][1]) * curveness, (pts[0][1] + pts[1][1]) / 2 - (pts[1][0] - pts[0][0]) * curveness];
                }
              }
              lineData.setItemLayout(i, pts);
            }
          }
        }
      };
    }
  };
  var linesLayout_default = linesLayout;

  // node_modules/echarts/lib/chart/lines/LinesView.js
  var LinesView = function(_super) {
    __extends(LinesView2, _super);
    function LinesView2() {
      var _this = _super !== null && _super.apply(this, arguments) || this;
      _this.type = LinesView2.type;
      return _this;
    }
    LinesView2.prototype.render = function(seriesModel, ecModel, api) {
      var data = seriesModel.getData();
      var lineDraw = this._updateLineDraw(data, seriesModel);
      var zlevel = seriesModel.get("zlevel");
      var trailLength = seriesModel.get(["effect", "trailLength"]);
      var zr = api.getZr();
      var isSvg = zr.painter.getType() === "svg";
      if (!isSvg) {
        zr.painter.getLayer(zlevel).clear(true);
      }
      if (this._lastZlevel != null && !isSvg) {
        zr.configLayer(this._lastZlevel, {
          motionBlur: false
        });
      }
      if (this._showEffect(seriesModel) && trailLength > 0) {
        if (!isSvg) {
          zr.configLayer(zlevel, {
            motionBlur: true,
            lastFrameAlpha: Math.max(Math.min(trailLength / 10 + 0.9, 1), 0)
          });
        } else if (true) {
          console.warn("SVG render mode doesn't support lines with trail effect");
        }
      }
      lineDraw.updateData(data);
      var clipPath = seriesModel.get("clip", true) && createClipPath(seriesModel.coordinateSystem, false, seriesModel);
      if (clipPath) {
        this.group.setClipPath(clipPath);
      } else {
        this.group.removeClipPath();
      }
      this._lastZlevel = zlevel;
      this._finished = true;
    };
    LinesView2.prototype.incrementalPrepareRender = function(seriesModel, ecModel, api) {
      var data = seriesModel.getData();
      var lineDraw = this._updateLineDraw(data, seriesModel);
      lineDraw.incrementalPrepareUpdate(data);
      this._clearLayer(api);
      this._finished = false;
    };
    LinesView2.prototype.incrementalRender = function(taskParams, seriesModel, ecModel) {
      this._lineDraw.incrementalUpdate(taskParams, seriesModel.getData());
      this._finished = taskParams.end === seriesModel.getData().count();
    };
    LinesView2.prototype.eachRendered = function(cb) {
      this._lineDraw && this._lineDraw.eachRendered(cb);
    };
    LinesView2.prototype.updateTransform = function(seriesModel, ecModel, api) {
      var data = seriesModel.getData();
      var pipelineContext = seriesModel.pipelineContext;
      if (!this._finished || pipelineContext.large || pipelineContext.progressiveRender) {
        return {
          update: true
        };
      } else {
        var res = linesLayout_default.reset(seriesModel, ecModel, api);
        if (res.progress) {
          res.progress({
            start: 0,
            end: data.count(),
            count: data.count()
          }, data);
        }
        this._lineDraw.updateLayout();
        this._clearLayer(api);
      }
    };
    LinesView2.prototype._updateLineDraw = function(data, seriesModel) {
      var lineDraw = this._lineDraw;
      var hasEffect = this._showEffect(seriesModel);
      var isPolyline = !!seriesModel.get("polyline");
      var pipelineContext = seriesModel.pipelineContext;
      var isLargeDraw = pipelineContext.large;
      if (true) {
        if (hasEffect && isLargeDraw) {
          console.warn("Large lines not support effect");
        }
      }
      if (!lineDraw || hasEffect !== this._hasEffet || isPolyline !== this._isPolyline || isLargeDraw !== this._isLargeDraw) {
        if (lineDraw) {
          lineDraw.remove();
        }
        lineDraw = this._lineDraw = isLargeDraw ? new LargeLineDraw_default() : new LineDraw_default(isPolyline ? hasEffect ? EffectPolyline_default : Polyline_default2 : hasEffect ? EffectLine_default : Line_default2);
        this._hasEffet = hasEffect;
        this._isPolyline = isPolyline;
        this._isLargeDraw = isLargeDraw;
      }
      this.group.add(lineDraw.group);
      return lineDraw;
    };
    LinesView2.prototype._showEffect = function(seriesModel) {
      return !!seriesModel.get(["effect", "show"]);
    };
    LinesView2.prototype._clearLayer = function(api) {
      var zr = api.getZr();
      var isSvg = zr.painter.getType() === "svg";
      if (!isSvg && this._lastZlevel != null) {
        zr.painter.getLayer(this._lastZlevel).clear(true);
      }
    };
    LinesView2.prototype.remove = function(ecModel, api) {
      this._lineDraw && this._lineDraw.remove();
      this._lineDraw = null;
      this._clearLayer(api);
    };
    LinesView2.prototype.dispose = function(ecModel, api) {
      this.remove(ecModel, api);
    };
    LinesView2.type = "lines";
    return LinesView2;
  }(Chart_default);
  var LinesView_default = LinesView;

  // node_modules/echarts/lib/chart/lines/LinesSeries.js
  var Uint32Arr = typeof Uint32Array === "undefined" ? Array : Uint32Array;
  var Float64Arr = typeof Float64Array === "undefined" ? Array : Float64Array;
  function compatEc2(seriesOpt) {
    var data = seriesOpt.data;
    if (data && data[0] && data[0][0] && data[0][0].coord) {
      if (true) {
        console.warn("Lines data configuration has been changed to { coords:[[1,2],[2,3]] }");
      }
      seriesOpt.data = map(data, function(itemOpt) {
        var coords = [itemOpt[0].coord, itemOpt[1].coord];
        var target = {
          coords
        };
        if (itemOpt[0].name) {
          target.fromName = itemOpt[0].name;
        }
        if (itemOpt[1].name) {
          target.toName = itemOpt[1].name;
        }
        return mergeAll([target, itemOpt[0], itemOpt[1]]);
      });
    }
  }
  var LinesSeriesModel = function(_super) {
    __extends(LinesSeriesModel2, _super);
    function LinesSeriesModel2() {
      var _this = _super !== null && _super.apply(this, arguments) || this;
      _this.type = LinesSeriesModel2.type;
      _this.visualStyleAccessPath = "lineStyle";
      _this.visualDrawType = "stroke";
      return _this;
    }
    LinesSeriesModel2.prototype.init = function(option) {
      option.data = option.data || [];
      compatEc2(option);
      var result = this._processFlatCoordsArray(option.data);
      this._flatCoords = result.flatCoords;
      this._flatCoordsOffset = result.flatCoordsOffset;
      if (result.flatCoords) {
        option.data = new Float32Array(result.count);
      }
      _super.prototype.init.apply(this, arguments);
    };
    LinesSeriesModel2.prototype.mergeOption = function(option) {
      compatEc2(option);
      if (option.data) {
        var result = this._processFlatCoordsArray(option.data);
        this._flatCoords = result.flatCoords;
        this._flatCoordsOffset = result.flatCoordsOffset;
        if (result.flatCoords) {
          option.data = new Float32Array(result.count);
        }
      }
      _super.prototype.mergeOption.apply(this, arguments);
    };
    LinesSeriesModel2.prototype.appendData = function(params) {
      var result = this._processFlatCoordsArray(params.data);
      if (result.flatCoords) {
        if (!this._flatCoords) {
          this._flatCoords = result.flatCoords;
          this._flatCoordsOffset = result.flatCoordsOffset;
        } else {
          this._flatCoords = concatArray(this._flatCoords, result.flatCoords);
          this._flatCoordsOffset = concatArray(this._flatCoordsOffset, result.flatCoordsOffset);
        }
        params.data = new Float32Array(result.count);
      }
      this.getRawData().appendData(params.data);
    };
    LinesSeriesModel2.prototype._getCoordsFromItemModel = function(idx) {
      var itemModel = this.getData().getItemModel(idx);
      var coords = itemModel.option instanceof Array ? itemModel.option : itemModel.getShallow("coords");
      if (true) {
        if (!(coords instanceof Array && coords.length > 0 && coords[0] instanceof Array)) {
          throw new Error("Invalid coords " + JSON.stringify(coords) + ". Lines must have 2d coords array in data item.");
        }
      }
      return coords;
    };
    LinesSeriesModel2.prototype.getLineCoordsCount = function(idx) {
      if (this._flatCoordsOffset) {
        return this._flatCoordsOffset[idx * 2 + 1];
      } else {
        return this._getCoordsFromItemModel(idx).length;
      }
    };
    LinesSeriesModel2.prototype.getLineCoords = function(idx, out2) {
      if (this._flatCoordsOffset) {
        var offset = this._flatCoordsOffset[idx * 2];
        var len2 = this._flatCoordsOffset[idx * 2 + 1];
        for (var i = 0; i < len2; i++) {
          out2[i] = out2[i] || [];
          out2[i][0] = this._flatCoords[offset + i * 2];
          out2[i][1] = this._flatCoords[offset + i * 2 + 1];
        }
        return len2;
      } else {
        var coords = this._getCoordsFromItemModel(idx);
        for (var i = 0; i < coords.length; i++) {
          out2[i] = out2[i] || [];
          out2[i][0] = coords[i][0];
          out2[i][1] = coords[i][1];
        }
        return coords.length;
      }
    };
    LinesSeriesModel2.prototype._processFlatCoordsArray = function(data) {
      var startOffset = 0;
      if (this._flatCoords) {
        startOffset = this._flatCoords.length;
      }
      if (isNumber(data[0])) {
        var len2 = data.length;
        var coordsOffsetAndLenStorage = new Uint32Arr(len2);
        var coordsStorage = new Float64Arr(len2);
        var coordsCursor = 0;
        var offsetCursor = 0;
        var dataCount = 0;
        for (var i = 0; i < len2; ) {
          dataCount++;
          var count2 = data[i++];
          coordsOffsetAndLenStorage[offsetCursor++] = coordsCursor + startOffset;
          coordsOffsetAndLenStorage[offsetCursor++] = count2;
          for (var k = 0; k < count2; k++) {
            var x = data[i++];
            var y = data[i++];
            coordsStorage[coordsCursor++] = x;
            coordsStorage[coordsCursor++] = y;
            if (i > len2) {
              if (true) {
                throw new Error("Invalid data format.");
              }
            }
          }
        }
        return {
          flatCoordsOffset: new Uint32Array(coordsOffsetAndLenStorage.buffer, 0, offsetCursor),
          flatCoords: coordsStorage,
          count: dataCount
        };
      }
      return {
        flatCoordsOffset: null,
        flatCoords: null,
        count: data.length
      };
    };
    LinesSeriesModel2.prototype.getInitialData = function(option, ecModel) {
      if (true) {
        var CoordSys = CoordinateSystem_default.get(option.coordinateSystem);
        if (!CoordSys) {
          throw new Error("Unkown coordinate system " + option.coordinateSystem);
        }
      }
      var lineData = new SeriesData_default(["value"], this);
      lineData.hasItemOption = false;
      lineData.initData(option.data, [], function(dataItem, dimName, dataIndex, dimIndex) {
        if (dataItem instanceof Array) {
          return NaN;
        } else {
          lineData.hasItemOption = true;
          var value = dataItem.value;
          if (value != null) {
            return value instanceof Array ? value[dimIndex] : value;
          }
        }
      });
      return lineData;
    };
    LinesSeriesModel2.prototype.formatTooltip = function(dataIndex, multipleSeries, dataType) {
      var data = this.getData();
      var itemModel = data.getItemModel(dataIndex);
      var name = itemModel.get("name");
      if (name) {
        return name;
      }
      var fromName = itemModel.get("fromName");
      var toName = itemModel.get("toName");
      var nameArr = [];
      fromName != null && nameArr.push(fromName);
      toName != null && nameArr.push(toName);
      return createTooltipMarkup("nameValue", {
        name: nameArr.join(" > ")
      });
    };
    LinesSeriesModel2.prototype.preventIncremental = function() {
      return !!this.get(["effect", "show"]);
    };
    LinesSeriesModel2.prototype.getProgressive = function() {
      var progressive = this.option.progressive;
      if (progressive == null) {
        return this.option.large ? 1e4 : this.get("progressive");
      }
      return progressive;
    };
    LinesSeriesModel2.prototype.getProgressiveThreshold = function() {
      var progressiveThreshold = this.option.progressiveThreshold;
      if (progressiveThreshold == null) {
        return this.option.large ? 2e4 : this.get("progressiveThreshold");
      }
      return progressiveThreshold;
    };
    LinesSeriesModel2.prototype.getZLevelKey = function() {
      var effectModel = this.getModel("effect");
      var trailLength = effectModel.get("trailLength");
      return this.getData().count() > this.getProgressiveThreshold() ? this.id : effectModel.get("show") && trailLength > 0 ? trailLength + "" : "";
    };
    LinesSeriesModel2.type = "series.lines";
    LinesSeriesModel2.dependencies = ["grid", "polar", "geo", "calendar"];
    LinesSeriesModel2.defaultOption = {
      coordinateSystem: "geo",
      z: 2,
      legendHoverLink: true,
      xAxisIndex: 0,
      yAxisIndex: 0,
      symbol: ["none", "none"],
      symbolSize: [10, 10],
      geoIndex: 0,
      effect: {
        show: false,
        period: 4,
        constantSpeed: 0,
        symbol: "circle",
        symbolSize: 3,
        loop: true,
        trailLength: 0.2
      },
      large: false,
      largeThreshold: 2e3,
      polyline: false,
      clip: true,
      label: {
        show: false,
        position: "end"
      },
      lineStyle: {
        opacity: 0.5
      }
    };
    return LinesSeriesModel2;
  }(Series_default);
  var LinesSeries_default = LinesSeriesModel;

  // node_modules/echarts/lib/chart/lines/linesVisual.js
  function normalize4(a) {
    if (!(a instanceof Array)) {
      a = [a, a];
    }
    return a;
  }
  var linesVisual = {
    seriesType: "lines",
    reset: function(seriesModel) {
      var symbolType = normalize4(seriesModel.get("symbol"));
      var symbolSize = normalize4(seriesModel.get("symbolSize"));
      var data = seriesModel.getData();
      data.setVisual("fromSymbol", symbolType && symbolType[0]);
      data.setVisual("toSymbol", symbolType && symbolType[1]);
      data.setVisual("fromSymbolSize", symbolSize && symbolSize[0]);
      data.setVisual("toSymbolSize", symbolSize && symbolSize[1]);
      function dataEach(data2, idx) {
        var itemModel = data2.getItemModel(idx);
        var symbolType2 = normalize4(itemModel.getShallow("symbol", true));
        var symbolSize2 = normalize4(itemModel.getShallow("symbolSize", true));
        symbolType2[0] && data2.setItemVisual(idx, "fromSymbol", symbolType2[0]);
        symbolType2[1] && data2.setItemVisual(idx, "toSymbol", symbolType2[1]);
        symbolSize2[0] && data2.setItemVisual(idx, "fromSymbolSize", symbolSize2[0]);
        symbolSize2[1] && data2.setItemVisual(idx, "toSymbolSize", symbolSize2[1]);
      }
      return {
        dataEach: data.hasItemOption ? dataEach : null
      };
    }
  };
  var linesVisual_default = linesVisual;

  // node_modules/echarts/lib/chart/lines/install.js
  function install23(registers) {
    registers.registerChartView(LinesView_default);
    registers.registerSeriesModel(LinesSeries_default);
    registers.registerLayout(linesLayout_default);
    registers.registerVisual(linesVisual_default);
  }

  // node_modules/echarts/lib/chart/heatmap/HeatmapLayer.js
  var GRADIENT_LEVELS = 256;
  var HeatmapLayer = function() {
    function HeatmapLayer2() {
      this.blurSize = 30;
      this.pointSize = 20;
      this.maxOpacity = 1;
      this.minOpacity = 0;
      this._gradientPixels = {
        inRange: null,
        outOfRange: null
      };
      var canvas = platformApi.createCanvas();
      this.canvas = canvas;
    }
    HeatmapLayer2.prototype.update = function(data, width, height, normalize5, colorFunc, isInRange) {
      var brush3 = this._getBrush();
      var gradientInRange = this._getGradient(colorFunc, "inRange");
      var gradientOutOfRange = this._getGradient(colorFunc, "outOfRange");
      var r = this.pointSize + this.blurSize;
      var canvas = this.canvas;
      var ctx = canvas.getContext("2d");
      var len2 = data.length;
      canvas.width = width;
      canvas.height = height;
      for (var i = 0; i < len2; ++i) {
        var p = data[i];
        var x = p[0];
        var y = p[1];
        var value = p[2];
        var alpha = normalize5(value);
        ctx.globalAlpha = alpha;
        ctx.drawImage(brush3, x - r, y - r);
      }
      if (!canvas.width || !canvas.height) {
        return canvas;
      }
      var imageData = ctx.getImageData(0, 0, canvas.width, canvas.height);
      var pixels = imageData.data;
      var offset = 0;
      var pixelLen = pixels.length;
      var minOpacity = this.minOpacity;
      var maxOpacity = this.maxOpacity;
      var diffOpacity = maxOpacity - minOpacity;
      while (offset < pixelLen) {
        var alpha = pixels[offset + 3] / 256;
        var gradientOffset = Math.floor(alpha * (GRADIENT_LEVELS - 1)) * 4;
        if (alpha > 0) {
          var gradient = isInRange(alpha) ? gradientInRange : gradientOutOfRange;
          alpha > 0 && (alpha = alpha * diffOpacity + minOpacity);
          pixels[offset++] = gradient[gradientOffset];
          pixels[offset++] = gradient[gradientOffset + 1];
          pixels[offset++] = gradient[gradientOffset + 2];
          pixels[offset++] = gradient[gradientOffset + 3] * alpha * 256;
        } else {
          offset += 4;
        }
      }
      ctx.putImageData(imageData, 0, 0);
      return canvas;
    };
    HeatmapLayer2.prototype._getBrush = function() {
      var brushCanvas = this._brushCanvas || (this._brushCanvas = platformApi.createCanvas());
      var r = this.pointSize + this.blurSize;
      var d = r * 2;
      brushCanvas.width = d;
      brushCanvas.height = d;
      var ctx = brushCanvas.getContext("2d");
      ctx.clearRect(0, 0, d, d);
      ctx.shadowOffsetX = d;
      ctx.shadowBlur = this.blurSize;
      ctx.shadowColor = "#000";
      ctx.beginPath();
      ctx.arc(-r, r, this.pointSize, 0, Math.PI * 2, true);
      ctx.closePath();
      ctx.fill();
      return brushCanvas;
    };
    HeatmapLayer2.prototype._getGradient = function(colorFunc, state) {
      var gradientPixels = this._gradientPixels;
      var pixelsSingleState = gradientPixels[state] || (gradientPixels[state] = new Uint8ClampedArray(256 * 4));
      var color = [0, 0, 0, 0];
      var off = 0;
      for (var i = 0; i < 256; i++) {
        colorFunc[state](i / 255, true, color);
        pixelsSingleState[off++] = color[0];
        pixelsSingleState[off++] = color[1];
        pixelsSingleState[off++] = color[2];
        pixelsSingleState[off++] = color[3];
      }
      return pixelsSingleState;
    };
    return HeatmapLayer2;
  }();
  var HeatmapLayer_default = HeatmapLayer;

  // node_modules/echarts/lib/chart/heatmap/HeatmapView.js
  function getIsInPiecewiseRange(dataExtent, pieceList, selected) {
    var dataSpan = dataExtent[1] - dataExtent[0];
    pieceList = map(pieceList, function(piece) {
      return {
        interval: [(piece.interval[0] - dataExtent[0]) / dataSpan, (piece.interval[1] - dataExtent[0]) / dataSpan]
      };
    });
    var len2 = pieceList.length;
    var lastIndex = 0;
    return function(val) {
      var i;
      for (i = lastIndex; i < len2; i++) {
        var interval = pieceList[i].interval;
        if (interval[0] <= val && val <= interval[1]) {
          lastIndex = i;
          break;
        }
      }
      if (i === len2) {
        for (i = lastIndex - 1; i >= 0; i--) {
          var interval = pieceList[i].interval;
          if (interval[0] <= val && val <= interval[1]) {
            lastIndex = i;
            break;
          }
        }
      }
      return i >= 0 && i < len2 && selected[i];
    };
  }
  function getIsInContinuousRange(dataExtent, range) {
    var dataSpan = dataExtent[1] - dataExtent[0];
    range = [(range[0] - dataExtent[0]) / dataSpan, (range[1] - dataExtent[0]) / dataSpan];
    return function(val) {
      return val >= range[0] && val <= range[1];
    };
  }
  function isGeoCoordSys(coordSys) {
    var dimensions = coordSys.dimensions;
    return dimensions[0] === "lng" && dimensions[1] === "lat";
  }
  var HeatmapView = function(_super) {
    __extends(HeatmapView2, _super);
    function HeatmapView2() {
      var _this = _super !== null && _super.apply(this, arguments) || this;
      _this.type = HeatmapView2.type;
      return _this;
    }
    HeatmapView2.prototype.render = function(seriesModel, ecModel, api) {
      var visualMapOfThisSeries;
      ecModel.eachComponent("visualMap", function(visualMap) {
        visualMap.eachTargetSeries(function(targetSeries) {
          if (targetSeries === seriesModel) {
            visualMapOfThisSeries = visualMap;
          }
        });
      });
      if (true) {
        if (!visualMapOfThisSeries) {
          throw new Error("Heatmap must use with visualMap");
        }
      }
      this._progressiveEls = null;
      this.group.removeAll();
      var coordSys = seriesModel.coordinateSystem;
      if (coordSys.type === "cartesian2d" || coordSys.type === "calendar") {
        this._renderOnCartesianAndCalendar(seriesModel, api, 0, seriesModel.getData().count());
      } else if (isGeoCoordSys(coordSys)) {
        this._renderOnGeo(coordSys, seriesModel, visualMapOfThisSeries, api);
      }
    };
    HeatmapView2.prototype.incrementalPrepareRender = function(seriesModel, ecModel, api) {
      this.group.removeAll();
    };
    HeatmapView2.prototype.incrementalRender = function(params, seriesModel, ecModel, api) {
      var coordSys = seriesModel.coordinateSystem;
      if (coordSys) {
        if (isGeoCoordSys(coordSys)) {
          this.render(seriesModel, ecModel, api);
        } else {
          this._progressiveEls = [];
          this._renderOnCartesianAndCalendar(seriesModel, api, params.start, params.end, true);
        }
      }
    };
    HeatmapView2.prototype.eachRendered = function(cb) {
      traverseElements(this._progressiveEls || this.group, cb);
    };
    HeatmapView2.prototype._renderOnCartesianAndCalendar = function(seriesModel, api, start2, end2, incremental) {
      var coordSys = seriesModel.coordinateSystem;
      var isCartesian2d = isCoordinateSystemType(coordSys, "cartesian2d");
      var width;
      var height;
      var xAxisExtent;
      var yAxisExtent;
      if (isCartesian2d) {
        var xAxis = coordSys.getAxis("x");
        var yAxis = coordSys.getAxis("y");
        if (true) {
          if (!(xAxis.type === "category" && yAxis.type === "category")) {
            throw new Error("Heatmap on cartesian must have two category axes");
          }
          if (!(xAxis.onBand && yAxis.onBand)) {
            throw new Error("Heatmap on cartesian must have two axes with boundaryGap true");
          }
        }
        width = xAxis.getBandWidth() + 0.5;
        height = yAxis.getBandWidth() + 0.5;
        xAxisExtent = xAxis.scale.getExtent();
        yAxisExtent = yAxis.scale.getExtent();
      }
      var group = this.group;
      var data = seriesModel.getData();
      var emphasisStyle = seriesModel.getModel(["emphasis", "itemStyle"]).getItemStyle();
      var blurStyle = seriesModel.getModel(["blur", "itemStyle"]).getItemStyle();
      var selectStyle = seriesModel.getModel(["select", "itemStyle"]).getItemStyle();
      var borderRadius = seriesModel.get(["itemStyle", "borderRadius"]);
      var labelStatesModels = getLabelStatesModels(seriesModel);
      var emphasisModel = seriesModel.getModel("emphasis");
      var focus = emphasisModel.get("focus");
      var blurScope = emphasisModel.get("blurScope");
      var emphasisDisabled = emphasisModel.get("disabled");
      var dataDims = isCartesian2d ? [data.mapDimension("x"), data.mapDimension("y"), data.mapDimension("value")] : [data.mapDimension("time"), data.mapDimension("value")];
      for (var idx = start2; idx < end2; idx++) {
        var rect = void 0;
        var style = data.getItemVisual(idx, "style");
        if (isCartesian2d) {
          var dataDimX = data.get(dataDims[0], idx);
          var dataDimY = data.get(dataDims[1], idx);
          if (isNaN(data.get(dataDims[2], idx)) || dataDimX < xAxisExtent[0] || dataDimX > xAxisExtent[1] || dataDimY < yAxisExtent[0] || dataDimY > yAxisExtent[1]) {
            continue;
          }
          var point = coordSys.dataToPoint([dataDimX, dataDimY]);
          rect = new Rect_default({
            shape: {
              x: point[0] - width / 2,
              y: point[1] - height / 2,
              width,
              height
            },
            style
          });
        } else {
          if (isNaN(data.get(dataDims[1], idx))) {
            continue;
          }
          rect = new Rect_default({
            z2: 1,
            shape: coordSys.dataToRect([data.get(dataDims[0], idx)]).contentShape,
            style
          });
        }
        if (data.hasItemOption) {
          var itemModel = data.getItemModel(idx);
          var emphasisModel_1 = itemModel.getModel("emphasis");
          emphasisStyle = emphasisModel_1.getModel("itemStyle").getItemStyle();
          blurStyle = itemModel.getModel(["blur", "itemStyle"]).getItemStyle();
          selectStyle = itemModel.getModel(["select", "itemStyle"]).getItemStyle();
          borderRadius = itemModel.get(["itemStyle", "borderRadius"]);
          focus = emphasisModel_1.get("focus");
          blurScope = emphasisModel_1.get("blurScope");
          emphasisDisabled = emphasisModel_1.get("disabled");
          labelStatesModels = getLabelStatesModels(itemModel);
        }
        rect.shape.r = borderRadius;
        var rawValue = seriesModel.getRawValue(idx);
        var defaultText = "-";
        if (rawValue && rawValue[2] != null) {
          defaultText = rawValue[2] + "";
        }
        setLabelStyle(rect, labelStatesModels, {
          labelFetcher: seriesModel,
          labelDataIndex: idx,
          defaultOpacity: style.opacity,
          defaultText
        });
        rect.ensureState("emphasis").style = emphasisStyle;
        rect.ensureState("blur").style = blurStyle;
        rect.ensureState("select").style = selectStyle;
        toggleHoverEmphasis(rect, focus, blurScope, emphasisDisabled);
        rect.incremental = incremental;
        if (incremental) {
          rect.states.emphasis.hoverLayer = true;
        }
        group.add(rect);
        data.setItemGraphicEl(idx, rect);
        if (this._progressiveEls) {
          this._progressiveEls.push(rect);
        }
      }
    };
    HeatmapView2.prototype._renderOnGeo = function(geo, seriesModel, visualMapModel, api) {
      var inRangeVisuals = visualMapModel.targetVisuals.inRange;
      var outOfRangeVisuals = visualMapModel.targetVisuals.outOfRange;
      var data = seriesModel.getData();
      var hmLayer = this._hmLayer || this._hmLayer || new HeatmapLayer_default();
      hmLayer.blurSize = seriesModel.get("blurSize");
      hmLayer.pointSize = seriesModel.get("pointSize");
      hmLayer.minOpacity = seriesModel.get("minOpacity");
      hmLayer.maxOpacity = seriesModel.get("maxOpacity");
      var rect = geo.getViewRect().clone();
      var roamTransform = geo.getRoamTransform();
      rect.applyTransform(roamTransform);
      var x = Math.max(rect.x, 0);
      var y = Math.max(rect.y, 0);
      var x2 = Math.min(rect.width + rect.x, api.getWidth());
      var y2 = Math.min(rect.height + rect.y, api.getHeight());
      var width = x2 - x;
      var height = y2 - y;
      var dims = [data.mapDimension("lng"), data.mapDimension("lat"), data.mapDimension("value")];
      var points4 = data.mapArray(dims, function(lng, lat, value) {
        var pt = geo.dataToPoint([lng, lat]);
        pt[0] -= x;
        pt[1] -= y;
        pt.push(value);
        return pt;
      });
      var dataExtent = visualMapModel.getExtent();
      var isInRange = visualMapModel.type === "visualMap.continuous" ? getIsInContinuousRange(dataExtent, visualMapModel.option.range) : getIsInPiecewiseRange(dataExtent, visualMapModel.getPieceList(), visualMapModel.option.selected);
      hmLayer.update(points4, width, height, inRangeVisuals.color.getNormalizer(), {
        inRange: inRangeVisuals.color.getColorMapper(),
        outOfRange: outOfRangeVisuals.color.getColorMapper()
      }, isInRange);
      var img = new Image_default({
        style: {
          width,
          height,
          x,
          y,
          image: hmLayer.canvas
        },
        silent: true
      });
      this.group.add(img);
    };
    HeatmapView2.type = "heatmap";
    return HeatmapView2;
  }(Chart_default);
  var HeatmapView_default = HeatmapView;

  // node_modules/echarts/lib/chart/heatmap/HeatmapSeries.js
  var HeatmapSeriesModel = function(_super) {
    __extends(HeatmapSeriesModel2, _super);
    function HeatmapSeriesModel2() {
      var _this = _super !== null && _super.apply(this, arguments) || this;
      _this.type = HeatmapSeriesModel2.type;
      return _this;
    }
    HeatmapSeriesModel2.prototype.getInitialData = function(option, ecModel) {
      return createSeriesData_default(null, this, {
        generateCoord: "value"
      });
    };
    HeatmapSeriesModel2.prototype.preventIncremental = function() {
      var coordSysCreator = CoordinateSystem_default.get(this.get("coordinateSystem"));
      if (coordSysCreator && coordSysCreator.dimensions) {
        return coordSysCreator.dimensions[0] === "lng" && coordSysCreator.dimensions[1] === "lat";
      }
    };
    HeatmapSeriesModel2.type = "series.heatmap";
    HeatmapSeriesModel2.dependencies = ["grid", "geo", "calendar"];
    HeatmapSeriesModel2.defaultOption = {
      coordinateSystem: "cartesian2d",
      z: 2,
      geoIndex: 0,
      blurSize: 30,
      pointSize: 20,
      maxOpacity: 1,
      minOpacity: 0,
      select: {
        itemStyle: {
          borderColor: "#212121"
        }
      }
    };
    return HeatmapSeriesModel2;
  }(Series_default);
  var HeatmapSeries_default = HeatmapSeriesModel;

  // node_modules/echarts/lib/chart/heatmap/install.js
  function install24(registers) {
    registers.registerChartView(HeatmapView_default);
    registers.registerSeriesModel(HeatmapSeries_default);
  }

  // node_modules/echarts/lib/chart/bar/PictorialBarView.js
  var BAR_BORDER_WIDTH_QUERY = ["itemStyle", "borderWidth"];
  var LAYOUT_ATTRS = [{
    xy: "x",
    wh: "width",
    index: 0,
    posDesc: ["left", "right"]
  }, {
    xy: "y",
    wh: "height",
    index: 1,
    posDesc: ["top", "bottom"]
  }];
  var pathForLineWidth = new Circle_default();
  var PictorialBarView = function(_super) {
    __extends(PictorialBarView2, _super);
    function PictorialBarView2() {
      var _this = _super !== null && _super.apply(this, arguments) || this;
      _this.type = PictorialBarView2.type;
      return _this;
    }
    PictorialBarView2.prototype.render = function(seriesModel, ecModel, api) {
      var group = this.group;
      var data = seriesModel.getData();
      var oldData = this._data;
      var cartesian = seriesModel.coordinateSystem;
      var baseAxis = cartesian.getBaseAxis();
      var isHorizontal = baseAxis.isHorizontal();
      var coordSysRect = cartesian.master.getRect();
      var opt = {
        ecSize: {
          width: api.getWidth(),
          height: api.getHeight()
        },
        seriesModel,
        coordSys: cartesian,
        coordSysExtent: [[coordSysRect.x, coordSysRect.x + coordSysRect.width], [coordSysRect.y, coordSysRect.y + coordSysRect.height]],
        isHorizontal,
        valueDim: LAYOUT_ATTRS[+isHorizontal],
        categoryDim: LAYOUT_ATTRS[1 - +isHorizontal]
      };
      data.diff(oldData).add(function(dataIndex) {
        if (!data.hasValue(dataIndex)) {
          return;
        }
        var itemModel = getItemModel(data, dataIndex);
        var symbolMeta = getSymbolMeta(data, dataIndex, itemModel, opt);
        var bar = createBar(data, opt, symbolMeta);
        data.setItemGraphicEl(dataIndex, bar);
        group.add(bar);
        updateCommon2(bar, opt, symbolMeta);
      }).update(function(newIndex, oldIndex) {
        var bar = oldData.getItemGraphicEl(oldIndex);
        if (!data.hasValue(newIndex)) {
          group.remove(bar);
          return;
        }
        var itemModel = getItemModel(data, newIndex);
        var symbolMeta = getSymbolMeta(data, newIndex, itemModel, opt);
        var pictorialShapeStr = getShapeStr(data, symbolMeta);
        if (bar && pictorialShapeStr !== bar.__pictorialShapeStr) {
          group.remove(bar);
          data.setItemGraphicEl(newIndex, null);
          bar = null;
        }
        if (bar) {
          updateBar(bar, opt, symbolMeta);
        } else {
          bar = createBar(data, opt, symbolMeta, true);
        }
        data.setItemGraphicEl(newIndex, bar);
        bar.__pictorialSymbolMeta = symbolMeta;
        group.add(bar);
        updateCommon2(bar, opt, symbolMeta);
      }).remove(function(dataIndex) {
        var bar = oldData.getItemGraphicEl(dataIndex);
        bar && removeBar(oldData, dataIndex, bar.__pictorialSymbolMeta.animationModel, bar);
      }).execute();
      this._data = data;
      return this.group;
    };
    PictorialBarView2.prototype.remove = function(ecModel, api) {
      var group = this.group;
      var data = this._data;
      if (ecModel.get("animation")) {
        if (data) {
          data.eachItemGraphicEl(function(bar) {
            removeBar(data, getECData(bar).dataIndex, ecModel, bar);
          });
        }
      } else {
        group.removeAll();
      }
    };
    PictorialBarView2.type = "pictorialBar";
    return PictorialBarView2;
  }(Chart_default);
  function getSymbolMeta(data, dataIndex, itemModel, opt) {
    var layout5 = data.getItemLayout(dataIndex);
    var symbolRepeat = itemModel.get("symbolRepeat");
    var symbolClip = itemModel.get("symbolClip");
    var symbolPosition = itemModel.get("symbolPosition") || "start";
    var symbolRotate = itemModel.get("symbolRotate");
    var rotation = (symbolRotate || 0) * Math.PI / 180 || 0;
    var symbolPatternSize = itemModel.get("symbolPatternSize") || 2;
    var isAnimationEnabled2 = itemModel.isAnimationEnabled();
    var symbolMeta = {
      dataIndex,
      layout: layout5,
      itemModel,
      symbolType: data.getItemVisual(dataIndex, "symbol") || "circle",
      style: data.getItemVisual(dataIndex, "style"),
      symbolClip,
      symbolRepeat,
      symbolRepeatDirection: itemModel.get("symbolRepeatDirection"),
      symbolPatternSize,
      rotation,
      animationModel: isAnimationEnabled2 ? itemModel : null,
      hoverScale: isAnimationEnabled2 && itemModel.get(["emphasis", "scale"]),
      z2: itemModel.getShallow("z", true) || 0
    };
    prepareBarLength(itemModel, symbolRepeat, layout5, opt, symbolMeta);
    prepareSymbolSize(data, dataIndex, layout5, symbolRepeat, symbolClip, symbolMeta.boundingLength, symbolMeta.pxSign, symbolPatternSize, opt, symbolMeta);
    prepareLineWidth(itemModel, symbolMeta.symbolScale, rotation, opt, symbolMeta);
    var symbolSize = symbolMeta.symbolSize;
    var symbolOffset = normalizeSymbolOffset(itemModel.get("symbolOffset"), symbolSize);
    prepareLayoutInfo(itemModel, symbolSize, layout5, symbolRepeat, symbolClip, symbolOffset, symbolPosition, symbolMeta.valueLineWidth, symbolMeta.boundingLength, symbolMeta.repeatCutLength, opt, symbolMeta);
    return symbolMeta;
  }
  function prepareBarLength(itemModel, symbolRepeat, layout5, opt, outputSymbolMeta) {
    var valueDim = opt.valueDim;
    var symbolBoundingData = itemModel.get("symbolBoundingData");
    var valueAxis2 = opt.coordSys.getOtherAxis(opt.coordSys.getBaseAxis());
    var zeroPx = valueAxis2.toGlobalCoord(valueAxis2.dataToCoord(0));
    var pxSignIdx = 1 - +(layout5[valueDim.wh] <= 0);
    var boundingLength;
    if (isArray(symbolBoundingData)) {
      var symbolBoundingExtent = [convertToCoordOnAxis(valueAxis2, symbolBoundingData[0]) - zeroPx, convertToCoordOnAxis(valueAxis2, symbolBoundingData[1]) - zeroPx];
      symbolBoundingExtent[1] < symbolBoundingExtent[0] && symbolBoundingExtent.reverse();
      boundingLength = symbolBoundingExtent[pxSignIdx];
    } else if (symbolBoundingData != null) {
      boundingLength = convertToCoordOnAxis(valueAxis2, symbolBoundingData) - zeroPx;
    } else if (symbolRepeat) {
      boundingLength = opt.coordSysExtent[valueDim.index][pxSignIdx] - zeroPx;
    } else {
      boundingLength = layout5[valueDim.wh];
    }
    outputSymbolMeta.boundingLength = boundingLength;
    if (symbolRepeat) {
      outputSymbolMeta.repeatCutLength = layout5[valueDim.wh];
    }
    outputSymbolMeta.pxSign = boundingLength > 0 ? 1 : -1;
  }
  function convertToCoordOnAxis(axis, value) {
    return axis.toGlobalCoord(axis.dataToCoord(axis.scale.parse(value)));
  }
  function prepareSymbolSize(data, dataIndex, layout5, symbolRepeat, symbolClip, boundingLength, pxSign, symbolPatternSize, opt, outputSymbolMeta) {
    var valueDim = opt.valueDim;
    var categoryDim = opt.categoryDim;
    var categorySize = Math.abs(layout5[categoryDim.wh]);
    var symbolSize = data.getItemVisual(dataIndex, "symbolSize");
    var parsedSymbolSize;
    if (isArray(symbolSize)) {
      parsedSymbolSize = symbolSize.slice();
    } else {
      if (symbolSize == null) {
        parsedSymbolSize = ["100%", "100%"];
      } else {
        parsedSymbolSize = [symbolSize, symbolSize];
      }
    }
    parsedSymbolSize[categoryDim.index] = parsePercent2(parsedSymbolSize[categoryDim.index], categorySize);
    parsedSymbolSize[valueDim.index] = parsePercent2(parsedSymbolSize[valueDim.index], symbolRepeat ? categorySize : Math.abs(boundingLength));
    outputSymbolMeta.symbolSize = parsedSymbolSize;
    var symbolScale = outputSymbolMeta.symbolScale = [parsedSymbolSize[0] / symbolPatternSize, parsedSymbolSize[1] / symbolPatternSize];
    symbolScale[valueDim.index] *= (opt.isHorizontal ? -1 : 1) * pxSign;
  }
  function prepareLineWidth(itemModel, symbolScale, rotation, opt, outputSymbolMeta) {
    var valueLineWidth = itemModel.get(BAR_BORDER_WIDTH_QUERY) || 0;
    if (valueLineWidth) {
      pathForLineWidth.attr({
        scaleX: symbolScale[0],
        scaleY: symbolScale[1],
        rotation
      });
      pathForLineWidth.updateTransform();
      valueLineWidth /= pathForLineWidth.getLineScale();
      valueLineWidth *= symbolScale[opt.valueDim.index];
    }
    outputSymbolMeta.valueLineWidth = valueLineWidth || 0;
  }
  function prepareLayoutInfo(itemModel, symbolSize, layout5, symbolRepeat, symbolClip, symbolOffset, symbolPosition, valueLineWidth, boundingLength, repeatCutLength, opt, outputSymbolMeta) {
    var categoryDim = opt.categoryDim;
    var valueDim = opt.valueDim;
    var pxSign = outputSymbolMeta.pxSign;
    var unitLength = Math.max(symbolSize[valueDim.index] + valueLineWidth, 0);
    var pathLen = unitLength;
    if (symbolRepeat) {
      var absBoundingLength = Math.abs(boundingLength);
      var symbolMargin = retrieve(itemModel.get("symbolMargin"), "15%") + "";
      var hasEndGap = false;
      if (symbolMargin.lastIndexOf("!") === symbolMargin.length - 1) {
        hasEndGap = true;
        symbolMargin = symbolMargin.slice(0, symbolMargin.length - 1);
      }
      var symbolMarginNumeric = parsePercent2(symbolMargin, symbolSize[valueDim.index]);
      var uLenWithMargin = Math.max(unitLength + symbolMarginNumeric * 2, 0);
      var endFix = hasEndGap ? 0 : symbolMarginNumeric * 2;
      var repeatSpecified = isNumeric(symbolRepeat);
      var repeatTimes = repeatSpecified ? symbolRepeat : toIntTimes((absBoundingLength + endFix) / uLenWithMargin);
      var mDiff = absBoundingLength - repeatTimes * unitLength;
      symbolMarginNumeric = mDiff / 2 / (hasEndGap ? repeatTimes : Math.max(repeatTimes - 1, 1));
      uLenWithMargin = unitLength + symbolMarginNumeric * 2;
      endFix = hasEndGap ? 0 : symbolMarginNumeric * 2;
      if (!repeatSpecified && symbolRepeat !== "fixed") {
        repeatTimes = repeatCutLength ? toIntTimes((Math.abs(repeatCutLength) + endFix) / uLenWithMargin) : 0;
      }
      pathLen = repeatTimes * uLenWithMargin - endFix;
      outputSymbolMeta.repeatTimes = repeatTimes;
      outputSymbolMeta.symbolMargin = symbolMarginNumeric;
    }
    var sizeFix = pxSign * (pathLen / 2);
    var pathPosition = outputSymbolMeta.pathPosition = [];
    pathPosition[categoryDim.index] = layout5[categoryDim.wh] / 2;
    pathPosition[valueDim.index] = symbolPosition === "start" ? sizeFix : symbolPosition === "end" ? boundingLength - sizeFix : boundingLength / 2;
    if (symbolOffset) {
      pathPosition[0] += symbolOffset[0];
      pathPosition[1] += symbolOffset[1];
    }
    var bundlePosition = outputSymbolMeta.bundlePosition = [];
    bundlePosition[categoryDim.index] = layout5[categoryDim.xy];
    bundlePosition[valueDim.index] = layout5[valueDim.xy];
    var barRectShape = outputSymbolMeta.barRectShape = extend({}, layout5);
    barRectShape[valueDim.wh] = pxSign * Math.max(Math.abs(layout5[valueDim.wh]), Math.abs(pathPosition[valueDim.index] + sizeFix));
    barRectShape[categoryDim.wh] = layout5[categoryDim.wh];
    var clipShape = outputSymbolMeta.clipShape = {};
    clipShape[categoryDim.xy] = -layout5[categoryDim.xy];
    clipShape[categoryDim.wh] = opt.ecSize[categoryDim.wh];
    clipShape[valueDim.xy] = 0;
    clipShape[valueDim.wh] = layout5[valueDim.wh];
  }
  function createPath(symbolMeta) {
    var symbolPatternSize = symbolMeta.symbolPatternSize;
    var path = createSymbol(symbolMeta.symbolType, -symbolPatternSize / 2, -symbolPatternSize / 2, symbolPatternSize, symbolPatternSize);
    path.attr({
      culling: true
    });
    path.type !== "image" && path.setStyle({
      strokeNoScale: true
    });
    return path;
  }
  function createOrUpdateRepeatSymbols(bar, opt, symbolMeta, isUpdate) {
    var bundle = bar.__pictorialBundle;
    var symbolSize = symbolMeta.symbolSize;
    var valueLineWidth = symbolMeta.valueLineWidth;
    var pathPosition = symbolMeta.pathPosition;
    var valueDim = opt.valueDim;
    var repeatTimes = symbolMeta.repeatTimes || 0;
    var index = 0;
    var unit = symbolSize[opt.valueDim.index] + valueLineWidth + symbolMeta.symbolMargin * 2;
    eachPath(bar, function(path2) {
      path2.__pictorialAnimationIndex = index;
      path2.__pictorialRepeatTimes = repeatTimes;
      if (index < repeatTimes) {
        updateAttr(path2, null, makeTarget(index), symbolMeta, isUpdate);
      } else {
        updateAttr(path2, null, {
          scaleX: 0,
          scaleY: 0
        }, symbolMeta, isUpdate, function() {
          bundle.remove(path2);
        });
      }
      index++;
    });
    for (; index < repeatTimes; index++) {
      var path = createPath(symbolMeta);
      path.__pictorialAnimationIndex = index;
      path.__pictorialRepeatTimes = repeatTimes;
      bundle.add(path);
      var target = makeTarget(index);
      updateAttr(path, {
        x: target.x,
        y: target.y,
        scaleX: 0,
        scaleY: 0
      }, {
        scaleX: target.scaleX,
        scaleY: target.scaleY,
        rotation: target.rotation
      }, symbolMeta, isUpdate);
    }
    function makeTarget(index2) {
      var position2 = pathPosition.slice();
      var pxSign = symbolMeta.pxSign;
      var i = index2;
      if (symbolMeta.symbolRepeatDirection === "start" ? pxSign > 0 : pxSign < 0) {
        i = repeatTimes - 1 - index2;
      }
      position2[valueDim.index] = unit * (i - repeatTimes / 2 + 0.5) + pathPosition[valueDim.index];
      return {
        x: position2[0],
        y: position2[1],
        scaleX: symbolMeta.symbolScale[0],
        scaleY: symbolMeta.symbolScale[1],
        rotation: symbolMeta.rotation
      };
    }
  }
  function createOrUpdateSingleSymbol(bar, opt, symbolMeta, isUpdate) {
    var bundle = bar.__pictorialBundle;
    var mainPath = bar.__pictorialMainPath;
    if (!mainPath) {
      mainPath = bar.__pictorialMainPath = createPath(symbolMeta);
      bundle.add(mainPath);
      updateAttr(mainPath, {
        x: symbolMeta.pathPosition[0],
        y: symbolMeta.pathPosition[1],
        scaleX: 0,
        scaleY: 0,
        rotation: symbolMeta.rotation
      }, {
        scaleX: symbolMeta.symbolScale[0],
        scaleY: symbolMeta.symbolScale[1]
      }, symbolMeta, isUpdate);
    } else {
      updateAttr(mainPath, null, {
        x: symbolMeta.pathPosition[0],
        y: symbolMeta.pathPosition[1],
        scaleX: symbolMeta.symbolScale[0],
        scaleY: symbolMeta.symbolScale[1],
        rotation: symbolMeta.rotation
      }, symbolMeta, isUpdate);
    }
  }
  function createOrUpdateBarRect(bar, symbolMeta, isUpdate) {
    var rectShape = extend({}, symbolMeta.barRectShape);
    var barRect = bar.__pictorialBarRect;
    if (!barRect) {
      barRect = bar.__pictorialBarRect = new Rect_default({
        z2: 2,
        shape: rectShape,
        silent: true,
        style: {
          stroke: "transparent",
          fill: "transparent",
          lineWidth: 0
        }
      });
      barRect.disableMorphing = true;
      bar.add(barRect);
    } else {
      updateAttr(barRect, null, {
        shape: rectShape
      }, symbolMeta, isUpdate);
    }
  }
  function createOrUpdateClip(bar, opt, symbolMeta, isUpdate) {
    if (symbolMeta.symbolClip) {
      var clipPath = bar.__pictorialClipPath;
      var clipShape = extend({}, symbolMeta.clipShape);
      var valueDim = opt.valueDim;
      var animationModel = symbolMeta.animationModel;
      var dataIndex = symbolMeta.dataIndex;
      if (clipPath) {
        updateProps(clipPath, {
          shape: clipShape
        }, animationModel, dataIndex);
      } else {
        clipShape[valueDim.wh] = 0;
        clipPath = new Rect_default({
          shape: clipShape
        });
        bar.__pictorialBundle.setClipPath(clipPath);
        bar.__pictorialClipPath = clipPath;
        var target = {};
        target[valueDim.wh] = symbolMeta.clipShape[valueDim.wh];
        graphic_exports[isUpdate ? "updateProps" : "initProps"](clipPath, {
          shape: target
        }, animationModel, dataIndex);
      }
    }
  }
  function getItemModel(data, dataIndex) {
    var itemModel = data.getItemModel(dataIndex);
    itemModel.getAnimationDelayParams = getAnimationDelayParams;
    itemModel.isAnimationEnabled = isAnimationEnabled;
    return itemModel;
  }
  function getAnimationDelayParams(path) {
    return {
      index: path.__pictorialAnimationIndex,
      count: path.__pictorialRepeatTimes
    };
  }
  function isAnimationEnabled() {
    return this.parentModel.isAnimationEnabled() && !!this.getShallow("animation");
  }
  function createBar(data, opt, symbolMeta, isUpdate) {
    var bar = new Group_default();
    var bundle = new Group_default();
    bar.add(bundle);
    bar.__pictorialBundle = bundle;
    bundle.x = symbolMeta.bundlePosition[0];
    bundle.y = symbolMeta.bundlePosition[1];
    if (symbolMeta.symbolRepeat) {
      createOrUpdateRepeatSymbols(bar, opt, symbolMeta);
    } else {
      createOrUpdateSingleSymbol(bar, opt, symbolMeta);
    }
    createOrUpdateBarRect(bar, symbolMeta, isUpdate);
    createOrUpdateClip(bar, opt, symbolMeta, isUpdate);
    bar.__pictorialShapeStr = getShapeStr(data, symbolMeta);
    bar.__pictorialSymbolMeta = symbolMeta;
    return bar;
  }
  function updateBar(bar, opt, symbolMeta) {
    var animationModel = symbolMeta.animationModel;
    var dataIndex = symbolMeta.dataIndex;
    var bundle = bar.__pictorialBundle;
    updateProps(bundle, {
      x: symbolMeta.bundlePosition[0],
      y: symbolMeta.bundlePosition[1]
    }, animationModel, dataIndex);
    if (symbolMeta.symbolRepeat) {
      createOrUpdateRepeatSymbols(bar, opt, symbolMeta, true);
    } else {
      createOrUpdateSingleSymbol(bar, opt, symbolMeta, true);
    }
    createOrUpdateBarRect(bar, symbolMeta, true);
    createOrUpdateClip(bar, opt, symbolMeta, true);
  }
  function removeBar(data, dataIndex, animationModel, bar) {
    var labelRect = bar.__pictorialBarRect;
    labelRect && labelRect.removeTextContent();
    var paths = [];
    eachPath(bar, function(path) {
      paths.push(path);
    });
    bar.__pictorialMainPath && paths.push(bar.__pictorialMainPath);
    bar.__pictorialClipPath && (animationModel = null);
    each(paths, function(path) {
      removeElement(path, {
        scaleX: 0,
        scaleY: 0
      }, animationModel, dataIndex, function() {
        bar.parent && bar.parent.remove(bar);
      });
    });
    data.setItemGraphicEl(dataIndex, null);
  }
  function getShapeStr(data, symbolMeta) {
    return [data.getItemVisual(symbolMeta.dataIndex, "symbol") || "none", !!symbolMeta.symbolRepeat, !!symbolMeta.symbolClip].join(":");
  }
  function eachPath(bar, cb, context) {
    each(bar.__pictorialBundle.children(), function(el) {
      el !== bar.__pictorialBarRect && cb.call(context, el);
    });
  }
  function updateAttr(el, immediateAttrs, animationAttrs, symbolMeta, isUpdate, cb) {
    immediateAttrs && el.attr(immediateAttrs);
    if (symbolMeta.symbolClip && !isUpdate) {
      animationAttrs && el.attr(animationAttrs);
    } else {
      animationAttrs && graphic_exports[isUpdate ? "updateProps" : "initProps"](el, animationAttrs, symbolMeta.animationModel, symbolMeta.dataIndex, cb);
    }
  }
  function updateCommon2(bar, opt, symbolMeta) {
    var dataIndex = symbolMeta.dataIndex;
    var itemModel = symbolMeta.itemModel;
    var emphasisModel = itemModel.getModel("emphasis");
    var emphasisStyle = emphasisModel.getModel("itemStyle").getItemStyle();
    var blurStyle = itemModel.getModel(["blur", "itemStyle"]).getItemStyle();
    var selectStyle = itemModel.getModel(["select", "itemStyle"]).getItemStyle();
    var cursorStyle = itemModel.getShallow("cursor");
    var focus = emphasisModel.get("focus");
    var blurScope = emphasisModel.get("blurScope");
    var hoverScale = emphasisModel.get("scale");
    eachPath(bar, function(path) {
      if (path instanceof Image_default) {
        var pathStyle = path.style;
        path.useStyle(extend({
          image: pathStyle.image,
          x: pathStyle.x,
          y: pathStyle.y,
          width: pathStyle.width,
          height: pathStyle.height
        }, symbolMeta.style));
      } else {
        path.useStyle(symbolMeta.style);
      }
      var emphasisState = path.ensureState("emphasis");
      emphasisState.style = emphasisStyle;
      if (hoverScale) {
        emphasisState.scaleX = path.scaleX * 1.1;
        emphasisState.scaleY = path.scaleY * 1.1;
      }
      path.ensureState("blur").style = blurStyle;
      path.ensureState("select").style = selectStyle;
      cursorStyle && (path.cursor = cursorStyle);
      path.z2 = symbolMeta.z2;
    });
    var barPositionOutside = opt.valueDim.posDesc[+(symbolMeta.boundingLength > 0)];
    var barRect = bar.__pictorialBarRect;
    setLabelStyle(barRect, getLabelStatesModels(itemModel), {
      labelFetcher: opt.seriesModel,
      labelDataIndex: dataIndex,
      defaultText: getDefaultLabel(opt.seriesModel.getData(), dataIndex),
      inheritColor: symbolMeta.style.fill,
      defaultOpacity: symbolMeta.style.opacity,
      defaultOutsidePosition: barPositionOutside
    });
    toggleHoverEmphasis(bar, focus, blurScope, emphasisModel.get("disabled"));
  }
  function toIntTimes(times) {
    var roundedTimes = Math.round(times);
    return Math.abs(times - roundedTimes) < 1e-4 ? roundedTimes : Math.ceil(times);
  }
  var PictorialBarView_default = PictorialBarView;

  // node_modules/echarts/lib/chart/bar/PictorialBarSeries.js
  var PictorialBarSeriesModel = function(_super) {
    __extends(PictorialBarSeriesModel2, _super);
    function PictorialBarSeriesModel2() {
      var _this = _super !== null && _super.apply(this, arguments) || this;
      _this.type = PictorialBarSeriesModel2.type;
      _this.hasSymbolVisual = true;
      _this.defaultSymbol = "roundRect";
      return _this;
    }
    PictorialBarSeriesModel2.prototype.getInitialData = function(option) {
      option.stack = null;
      return _super.prototype.getInitialData.apply(this, arguments);
    };
    PictorialBarSeriesModel2.type = "series.pictorialBar";
    PictorialBarSeriesModel2.dependencies = ["grid"];
    PictorialBarSeriesModel2.defaultOption = inheritDefaultOption(BaseBarSeries_default.defaultOption, {
      symbol: "circle",
      symbolSize: null,
      symbolRotate: null,
      symbolPosition: null,
      symbolOffset: null,
      symbolMargin: null,
      symbolRepeat: false,
      symbolRepeatDirection: "end",
      symbolClip: false,
      symbolBoundingData: null,
      symbolPatternSize: 400,
      barGap: "-100%",
      progressive: 0,
      emphasis: {
        scale: false
      },
      select: {
        itemStyle: {
          borderColor: "#212121"
        }
      }
    });
    return PictorialBarSeriesModel2;
  }(BaseBarSeries_default);
  var PictorialBarSeries_default = PictorialBarSeriesModel;

  // node_modules/echarts/lib/chart/bar/installPictorialBar.js
  function install25(registers) {
    registers.registerChartView(PictorialBarView_default);
    registers.registerSeriesModel(PictorialBarSeries_default);
    registers.registerLayout(registers.PRIORITY.VISUAL.LAYOUT, curry(layout, "pictorialBar"));
    registers.registerLayout(registers.PRIORITY.VISUAL.PROGRESSIVE_LAYOUT, createProgressiveLayout("pictorialBar"));
  }

  // node_modules/echarts/lib/chart/themeRiver/ThemeRiverView.js
  var ThemeRiverView = function(_super) {
    __extends(ThemeRiverView2, _super);
    function ThemeRiverView2() {
      var _this = _super !== null && _super.apply(this, arguments) || this;
      _this.type = ThemeRiverView2.type;
      _this._layers = [];
      return _this;
    }
    ThemeRiverView2.prototype.render = function(seriesModel, ecModel, api) {
      var data = seriesModel.getData();
      var self2 = this;
      var group = this.group;
      var layersSeries = seriesModel.getLayerSeries();
      var layoutInfo = data.getLayout("layoutInfo");
      var rect = layoutInfo.rect;
      var boundaryGap = layoutInfo.boundaryGap;
      group.x = 0;
      group.y = rect.y + boundaryGap[0];
      function keyGetter(item) {
        return item.name;
      }
      var dataDiffer = new DataDiffer_default(this._layersSeries || [], layersSeries, keyGetter, keyGetter);
      var newLayersGroups = [];
      dataDiffer.add(bind(process2, this, "add")).update(bind(process2, this, "update")).remove(bind(process2, this, "remove")).execute();
      function process2(status, idx, oldIdx) {
        var oldLayersGroups = self2._layers;
        if (status === "remove") {
          group.remove(oldLayersGroups[idx]);
          return;
        }
        var points0 = [];
        var points1 = [];
        var style;
        var indices = layersSeries[idx].indices;
        var j = 0;
        for (; j < indices.length; j++) {
          var layout5 = data.getItemLayout(indices[j]);
          var x = layout5.x;
          var y0 = layout5.y0;
          var y = layout5.y;
          points0.push(x, y0);
          points1.push(x, y0 + y);
          style = data.getItemVisual(indices[j], "style");
        }
        var polygon;
        var textLayout = data.getItemLayout(indices[0]);
        var labelModel = seriesModel.getModel("label");
        var margin = labelModel.get("margin");
        var emphasisModel = seriesModel.getModel("emphasis");
        if (status === "add") {
          var layerGroup = newLayersGroups[idx] = new Group_default();
          polygon = new ECPolygon({
            shape: {
              points: points0,
              stackedOnPoints: points1,
              smooth: 0.4,
              stackedOnSmooth: 0.4,
              smoothConstraint: false
            },
            z2: 0
          });
          layerGroup.add(polygon);
          group.add(layerGroup);
          if (seriesModel.isAnimationEnabled()) {
            polygon.setClipPath(createGridClipShape3(polygon.getBoundingRect(), seriesModel, function() {
              polygon.removeClipPath();
            }));
          }
        } else {
          var layerGroup = oldLayersGroups[oldIdx];
          polygon = layerGroup.childAt(0);
          group.add(layerGroup);
          newLayersGroups[idx] = layerGroup;
          updateProps(polygon, {
            shape: {
              points: points0,
              stackedOnPoints: points1
            }
          }, seriesModel);
          saveOldStyle(polygon);
        }
        setLabelStyle(polygon, getLabelStatesModels(seriesModel), {
          labelDataIndex: indices[j - 1],
          defaultText: data.getName(indices[j - 1]),
          inheritColor: style.fill
        }, {
          normal: {
            verticalAlign: "middle"
          }
        });
        polygon.setTextConfig({
          position: null,
          local: true
        });
        var labelEl = polygon.getTextContent();
        if (labelEl) {
          labelEl.x = textLayout.x - margin;
          labelEl.y = textLayout.y0 + textLayout.y / 2;
        }
        polygon.useStyle(style);
        data.setItemGraphicEl(idx, polygon);
        setStatesStylesFromModel(polygon, seriesModel);
        toggleHoverEmphasis(polygon, emphasisModel.get("focus"), emphasisModel.get("blurScope"), emphasisModel.get("disabled"));
      }
      this._layersSeries = layersSeries;
      this._layers = newLayersGroups;
    };
    ThemeRiverView2.type = "themeRiver";
    return ThemeRiverView2;
  }(Chart_default);
  function createGridClipShape3(rect, seriesModel, cb) {
    var rectEl = new Rect_default({
      shape: {
        x: rect.x - 10,
        y: rect.y - 10,
        width: 0,
        height: rect.height + 20
      }
    });
    initProps(rectEl, {
      shape: {
        x: rect.x - 50,
        width: rect.width + 100,
        height: rect.height + 20
      }
    }, seriesModel, cb);
    return rectEl;
  }
  var ThemeRiverView_default = ThemeRiverView;

  // node_modules/echarts/lib/chart/themeRiver/ThemeRiverSeries.js
  var DATA_NAME_INDEX = 2;
  var ThemeRiverSeriesModel = function(_super) {
    __extends(ThemeRiverSeriesModel2, _super);
    function ThemeRiverSeriesModel2() {
      var _this = _super !== null && _super.apply(this, arguments) || this;
      _this.type = ThemeRiverSeriesModel2.type;
      return _this;
    }
    ThemeRiverSeriesModel2.prototype.init = function(option) {
      _super.prototype.init.apply(this, arguments);
      this.legendVisualProvider = new LegendVisualProvider_default(bind(this.getData, this), bind(this.getRawData, this));
    };
    ThemeRiverSeriesModel2.prototype.fixData = function(data) {
      var rawDataLength = data.length;
      var timeValueKeys = {};
      var groupResult = groupData(data, function(item) {
        if (!timeValueKeys.hasOwnProperty(item[0] + "")) {
          timeValueKeys[item[0] + ""] = -1;
        }
        return item[2];
      });
      var layerData = [];
      groupResult.buckets.each(function(items, key) {
        layerData.push({
          name: key,
          dataList: items
        });
      });
      var layerNum = layerData.length;
      for (var k = 0; k < layerNum; ++k) {
        var name_1 = layerData[k].name;
        for (var j = 0; j < layerData[k].dataList.length; ++j) {
          var timeValue = layerData[k].dataList[j][0] + "";
          timeValueKeys[timeValue] = k;
        }
        for (var timeValue in timeValueKeys) {
          if (timeValueKeys.hasOwnProperty(timeValue) && timeValueKeys[timeValue] !== k) {
            timeValueKeys[timeValue] = k;
            data[rawDataLength] = [timeValue, 0, name_1];
            rawDataLength++;
          }
        }
      }
      return data;
    };
    ThemeRiverSeriesModel2.prototype.getInitialData = function(option, ecModel) {
      var singleAxisModel = this.getReferringComponents("singleAxis", SINGLE_REFERRING).models[0];
      var axisType = singleAxisModel.get("type");
      var filterData = filter(option.data, function(dataItem) {
        return dataItem[2] !== void 0;
      });
      var data = this.fixData(filterData || []);
      var nameList = [];
      var nameMap = this.nameMap = createHashMap();
      var count2 = 0;
      for (var i = 0; i < data.length; ++i) {
        nameList.push(data[i][DATA_NAME_INDEX]);
        if (!nameMap.get(data[i][DATA_NAME_INDEX])) {
          nameMap.set(data[i][DATA_NAME_INDEX], count2);
          count2++;
        }
      }
      var dimensions = prepareSeriesDataSchema(data, {
        coordDimensions: ["single"],
        dimensionsDefine: [{
          name: "time",
          type: getDimensionTypeByAxis(axisType)
        }, {
          name: "value",
          type: "float"
        }, {
          name: "name",
          type: "ordinal"
        }],
        encodeDefine: {
          single: 0,
          value: 1,
          itemName: 2
        }
      }).dimensions;
      var list = new SeriesData_default(dimensions, this);
      list.initData(data);
      return list;
    };
    ThemeRiverSeriesModel2.prototype.getLayerSeries = function() {
      var data = this.getData();
      var lenCount = data.count();
      var indexArr = [];
      for (var i = 0; i < lenCount; ++i) {
        indexArr[i] = i;
      }
      var timeDim = data.mapDimension("single");
      var groupResult = groupData(indexArr, function(index) {
        return data.get("name", index);
      });
      var layerSeries = [];
      groupResult.buckets.each(function(items, key) {
        items.sort(function(index1, index2) {
          return data.get(timeDim, index1) - data.get(timeDim, index2);
        });
        layerSeries.push({
          name: key,
          indices: items
        });
      });
      return layerSeries;
    };
    ThemeRiverSeriesModel2.prototype.getAxisTooltipData = function(dim, value, baseAxis) {
      if (!isArray(dim)) {
        dim = dim ? [dim] : [];
      }
      var data = this.getData();
      var layerSeries = this.getLayerSeries();
      var indices = [];
      var layerNum = layerSeries.length;
      var nestestValue;
      for (var i = 0; i < layerNum; ++i) {
        var minDist = Number.MAX_VALUE;
        var nearestIdx = -1;
        var pointNum = layerSeries[i].indices.length;
        for (var j = 0; j < pointNum; ++j) {
          var theValue = data.get(dim[0], layerSeries[i].indices[j]);
          var dist3 = Math.abs(theValue - value);
          if (dist3 <= minDist) {
            nestestValue = theValue;
            minDist = dist3;
            nearestIdx = layerSeries[i].indices[j];
          }
        }
        indices.push(nearestIdx);
      }
      return {
        dataIndices: indices,
        nestestValue
      };
    };
    ThemeRiverSeriesModel2.prototype.formatTooltip = function(dataIndex, multipleSeries, dataType) {
      var data = this.getData();
      var name = data.getName(dataIndex);
      var value = data.get(data.mapDimension("value"), dataIndex);
      return createTooltipMarkup("nameValue", {
        name,
        value
      });
    };
    ThemeRiverSeriesModel2.type = "series.themeRiver";
    ThemeRiverSeriesModel2.dependencies = ["singleAxis"];
    ThemeRiverSeriesModel2.defaultOption = {
      z: 2,
      colorBy: "data",
      coordinateSystem: "singleAxis",
      boundaryGap: ["10%", "10%"],
      singleAxisIndex: 0,
      animationEasing: "linear",
      label: {
        margin: 4,
        show: true,
        position: "left",
        fontSize: 11
      },
      emphasis: {
        label: {
          show: true
        }
      }
    };
    return ThemeRiverSeriesModel2;
  }(Series_default);
  var ThemeRiverSeries_default = ThemeRiverSeriesModel;

  // node_modules/echarts/lib/chart/themeRiver/themeRiverLayout.js
  function themeRiverLayout(ecModel, api) {
    ecModel.eachSeriesByType("themeRiver", function(seriesModel) {
      var data = seriesModel.getData();
      var single = seriesModel.coordinateSystem;
      var layoutInfo = {};
      var rect = single.getRect();
      layoutInfo.rect = rect;
      var boundaryGap = seriesModel.get("boundaryGap");
      var axis = single.getAxis();
      layoutInfo.boundaryGap = boundaryGap;
      if (axis.orient === "horizontal") {
        boundaryGap[0] = parsePercent2(boundaryGap[0], rect.height);
        boundaryGap[1] = parsePercent2(boundaryGap[1], rect.height);
        var height = rect.height - boundaryGap[0] - boundaryGap[1];
        doThemeRiverLayout(data, seriesModel, height);
      } else {
        boundaryGap[0] = parsePercent2(boundaryGap[0], rect.width);
        boundaryGap[1] = parsePercent2(boundaryGap[1], rect.width);
        var width = rect.width - boundaryGap[0] - boundaryGap[1];
        doThemeRiverLayout(data, seriesModel, width);
      }
      data.setLayout("layoutInfo", layoutInfo);
    });
  }
  function doThemeRiverLayout(data, seriesModel, height) {
    if (!data.count()) {
      return;
    }
    var coordSys = seriesModel.coordinateSystem;
    var layerSeries = seriesModel.getLayerSeries();
    var timeDim = data.mapDimension("single");
    var valueDim = data.mapDimension("value");
    var layerPoints = map(layerSeries, function(singleLayer) {
      return map(singleLayer.indices, function(idx) {
        var pt = coordSys.dataToPoint(data.get(timeDim, idx));
        pt[1] = data.get(valueDim, idx);
        return pt;
      });
    });
    var base2 = computeBaseline(layerPoints);
    var baseLine = base2.y0;
    var ky = height / base2.max;
    var n = layerSeries.length;
    var m2 = layerSeries[0].indices.length;
    var baseY0;
    for (var j = 0; j < m2; ++j) {
      baseY0 = baseLine[j] * ky;
      data.setItemLayout(layerSeries[0].indices[j], {
        layerIndex: 0,
        x: layerPoints[0][j][0],
        y0: baseY0,
        y: layerPoints[0][j][1] * ky
      });
      for (var i = 1; i < n; ++i) {
        baseY0 += layerPoints[i - 1][j][1] * ky;
        data.setItemLayout(layerSeries[i].indices[j], {
          layerIndex: i,
          x: layerPoints[i][j][0],
          y0: baseY0,
          y: layerPoints[i][j][1] * ky
        });
      }
    }
  }
  function computeBaseline(data) {
    var layerNum = data.length;
    var pointNum = data[0].length;
    var sums = [];
    var y0 = [];
    var max3 = 0;
    for (var i = 0; i < pointNum; ++i) {
      var temp = 0;
      for (var j = 0; j < layerNum; ++j) {
        temp += data[j][i][1];
      }
      if (temp > max3) {
        max3 = temp;
      }
      sums.push(temp);
    }
    for (var k = 0; k < pointNum; ++k) {
      y0[k] = (max3 - sums[k]) / 2;
    }
    max3 = 0;
    for (var l = 0; l < pointNum; ++l) {
      var sum2 = sums[l] + y0[l];
      if (sum2 > max3) {
        max3 = sum2;
      }
    }
    return {
      y0,
      max: max3
    };
  }

  // node_modules/echarts/lib/chart/themeRiver/install.js
  function install26(registers) {
    registers.registerChartView(ThemeRiverView_default);
    registers.registerSeriesModel(ThemeRiverSeries_default);
    registers.registerLayout(themeRiverLayout);
    registers.registerProcessor(dataFilter("themeRiver"));
  }

  // node_modules/echarts/lib/chart/sunburst/SunburstPiece.js
  var DEFAULT_SECTOR_Z = 2;
  var DEFAULT_TEXT_Z = 4;
  var SunburstPiece = function(_super) {
    __extends(SunburstPiece2, _super);
    function SunburstPiece2(node, seriesModel, ecModel, api) {
      var _this = _super.call(this) || this;
      _this.z2 = DEFAULT_SECTOR_Z;
      _this.textConfig = {
        inside: true
      };
      getECData(_this).seriesIndex = seriesModel.seriesIndex;
      var text = new Text_default({
        z2: DEFAULT_TEXT_Z,
        silent: node.getModel().get(["label", "silent"])
      });
      _this.setTextContent(text);
      _this.updateData(true, node, seriesModel, ecModel, api);
      return _this;
    }
    SunburstPiece2.prototype.updateData = function(firstCreate, node, seriesModel, ecModel, api) {
      this.node = node;
      node.piece = this;
      seriesModel = seriesModel || this._seriesModel;
      ecModel = ecModel || this._ecModel;
      var sector = this;
      getECData(sector).dataIndex = node.dataIndex;
      var itemModel = node.getModel();
      var emphasisModel = itemModel.getModel("emphasis");
      var layout5 = node.getLayout();
      var sectorShape = extend({}, layout5);
      sectorShape.label = null;
      var normalStyle = node.getVisual("style");
      normalStyle.lineJoin = "bevel";
      var decal = node.getVisual("decal");
      if (decal) {
        normalStyle.decal = createOrUpdatePatternFromDecal(decal, api);
      }
      var cornerRadius = getSectorCornerRadius(itemModel.getModel("itemStyle"), sectorShape, true);
      extend(sectorShape, cornerRadius);
      each(SPECIAL_STATES, function(stateName) {
        var state = sector.ensureState(stateName);
        var itemStyleModel = itemModel.getModel([stateName, "itemStyle"]);
        state.style = itemStyleModel.getItemStyle();
        var cornerRadius2 = getSectorCornerRadius(itemStyleModel, sectorShape);
        if (cornerRadius2) {
          state.shape = cornerRadius2;
        }
      });
      if (firstCreate) {
        sector.setShape(sectorShape);
        sector.shape.r = layout5.r0;
        updateProps(sector, {
          shape: {
            r: layout5.r
          }
        }, seriesModel, node.dataIndex);
      } else {
        updateProps(sector, {
          shape: sectorShape
        }, seriesModel);
        saveOldStyle(sector);
      }
      sector.useStyle(normalStyle);
      this._updateLabel(seriesModel);
      var cursorStyle = itemModel.getShallow("cursor");
      cursorStyle && sector.attr("cursor", cursorStyle);
      this._seriesModel = seriesModel || this._seriesModel;
      this._ecModel = ecModel || this._ecModel;
      var focus = emphasisModel.get("focus");
      var focusOrIndices = focus === "ancestor" ? node.getAncestorsIndices() : focus === "descendant" ? node.getDescendantIndices() : focus;
      toggleHoverEmphasis(this, focusOrIndices, emphasisModel.get("blurScope"), emphasisModel.get("disabled"));
    };
    SunburstPiece2.prototype._updateLabel = function(seriesModel) {
      var _this = this;
      var itemModel = this.node.getModel();
      var normalLabelModel = itemModel.getModel("label");
      var layout5 = this.node.getLayout();
      var angle = layout5.endAngle - layout5.startAngle;
      var midAngle = (layout5.startAngle + layout5.endAngle) / 2;
      var dx = Math.cos(midAngle);
      var dy = Math.sin(midAngle);
      var sector = this;
      var label = sector.getTextContent();
      var dataIndex = this.node.dataIndex;
      var labelMinAngle = normalLabelModel.get("minAngle") / 180 * Math.PI;
      var isNormalShown = normalLabelModel.get("show") && !(labelMinAngle != null && Math.abs(angle) < labelMinAngle);
      label.ignore = !isNormalShown;
      each(DISPLAY_STATES, function(stateName) {
        var labelStateModel = stateName === "normal" ? itemModel.getModel("label") : itemModel.getModel([stateName, "label"]);
        var isNormal = stateName === "normal";
        var state = isNormal ? label : label.ensureState(stateName);
        var text = seriesModel.getFormattedLabel(dataIndex, stateName);
        if (isNormal) {
          text = text || _this.node.name;
        }
        state.style = createTextStyle(labelStateModel, {}, null, stateName !== "normal", true);
        if (text) {
          state.style.text = text;
        }
        var isShown = labelStateModel.get("show");
        if (isShown != null && !isNormal) {
          state.ignore = !isShown;
        }
        var labelPosition = getLabelAttr(labelStateModel, "position");
        var sectorState = isNormal ? sector : sector.states[stateName];
        var labelColor = sectorState.style.fill;
        sectorState.textConfig = {
          outsideFill: labelStateModel.get("color") === "inherit" ? labelColor : null,
          inside: labelPosition !== "outside"
        };
        var r;
        var labelPadding = getLabelAttr(labelStateModel, "distance") || 0;
        var textAlign = getLabelAttr(labelStateModel, "align");
        if (labelPosition === "outside") {
          r = layout5.r + labelPadding;
          textAlign = midAngle > Math.PI / 2 ? "right" : "left";
        } else {
          if (!textAlign || textAlign === "center") {
            if (angle === 2 * Math.PI && layout5.r0 === 0) {
              r = 0;
            } else {
              r = (layout5.r + layout5.r0) / 2;
            }
            textAlign = "center";
          } else if (textAlign === "left") {
            r = layout5.r0 + labelPadding;
            if (midAngle > Math.PI / 2) {
              textAlign = "right";
            }
          } else if (textAlign === "right") {
            r = layout5.r - labelPadding;
            if (midAngle > Math.PI / 2) {
              textAlign = "left";
            }
          }
        }
        state.style.align = textAlign;
        state.style.verticalAlign = getLabelAttr(labelStateModel, "verticalAlign") || "middle";
        state.x = r * dx + layout5.cx;
        state.y = r * dy + layout5.cy;
        var rotateType = getLabelAttr(labelStateModel, "rotate");
        var rotate2 = 0;
        if (rotateType === "radial") {
          rotate2 = -midAngle;
          if (rotate2 < -Math.PI / 2) {
            rotate2 += Math.PI;
          }
        } else if (rotateType === "tangential") {
          rotate2 = Math.PI / 2 - midAngle;
          if (rotate2 > Math.PI / 2) {
            rotate2 -= Math.PI;
          } else if (rotate2 < -Math.PI / 2) {
            rotate2 += Math.PI;
          }
        } else if (isNumber(rotateType)) {
          rotate2 = rotateType * Math.PI / 180;
        }
        state.rotation = rotate2;
      });
      function getLabelAttr(model, name) {
        var stateAttr = model.get(name);
        if (stateAttr == null) {
          return normalLabelModel.get(name);
        }
        return stateAttr;
      }
      label.dirtyStyle();
    };
    return SunburstPiece2;
  }(Sector_default);
  var SunburstPiece_default = SunburstPiece;

  // node_modules/echarts/lib/chart/sunburst/sunburstAction.js
  var ROOT_TO_NODE_ACTION = "sunburstRootToNode";
  var HIGHLIGHT_ACTION = "sunburstHighlight";
  var UNHIGHLIGHT_ACTION = "sunburstUnhighlight";
  function installSunburstAction(registers) {
    registers.registerAction({
      type: ROOT_TO_NODE_ACTION,
      update: "updateView"
    }, function(payload, ecModel) {
      ecModel.eachComponent({
        mainType: "series",
        subType: "sunburst",
        query: payload
      }, handleRootToNode);
      function handleRootToNode(model, index) {
        var targetInfo = retrieveTargetInfo(payload, [ROOT_TO_NODE_ACTION], model);
        if (targetInfo) {
          var originViewRoot = model.getViewRoot();
          if (originViewRoot) {
            payload.direction = aboveViewRoot(originViewRoot, targetInfo.node) ? "rollUp" : "drillDown";
          }
          model.resetViewRoot(targetInfo.node);
        }
      }
    });
    registers.registerAction({
      type: HIGHLIGHT_ACTION,
      update: "none"
    }, function(payload, ecModel, api) {
      payload = extend({}, payload);
      ecModel.eachComponent({
        mainType: "series",
        subType: "sunburst",
        query: payload
      }, handleHighlight);
      function handleHighlight(model) {
        var targetInfo = retrieveTargetInfo(payload, [HIGHLIGHT_ACTION], model);
        if (targetInfo) {
          payload.dataIndex = targetInfo.node.dataIndex;
        }
      }
      if (true) {
        deprecateReplaceLog("highlight", "sunburstHighlight");
      }
      api.dispatchAction(extend(payload, {
        type: "highlight"
      }));
    });
    registers.registerAction({
      type: UNHIGHLIGHT_ACTION,
      update: "updateView"
    }, function(payload, ecModel, api) {
      payload = extend({}, payload);
      if (true) {
        deprecateReplaceLog("downplay", "sunburstUnhighlight");
      }
      api.dispatchAction(extend(payload, {
        type: "downplay"
      }));
    });
  }

  // node_modules/echarts/lib/chart/sunburst/SunburstView.js
  var SunburstView = function(_super) {
    __extends(SunburstView2, _super);
    function SunburstView2() {
      var _this = _super !== null && _super.apply(this, arguments) || this;
      _this.type = SunburstView2.type;
      return _this;
    }
    SunburstView2.prototype.render = function(seriesModel, ecModel, api, payload) {
      var self2 = this;
      this.seriesModel = seriesModel;
      this.api = api;
      this.ecModel = ecModel;
      var data = seriesModel.getData();
      var virtualRoot = data.tree.root;
      var newRoot = seriesModel.getViewRoot();
      var group = this.group;
      var renderLabelForZeroData = seriesModel.get("renderLabelForZeroData");
      var newChildren = [];
      newRoot.eachNode(function(node) {
        newChildren.push(node);
      });
      var oldChildren = this._oldChildren || [];
      dualTravel(newChildren, oldChildren);
      renderRollUp(virtualRoot, newRoot);
      this._initEvents();
      this._oldChildren = newChildren;
      function dualTravel(newChildren2, oldChildren2) {
        if (newChildren2.length === 0 && oldChildren2.length === 0) {
          return;
        }
        new DataDiffer_default(oldChildren2, newChildren2, getKey2, getKey2).add(processNode).update(processNode).remove(curry(processNode, null)).execute();
        function getKey2(node) {
          return node.getId();
        }
        function processNode(newIdx, oldIdx) {
          var newNode = newIdx == null ? null : newChildren2[newIdx];
          var oldNode = oldIdx == null ? null : oldChildren2[oldIdx];
          doRenderNode(newNode, oldNode);
        }
      }
      function doRenderNode(newNode, oldNode) {
        if (!renderLabelForZeroData && newNode && !newNode.getValue()) {
          newNode = null;
        }
        if (newNode !== virtualRoot && oldNode !== virtualRoot) {
          if (oldNode && oldNode.piece) {
            if (newNode) {
              oldNode.piece.updateData(false, newNode, seriesModel, ecModel, api);
              data.setItemGraphicEl(newNode.dataIndex, oldNode.piece);
            } else {
              removeNode2(oldNode);
            }
          } else if (newNode) {
            var piece = new SunburstPiece_default(newNode, seriesModel, ecModel, api);
            group.add(piece);
            data.setItemGraphicEl(newNode.dataIndex, piece);
          }
        }
      }
      function removeNode2(node) {
        if (!node) {
          return;
        }
        if (node.piece) {
          group.remove(node.piece);
          node.piece = null;
        }
      }
      function renderRollUp(virtualRoot2, viewRoot) {
        if (viewRoot.depth > 0) {
          if (self2.virtualPiece) {
            self2.virtualPiece.updateData(false, virtualRoot2, seriesModel, ecModel, api);
          } else {
            self2.virtualPiece = new SunburstPiece_default(virtualRoot2, seriesModel, ecModel, api);
            group.add(self2.virtualPiece);
          }
          viewRoot.piece.off("click");
          self2.virtualPiece.on("click", function(e2) {
            self2._rootToNode(viewRoot.parentNode);
          });
        } else if (self2.virtualPiece) {
          group.remove(self2.virtualPiece);
          self2.virtualPiece = null;
        }
      }
    };
    SunburstView2.prototype._initEvents = function() {
      var _this = this;
      this.group.off("click");
      this.group.on("click", function(e2) {
        var targetFound = false;
        var viewRoot = _this.seriesModel.getViewRoot();
        viewRoot.eachNode(function(node) {
          if (!targetFound && node.piece && node.piece === e2.target) {
            var nodeClick = node.getModel().get("nodeClick");
            if (nodeClick === "rootToNode") {
              _this._rootToNode(node);
            } else if (nodeClick === "link") {
              var itemModel = node.getModel();
              var link = itemModel.get("link");
              if (link) {
                var linkTarget = itemModel.get("target", true) || "_blank";
                windowOpen(link, linkTarget);
              }
            }
            targetFound = true;
          }
        });
      });
    };
    SunburstView2.prototype._rootToNode = function(node) {
      if (node !== this.seriesModel.getViewRoot()) {
        this.api.dispatchAction({
          type: ROOT_TO_NODE_ACTION,
          from: this.uid,
          seriesId: this.seriesModel.id,
          targetNode: node
        });
      }
    };
    SunburstView2.prototype.containPoint = function(point, seriesModel) {
      var treeRoot = seriesModel.getData();
      var itemLayout = treeRoot.getItemLayout(0);
      if (itemLayout) {
        var dx = point[0] - itemLayout.cx;
        var dy = point[1] - itemLayout.cy;
        var radius = Math.sqrt(dx * dx + dy * dy);
        return radius <= itemLayout.r && radius >= itemLayout.r0;
      }
    };
    SunburstView2.type = "sunburst";
    return SunburstView2;
  }(Chart_default);
  var SunburstView_default = SunburstView;

  // node_modules/echarts/lib/chart/sunburst/SunburstSeries.js
  var SunburstSeriesModel = function(_super) {
    __extends(SunburstSeriesModel2, _super);
    function SunburstSeriesModel2() {
      var _this = _super !== null && _super.apply(this, arguments) || this;
      _this.type = SunburstSeriesModel2.type;
      _this.ignoreStyleOnData = true;
      return _this;
    }
    SunburstSeriesModel2.prototype.getInitialData = function(option, ecModel) {
      var root = {
        name: option.name,
        children: option.data
      };
      completeTreeValue2(root);
      var levelModels = this._levelModels = map(option.levels || [], function(levelDefine) {
        return new Model_default(levelDefine, this, ecModel);
      }, this);
      var tree = Tree_default.createTree(root, this, beforeLink);
      function beforeLink(nodeData) {
        nodeData.wrapMethod("getItemModel", function(model, idx) {
          var node = tree.getNodeByDataIndex(idx);
          var levelModel = levelModels[node.depth];
          levelModel && (model.parentModel = levelModel);
          return model;
        });
      }
      return tree.data;
    };
    SunburstSeriesModel2.prototype.optionUpdated = function() {
      this.resetViewRoot();
    };
    SunburstSeriesModel2.prototype.getDataParams = function(dataIndex) {
      var params = _super.prototype.getDataParams.apply(this, arguments);
      var node = this.getData().tree.getNodeByDataIndex(dataIndex);
      params.treePathInfo = wrapTreePathInfo(node, this);
      return params;
    };
    SunburstSeriesModel2.prototype.getLevelModel = function(node) {
      return this._levelModels && this._levelModels[node.depth];
    };
    SunburstSeriesModel2.prototype.getViewRoot = function() {
      return this._viewRoot;
    };
    SunburstSeriesModel2.prototype.resetViewRoot = function(viewRoot) {
      viewRoot ? this._viewRoot = viewRoot : viewRoot = this._viewRoot;
      var root = this.getRawData().tree.root;
      if (!viewRoot || viewRoot !== root && !root.contains(viewRoot)) {
        this._viewRoot = root;
      }
    };
    SunburstSeriesModel2.prototype.enableAriaDecal = function() {
      enableAriaDecalForTree(this);
    };
    SunburstSeriesModel2.type = "series.sunburst";
    SunburstSeriesModel2.defaultOption = {
      z: 2,
      center: ["50%", "50%"],
      radius: [0, "75%"],
      clockwise: true,
      startAngle: 90,
      minAngle: 0,
      stillShowZeroSum: true,
      nodeClick: "rootToNode",
      renderLabelForZeroData: false,
      label: {
        rotate: "radial",
        show: true,
        opacity: 1,
        align: "center",
        position: "inside",
        distance: 5,
        silent: true
      },
      itemStyle: {
        borderWidth: 1,
        borderColor: "white",
        borderType: "solid",
        shadowBlur: 0,
        shadowColor: "rgba(0, 0, 0, 0.2)",
        shadowOffsetX: 0,
        shadowOffsetY: 0,
        opacity: 1
      },
      emphasis: {
        focus: "descendant"
      },
      blur: {
        itemStyle: {
          opacity: 0.2
        },
        label: {
          opacity: 0.1
        }
      },
      animationType: "expansion",
      animationDuration: 1e3,
      animationDurationUpdate: 500,
      data: [],
      sort: "desc"
    };
    return SunburstSeriesModel2;
  }(Series_default);
  function completeTreeValue2(dataNode) {
    var sum2 = 0;
    each(dataNode.children, function(child) {
      completeTreeValue2(child);
      var childValue = child.value;
      isArray(childValue) && (childValue = childValue[0]);
      sum2 += childValue;
    });
    var thisValue = dataNode.value;
    if (isArray(thisValue)) {
      thisValue = thisValue[0];
    }
    if (thisValue == null || isNaN(thisValue)) {
      thisValue = sum2;
    }
    if (thisValue < 0) {
      thisValue = 0;
    }
    isArray(dataNode.value) ? dataNode.value[0] = thisValue : dataNode.value = thisValue;
  }
  var SunburstSeries_default = SunburstSeriesModel;

  // node_modules/echarts/lib/chart/sunburst/sunburstLayout.js
  var RADIAN3 = Math.PI / 180;
  function sunburstLayout(seriesType2, ecModel, api) {
    ecModel.eachSeriesByType(seriesType2, function(seriesModel) {
      var center3 = seriesModel.get("center");
      var radius = seriesModel.get("radius");
      if (!isArray(radius)) {
        radius = [0, radius];
      }
      if (!isArray(center3)) {
        center3 = [center3, center3];
      }
      var width = api.getWidth();
      var height = api.getHeight();
      var size = Math.min(width, height);
      var cx = parsePercent2(center3[0], width);
      var cy = parsePercent2(center3[1], height);
      var r0 = parsePercent2(radius[0], size / 2);
      var r = parsePercent2(radius[1], size / 2);
      var startAngle = -seriesModel.get("startAngle") * RADIAN3;
      var minAngle = seriesModel.get("minAngle") * RADIAN3;
      var virtualRoot = seriesModel.getData().tree.root;
      var treeRoot = seriesModel.getViewRoot();
      var rootDepth = treeRoot.depth;
      var sort4 = seriesModel.get("sort");
      if (sort4 != null) {
        initChildren2(treeRoot, sort4);
      }
      var validDataCount = 0;
      each(treeRoot.children, function(child) {
        !isNaN(child.getValue()) && validDataCount++;
      });
      var sum2 = treeRoot.getValue();
      var unitRadian = Math.PI / (sum2 || validDataCount) * 2;
      var renderRollupNode = treeRoot.depth > 0;
      var levels = treeRoot.height - (renderRollupNode ? -1 : 1);
      var rPerLevel = (r - r0) / (levels || 1);
      var clockwise = seriesModel.get("clockwise");
      var stillShowZeroSum = seriesModel.get("stillShowZeroSum");
      var dir3 = clockwise ? 1 : -1;
      var renderNode2 = function(node, startAngle2) {
        if (!node) {
          return;
        }
        var endAngle = startAngle2;
        if (node !== virtualRoot) {
          var value = node.getValue();
          var angle2 = sum2 === 0 && stillShowZeroSum ? unitRadian : value * unitRadian;
          if (angle2 < minAngle) {
            angle2 = minAngle;
          }
          endAngle = startAngle2 + dir3 * angle2;
          var depth = node.depth - rootDepth - (renderRollupNode ? -1 : 1);
          var rStart2 = r0 + rPerLevel * depth;
          var rEnd2 = r0 + rPerLevel * (depth + 1);
          var levelModel = seriesModel.getLevelModel(node);
          if (levelModel) {
            var r0_1 = levelModel.get("r0", true);
            var r_1 = levelModel.get("r", true);
            var radius_1 = levelModel.get("radius", true);
            if (radius_1 != null) {
              r0_1 = radius_1[0];
              r_1 = radius_1[1];
            }
            r0_1 != null && (rStart2 = parsePercent2(r0_1, size / 2));
            r_1 != null && (rEnd2 = parsePercent2(r_1, size / 2));
          }
          node.setLayout({
            angle: angle2,
            startAngle: startAngle2,
            endAngle,
            clockwise,
            cx,
            cy,
            r0: rStart2,
            r: rEnd2
          });
        }
        if (node.children && node.children.length) {
          var siblingAngle_1 = 0;
          each(node.children, function(node2) {
            siblingAngle_1 += renderNode2(node2, startAngle2 + siblingAngle_1);
          });
        }
        return endAngle - startAngle2;
      };
      if (renderRollupNode) {
        var rStart = r0;
        var rEnd = r0 + rPerLevel;
        var angle = Math.PI * 2;
        virtualRoot.setLayout({
          angle,
          startAngle,
          endAngle: startAngle + angle,
          clockwise,
          cx,
          cy,
          r0: rStart,
          r: rEnd
        });
      }
      renderNode2(treeRoot, startAngle);
    });
  }
  function initChildren2(node, sortOrder) {
    var children = node.children || [];
    node.children = sort3(children, sortOrder);
    if (children.length) {
      each(node.children, function(child) {
        initChildren2(child, sortOrder);
      });
    }
  }
  function sort3(children, sortOrder) {
    if (isFunction(sortOrder)) {
      var sortTargets = map(children, function(child, idx) {
        var value = child.getValue();
        return {
          params: {
            depth: child.depth,
            height: child.height,
            dataIndex: child.dataIndex,
            getValue: function() {
              return value;
            }
          },
          index: idx
        };
      });
      sortTargets.sort(function(a, b) {
        return sortOrder(a.params, b.params);
      });
      return map(sortTargets, function(target) {
        return children[target.index];
      });
    } else {
      var isAsc_1 = sortOrder === "asc";
      return children.sort(function(a, b) {
        var diff = (a.getValue() - b.getValue()) * (isAsc_1 ? 1 : -1);
        return diff === 0 ? (a.dataIndex - b.dataIndex) * (isAsc_1 ? -1 : 1) : diff;
      });
    }
  }

  // node_modules/echarts/lib/chart/sunburst/sunburstVisual.js
  function sunburstVisual(ecModel) {
    var paletteScope = {};
    function pickColor(node, seriesModel, treeHeight) {
      var current = node;
      while (current && current.depth > 1) {
        current = current.parentNode;
      }
      var color = seriesModel.getColorFromPalette(current.name || current.dataIndex + "", paletteScope);
      if (node.depth > 1 && isString(color)) {
        color = lift(color, (node.depth - 1) / (treeHeight - 1) * 0.5);
      }
      return color;
    }
    ecModel.eachSeriesByType("sunburst", function(seriesModel) {
      var data = seriesModel.getData();
      var tree = data.tree;
      tree.eachNode(function(node) {
        var model = node.getModel();
        var style = model.getModel("itemStyle").getItemStyle();
        if (!style.fill) {
          style.fill = pickColor(node, seriesModel, tree.root.height);
        }
        var existsStyle = data.ensureUniqueItemVisual(node.dataIndex, "style");
        extend(existsStyle, style);
      });
    });
  }

  // node_modules/echarts/lib/chart/sunburst/install.js
  function install27(registers) {
    registers.registerChartView(SunburstView_default);
    registers.registerSeriesModel(SunburstSeries_default);
    registers.registerLayout(curry(sunburstLayout, "sunburst"));
    registers.registerProcessor(curry(dataFilter, "sunburst"));
    registers.registerVisual(sunburstVisual);
    installSunburstAction(registers);
  }

  // node_modules/echarts/lib/chart/custom/CustomSeries.js
  var STYLE_VISUAL_TYPE = {
    color: "fill",
    borderColor: "stroke"
  };
  var NON_STYLE_VISUAL_PROPS = {
    symbol: 1,
    symbolSize: 1,
    symbolKeepAspect: 1,
    legendIcon: 1,
    visualMeta: 1,
    liftZ: 1,
    decal: 1
  };
  var customInnerStore = makeInner();
  var CustomSeriesModel = function(_super) {
    __extends(CustomSeriesModel2, _super);
    function CustomSeriesModel2() {
      var _this = _super !== null && _super.apply(this, arguments) || this;
      _this.type = CustomSeriesModel2.type;
      return _this;
    }
    CustomSeriesModel2.prototype.optionUpdated = function() {
      this.currentZLevel = this.get("zlevel", true);
      this.currentZ = this.get("z", true);
    };
    CustomSeriesModel2.prototype.getInitialData = function(option, ecModel) {
      return createSeriesData_default(null, this);
    };
    CustomSeriesModel2.prototype.getDataParams = function(dataIndex, dataType, el) {
      var params = _super.prototype.getDataParams.call(this, dataIndex, dataType);
      el && (params.info = customInnerStore(el).info);
      return params;
    };
    CustomSeriesModel2.type = "series.custom";
    CustomSeriesModel2.dependencies = ["grid", "polar", "geo", "singleAxis", "calendar"];
    CustomSeriesModel2.defaultOption = {
      coordinateSystem: "cartesian2d",
      z: 2,
      legendHoverLink: true,
      clip: false
    };
    return CustomSeriesModel2;
  }(Series_default);
  var CustomSeries_default = CustomSeriesModel;

  // node_modules/echarts/lib/coord/cartesian/prepareCustom.js
  function dataToCoordSize(dataSize, dataItem) {
    dataItem = dataItem || [0, 0];
    return map(["x", "y"], function(dim, dimIdx) {
      var axis = this.getAxis(dim);
      var val = dataItem[dimIdx];
      var halfSize = dataSize[dimIdx] / 2;
      return axis.type === "category" ? axis.getBandWidth() : Math.abs(axis.dataToCoord(val - halfSize) - axis.dataToCoord(val + halfSize));
    }, this);
  }
  function cartesianPrepareCustom(coordSys) {
    var rect = coordSys.master.getRect();
    return {
      coordSys: {
        type: "cartesian2d",
        x: rect.x,
        y: rect.y,
        width: rect.width,
        height: rect.height
      },
      api: {
        coord: function(data) {
          return coordSys.dataToPoint(data);
        },
        size: bind(dataToCoordSize, coordSys)
      }
    };
  }

  // node_modules/echarts/lib/coord/geo/prepareCustom.js
  function dataToCoordSize2(dataSize, dataItem) {
    dataItem = dataItem || [0, 0];
    return map([0, 1], function(dimIdx) {
      var val = dataItem[dimIdx];
      var halfSize = dataSize[dimIdx] / 2;
      var p1 = [];
      var p2 = [];
      p1[dimIdx] = val - halfSize;
      p2[dimIdx] = val + halfSize;
      p1[1 - dimIdx] = p2[1 - dimIdx] = dataItem[1 - dimIdx];
      return Math.abs(this.dataToPoint(p1)[dimIdx] - this.dataToPoint(p2)[dimIdx]);
    }, this);
  }
  function geoPrepareCustom(coordSys) {
    var rect = coordSys.getBoundingRect();
    return {
      coordSys: {
        type: "geo",
        x: rect.x,
        y: rect.y,
        width: rect.width,
        height: rect.height,
        zoom: coordSys.getZoom()
      },
      api: {
        coord: function(data) {
          return coordSys.dataToPoint(data);
        },
        size: bind(dataToCoordSize2, coordSys)
      }
    };
  }

  // node_modules/echarts/lib/coord/single/prepareCustom.js
  function dataToCoordSize3(dataSize, dataItem) {
    var axis = this.getAxis();
    var val = dataItem instanceof Array ? dataItem[0] : dataItem;
    var halfSize = (dataSize instanceof Array ? dataSize[0] : dataSize) / 2;
    return axis.type === "category" ? axis.getBandWidth() : Math.abs(axis.dataToCoord(val - halfSize) - axis.dataToCoord(val + halfSize));
  }
  function singlePrepareCustom(coordSys) {
    var rect = coordSys.getRect();
    return {
      coordSys: {
        type: "singleAxis",
        x: rect.x,
        y: rect.y,
        width: rect.width,
        height: rect.height
      },
      api: {
        coord: function(val) {
          return coordSys.dataToPoint(val);
        },
        size: bind(dataToCoordSize3, coordSys)
      }
    };
  }

  // node_modules/echarts/lib/coord/polar/prepareCustom.js
  function dataToCoordSize4(dataSize, dataItem) {
    dataItem = dataItem || [0, 0];
    return map(["Radius", "Angle"], function(dim, dimIdx) {
      var getterName = "get" + dim + "Axis";
      var axis = this[getterName]();
      var val = dataItem[dimIdx];
      var halfSize = dataSize[dimIdx] / 2;
      var result = axis.type === "category" ? axis.getBandWidth() : Math.abs(axis.dataToCoord(val - halfSize) - axis.dataToCoord(val + halfSize));
      if (dim === "Angle") {
        result = result * Math.PI / 180;
      }
      return result;
    }, this);
  }
  function polarPrepareCustom(coordSys) {
    var radiusAxis = coordSys.getRadiusAxis();
    var angleAxis = coordSys.getAngleAxis();
    var radius = radiusAxis.getExtent();
    radius[0] > radius[1] && radius.reverse();
    return {
      coordSys: {
        type: "polar",
        cx: coordSys.cx,
        cy: coordSys.cy,
        r: radius[1],
        r0: radius[0]
      },
      api: {
        coord: function(data) {
          var radius2 = radiusAxis.dataToRadius(data[0]);
          var angle = angleAxis.dataToAngle(data[1]);
          var coord = coordSys.coordToPoint([radius2, angle]);
          coord.push(radius2, angle * Math.PI / 180);
          return coord;
        },
        size: bind(dataToCoordSize4, coordSys)
      }
    };
  }

  // node_modules/echarts/lib/coord/calendar/prepareCustom.js
  function calendarPrepareCustom(coordSys) {
    var rect = coordSys.getRect();
    var rangeInfo = coordSys.getRangeInfo();
    return {
      coordSys: {
        type: "calendar",
        x: rect.x,
        y: rect.y,
        width: rect.width,
        height: rect.height,
        cellWidth: coordSys.getCellWidth(),
        cellHeight: coordSys.getCellHeight(),
        rangeInfo: {
          start: rangeInfo.start,
          end: rangeInfo.end,
          weeks: rangeInfo.weeks,
          dayCount: rangeInfo.allDay
        }
      },
      api: {
        coord: function(data, clamp2) {
          return coordSys.dataToPoint(data, clamp2);
        }
      }
    };
  }

  // node_modules/echarts/lib/util/styleCompat.js
  var deprecatedLogs = {};
  function isEC4CompatibleStyle(style, elType, hasOwnTextContentOption, hasOwnTextConfig) {
    return style && (style.legacy || style.legacy !== false && !hasOwnTextContentOption && !hasOwnTextConfig && elType !== "tspan" && (elType === "text" || hasOwn(style, "text")));
  }
  function convertFromEC4CompatibleStyle(hostStyle, elType, isNormal) {
    var srcStyle = hostStyle;
    var textConfig;
    var textContent;
    var textContentStyle;
    if (elType === "text") {
      textContentStyle = srcStyle;
    } else {
      textContentStyle = {};
      hasOwn(srcStyle, "text") && (textContentStyle.text = srcStyle.text);
      hasOwn(srcStyle, "rich") && (textContentStyle.rich = srcStyle.rich);
      hasOwn(srcStyle, "textFill") && (textContentStyle.fill = srcStyle.textFill);
      hasOwn(srcStyle, "textStroke") && (textContentStyle.stroke = srcStyle.textStroke);
      hasOwn(srcStyle, "fontFamily") && (textContentStyle.fontFamily = srcStyle.fontFamily);
      hasOwn(srcStyle, "fontSize") && (textContentStyle.fontSize = srcStyle.fontSize);
      hasOwn(srcStyle, "fontStyle") && (textContentStyle.fontStyle = srcStyle.fontStyle);
      hasOwn(srcStyle, "fontWeight") && (textContentStyle.fontWeight = srcStyle.fontWeight);
      textContent = {
        type: "text",
        style: textContentStyle,
        silent: true
      };
      textConfig = {};
      var hasOwnPos = hasOwn(srcStyle, "textPosition");
      if (isNormal) {
        textConfig.position = hasOwnPos ? srcStyle.textPosition : "inside";
      } else {
        hasOwnPos && (textConfig.position = srcStyle.textPosition);
      }
      hasOwn(srcStyle, "textPosition") && (textConfig.position = srcStyle.textPosition);
      hasOwn(srcStyle, "textOffset") && (textConfig.offset = srcStyle.textOffset);
      hasOwn(srcStyle, "textRotation") && (textConfig.rotation = srcStyle.textRotation);
      hasOwn(srcStyle, "textDistance") && (textConfig.distance = srcStyle.textDistance);
    }
    convertEC4CompatibleRichItem(textContentStyle, hostStyle);
    each(textContentStyle.rich, function(richItem) {
      convertEC4CompatibleRichItem(richItem, richItem);
    });
    return {
      textConfig,
      textContent
    };
  }
  function convertEC4CompatibleRichItem(out2, richItem) {
    if (!richItem) {
      return;
    }
    richItem.font = richItem.textFont || richItem.font;
    hasOwn(richItem, "textStrokeWidth") && (out2.lineWidth = richItem.textStrokeWidth);
    hasOwn(richItem, "textAlign") && (out2.align = richItem.textAlign);
    hasOwn(richItem, "textVerticalAlign") && (out2.verticalAlign = richItem.textVerticalAlign);
    hasOwn(richItem, "textLineHeight") && (out2.lineHeight = richItem.textLineHeight);
    hasOwn(richItem, "textWidth") && (out2.width = richItem.textWidth);
    hasOwn(richItem, "textHeight") && (out2.height = richItem.textHeight);
    hasOwn(richItem, "textBackgroundColor") && (out2.backgroundColor = richItem.textBackgroundColor);
    hasOwn(richItem, "textPadding") && (out2.padding = richItem.textPadding);
    hasOwn(richItem, "textBorderColor") && (out2.borderColor = richItem.textBorderColor);
    hasOwn(richItem, "textBorderWidth") && (out2.borderWidth = richItem.textBorderWidth);
    hasOwn(richItem, "textBorderRadius") && (out2.borderRadius = richItem.textBorderRadius);
    hasOwn(richItem, "textBoxShadowColor") && (out2.shadowColor = richItem.textBoxShadowColor);
    hasOwn(richItem, "textBoxShadowBlur") && (out2.shadowBlur = richItem.textBoxShadowBlur);
    hasOwn(richItem, "textBoxShadowOffsetX") && (out2.shadowOffsetX = richItem.textBoxShadowOffsetX);
    hasOwn(richItem, "textBoxShadowOffsetY") && (out2.shadowOffsetY = richItem.textBoxShadowOffsetY);
  }
  function convertToEC4StyleForCustomSerise(itemStl, txStl, txCfg) {
    var out2 = itemStl;
    out2.textPosition = out2.textPosition || txCfg.position || "inside";
    txCfg.offset != null && (out2.textOffset = txCfg.offset);
    txCfg.rotation != null && (out2.textRotation = txCfg.rotation);
    txCfg.distance != null && (out2.textDistance = txCfg.distance);
    var isInside = out2.textPosition.indexOf("inside") >= 0;
    var hostFill = itemStl.fill || "#000";
    convertToEC4RichItem(out2, txStl);
    var textFillNotSet = out2.textFill == null;
    if (isInside) {
      if (textFillNotSet) {
        out2.textFill = txCfg.insideFill || "#fff";
        !out2.textStroke && txCfg.insideStroke && (out2.textStroke = txCfg.insideStroke);
        !out2.textStroke && (out2.textStroke = hostFill);
        out2.textStrokeWidth == null && (out2.textStrokeWidth = 2);
      }
    } else {
      if (textFillNotSet) {
        out2.textFill = itemStl.fill || txCfg.outsideFill || "#000";
      }
      !out2.textStroke && txCfg.outsideStroke && (out2.textStroke = txCfg.outsideStroke);
    }
    out2.text = txStl.text;
    out2.rich = txStl.rich;
    each(txStl.rich, function(richItem) {
      convertToEC4RichItem(richItem, richItem);
    });
    return out2;
  }
  function convertToEC4RichItem(out2, richItem) {
    if (!richItem) {
      return;
    }
    hasOwn(richItem, "fill") && (out2.textFill = richItem.fill);
    hasOwn(richItem, "stroke") && (out2.textStroke = richItem.fill);
    hasOwn(richItem, "lineWidth") && (out2.textStrokeWidth = richItem.lineWidth);
    hasOwn(richItem, "font") && (out2.font = richItem.font);
    hasOwn(richItem, "fontStyle") && (out2.fontStyle = richItem.fontStyle);
    hasOwn(richItem, "fontWeight") && (out2.fontWeight = richItem.fontWeight);
    hasOwn(richItem, "fontSize") && (out2.fontSize = richItem.fontSize);
    hasOwn(richItem, "fontFamily") && (out2.fontFamily = richItem.fontFamily);
    hasOwn(richItem, "align") && (out2.textAlign = richItem.align);
    hasOwn(richItem, "verticalAlign") && (out2.textVerticalAlign = richItem.verticalAlign);
    hasOwn(richItem, "lineHeight") && (out2.textLineHeight = richItem.lineHeight);
    hasOwn(richItem, "width") && (out2.textWidth = richItem.width);
    hasOwn(richItem, "height") && (out2.textHeight = richItem.height);
    hasOwn(richItem, "backgroundColor") && (out2.textBackgroundColor = richItem.backgroundColor);
    hasOwn(richItem, "padding") && (out2.textPadding = richItem.padding);
    hasOwn(richItem, "borderColor") && (out2.textBorderColor = richItem.borderColor);
    hasOwn(richItem, "borderWidth") && (out2.textBorderWidth = richItem.borderWidth);
    hasOwn(richItem, "borderRadius") && (out2.textBorderRadius = richItem.borderRadius);
    hasOwn(richItem, "shadowColor") && (out2.textBoxShadowColor = richItem.shadowColor);
    hasOwn(richItem, "shadowBlur") && (out2.textBoxShadowBlur = richItem.shadowBlur);
    hasOwn(richItem, "shadowOffsetX") && (out2.textBoxShadowOffsetX = richItem.shadowOffsetX);
    hasOwn(richItem, "shadowOffsetY") && (out2.textBoxShadowOffsetY = richItem.shadowOffsetY);
    hasOwn(richItem, "textShadowColor") && (out2.textShadowColor = richItem.textShadowColor);
    hasOwn(richItem, "textShadowBlur") && (out2.textShadowBlur = richItem.textShadowBlur);
    hasOwn(richItem, "textShadowOffsetX") && (out2.textShadowOffsetX = richItem.textShadowOffsetX);
    hasOwn(richItem, "textShadowOffsetY") && (out2.textShadowOffsetY = richItem.textShadowOffsetY);
  }
  function warnDeprecated(deprecated, insteadApproach) {
    if (true) {
      var key = deprecated + "^_^" + insteadApproach;
      if (!deprecatedLogs[key]) {
        console.warn('[ECharts] DEPRECATED: "' + deprecated + '" has been deprecated. ' + insteadApproach);
        deprecatedLogs[key] = true;
      }
    }
  }

  // node_modules/echarts/lib/animation/customGraphicTransition.js
  var LEGACY_TRANSFORM_PROPS_MAP = {
    position: ["x", "y"],
    scale: ["scaleX", "scaleY"],
    origin: ["originX", "originY"]
  };
  var LEGACY_TRANSFORM_PROPS = keys(LEGACY_TRANSFORM_PROPS_MAP);
  var TRANSFORM_PROPS_MAP = reduce(TRANSFORMABLE_PROPS, function(obj, key) {
    obj[key] = 1;
    return obj;
  }, {});
  var transformPropNamesStr = TRANSFORMABLE_PROPS.join(", ");
  var ELEMENT_ANIMATABLE_PROPS = ["", "style", "shape", "extra"];
  var transitionInnerStore = makeInner();
  function getElementAnimationConfig(animationType, el, elOption, parentModel, dataIndex) {
    var animationProp = animationType + "Animation";
    var config = getAnimationConfig(animationType, parentModel, dataIndex) || {};
    var userDuring = transitionInnerStore(el).userDuring;
    if (config.duration > 0) {
      config.during = userDuring ? bind(duringCall, {
        el,
        userDuring
      }) : null;
      config.setToFinal = true;
      config.scope = animationType;
    }
    extend(config, elOption[animationProp]);
    return config;
  }
  function applyUpdateTransition(el, elOption, animatableModel, opts) {
    opts = opts || {};
    var dataIndex = opts.dataIndex, isInit = opts.isInit, clearStyle = opts.clearStyle;
    var hasAnimation = animatableModel.isAnimationEnabled();
    var store = transitionInnerStore(el);
    var styleOpt = elOption.style;
    store.userDuring = elOption.during;
    var transFromProps = {};
    var propsToSet = {};
    prepareTransformAllPropsFinal(el, elOption, propsToSet);
    prepareShapeOrExtraAllPropsFinal("shape", elOption, propsToSet);
    prepareShapeOrExtraAllPropsFinal("extra", elOption, propsToSet);
    if (!isInit && hasAnimation) {
      prepareTransformTransitionFrom(el, elOption, transFromProps);
      prepareShapeOrExtraTransitionFrom("shape", el, elOption, transFromProps);
      prepareShapeOrExtraTransitionFrom("extra", el, elOption, transFromProps);
      prepareStyleTransitionFrom(el, elOption, styleOpt, transFromProps);
    }
    propsToSet.style = styleOpt;
    applyPropsDirectly(el, propsToSet, clearStyle);
    applyMiscProps(el, elOption);
    if (hasAnimation) {
      if (isInit) {
        var enterFromProps_1 = {};
        each(ELEMENT_ANIMATABLE_PROPS, function(propName) {
          var prop = propName ? elOption[propName] : elOption;
          if (prop && prop.enterFrom) {
            if (propName) {
              enterFromProps_1[propName] = enterFromProps_1[propName] || {};
            }
            extend(propName ? enterFromProps_1[propName] : enterFromProps_1, prop.enterFrom);
          }
        });
        var config = getElementAnimationConfig("enter", el, elOption, animatableModel, dataIndex);
        if (config.duration > 0) {
          el.animateFrom(enterFromProps_1, config);
        }
      } else {
        applyPropsTransition(el, elOption, dataIndex || 0, animatableModel, transFromProps);
      }
    }
    updateLeaveTo(el, elOption);
    styleOpt ? el.dirty() : el.markRedraw();
  }
  function updateLeaveTo(el, elOption) {
    var leaveToProps = transitionInnerStore(el).leaveToProps;
    for (var i = 0; i < ELEMENT_ANIMATABLE_PROPS.length; i++) {
      var propName = ELEMENT_ANIMATABLE_PROPS[i];
      var prop = propName ? elOption[propName] : elOption;
      if (prop && prop.leaveTo) {
        if (!leaveToProps) {
          leaveToProps = transitionInnerStore(el).leaveToProps = {};
        }
        if (propName) {
          leaveToProps[propName] = leaveToProps[propName] || {};
        }
        extend(propName ? leaveToProps[propName] : leaveToProps, prop.leaveTo);
      }
    }
  }
  function applyLeaveTransition(el, elOption, animatableModel, onRemove) {
    if (el) {
      var parent_1 = el.parent;
      var leaveToProps = transitionInnerStore(el).leaveToProps;
      if (leaveToProps) {
        var config = getElementAnimationConfig("update", el, elOption, animatableModel, 0);
        config.done = function() {
          parent_1.remove(el);
          onRemove && onRemove();
        };
        el.animateTo(leaveToProps, config);
      } else {
        parent_1.remove(el);
        onRemove && onRemove();
      }
    }
  }
  function isTransitionAll(transition) {
    return transition === "all";
  }
  function applyPropsDirectly(el, allPropsFinal, clearStyle) {
    var styleOpt = allPropsFinal.style;
    if (!el.isGroup && styleOpt) {
      if (clearStyle) {
        el.useStyle({});
        var animators = el.animators;
        for (var i = 0; i < animators.length; i++) {
          var animator = animators[i];
          if (animator.targetName === "style") {
            animator.changeTarget(el.style);
          }
        }
      }
      el.setStyle(styleOpt);
    }
    if (allPropsFinal) {
      allPropsFinal.style = null;
      allPropsFinal && el.attr(allPropsFinal);
      allPropsFinal.style = styleOpt;
    }
  }
  function applyPropsTransition(el, elOption, dataIndex, model, transFromProps) {
    if (transFromProps) {
      var config = getElementAnimationConfig("update", el, elOption, model, dataIndex);
      if (config.duration > 0) {
        el.animateFrom(transFromProps, config);
      }
    }
  }
  function applyMiscProps(el, elOption) {
    hasOwn(elOption, "silent") && (el.silent = elOption.silent);
    hasOwn(elOption, "ignore") && (el.ignore = elOption.ignore);
    if (el instanceof Displayable_default) {
      hasOwn(elOption, "invisible") && (el.invisible = elOption.invisible);
    }
    if (el instanceof Path_default) {
      hasOwn(elOption, "autoBatch") && (el.autoBatch = elOption.autoBatch);
    }
  }
  var tmpDuringScope = {};
  var transitionDuringAPI = {
    setTransform: function(key, val) {
      if (true) {
        assert(hasOwn(TRANSFORM_PROPS_MAP, key), "Only " + transformPropNamesStr + " available in `setTransform`.");
      }
      tmpDuringScope.el[key] = val;
      return this;
    },
    getTransform: function(key) {
      if (true) {
        assert(hasOwn(TRANSFORM_PROPS_MAP, key), "Only " + transformPropNamesStr + " available in `getTransform`.");
      }
      return tmpDuringScope.el[key];
    },
    setShape: function(key, val) {
      if (true) {
        assertNotReserved(key);
      }
      var el = tmpDuringScope.el;
      var shape = el.shape || (el.shape = {});
      shape[key] = val;
      el.dirtyShape && el.dirtyShape();
      return this;
    },
    getShape: function(key) {
      if (true) {
        assertNotReserved(key);
      }
      var shape = tmpDuringScope.el.shape;
      if (shape) {
        return shape[key];
      }
    },
    setStyle: function(key, val) {
      if (true) {
        assertNotReserved(key);
      }
      var el = tmpDuringScope.el;
      var style = el.style;
      if (style) {
        if (true) {
          if (eqNaN(val)) {
            warn("style." + key + " must not be assigned with NaN.");
          }
        }
        style[key] = val;
        el.dirtyStyle && el.dirtyStyle();
      }
      return this;
    },
    getStyle: function(key) {
      if (true) {
        assertNotReserved(key);
      }
      var style = tmpDuringScope.el.style;
      if (style) {
        return style[key];
      }
    },
    setExtra: function(key, val) {
      if (true) {
        assertNotReserved(key);
      }
      var extra = tmpDuringScope.el.extra || (tmpDuringScope.el.extra = {});
      extra[key] = val;
      return this;
    },
    getExtra: function(key) {
      if (true) {
        assertNotReserved(key);
      }
      var extra = tmpDuringScope.el.extra;
      if (extra) {
        return extra[key];
      }
    }
  };
  function assertNotReserved(key) {
    if (true) {
      if (key === "transition" || key === "enterFrom" || key === "leaveTo") {
        throw new Error('key must not be "' + key + '"');
      }
    }
  }
  function duringCall() {
    var scope = this;
    var el = scope.el;
    if (!el) {
      return;
    }
    var latestUserDuring = transitionInnerStore(el).userDuring;
    var scopeUserDuring = scope.userDuring;
    if (latestUserDuring !== scopeUserDuring) {
      scope.el = scope.userDuring = null;
      return;
    }
    tmpDuringScope.el = el;
    scopeUserDuring(transitionDuringAPI);
  }
  function prepareShapeOrExtraTransitionFrom(mainAttr, fromEl, elOption, transFromProps) {
    var attrOpt = elOption[mainAttr];
    if (!attrOpt) {
      return;
    }
    var elPropsInAttr = fromEl[mainAttr];
    var transFromPropsInAttr;
    if (elPropsInAttr) {
      var transition = elOption.transition;
      var attrTransition = attrOpt.transition;
      if (attrTransition) {
        !transFromPropsInAttr && (transFromPropsInAttr = transFromProps[mainAttr] = {});
        if (isTransitionAll(attrTransition)) {
          extend(transFromPropsInAttr, elPropsInAttr);
        } else {
          var transitionKeys = normalizeToArray(attrTransition);
          for (var i = 0; i < transitionKeys.length; i++) {
            var key = transitionKeys[i];
            var elVal = elPropsInAttr[key];
            transFromPropsInAttr[key] = elVal;
          }
        }
      } else if (isTransitionAll(transition) || indexOf(transition, mainAttr) >= 0) {
        !transFromPropsInAttr && (transFromPropsInAttr = transFromProps[mainAttr] = {});
        var elPropsInAttrKeys = keys(elPropsInAttr);
        for (var i = 0; i < elPropsInAttrKeys.length; i++) {
          var key = elPropsInAttrKeys[i];
          var elVal = elPropsInAttr[key];
          if (isNonStyleTransitionEnabled(attrOpt[key], elVal)) {
            transFromPropsInAttr[key] = elVal;
          }
        }
      }
    }
  }
  function prepareShapeOrExtraAllPropsFinal(mainAttr, elOption, allProps) {
    var attrOpt = elOption[mainAttr];
    if (!attrOpt) {
      return;
    }
    var allPropsInAttr = allProps[mainAttr] = {};
    var keysInAttr = keys(attrOpt);
    for (var i = 0; i < keysInAttr.length; i++) {
      var key = keysInAttr[i];
      allPropsInAttr[key] = cloneValue(attrOpt[key]);
    }
  }
  function prepareTransformTransitionFrom(el, elOption, transFromProps) {
    var transition = elOption.transition;
    var transitionKeys = isTransitionAll(transition) ? TRANSFORMABLE_PROPS : normalizeToArray(transition || []);
    for (var i = 0; i < transitionKeys.length; i++) {
      var key = transitionKeys[i];
      if (key === "style" || key === "shape" || key === "extra") {
        continue;
      }
      var elVal = el[key];
      if (true) {
        checkTransformPropRefer(key, "el.transition");
      }
      transFromProps[key] = elVal;
    }
  }
  function prepareTransformAllPropsFinal(el, elOption, allProps) {
    for (var i = 0; i < LEGACY_TRANSFORM_PROPS.length; i++) {
      var legacyName = LEGACY_TRANSFORM_PROPS[i];
      var xyName = LEGACY_TRANSFORM_PROPS_MAP[legacyName];
      var legacyArr = elOption[legacyName];
      if (legacyArr) {
        allProps[xyName[0]] = legacyArr[0];
        allProps[xyName[1]] = legacyArr[1];
      }
    }
    for (var i = 0; i < TRANSFORMABLE_PROPS.length; i++) {
      var key = TRANSFORMABLE_PROPS[i];
      if (elOption[key] != null) {
        allProps[key] = elOption[key];
      }
    }
  }
  function prepareStyleTransitionFrom(fromEl, elOption, styleOpt, transFromProps) {
    if (!styleOpt) {
      return;
    }
    var fromElStyle = fromEl.style;
    var transFromStyleProps;
    if (fromElStyle) {
      var styleTransition = styleOpt.transition;
      var elTransition = elOption.transition;
      if (styleTransition && !isTransitionAll(styleTransition)) {
        var transitionKeys = normalizeToArray(styleTransition);
        !transFromStyleProps && (transFromStyleProps = transFromProps.style = {});
        for (var i = 0; i < transitionKeys.length; i++) {
          var key = transitionKeys[i];
          var elVal = fromElStyle[key];
          transFromStyleProps[key] = elVal;
        }
      } else if (fromEl.getAnimationStyleProps && (isTransitionAll(elTransition) || isTransitionAll(styleTransition) || indexOf(elTransition, "style") >= 0)) {
        var animationProps = fromEl.getAnimationStyleProps();
        var animationStyleProps = animationProps ? animationProps.style : null;
        if (animationStyleProps) {
          !transFromStyleProps && (transFromStyleProps = transFromProps.style = {});
          var styleKeys = keys(styleOpt);
          for (var i = 0; i < styleKeys.length; i++) {
            var key = styleKeys[i];
            if (animationStyleProps[key]) {
              var elVal = fromElStyle[key];
              transFromStyleProps[key] = elVal;
            }
          }
        }
      }
    }
  }
  function isNonStyleTransitionEnabled(optVal, elVal) {
    return !isArrayLike(optVal) ? optVal != null && isFinite(optVal) : optVal !== elVal;
  }
  var checkTransformPropRefer;
  if (true) {
    checkTransformPropRefer = function(key, usedIn) {
      if (!hasOwn(TRANSFORM_PROPS_MAP, key)) {
        warn("Prop `" + key + "` is not a permitted in `" + usedIn + "`. Only `" + keys(TRANSFORM_PROPS_MAP).join("`, `") + "` are permitted.");
      }
    };
  }

  // node_modules/echarts/lib/animation/customGraphicKeyframeAnimation.js
  var getStateToRestore = makeInner();
  var KEYFRAME_EXCLUDE_KEYS = ["percent", "easing", "shape", "style", "extra"];
  function stopPreviousKeyframeAnimationAndRestore(el) {
    el.stopAnimation("keyframe");
    el.attr(getStateToRestore(el));
  }
  function applyKeyframeAnimation(el, animationOpts, animatableModel) {
    if (!animatableModel.isAnimationEnabled() || !animationOpts) {
      return;
    }
    if (isArray(animationOpts)) {
      each(animationOpts, function(singleAnimationOpts) {
        applyKeyframeAnimation(el, singleAnimationOpts, animatableModel);
      });
      return;
    }
    var keyframes = animationOpts.keyframes;
    var duration = animationOpts.duration;
    if (animatableModel && duration == null) {
      var config = getAnimationConfig("enter", animatableModel, 0);
      duration = config && config.duration;
    }
    if (!keyframes || !duration) {
      return;
    }
    var stateToRestore = getStateToRestore(el);
    each(ELEMENT_ANIMATABLE_PROPS, function(targetPropName) {
      if (targetPropName && !el[targetPropName]) {
        return;
      }
      var animator;
      var endFrameIsSet = false;
      keyframes.sort(function(a, b) {
        return a.percent - b.percent;
      });
      each(keyframes, function(kf) {
        var animators = el.animators;
        var kfValues = targetPropName ? kf[targetPropName] : kf;
        if (true) {
          if (kf.percent >= 1) {
            endFrameIsSet = true;
          }
        }
        if (!kfValues) {
          return;
        }
        var propKeys = keys(kfValues);
        if (!targetPropName) {
          propKeys = filter(propKeys, function(key) {
            return indexOf(KEYFRAME_EXCLUDE_KEYS, key) < 0;
          });
        }
        if (!propKeys.length) {
          return;
        }
        if (!animator) {
          animator = el.animate(targetPropName, animationOpts.loop, true);
          animator.scope = "keyframe";
        }
        for (var i = 0; i < animators.length; i++) {
          if (animators[i] !== animator && animators[i].targetName === animator.targetName) {
            animators[i].stopTracks(propKeys);
          }
        }
        targetPropName && (stateToRestore[targetPropName] = stateToRestore[targetPropName] || {});
        var savedTarget = targetPropName ? stateToRestore[targetPropName] : stateToRestore;
        each(propKeys, function(key) {
          savedTarget[key] = ((targetPropName ? el[targetPropName] : el) || {})[key];
        });
        animator.whenWithKeys(duration * kf.percent, kfValues, propKeys, kf.easing);
      });
      if (!animator) {
        return;
      }
      if (true) {
        if (!endFrameIsSet) {
          warn("End frame with percent: 1 is missing in the keyframeAnimation.", true);
        }
      }
      animator.delay(animationOpts.delay || 0).duration(duration).start(animationOpts.easing);
    });
  }

  // node_modules/echarts/lib/chart/custom/CustomView.js
  var EMPHASIS = "emphasis";
  var NORMAL = "normal";
  var BLUR = "blur";
  var SELECT = "select";
  var STATES = [NORMAL, EMPHASIS, BLUR, SELECT];
  var PATH_ITEM_STYLE = {
    normal: ["itemStyle"],
    emphasis: [EMPHASIS, "itemStyle"],
    blur: [BLUR, "itemStyle"],
    select: [SELECT, "itemStyle"]
  };
  var PATH_LABEL = {
    normal: ["label"],
    emphasis: [EMPHASIS, "label"],
    blur: [BLUR, "label"],
    select: [SELECT, "label"]
  };
  var DEFAULT_TRANSITION = ["x", "y"];
  var GROUP_DIFF_PREFIX = "e\0\0";
  var attachedTxInfoTmp = {
    normal: {},
    emphasis: {},
    blur: {},
    select: {}
  };
  var prepareCustoms = {
    cartesian2d: cartesianPrepareCustom,
    geo: geoPrepareCustom,
    single: singlePrepareCustom,
    polar: polarPrepareCustom,
    calendar: calendarPrepareCustom
  };
  function isPath2(el) {
    return el instanceof Path_default;
  }
  function isDisplayable(el) {
    return el instanceof Displayable_default;
  }
  function copyElement(sourceEl, targetEl) {
    targetEl.copyTransform(sourceEl);
    if (isDisplayable(targetEl) && isDisplayable(sourceEl)) {
      targetEl.setStyle(sourceEl.style);
      targetEl.z = sourceEl.z;
      targetEl.z2 = sourceEl.z2;
      targetEl.zlevel = sourceEl.zlevel;
      targetEl.invisible = sourceEl.invisible;
      targetEl.ignore = sourceEl.ignore;
      if (isPath2(targetEl) && isPath2(sourceEl)) {
        targetEl.setShape(sourceEl.shape);
      }
    }
  }
  var CustomChartView = function(_super) {
    __extends(CustomChartView2, _super);
    function CustomChartView2() {
      var _this = _super !== null && _super.apply(this, arguments) || this;
      _this.type = CustomChartView2.type;
      return _this;
    }
    CustomChartView2.prototype.render = function(customSeries, ecModel, api, payload) {
      this._progressiveEls = null;
      var oldData = this._data;
      var data = customSeries.getData();
      var group = this.group;
      var renderItem = makeRenderItem(customSeries, data, ecModel, api);
      if (!oldData) {
        group.removeAll();
      }
      data.diff(oldData).add(function(newIdx) {
        createOrUpdateItem(api, null, newIdx, renderItem(newIdx, payload), customSeries, group, data);
      }).remove(function(oldIdx) {
        var el = oldData.getItemGraphicEl(oldIdx);
        applyLeaveTransition(el, customInnerStore(el).option, customSeries);
      }).update(function(newIdx, oldIdx) {
        var oldEl = oldData.getItemGraphicEl(oldIdx);
        createOrUpdateItem(api, oldEl, newIdx, renderItem(newIdx, payload), customSeries, group, data);
      }).execute();
      var clipPath = customSeries.get("clip", true) ? createClipPath(customSeries.coordinateSystem, false, customSeries) : null;
      if (clipPath) {
        group.setClipPath(clipPath);
      } else {
        group.removeClipPath();
      }
      this._data = data;
    };
    CustomChartView2.prototype.incrementalPrepareRender = function(customSeries, ecModel, api) {
      this.group.removeAll();
      this._data = null;
    };
    CustomChartView2.prototype.incrementalRender = function(params, customSeries, ecModel, api, payload) {
      var data = customSeries.getData();
      var renderItem = makeRenderItem(customSeries, data, ecModel, api);
      var progressiveEls = this._progressiveEls = [];
      function setIncrementalAndHoverLayer(el2) {
        if (!el2.isGroup) {
          el2.incremental = true;
          el2.ensureState("emphasis").hoverLayer = true;
        }
      }
      for (var idx = params.start; idx < params.end; idx++) {
        var el = createOrUpdateItem(null, null, idx, renderItem(idx, payload), customSeries, this.group, data);
        if (el) {
          el.traverse(setIncrementalAndHoverLayer);
          progressiveEls.push(el);
        }
      }
    };
    CustomChartView2.prototype.eachRendered = function(cb) {
      traverseElements(this._progressiveEls || this.group, cb);
    };
    CustomChartView2.prototype.filterForExposedEvent = function(eventType, query, targetEl, packedEvent) {
      var elementName = query.element;
      if (elementName == null || targetEl.name === elementName) {
        return true;
      }
      while ((targetEl = targetEl.__hostTarget || targetEl.parent) && targetEl !== this.group) {
        if (targetEl.name === elementName) {
          return true;
        }
      }
      return false;
    };
    CustomChartView2.type = "custom";
    return CustomChartView2;
  }(Chart_default);
  var CustomView_default = CustomChartView;
  function createEl(elOption) {
    var graphicType = elOption.type;
    var el;
    if (graphicType === "path") {
      var shape = elOption.shape;
      var pathRect = shape.width != null && shape.height != null ? {
        x: shape.x || 0,
        y: shape.y || 0,
        width: shape.width,
        height: shape.height
      } : null;
      var pathData = getPathData(shape);
      el = makePath(pathData, null, pathRect, shape.layout || "center");
      customInnerStore(el).customPathData = pathData;
    } else if (graphicType === "image") {
      el = new Image_default({});
      customInnerStore(el).customImagePath = elOption.style.image;
    } else if (graphicType === "text") {
      el = new Text_default({});
    } else if (graphicType === "group") {
      el = new Group_default();
    } else if (graphicType === "compoundPath") {
      throw new Error('"compoundPath" is not supported yet.');
    } else {
      var Clz = getShapeClass(graphicType);
      if (!Clz) {
        var errMsg = "";
        if (true) {
          errMsg = 'graphic type "' + graphicType + '" can not be found.';
        }
        throwError(errMsg);
      }
      el = new Clz();
    }
    customInnerStore(el).customGraphicType = graphicType;
    el.name = elOption.name;
    el.z2EmphasisLift = 1;
    el.z2SelectLift = 1;
    return el;
  }
  function updateElNormal(api, el, dataIndex, elOption, attachedTxInfo, seriesModel, isInit) {
    stopPreviousKeyframeAnimationAndRestore(el);
    var txCfgOpt = attachedTxInfo && attachedTxInfo.normal.cfg;
    if (txCfgOpt) {
      el.setTextConfig(txCfgOpt);
    }
    if (elOption && elOption.transition == null) {
      elOption.transition = DEFAULT_TRANSITION;
    }
    var styleOpt = elOption && elOption.style;
    if (styleOpt) {
      if (el.type === "text") {
        var textOptionStyle = styleOpt;
        hasOwn(textOptionStyle, "textFill") && (textOptionStyle.fill = textOptionStyle.textFill);
        hasOwn(textOptionStyle, "textStroke") && (textOptionStyle.stroke = textOptionStyle.textStroke);
      }
      var decalPattern = void 0;
      var decalObj = isPath2(el) ? styleOpt.decal : null;
      if (api && decalObj) {
        decalObj.dirty = true;
        decalPattern = createOrUpdatePatternFromDecal(decalObj, api);
      }
      styleOpt.__decalPattern = decalPattern;
    }
    if (isDisplayable(el)) {
      if (styleOpt) {
        var decalPattern = styleOpt.__decalPattern;
        if (decalPattern) {
          styleOpt.decal = decalPattern;
        }
      }
    }
    applyUpdateTransition(el, elOption, seriesModel, {
      dataIndex,
      isInit,
      clearStyle: true
    });
    applyKeyframeAnimation(el, elOption.keyframeAnimation, seriesModel);
  }
  function updateElOnState(state, el, elStateOpt, styleOpt, attachedTxInfo) {
    var elDisplayable = el.isGroup ? null : el;
    var txCfgOpt = attachedTxInfo && attachedTxInfo[state].cfg;
    if (elDisplayable) {
      var stateObj = elDisplayable.ensureState(state);
      if (styleOpt === false) {
        var existingEmphasisState = elDisplayable.getState(state);
        if (existingEmphasisState) {
          existingEmphasisState.style = null;
        }
      } else {
        stateObj.style = styleOpt || null;
      }
      if (txCfgOpt) {
        stateObj.textConfig = txCfgOpt;
      }
      setDefaultStateProxy(elDisplayable);
    }
  }
  function updateZ2(el, elOption, seriesModel) {
    if (el.isGroup) {
      return;
    }
    var elDisplayable = el;
    var currentZ = seriesModel.currentZ;
    var currentZLevel = seriesModel.currentZLevel;
    elDisplayable.z = currentZ;
    elDisplayable.zlevel = currentZLevel;
    var optZ2 = elOption.z2;
    optZ2 != null && (elDisplayable.z2 = optZ2 || 0);
    for (var i = 0; i < STATES.length; i++) {
      updateZForEachState(elDisplayable, elOption, STATES[i]);
    }
  }
  function updateZForEachState(elDisplayable, elOption, state) {
    var isNormal = state === NORMAL;
    var elStateOpt = isNormal ? elOption : retrieveStateOption(elOption, state);
    var optZ2 = elStateOpt ? elStateOpt.z2 : null;
    var stateObj;
    if (optZ2 != null) {
      stateObj = isNormal ? elDisplayable : elDisplayable.ensureState(state);
      stateObj.z2 = optZ2 || 0;
    }
  }
  function makeRenderItem(customSeries, data, ecModel, api) {
    var renderItem = customSeries.get("renderItem");
    var coordSys = customSeries.coordinateSystem;
    var prepareResult2 = {};
    if (coordSys) {
      if (true) {
        assert(renderItem, "series.render is required.");
        assert(coordSys.prepareCustoms || prepareCustoms[coordSys.type], "This coordSys does not support custom series.");
      }
      prepareResult2 = coordSys.prepareCustoms ? coordSys.prepareCustoms(coordSys) : prepareCustoms[coordSys.type](coordSys);
    }
    var userAPI = defaults({
      getWidth: api.getWidth,
      getHeight: api.getHeight,
      getZr: api.getZr,
      getDevicePixelRatio: api.getDevicePixelRatio,
      value,
      style,
      ordinalRawValue,
      styleEmphasis,
      visual,
      barLayout,
      currentSeriesIndices,
      font
    }, prepareResult2.api || {});
    var userParams = {
      context: {},
      seriesId: customSeries.id,
      seriesName: customSeries.name,
      seriesIndex: customSeries.seriesIndex,
      coordSys: prepareResult2.coordSys,
      dataInsideLength: data.count(),
      encode: wrapEncodeDef(customSeries.getData())
    };
    var currDataIndexInside;
    var currItemModel;
    var currItemStyleModels = {};
    var currLabelModels = {};
    var seriesItemStyleModels = {};
    var seriesLabelModels = {};
    for (var i = 0; i < STATES.length; i++) {
      var stateName = STATES[i];
      seriesItemStyleModels[stateName] = customSeries.getModel(PATH_ITEM_STYLE[stateName]);
      seriesLabelModels[stateName] = customSeries.getModel(PATH_LABEL[stateName]);
    }
    function getItemModel2(dataIndexInside) {
      return dataIndexInside === currDataIndexInside ? currItemModel || (currItemModel = data.getItemModel(dataIndexInside)) : data.getItemModel(dataIndexInside);
    }
    function getItemStyleModel(dataIndexInside, state) {
      return !data.hasItemOption ? seriesItemStyleModels[state] : dataIndexInside === currDataIndexInside ? currItemStyleModels[state] || (currItemStyleModels[state] = getItemModel2(dataIndexInside).getModel(PATH_ITEM_STYLE[state])) : getItemModel2(dataIndexInside).getModel(PATH_ITEM_STYLE[state]);
    }
    function getLabelModel(dataIndexInside, state) {
      return !data.hasItemOption ? seriesLabelModels[state] : dataIndexInside === currDataIndexInside ? currLabelModels[state] || (currLabelModels[state] = getItemModel2(dataIndexInside).getModel(PATH_LABEL[state])) : getItemModel2(dataIndexInside).getModel(PATH_LABEL[state]);
    }
    return function(dataIndexInside, payload) {
      currDataIndexInside = dataIndexInside;
      currItemModel = null;
      currItemStyleModels = {};
      currLabelModels = {};
      return renderItem && renderItem(defaults({
        dataIndexInside,
        dataIndex: data.getRawIndex(dataIndexInside),
        actionType: payload ? payload.type : null
      }, userParams), userAPI);
    };
    function value(dim, dataIndexInside) {
      dataIndexInside == null && (dataIndexInside = currDataIndexInside);
      return data.getStore().get(data.getDimensionIndex(dim || 0), dataIndexInside);
    }
    function ordinalRawValue(dim, dataIndexInside) {
      dataIndexInside == null && (dataIndexInside = currDataIndexInside);
      dim = dim || 0;
      var dimInfo = data.getDimensionInfo(dim);
      if (!dimInfo) {
        var dimIndex = data.getDimensionIndex(dim);
        return dimIndex >= 0 ? data.getStore().get(dimIndex, dataIndexInside) : void 0;
      }
      var val = data.get(dimInfo.name, dataIndexInside);
      var ordinalMeta = dimInfo && dimInfo.ordinalMeta;
      return ordinalMeta ? ordinalMeta.categories[val] : val;
    }
    function style(userProps, dataIndexInside) {
      if (true) {
        warnDeprecated("api.style", "Please write literal style directly instead.");
      }
      dataIndexInside == null && (dataIndexInside = currDataIndexInside);
      var style2 = data.getItemVisual(dataIndexInside, "style");
      var visualColor = style2 && style2.fill;
      var opacity = style2 && style2.opacity;
      var itemStyle = getItemStyleModel(dataIndexInside, NORMAL).getItemStyle();
      visualColor != null && (itemStyle.fill = visualColor);
      opacity != null && (itemStyle.opacity = opacity);
      var opt = {
        inheritColor: isString(visualColor) ? visualColor : "#000"
      };
      var labelModel = getLabelModel(dataIndexInside, NORMAL);
      var textStyle = createTextStyle(labelModel, null, opt, false, true);
      textStyle.text = labelModel.getShallow("show") ? retrieve2(customSeries.getFormattedLabel(dataIndexInside, NORMAL), getDefaultLabel(data, dataIndexInside)) : null;
      var textConfig = createTextConfig(labelModel, opt, false);
      preFetchFromExtra(userProps, itemStyle);
      itemStyle = convertToEC4StyleForCustomSerise(itemStyle, textStyle, textConfig);
      userProps && applyUserPropsAfter(itemStyle, userProps);
      itemStyle.legacy = true;
      return itemStyle;
    }
    function styleEmphasis(userProps, dataIndexInside) {
      if (true) {
        warnDeprecated("api.styleEmphasis", "Please write literal style directly instead.");
      }
      dataIndexInside == null && (dataIndexInside = currDataIndexInside);
      var itemStyle = getItemStyleModel(dataIndexInside, EMPHASIS).getItemStyle();
      var labelModel = getLabelModel(dataIndexInside, EMPHASIS);
      var textStyle = createTextStyle(labelModel, null, null, true, true);
      textStyle.text = labelModel.getShallow("show") ? retrieve3(customSeries.getFormattedLabel(dataIndexInside, EMPHASIS), customSeries.getFormattedLabel(dataIndexInside, NORMAL), getDefaultLabel(data, dataIndexInside)) : null;
      var textConfig = createTextConfig(labelModel, null, true);
      preFetchFromExtra(userProps, itemStyle);
      itemStyle = convertToEC4StyleForCustomSerise(itemStyle, textStyle, textConfig);
      userProps && applyUserPropsAfter(itemStyle, userProps);
      itemStyle.legacy = true;
      return itemStyle;
    }
    function applyUserPropsAfter(itemStyle, extra) {
      for (var key in extra) {
        if (hasOwn(extra, key)) {
          itemStyle[key] = extra[key];
        }
      }
    }
    function preFetchFromExtra(extra, itemStyle) {
      if (extra) {
        extra.textFill && (itemStyle.textFill = extra.textFill);
        extra.textPosition && (itemStyle.textPosition = extra.textPosition);
      }
    }
    function visual(visualType, dataIndexInside) {
      dataIndexInside == null && (dataIndexInside = currDataIndexInside);
      if (hasOwn(STYLE_VISUAL_TYPE, visualType)) {
        var style_1 = data.getItemVisual(dataIndexInside, "style");
        return style_1 ? style_1[STYLE_VISUAL_TYPE[visualType]] : null;
      }
      if (hasOwn(NON_STYLE_VISUAL_PROPS, visualType)) {
        return data.getItemVisual(dataIndexInside, visualType);
      }
    }
    function barLayout(opt) {
      if (coordSys.type === "cartesian2d") {
        var baseAxis = coordSys.getBaseAxis();
        return getLayoutOnAxis(defaults({
          axis: baseAxis
        }, opt));
      }
    }
    function currentSeriesIndices() {
      return ecModel.getCurrentSeriesIndices();
    }
    function font(opt) {
      return getFont(opt, ecModel);
    }
  }
  function wrapEncodeDef(data) {
    var encodeDef = {};
    each(data.dimensions, function(dimName) {
      var dimInfo = data.getDimensionInfo(dimName);
      if (!dimInfo.isExtraCoord) {
        var coordDim = dimInfo.coordDim;
        var dataDims = encodeDef[coordDim] = encodeDef[coordDim] || [];
        dataDims[dimInfo.coordDimIndex] = data.getDimensionIndex(dimName);
      }
    });
    return encodeDef;
  }
  function createOrUpdateItem(api, existsEl, dataIndex, elOption, seriesModel, group, data) {
    if (!elOption) {
      group.remove(existsEl);
      return;
    }
    var el = doCreateOrUpdateEl(api, existsEl, dataIndex, elOption, seriesModel, group);
    el && data.setItemGraphicEl(dataIndex, el);
    el && toggleHoverEmphasis(el, elOption.focus, elOption.blurScope, elOption.emphasisDisabled);
    return el;
  }
  function doCreateOrUpdateEl(api, existsEl, dataIndex, elOption, seriesModel, group) {
    if (true) {
      assert(elOption, "should not have an null/undefined element setting");
    }
    var toBeReplacedIdx = -1;
    var oldEl = existsEl;
    if (existsEl && doesElNeedRecreate(existsEl, elOption, seriesModel)) {
      toBeReplacedIdx = indexOf(group.childrenRef(), existsEl);
      existsEl = null;
    }
    var isInit = !existsEl;
    var el = existsEl;
    if (!el) {
      el = createEl(elOption);
      if (oldEl) {
        copyElement(oldEl, el);
      }
    } else {
      el.clearStates();
    }
    if (elOption.morph === false) {
      el.disableMorphing = true;
    } else if (el.disableMorphing) {
      el.disableMorphing = false;
    }
    attachedTxInfoTmp.normal.cfg = attachedTxInfoTmp.normal.conOpt = attachedTxInfoTmp.emphasis.cfg = attachedTxInfoTmp.emphasis.conOpt = attachedTxInfoTmp.blur.cfg = attachedTxInfoTmp.blur.conOpt = attachedTxInfoTmp.select.cfg = attachedTxInfoTmp.select.conOpt = null;
    attachedTxInfoTmp.isLegacy = false;
    doCreateOrUpdateAttachedTx(el, dataIndex, elOption, seriesModel, isInit, attachedTxInfoTmp);
    doCreateOrUpdateClipPath(el, dataIndex, elOption, seriesModel, isInit);
    updateElNormal(api, el, dataIndex, elOption, attachedTxInfoTmp, seriesModel, isInit);
    hasOwn(elOption, "info") && (customInnerStore(el).info = elOption.info);
    for (var i = 0; i < STATES.length; i++) {
      var stateName = STATES[i];
      if (stateName !== NORMAL) {
        var otherStateOpt = retrieveStateOption(elOption, stateName);
        var otherStyleOpt = retrieveStyleOptionOnState(elOption, otherStateOpt, stateName);
        updateElOnState(stateName, el, otherStateOpt, otherStyleOpt, attachedTxInfoTmp);
      }
    }
    updateZ2(el, elOption, seriesModel);
    if (elOption.type === "group") {
      mergeChildren(api, el, dataIndex, elOption, seriesModel);
    }
    if (toBeReplacedIdx >= 0) {
      group.replaceAt(el, toBeReplacedIdx);
    } else {
      group.add(el);
    }
    return el;
  }
  function doesElNeedRecreate(el, elOption, seriesModel) {
    var elInner = customInnerStore(el);
    var elOptionType = elOption.type;
    var elOptionShape = elOption.shape;
    var elOptionStyle = elOption.style;
    return seriesModel.isUniversalTransitionEnabled() || elOptionType != null && elOptionType !== elInner.customGraphicType || elOptionType === "path" && hasOwnPathData(elOptionShape) && getPathData(elOptionShape) !== elInner.customPathData || elOptionType === "image" && hasOwn(elOptionStyle, "image") && elOptionStyle.image !== elInner.customImagePath;
  }
  function doCreateOrUpdateClipPath(el, dataIndex, elOption, seriesModel, isInit) {
    var clipPathOpt = elOption.clipPath;
    if (clipPathOpt === false) {
      if (el && el.getClipPath()) {
        el.removeClipPath();
      }
    } else if (clipPathOpt) {
      var clipPath = el.getClipPath();
      if (clipPath && doesElNeedRecreate(clipPath, clipPathOpt, seriesModel)) {
        clipPath = null;
      }
      if (!clipPath) {
        clipPath = createEl(clipPathOpt);
        if (true) {
          assert(isPath2(clipPath), "Only any type of `path` can be used in `clipPath`, rather than " + clipPath.type + ".");
        }
        el.setClipPath(clipPath);
      }
      updateElNormal(null, clipPath, dataIndex, clipPathOpt, null, seriesModel, isInit);
    }
  }
  function doCreateOrUpdateAttachedTx(el, dataIndex, elOption, seriesModel, isInit, attachedTxInfo) {
    if (el.isGroup) {
      return;
    }
    processTxInfo(elOption, null, attachedTxInfo);
    processTxInfo(elOption, EMPHASIS, attachedTxInfo);
    var txConOptNormal = attachedTxInfo.normal.conOpt;
    var txConOptEmphasis = attachedTxInfo.emphasis.conOpt;
    var txConOptBlur = attachedTxInfo.blur.conOpt;
    var txConOptSelect = attachedTxInfo.select.conOpt;
    if (txConOptNormal != null || txConOptEmphasis != null || txConOptSelect != null || txConOptBlur != null) {
      var textContent = el.getTextContent();
      if (txConOptNormal === false) {
        textContent && el.removeTextContent();
      } else {
        txConOptNormal = attachedTxInfo.normal.conOpt = txConOptNormal || {
          type: "text"
        };
        if (!textContent) {
          textContent = createEl(txConOptNormal);
          el.setTextContent(textContent);
        } else {
          textContent.clearStates();
        }
        updateElNormal(null, textContent, dataIndex, txConOptNormal, null, seriesModel, isInit);
        var txConStlOptNormal = txConOptNormal && txConOptNormal.style;
        for (var i = 0; i < STATES.length; i++) {
          var stateName = STATES[i];
          if (stateName !== NORMAL) {
            var txConOptOtherState = attachedTxInfo[stateName].conOpt;
            updateElOnState(stateName, textContent, txConOptOtherState, retrieveStyleOptionOnState(txConOptNormal, txConOptOtherState, stateName), null);
          }
        }
        txConStlOptNormal ? textContent.dirty() : textContent.markRedraw();
      }
    }
  }
  function processTxInfo(elOption, state, attachedTxInfo) {
    var stateOpt = !state ? elOption : retrieveStateOption(elOption, state);
    var styleOpt = !state ? elOption.style : retrieveStyleOptionOnState(elOption, stateOpt, EMPHASIS);
    var elType = elOption.type;
    var txCfg = stateOpt ? stateOpt.textConfig : null;
    var txConOptNormal = elOption.textContent;
    var txConOpt = !txConOptNormal ? null : !state ? txConOptNormal : retrieveStateOption(txConOptNormal, state);
    if (styleOpt && (attachedTxInfo.isLegacy || isEC4CompatibleStyle(styleOpt, elType, !!txCfg, !!txConOpt))) {
      attachedTxInfo.isLegacy = true;
      var convertResult = convertFromEC4CompatibleStyle(styleOpt, elType, !state);
      if (!txCfg && convertResult.textConfig) {
        txCfg = convertResult.textConfig;
      }
      if (!txConOpt && convertResult.textContent) {
        txConOpt = convertResult.textContent;
      }
    }
    if (!state && txConOpt) {
      var txConOptNormal_1 = txConOpt;
      !txConOptNormal_1.type && (txConOptNormal_1.type = "text");
      if (true) {
        assert(txConOptNormal_1.type === "text", 'textContent.type must be "text"');
      }
    }
    var info = !state ? attachedTxInfo.normal : attachedTxInfo[state];
    info.cfg = txCfg;
    info.conOpt = txConOpt;
  }
  function retrieveStateOption(elOption, state) {
    return !state ? elOption : elOption ? elOption[state] : null;
  }
  function retrieveStyleOptionOnState(stateOptionNormal, stateOption, state) {
    var style = stateOption && stateOption.style;
    if (style == null && state === EMPHASIS && stateOptionNormal) {
      style = stateOptionNormal.styleEmphasis;
    }
    return style;
  }
  function mergeChildren(api, el, dataIndex, elOption, seriesModel) {
    var newChildren = elOption.children;
    var newLen = newChildren ? newChildren.length : 0;
    var mergeChildren2 = elOption.$mergeChildren;
    var byName = mergeChildren2 === "byName" || elOption.diffChildrenByName;
    var notMerge = mergeChildren2 === false;
    if (!newLen && !byName && !notMerge) {
      return;
    }
    if (byName) {
      diffGroupChildren({
        api,
        oldChildren: el.children() || [],
        newChildren: newChildren || [],
        dataIndex,
        seriesModel,
        group: el
      });
      return;
    }
    notMerge && el.removeAll();
    var index = 0;
    for (; index < newLen; index++) {
      newChildren[index] && doCreateOrUpdateEl(api, el.childAt(index), dataIndex, newChildren[index], seriesModel, el);
    }
    for (var i = el.childCount() - 1; i >= index; i--) {
      var child = el.childAt(i);
      applyLeaveTransition(child, customInnerStore(el).option, seriesModel);
    }
  }
  function diffGroupChildren(context) {
    new DataDiffer_default(context.oldChildren, context.newChildren, getKey, getKey, context).add(processAddUpdate).update(processAddUpdate).remove(processRemove).execute();
  }
  function getKey(item, idx) {
    var name = item && item.name;
    return name != null ? name : GROUP_DIFF_PREFIX + idx;
  }
  function processAddUpdate(newIndex, oldIndex) {
    var context = this.context;
    var childOption = newIndex != null ? context.newChildren[newIndex] : null;
    var child = oldIndex != null ? context.oldChildren[oldIndex] : null;
    doCreateOrUpdateEl(context.api, child, context.dataIndex, childOption, context.seriesModel, context.group);
  }
  function processRemove(oldIndex) {
    var context = this.context;
    var child = context.oldChildren[oldIndex];
    applyLeaveTransition(child, customInnerStore(child).option, context.seriesModel);
  }
  function getPathData(shape) {
    return shape && (shape.pathData || shape.d);
  }
  function hasOwnPathData(shape) {
    return shape && (hasOwn(shape, "pathData") || hasOwn(shape, "d"));
  }

  // node_modules/echarts/lib/chart/custom/install.js
  function install28(registers) {
    registers.registerChartView(CustomView_default);
    registers.registerSeriesModel(CustomSeries_default);
  }

  // node_modules/echarts/lib/component/axisPointer/BaseAxisPointer.js
  var inner11 = makeInner();
  var clone4 = clone;
  var bind2 = bind;
  var BaseAxisPointer = function() {
    function BaseAxisPointer2() {
      this._dragging = false;
      this.animationThreshold = 15;
    }
    BaseAxisPointer2.prototype.render = function(axisModel, axisPointerModel, api, forceRender) {
      var value = axisPointerModel.get("value");
      var status = axisPointerModel.get("status");
      this._axisModel = axisModel;
      this._axisPointerModel = axisPointerModel;
      this._api = api;
      if (!forceRender && this._lastValue === value && this._lastStatus === status) {
        return;
      }
      this._lastValue = value;
      this._lastStatus = status;
      var group = this._group;
      var handle = this._handle;
      if (!status || status === "hide") {
        group && group.hide();
        handle && handle.hide();
        return;
      }
      group && group.show();
      handle && handle.show();
      var elOption = {};
      this.makeElOption(elOption, value, axisModel, axisPointerModel, api);
      var graphicKey = elOption.graphicKey;
      if (graphicKey !== this._lastGraphicKey) {
        this.clear(api);
      }
      this._lastGraphicKey = graphicKey;
      var moveAnimation = this._moveAnimation = this.determineAnimation(axisModel, axisPointerModel);
      if (!group) {
        group = this._group = new Group_default();
        this.createPointerEl(group, elOption, axisModel, axisPointerModel);
        this.createLabelEl(group, elOption, axisModel, axisPointerModel);
        api.getZr().add(group);
      } else {
        var doUpdateProps = curry(updateProps2, axisPointerModel, moveAnimation);
        this.updatePointerEl(group, elOption, doUpdateProps);
        this.updateLabelEl(group, elOption, doUpdateProps, axisPointerModel);
      }
      updateMandatoryProps(group, axisPointerModel, true);
      this._renderHandle(value);
    };
    BaseAxisPointer2.prototype.remove = function(api) {
      this.clear(api);
    };
    BaseAxisPointer2.prototype.dispose = function(api) {
      this.clear(api);
    };
    BaseAxisPointer2.prototype.determineAnimation = function(axisModel, axisPointerModel) {
      var animation = axisPointerModel.get("animation");
      var axis = axisModel.axis;
      var isCategoryAxis = axis.type === "category";
      var useSnap = axisPointerModel.get("snap");
      if (!useSnap && !isCategoryAxis) {
        return false;
      }
      if (animation === "auto" || animation == null) {
        var animationThreshold = this.animationThreshold;
        if (isCategoryAxis && axis.getBandWidth() > animationThreshold) {
          return true;
        }
        if (useSnap) {
          var seriesDataCount = getAxisInfo(axisModel).seriesDataCount;
          var axisExtent = axis.getExtent();
          return Math.abs(axisExtent[0] - axisExtent[1]) / seriesDataCount > animationThreshold;
        }
        return false;
      }
      return animation === true;
    };
    BaseAxisPointer2.prototype.makeElOption = function(elOption, value, axisModel, axisPointerModel, api) {
    };
    BaseAxisPointer2.prototype.createPointerEl = function(group, elOption, axisModel, axisPointerModel) {
      var pointerOption = elOption.pointer;
      if (pointerOption) {
        var pointerEl = inner11(group).pointerEl = new graphic_exports[pointerOption.type](clone4(elOption.pointer));
        group.add(pointerEl);
      }
    };
    BaseAxisPointer2.prototype.createLabelEl = function(group, elOption, axisModel, axisPointerModel) {
      if (elOption.label) {
        var labelEl = inner11(group).labelEl = new Text_default(clone4(elOption.label));
        group.add(labelEl);
        updateLabelShowHide(labelEl, axisPointerModel);
      }
    };
    BaseAxisPointer2.prototype.updatePointerEl = function(group, elOption, updateProps3) {
      var pointerEl = inner11(group).pointerEl;
      if (pointerEl && elOption.pointer) {
        pointerEl.setStyle(elOption.pointer.style);
        updateProps3(pointerEl, {
          shape: elOption.pointer.shape
        });
      }
    };
    BaseAxisPointer2.prototype.updateLabelEl = function(group, elOption, updateProps3, axisPointerModel) {
      var labelEl = inner11(group).labelEl;
      if (labelEl) {
        labelEl.setStyle(elOption.label.style);
        updateProps3(labelEl, {
          x: elOption.label.x,
          y: elOption.label.y
        });
        updateLabelShowHide(labelEl, axisPointerModel);
      }
    };
    BaseAxisPointer2.prototype._renderHandle = function(value) {
      if (this._dragging || !this.updateHandleTransform) {
        return;
      }
      var axisPointerModel = this._axisPointerModel;
      var zr = this._api.getZr();
      var handle = this._handle;
      var handleModel = axisPointerModel.getModel("handle");
      var status = axisPointerModel.get("status");
      if (!handleModel.get("show") || !status || status === "hide") {
        handle && zr.remove(handle);
        this._handle = null;
        return;
      }
      var isInit;
      if (!this._handle) {
        isInit = true;
        handle = this._handle = createIcon(handleModel.get("icon"), {
          cursor: "move",
          draggable: true,
          onmousemove: function(e2) {
            stop(e2.event);
          },
          onmousedown: bind2(this._onHandleDragMove, this, 0, 0),
          drift: bind2(this._onHandleDragMove, this),
          ondragend: bind2(this._onHandleDragEnd, this)
        });
        zr.add(handle);
      }
      updateMandatoryProps(handle, axisPointerModel, false);
      handle.setStyle(handleModel.getItemStyle(null, ["color", "borderColor", "borderWidth", "opacity", "shadowColor", "shadowBlur", "shadowOffsetX", "shadowOffsetY"]));
      var handleSize = handleModel.get("size");
      if (!isArray(handleSize)) {
        handleSize = [handleSize, handleSize];
      }
      handle.scaleX = handleSize[0] / 2;
      handle.scaleY = handleSize[1] / 2;
      createOrUpdate(this, "_doDispatchAxisPointer", handleModel.get("throttle") || 0, "fixRate");
      this._moveHandleToValue(value, isInit);
    };
    BaseAxisPointer2.prototype._moveHandleToValue = function(value, isInit) {
      updateProps2(this._axisPointerModel, !isInit && this._moveAnimation, this._handle, getHandleTransProps(this.getHandleTransform(value, this._axisModel, this._axisPointerModel)));
    };
    BaseAxisPointer2.prototype._onHandleDragMove = function(dx, dy) {
      var handle = this._handle;
      if (!handle) {
        return;
      }
      this._dragging = true;
      var trans = this.updateHandleTransform(getHandleTransProps(handle), [dx, dy], this._axisModel, this._axisPointerModel);
      this._payloadInfo = trans;
      handle.stopAnimation();
      handle.attr(getHandleTransProps(trans));
      inner11(handle).lastProp = null;
      this._doDispatchAxisPointer();
    };
    BaseAxisPointer2.prototype._doDispatchAxisPointer = function() {
      var handle = this._handle;
      if (!handle) {
        return;
      }
      var payloadInfo = this._payloadInfo;
      var axisModel = this._axisModel;
      this._api.dispatchAction({
        type: "updateAxisPointer",
        x: payloadInfo.cursorPoint[0],
        y: payloadInfo.cursorPoint[1],
        tooltipOption: payloadInfo.tooltipOption,
        axesInfo: [{
          axisDim: axisModel.axis.dim,
          axisIndex: axisModel.componentIndex
        }]
      });
    };
    BaseAxisPointer2.prototype._onHandleDragEnd = function() {
      this._dragging = false;
      var handle = this._handle;
      if (!handle) {
        return;
      }
      var value = this._axisPointerModel.get("value");
      this._moveHandleToValue(value);
      this._api.dispatchAction({
        type: "hideTip"
      });
    };
    BaseAxisPointer2.prototype.clear = function(api) {
      this._lastValue = null;
      this._lastStatus = null;
      var zr = api.getZr();
      var group = this._group;
      var handle = this._handle;
      if (zr && group) {
        this._lastGraphicKey = null;
        group && zr.remove(group);
        handle && zr.remove(handle);
        this._group = null;
        this._handle = null;
        this._payloadInfo = null;
      }
      clear(this, "_doDispatchAxisPointer");
    };
    BaseAxisPointer2.prototype.doClear = function() {
    };
    BaseAxisPointer2.prototype.buildLabel = function(xy, wh, xDimIndex) {
      xDimIndex = xDimIndex || 0;
      return {
        x: xy[xDimIndex],
        y: xy[1 - xDimIndex],
        width: wh[xDimIndex],
        height: wh[1 - xDimIndex]
      };
    };
    return BaseAxisPointer2;
  }();
  function updateProps2(animationModel, moveAnimation, el, props) {
    if (!propsEqual(inner11(el).lastProp, props)) {
      inner11(el).lastProp = props;
      moveAnimation ? updateProps(el, props, animationModel) : (el.stopAnimation(), el.attr(props));
    }
  }
  function propsEqual(lastProps, newProps) {
    if (isObject(lastProps) && isObject(newProps)) {
      var equals_1 = true;
      each(newProps, function(item, key) {
        equals_1 = equals_1 && propsEqual(lastProps[key], item);
      });
      return !!equals_1;
    } else {
      return lastProps === newProps;
    }
  }
  function updateLabelShowHide(labelEl, axisPointerModel) {
    labelEl[axisPointerModel.get(["label", "show"]) ? "show" : "hide"]();
  }
  function getHandleTransProps(trans) {
    return {
      x: trans.x || 0,
      y: trans.y || 0,
      rotation: trans.rotation || 0
    };
  }
  function updateMandatoryProps(group, axisPointerModel, silent) {
    var z = axisPointerModel.get("z");
    var zlevel = axisPointerModel.get("zlevel");
    group && group.traverse(function(el) {
      if (el.type !== "group") {
        z != null && (el.z = z);
        zlevel != null && (el.zlevel = zlevel);
        el.silent = silent;
      }
    });
  }
  var BaseAxisPointer_default = BaseAxisPointer;

  // node_modules/echarts/lib/component/axisPointer/viewHelper.js
  function buildElStyle(axisPointerModel) {
    var axisPointerType = axisPointerModel.get("type");
    var styleModel = axisPointerModel.getModel(axisPointerType + "Style");
    var style;
    if (axisPointerType === "line") {
      style = styleModel.getLineStyle();
      style.fill = null;
    } else if (axisPointerType === "shadow") {
      style = styleModel.getAreaStyle();
      style.stroke = null;
    }
    return style;
  }
  function buildLabelElOption(elOption, axisModel, axisPointerModel, api, labelPos) {
    var value = axisPointerModel.get("value");
    var text = getValueLabel(value, axisModel.axis, axisModel.ecModel, axisPointerModel.get("seriesDataIndices"), {
      precision: axisPointerModel.get(["label", "precision"]),
      formatter: axisPointerModel.get(["label", "formatter"])
    });
    var labelModel = axisPointerModel.getModel("label");
    var paddings = normalizeCssArray2(labelModel.get("padding") || 0);
    var font = labelModel.getFont();
    var textRect = getBoundingRect(text, font);
    var position2 = labelPos.position;
    var width = textRect.width + paddings[1] + paddings[3];
    var height = textRect.height + paddings[0] + paddings[2];
    var align = labelPos.align;
    align === "right" && (position2[0] -= width);
    align === "center" && (position2[0] -= width / 2);
    var verticalAlign = labelPos.verticalAlign;
    verticalAlign === "bottom" && (position2[1] -= height);
    verticalAlign === "middle" && (position2[1] -= height / 2);
    confineInContainer(position2, width, height, api);
    var bgColor = labelModel.get("backgroundColor");
    if (!bgColor || bgColor === "auto") {
      bgColor = axisModel.get(["axisLine", "lineStyle", "color"]);
    }
    elOption.label = {
      x: position2[0],
      y: position2[1],
      style: createTextStyle(labelModel, {
        text,
        font,
        fill: labelModel.getTextColor(),
        padding: paddings,
        backgroundColor: bgColor
      }),
      z2: 10
    };
  }
  function confineInContainer(position2, width, height, api) {
    var viewWidth = api.getWidth();
    var viewHeight = api.getHeight();
    position2[0] = Math.min(position2[0] + width, viewWidth) - width;
    position2[1] = Math.min(position2[1] + height, viewHeight) - height;
    position2[0] = Math.max(position2[0], 0);
    position2[1] = Math.max(position2[1], 0);
  }
  function getValueLabel(value, axis, ecModel, seriesDataIndices, opt) {
    value = axis.scale.parse(value);
    var text = axis.scale.getLabel({
      value
    }, {
      precision: opt.precision
    });
    var formatter = opt.formatter;
    if (formatter) {
      var params_1 = {
        value: getAxisRawValue(axis, {
          value
        }),
        axisDimension: axis.dim,
        axisIndex: axis.index,
        seriesData: []
      };
      each(seriesDataIndices, function(idxItem) {
        var series = ecModel.getSeriesByIndex(idxItem.seriesIndex);
        var dataIndex = idxItem.dataIndexInside;
        var dataParams = series && series.getDataParams(dataIndex);
        dataParams && params_1.seriesData.push(dataParams);
      });
      if (isString(formatter)) {
        text = formatter.replace("{value}", text);
      } else if (isFunction(formatter)) {
        text = formatter(params_1);
      }
    }
    return text;
  }
  function getTransformedPosition(axis, value, layoutInfo) {
    var transform2 = create2();
    rotate(transform2, transform2, layoutInfo.rotation);
    translate(transform2, transform2, layoutInfo.position);
    return applyTransform2([axis.dataToCoord(value), (layoutInfo.labelOffset || 0) + (layoutInfo.labelDirection || 1) * (layoutInfo.labelMargin || 0)], transform2);
  }
  function buildCartesianSingleLabelElOption(value, elOption, layoutInfo, axisModel, axisPointerModel, api) {
    var textLayout = AxisBuilder_default.innerTextLayout(layoutInfo.rotation, 0, layoutInfo.labelDirection);
    layoutInfo.labelMargin = axisPointerModel.get(["label", "margin"]);
    buildLabelElOption(elOption, axisModel, axisPointerModel, api, {
      position: getTransformedPosition(axisModel.axis, value, layoutInfo),
      align: textLayout.textAlign,
      verticalAlign: textLayout.textVerticalAlign
    });
  }
  function makeLineShape(p1, p2, xDimIndex) {
    xDimIndex = xDimIndex || 0;
    return {
      x1: p1[xDimIndex],
      y1: p1[1 - xDimIndex],
      x2: p2[xDimIndex],
      y2: p2[1 - xDimIndex]
    };
  }
  function makeRectShape(xy, wh, xDimIndex) {
    xDimIndex = xDimIndex || 0;
    return {
      x: xy[xDimIndex],
      y: xy[1 - xDimIndex],
      width: wh[xDimIndex],
      height: wh[1 - xDimIndex]
    };
  }
  function makeSectorShape(cx, cy, r0, r, startAngle, endAngle) {
    return {
      cx,
      cy,
      r0,
      r,
      startAngle,
      endAngle,
      clockwise: true
    };
  }

  // node_modules/echarts/lib/component/axisPointer/CartesianAxisPointer.js
  var CartesianAxisPointer = function(_super) {
    __extends(CartesianAxisPointer2, _super);
    function CartesianAxisPointer2() {
      return _super !== null && _super.apply(this, arguments) || this;
    }
    CartesianAxisPointer2.prototype.makeElOption = function(elOption, value, axisModel, axisPointerModel, api) {
      var axis = axisModel.axis;
      var grid = axis.grid;
      var axisPointerType = axisPointerModel.get("type");
      var otherExtent = getCartesian(grid, axis).getOtherAxis(axis).getGlobalExtent();
      var pixelValue = axis.toGlobalCoord(axis.dataToCoord(value, true));
      if (axisPointerType && axisPointerType !== "none") {
        var elStyle = buildElStyle(axisPointerModel);
        var pointerOption = pointerShapeBuilder[axisPointerType](axis, pixelValue, otherExtent);
        pointerOption.style = elStyle;
        elOption.graphicKey = pointerOption.type;
        elOption.pointer = pointerOption;
      }
      var layoutInfo = layout2(grid.model, axisModel);
      buildCartesianSingleLabelElOption(value, elOption, layoutInfo, axisModel, axisPointerModel, api);
    };
    CartesianAxisPointer2.prototype.getHandleTransform = function(value, axisModel, axisPointerModel) {
      var layoutInfo = layout2(axisModel.axis.grid.model, axisModel, {
        labelInside: false
      });
      layoutInfo.labelMargin = axisPointerModel.get(["handle", "margin"]);
      var pos = getTransformedPosition(axisModel.axis, value, layoutInfo);
      return {
        x: pos[0],
        y: pos[1],
        rotation: layoutInfo.rotation + (layoutInfo.labelDirection < 0 ? Math.PI : 0)
      };
    };
    CartesianAxisPointer2.prototype.updateHandleTransform = function(transform2, delta, axisModel, axisPointerModel) {
      var axis = axisModel.axis;
      var grid = axis.grid;
      var axisExtent = axis.getGlobalExtent(true);
      var otherExtent = getCartesian(grid, axis).getOtherAxis(axis).getGlobalExtent();
      var dimIndex = axis.dim === "x" ? 0 : 1;
      var currPosition = [transform2.x, transform2.y];
      currPosition[dimIndex] += delta[dimIndex];
      currPosition[dimIndex] = Math.min(axisExtent[1], currPosition[dimIndex]);
      currPosition[dimIndex] = Math.max(axisExtent[0], currPosition[dimIndex]);
      var cursorOtherValue = (otherExtent[1] + otherExtent[0]) / 2;
      var cursorPoint = [cursorOtherValue, cursorOtherValue];
      cursorPoint[dimIndex] = currPosition[dimIndex];
      var tooltipOptions = [{
        verticalAlign: "middle"
      }, {
        align: "center"
      }];
      return {
        x: currPosition[0],
        y: currPosition[1],
        rotation: transform2.rotation,
        cursorPoint,
        tooltipOption: tooltipOptions[dimIndex]
      };
    };
    return CartesianAxisPointer2;
  }(BaseAxisPointer_default);
  function getCartesian(grid, axis) {
    var opt = {};
    opt[axis.dim + "AxisIndex"] = axis.index;
    return grid.getCartesian(opt);
  }
  var pointerShapeBuilder = {
    line: function(axis, pixelValue, otherExtent) {
      var targetShape = makeLineShape([pixelValue, otherExtent[0]], [pixelValue, otherExtent[1]], getAxisDimIndex(axis));
      return {
        type: "Line",
        subPixelOptimize: true,
        shape: targetShape
      };
    },
    shadow: function(axis, pixelValue, otherExtent) {
      var bandWidth = Math.max(1, axis.getBandWidth());
      var span = otherExtent[1] - otherExtent[0];
      return {
        type: "Rect",
        shape: makeRectShape([pixelValue - bandWidth / 2, otherExtent[0]], [bandWidth, span], getAxisDimIndex(axis))
      };
    }
  };
  function getAxisDimIndex(axis) {
    return axis.dim === "x" ? 0 : 1;
  }
  var CartesianAxisPointer_default = CartesianAxisPointer;

  // node_modules/echarts/lib/component/axisPointer/AxisPointerModel.js
  var AxisPointerModel = function(_super) {
    __extends(AxisPointerModel2, _super);
    function AxisPointerModel2() {
      var _this = _super !== null && _super.apply(this, arguments) || this;
      _this.type = AxisPointerModel2.type;
      return _this;
    }
    AxisPointerModel2.type = "axisPointer";
    AxisPointerModel2.defaultOption = {
      show: "auto",
      z: 50,
      type: "line",
      snap: false,
      triggerTooltip: true,
      value: null,
      status: null,
      link: [],
      animation: null,
      animationDurationUpdate: 200,
      lineStyle: {
        color: "#B9BEC9",
        width: 1,
        type: "dashed"
      },
      shadowStyle: {
        color: "rgba(210,219,238,0.2)"
      },
      label: {
        show: true,
        formatter: null,
        precision: "auto",
        margin: 3,
        color: "#fff",
        padding: [5, 7, 5, 7],
        backgroundColor: "auto",
        borderColor: null,
        borderWidth: 0,
        borderRadius: 3
      },
      handle: {
        show: false,
        icon: "M10.7,11.9v-1.3H9.3v1.3c-4.9,0.3-8.8,4.4-8.8,9.4c0,5,3.9,9.1,8.8,9.4h1.3c4.9-0.3,8.8-4.4,8.8-9.4C19.5,16.3,15.6,12.2,10.7,11.9z M13.3,24.4H6.7v-1.2h6.6z M13.3,22H6.7v-1.2h6.6z M13.3,19.6H6.7v-1.2h6.6z",
        size: 45,
        margin: 50,
        color: "#333",
        shadowBlur: 3,
        shadowColor: "#aaa",
        shadowOffsetX: 0,
        shadowOffsetY: 2,
        throttle: 40
      }
    };
    return AxisPointerModel2;
  }(Component_default);
  var AxisPointerModel_default = AxisPointerModel;

  // node_modules/echarts/lib/component/axisPointer/globalListener.js
  var inner12 = makeInner();
  var each8 = each;
  function register(key, api, handler) {
    if (env_default.node) {
      return;
    }
    var zr = api.getZr();
    inner12(zr).records || (inner12(zr).records = {});
    initGlobalListeners(zr, api);
    var record = inner12(zr).records[key] || (inner12(zr).records[key] = {});
    record.handler = handler;
  }
  function initGlobalListeners(zr, api) {
    if (inner12(zr).initialized) {
      return;
    }
    inner12(zr).initialized = true;
    useHandler("click", curry(doEnter, "click"));
    useHandler("mousemove", curry(doEnter, "mousemove"));
    useHandler("globalout", onLeave);
    function useHandler(eventType, cb) {
      zr.on(eventType, function(e2) {
        var dis = makeDispatchAction(api);
        each8(inner12(zr).records, function(record) {
          record && cb(record, e2, dis.dispatchAction);
        });
        dispatchTooltipFinally(dis.pendings, api);
      });
    }
  }
  function dispatchTooltipFinally(pendings, api) {
    var showLen = pendings.showTip.length;
    var hideLen = pendings.hideTip.length;
    var actuallyPayload;
    if (showLen) {
      actuallyPayload = pendings.showTip[showLen - 1];
    } else if (hideLen) {
      actuallyPayload = pendings.hideTip[hideLen - 1];
    }
    if (actuallyPayload) {
      actuallyPayload.dispatchAction = null;
      api.dispatchAction(actuallyPayload);
    }
  }
  function onLeave(record, e2, dispatchAction3) {
    record.handler("leave", null, dispatchAction3);
  }
  function doEnter(currTrigger, record, e2, dispatchAction3) {
    record.handler(currTrigger, e2, dispatchAction3);
  }
  function makeDispatchAction(api) {
    var pendings = {
      showTip: [],
      hideTip: []
    };
    var dispatchAction3 = function(payload) {
      var pendingList = pendings[payload.type];
      if (pendingList) {
        pendingList.push(payload);
      } else {
        payload.dispatchAction = dispatchAction3;
        api.dispatchAction(payload);
      }
    };
    return {
      dispatchAction: dispatchAction3,
      pendings
    };
  }
  function unregister(key, api) {
    if (env_default.node) {
      return;
    }
    var zr = api.getZr();
    var record = (inner12(zr).records || {})[key];
    if (record) {
      inner12(zr).records[key] = null;
    }
  }

  // node_modules/echarts/lib/component/axisPointer/AxisPointerView.js
  var AxisPointerView = function(_super) {
    __extends(AxisPointerView2, _super);
    function AxisPointerView2() {
      var _this = _super !== null && _super.apply(this, arguments) || this;
      _this.type = AxisPointerView2.type;
      return _this;
    }
    AxisPointerView2.prototype.render = function(globalAxisPointerModel, ecModel, api) {
      var globalTooltipModel = ecModel.getComponent("tooltip");
      var triggerOn = globalAxisPointerModel.get("triggerOn") || globalTooltipModel && globalTooltipModel.get("triggerOn") || "mousemove|click";
      register("axisPointer", api, function(currTrigger, e2, dispatchAction3) {
        if (triggerOn !== "none" && (currTrigger === "leave" || triggerOn.indexOf(currTrigger) >= 0)) {
          dispatchAction3({
            type: "updateAxisPointer",
            currTrigger,
            x: e2 && e2.offsetX,
            y: e2 && e2.offsetY
          });
        }
      });
    };
    AxisPointerView2.prototype.remove = function(ecModel, api) {
      unregister("axisPointer", api);
    };
    AxisPointerView2.prototype.dispose = function(ecModel, api) {
      unregister("axisPointer", api);
    };
    AxisPointerView2.type = "axisPointer";
    return AxisPointerView2;
  }(Component_default2);
  var AxisPointerView_default = AxisPointerView;

  // node_modules/echarts/lib/component/axisPointer/findPointFromSeries.js
  function findPointFromSeries(finder, ecModel) {
    var point = [];
    var seriesIndex = finder.seriesIndex;
    var seriesModel;
    if (seriesIndex == null || !(seriesModel = ecModel.getSeriesByIndex(seriesIndex))) {
      return {
        point: []
      };
    }
    var data = seriesModel.getData();
    var dataIndex = queryDataIndex(data, finder);
    if (dataIndex == null || dataIndex < 0 || isArray(dataIndex)) {
      return {
        point: []
      };
    }
    var el = data.getItemGraphicEl(dataIndex);
    var coordSys = seriesModel.coordinateSystem;
    if (seriesModel.getTooltipPosition) {
      point = seriesModel.getTooltipPosition(dataIndex) || [];
    } else if (coordSys && coordSys.dataToPoint) {
      if (finder.isStacked) {
        var baseAxis = coordSys.getBaseAxis();
        var valueAxis2 = coordSys.getOtherAxis(baseAxis);
        var valueAxisDim = valueAxis2.dim;
        var baseAxisDim = baseAxis.dim;
        var baseDataOffset = valueAxisDim === "x" || valueAxisDim === "radius" ? 1 : 0;
        var baseDim = data.mapDimension(baseAxisDim);
        var stackedData = [];
        stackedData[baseDataOffset] = data.get(baseDim, dataIndex);
        stackedData[1 - baseDataOffset] = data.get(data.getCalculationInfo("stackResultDimension"), dataIndex);
        point = coordSys.dataToPoint(stackedData) || [];
      } else {
        point = coordSys.dataToPoint(data.getValues(map(coordSys.dimensions, function(dim) {
          return data.mapDimension(dim);
        }), dataIndex)) || [];
      }
    } else if (el) {
      var rect = el.getBoundingRect().clone();
      rect.applyTransform(el.transform);
      point = [rect.x + rect.width / 2, rect.y + rect.height / 2];
    }
    return {
      point,
      el
    };
  }

  // node_modules/echarts/lib/component/axisPointer/axisTrigger.js
  var inner13 = makeInner();
  function axisTrigger(payload, ecModel, api) {
    var currTrigger = payload.currTrigger;
    var point = [payload.x, payload.y];
    var finder = payload;
    var dispatchAction3 = payload.dispatchAction || bind(api.dispatchAction, api);
    var coordSysAxesInfo = ecModel.getComponent("axisPointer").coordSysAxesInfo;
    if (!coordSysAxesInfo) {
      return;
    }
    if (illegalPoint(point)) {
      point = findPointFromSeries({
        seriesIndex: finder.seriesIndex,
        dataIndex: finder.dataIndex
      }, ecModel).point;
    }
    var isIllegalPoint = illegalPoint(point);
    var inputAxesInfo = finder.axesInfo;
    var axesInfo = coordSysAxesInfo.axesInfo;
    var shouldHide = currTrigger === "leave" || illegalPoint(point);
    var outputPayload = {};
    var showValueMap = {};
    var dataByCoordSys = {
      list: [],
      map: {}
    };
    var updaters = {
      showPointer: curry(showPointer, showValueMap),
      showTooltip: curry(showTooltip, dataByCoordSys)
    };
    each(coordSysAxesInfo.coordSysMap, function(coordSys, coordSysKey) {
      var coordSysContainsPoint = isIllegalPoint || coordSys.containPoint(point);
      each(coordSysAxesInfo.coordSysAxesInfo[coordSysKey], function(axisInfo, key) {
        var axis = axisInfo.axis;
        var inputAxisInfo = findInputAxisInfo(inputAxesInfo, axisInfo);
        if (!shouldHide && coordSysContainsPoint && (!inputAxesInfo || inputAxisInfo)) {
          var val = inputAxisInfo && inputAxisInfo.value;
          if (val == null && !isIllegalPoint) {
            val = axis.pointToData(point);
          }
          val != null && processOnAxis(axisInfo, val, updaters, false, outputPayload);
        }
      });
    });
    var linkTriggers = {};
    each(axesInfo, function(tarAxisInfo, tarKey) {
      var linkGroup = tarAxisInfo.linkGroup;
      if (linkGroup && !showValueMap[tarKey]) {
        each(linkGroup.axesInfo, function(srcAxisInfo, srcKey) {
          var srcValItem = showValueMap[srcKey];
          if (srcAxisInfo !== tarAxisInfo && srcValItem) {
            var val = srcValItem.value;
            linkGroup.mapper && (val = tarAxisInfo.axis.scale.parse(linkGroup.mapper(val, makeMapperParam(srcAxisInfo), makeMapperParam(tarAxisInfo))));
            linkTriggers[tarAxisInfo.key] = val;
          }
        });
      }
    });
    each(linkTriggers, function(val, tarKey) {
      processOnAxis(axesInfo[tarKey], val, updaters, true, outputPayload);
    });
    updateModelActually(showValueMap, axesInfo, outputPayload);
    dispatchTooltipActually(dataByCoordSys, point, payload, dispatchAction3);
    dispatchHighDownActually(axesInfo, dispatchAction3, api);
    return outputPayload;
  }
  function processOnAxis(axisInfo, newValue, updaters, noSnap, outputFinder) {
    var axis = axisInfo.axis;
    if (axis.scale.isBlank() || !axis.containData(newValue)) {
      return;
    }
    if (!axisInfo.involveSeries) {
      updaters.showPointer(axisInfo, newValue);
      return;
    }
    var payloadInfo = buildPayloadsBySeries(newValue, axisInfo);
    var payloadBatch = payloadInfo.payloadBatch;
    var snapToValue = payloadInfo.snapToValue;
    if (payloadBatch[0] && outputFinder.seriesIndex == null) {
      extend(outputFinder, payloadBatch[0]);
    }
    if (!noSnap && axisInfo.snap) {
      if (axis.containData(snapToValue) && snapToValue != null) {
        newValue = snapToValue;
      }
    }
    updaters.showPointer(axisInfo, newValue, payloadBatch);
    updaters.showTooltip(axisInfo, payloadInfo, snapToValue);
  }
  function buildPayloadsBySeries(value, axisInfo) {
    var axis = axisInfo.axis;
    var dim = axis.dim;
    var snapToValue = value;
    var payloadBatch = [];
    var minDist = Number.MAX_VALUE;
    var minDiff = -1;
    each(axisInfo.seriesModels, function(series, idx) {
      var dataDim = series.getData().mapDimensionsAll(dim);
      var seriesNestestValue;
      var dataIndices;
      if (series.getAxisTooltipData) {
        var result = series.getAxisTooltipData(dataDim, value, axis);
        dataIndices = result.dataIndices;
        seriesNestestValue = result.nestestValue;
      } else {
        dataIndices = series.getData().indicesOfNearest(dataDim[0], value, axis.type === "category" ? 0.5 : null);
        if (!dataIndices.length) {
          return;
        }
        seriesNestestValue = series.getData().get(dataDim[0], dataIndices[0]);
      }
      if (seriesNestestValue == null || !isFinite(seriesNestestValue)) {
        return;
      }
      var diff = value - seriesNestestValue;
      var dist3 = Math.abs(diff);
      if (dist3 <= minDist) {
        if (dist3 < minDist || diff >= 0 && minDiff < 0) {
          minDist = dist3;
          minDiff = diff;
          snapToValue = seriesNestestValue;
          payloadBatch.length = 0;
        }
        each(dataIndices, function(dataIndex) {
          payloadBatch.push({
            seriesIndex: series.seriesIndex,
            dataIndexInside: dataIndex,
            dataIndex: series.getData().getRawIndex(dataIndex)
          });
        });
      }
    });
    return {
      payloadBatch,
      snapToValue
    };
  }
  function showPointer(showValueMap, axisInfo, value, payloadBatch) {
    showValueMap[axisInfo.key] = {
      value,
      payloadBatch
    };
  }
  function showTooltip(dataByCoordSys, axisInfo, payloadInfo, value) {
    var payloadBatch = payloadInfo.payloadBatch;
    var axis = axisInfo.axis;
    var axisModel = axis.model;
    var axisPointerModel = axisInfo.axisPointerModel;
    if (!axisInfo.triggerTooltip || !payloadBatch.length) {
      return;
    }
    var coordSysModel = axisInfo.coordSys.model;
    var coordSysKey = makeKey(coordSysModel);
    var coordSysItem = dataByCoordSys.map[coordSysKey];
    if (!coordSysItem) {
      coordSysItem = dataByCoordSys.map[coordSysKey] = {
        coordSysId: coordSysModel.id,
        coordSysIndex: coordSysModel.componentIndex,
        coordSysType: coordSysModel.type,
        coordSysMainType: coordSysModel.mainType,
        dataByAxis: []
      };
      dataByCoordSys.list.push(coordSysItem);
    }
    coordSysItem.dataByAxis.push({
      axisDim: axis.dim,
      axisIndex: axisModel.componentIndex,
      axisType: axisModel.type,
      axisId: axisModel.id,
      value,
      valueLabelOpt: {
        precision: axisPointerModel.get(["label", "precision"]),
        formatter: axisPointerModel.get(["label", "formatter"])
      },
      seriesDataIndices: payloadBatch.slice()
    });
  }
  function updateModelActually(showValueMap, axesInfo, outputPayload) {
    var outputAxesInfo = outputPayload.axesInfo = [];
    each(axesInfo, function(axisInfo, key) {
      var option = axisInfo.axisPointerModel.option;
      var valItem = showValueMap[key];
      if (valItem) {
        !axisInfo.useHandle && (option.status = "show");
        option.value = valItem.value;
        option.seriesDataIndices = (valItem.payloadBatch || []).slice();
      } else {
        !axisInfo.useHandle && (option.status = "hide");
      }
      option.status === "show" && outputAxesInfo.push({
        axisDim: axisInfo.axis.dim,
        axisIndex: axisInfo.axis.model.componentIndex,
        value: option.value
      });
    });
  }
  function dispatchTooltipActually(dataByCoordSys, point, payload, dispatchAction3) {
    if (illegalPoint(point) || !dataByCoordSys.list.length) {
      dispatchAction3({
        type: "hideTip"
      });
      return;
    }
    var sampleItem = ((dataByCoordSys.list[0].dataByAxis[0] || {}).seriesDataIndices || [])[0] || {};
    dispatchAction3({
      type: "showTip",
      escapeConnect: true,
      x: point[0],
      y: point[1],
      tooltipOption: payload.tooltipOption,
      position: payload.position,
      dataIndexInside: sampleItem.dataIndexInside,
      dataIndex: sampleItem.dataIndex,
      seriesIndex: sampleItem.seriesIndex,
      dataByCoordSys: dataByCoordSys.list
    });
  }
  function dispatchHighDownActually(axesInfo, dispatchAction3, api) {
    var zr = api.getZr();
    var highDownKey = "axisPointerLastHighlights";
    var lastHighlights = inner13(zr)[highDownKey] || {};
    var newHighlights = inner13(zr)[highDownKey] = {};
    each(axesInfo, function(axisInfo, key) {
      var option = axisInfo.axisPointerModel.option;
      option.status === "show" && each(option.seriesDataIndices, function(batchItem) {
        var key2 = batchItem.seriesIndex + " | " + batchItem.dataIndex;
        newHighlights[key2] = batchItem;
      });
    });
    var toHighlight = [];
    var toDownplay = [];
    each(lastHighlights, function(batchItem, key) {
      !newHighlights[key] && toDownplay.push(batchItem);
    });
    each(newHighlights, function(batchItem, key) {
      !lastHighlights[key] && toHighlight.push(batchItem);
    });
    toDownplay.length && api.dispatchAction({
      type: "downplay",
      escapeConnect: true,
      notBlur: true,
      batch: toDownplay
    });
    toHighlight.length && api.dispatchAction({
      type: "highlight",
      escapeConnect: true,
      notBlur: true,
      batch: toHighlight
    });
  }
  function findInputAxisInfo(inputAxesInfo, axisInfo) {
    for (var i = 0; i < (inputAxesInfo || []).length; i++) {
      var inputAxisInfo = inputAxesInfo[i];
      if (axisInfo.axis.dim === inputAxisInfo.axisDim && axisInfo.axis.model.componentIndex === inputAxisInfo.axisIndex) {
        return inputAxisInfo;
      }
    }
  }
  function makeMapperParam(axisInfo) {
    var axisModel = axisInfo.axis.model;
    var item = {};
    var dim = item.axisDim = axisInfo.axis.dim;
    item.axisIndex = item[dim + "AxisIndex"] = axisModel.componentIndex;
    item.axisName = item[dim + "AxisName"] = axisModel.name;
    item.axisId = item[dim + "AxisId"] = axisModel.id;
    return item;
  }
  function illegalPoint(point) {
    return !point || point[0] == null || isNaN(point[0]) || point[1] == null || isNaN(point[1]);
  }

  // node_modules/echarts/lib/component/axisPointer/install.js
  function install29(registers) {
    AxisView_default.registerAxisPointerClass("CartesianAxisPointer", CartesianAxisPointer_default);
    registers.registerComponentModel(AxisPointerModel_default);
    registers.registerComponentView(AxisPointerView_default);
    registers.registerPreprocessor(function(option) {
      if (option) {
        (!option.axisPointer || option.axisPointer.length === 0) && (option.axisPointer = {});
        var link = option.axisPointer.link;
        if (link && !isArray(link)) {
          option.axisPointer.link = [link];
        }
      }
    });
    registers.registerProcessor(registers.PRIORITY.PROCESSOR.STATISTIC, function(ecModel, api) {
      ecModel.getComponent("axisPointer").coordSysAxesInfo = collect(ecModel, api);
    });
    registers.registerAction({
      type: "updateAxisPointer",
      event: "updateAxisPointer",
      update: ":updateAxisPointer"
    }, axisTrigger);
  }

  // node_modules/echarts/lib/component/grid/install.js
  function install30(registers) {
    use(install6);
    use(install29);
  }

  // node_modules/echarts/lib/component/axisPointer/PolarAxisPointer.js
  var PolarAxisPointer = function(_super) {
    __extends(PolarAxisPointer2, _super);
    function PolarAxisPointer2() {
      return _super !== null && _super.apply(this, arguments) || this;
    }
    PolarAxisPointer2.prototype.makeElOption = function(elOption, value, axisModel, axisPointerModel, api) {
      var axis = axisModel.axis;
      if (axis.dim === "angle") {
        this.animationThreshold = Math.PI / 18;
      }
      var polar = axis.polar;
      var otherAxis = polar.getOtherAxis(axis);
      var otherExtent = otherAxis.getExtent();
      var coordValue = axis.dataToCoord(value);
      var axisPointerType = axisPointerModel.get("type");
      if (axisPointerType && axisPointerType !== "none") {
        var elStyle = buildElStyle(axisPointerModel);
        var pointerOption = pointerShapeBuilder2[axisPointerType](axis, polar, coordValue, otherExtent);
        pointerOption.style = elStyle;
        elOption.graphicKey = pointerOption.type;
        elOption.pointer = pointerOption;
      }
      var labelMargin = axisPointerModel.get(["label", "margin"]);
      var labelPos = getLabelPosition(value, axisModel, axisPointerModel, polar, labelMargin);
      buildLabelElOption(elOption, axisModel, axisPointerModel, api, labelPos);
    };
    return PolarAxisPointer2;
  }(BaseAxisPointer_default);
  function getLabelPosition(value, axisModel, axisPointerModel, polar, labelMargin) {
    var axis = axisModel.axis;
    var coord = axis.dataToCoord(value);
    var axisAngle = polar.getAngleAxis().getExtent()[0];
    axisAngle = axisAngle / 180 * Math.PI;
    var radiusExtent = polar.getRadiusAxis().getExtent();
    var position2;
    var align;
    var verticalAlign;
    if (axis.dim === "radius") {
      var transform2 = create2();
      rotate(transform2, transform2, axisAngle);
      translate(transform2, transform2, [polar.cx, polar.cy]);
      position2 = applyTransform2([coord, -labelMargin], transform2);
      var labelRotation = axisModel.getModel("axisLabel").get("rotate") || 0;
      var labelLayout2 = AxisBuilder_default.innerTextLayout(axisAngle, labelRotation * Math.PI / 180, -1);
      align = labelLayout2.textAlign;
      verticalAlign = labelLayout2.textVerticalAlign;
    } else {
      var r = radiusExtent[1];
      position2 = polar.coordToPoint([r + labelMargin, coord]);
      var cx = polar.cx;
      var cy = polar.cy;
      align = Math.abs(position2[0] - cx) / r < 0.3 ? "center" : position2[0] > cx ? "left" : "right";
      verticalAlign = Math.abs(position2[1] - cy) / r < 0.3 ? "middle" : position2[1] > cy ? "top" : "bottom";
    }
    return {
      position: position2,
      align,
      verticalAlign
    };
  }
  var pointerShapeBuilder2 = {
    line: function(axis, polar, coordValue, otherExtent) {
      return axis.dim === "angle" ? {
        type: "Line",
        shape: makeLineShape(polar.coordToPoint([otherExtent[0], coordValue]), polar.coordToPoint([otherExtent[1], coordValue]))
      } : {
        type: "Circle",
        shape: {
          cx: polar.cx,
          cy: polar.cy,
          r: coordValue
        }
      };
    },
    shadow: function(axis, polar, coordValue, otherExtent) {
      var bandWidth = Math.max(1, axis.getBandWidth());
      var radian = Math.PI / 180;
      return axis.dim === "angle" ? {
        type: "Sector",
        shape: makeSectorShape(polar.cx, polar.cy, otherExtent[0], otherExtent[1], (-coordValue - bandWidth / 2) * radian, (-coordValue + bandWidth / 2) * radian)
      } : {
        type: "Sector",
        shape: makeSectorShape(polar.cx, polar.cy, coordValue - bandWidth / 2, coordValue + bandWidth / 2, 0, Math.PI * 2)
      };
    }
  };
  var PolarAxisPointer_default = PolarAxisPointer;

  // node_modules/echarts/lib/coord/polar/PolarModel.js
  var PolarModel = function(_super) {
    __extends(PolarModel2, _super);
    function PolarModel2() {
      var _this = _super !== null && _super.apply(this, arguments) || this;
      _this.type = PolarModel2.type;
      return _this;
    }
    PolarModel2.prototype.findAxisModel = function(axisType) {
      var foundAxisModel;
      var ecModel = this.ecModel;
      ecModel.eachComponent(axisType, function(axisModel) {
        if (axisModel.getCoordSysModel() === this) {
          foundAxisModel = axisModel;
        }
      }, this);
      return foundAxisModel;
    };
    PolarModel2.type = "polar";
    PolarModel2.dependencies = ["radiusAxis", "angleAxis"];
    PolarModel2.defaultOption = {
      z: 0,
      center: ["50%", "50%"],
      radius: "80%"
    };
    return PolarModel2;
  }(Component_default);
  var PolarModel_default = PolarModel;

  // node_modules/echarts/lib/coord/polar/AxisModel.js
  var PolarAxisModel = function(_super) {
    __extends(PolarAxisModel2, _super);
    function PolarAxisModel2() {
      return _super !== null && _super.apply(this, arguments) || this;
    }
    PolarAxisModel2.prototype.getCoordSysModel = function() {
      return this.getReferringComponents("polar", SINGLE_REFERRING).models[0];
    };
    PolarAxisModel2.type = "polarAxis";
    return PolarAxisModel2;
  }(Component_default);
  mixin(PolarAxisModel, AxisModelCommonMixin);
  var AngleAxisModel = function(_super) {
    __extends(AngleAxisModel2, _super);
    function AngleAxisModel2() {
      var _this = _super !== null && _super.apply(this, arguments) || this;
      _this.type = AngleAxisModel2.type;
      return _this;
    }
    AngleAxisModel2.type = "angleAxis";
    return AngleAxisModel2;
  }(PolarAxisModel);
  var RadiusAxisModel = function(_super) {
    __extends(RadiusAxisModel2, _super);
    function RadiusAxisModel2() {
      var _this = _super !== null && _super.apply(this, arguments) || this;
      _this.type = RadiusAxisModel2.type;
      return _this;
    }
    RadiusAxisModel2.type = "radiusAxis";
    return RadiusAxisModel2;
  }(PolarAxisModel);

  // node_modules/echarts/lib/coord/polar/RadiusAxis.js
  var RadiusAxis = function(_super) {
    __extends(RadiusAxis2, _super);
    function RadiusAxis2(scale4, radiusExtent) {
      return _super.call(this, "radius", scale4, radiusExtent) || this;
    }
    RadiusAxis2.prototype.pointToData = function(point, clamp2) {
      return this.polar.pointToData(point, clamp2)[this.dim === "radius" ? 0 : 1];
    };
    return RadiusAxis2;
  }(Axis_default);
  RadiusAxis.prototype.dataToRadius = Axis_default.prototype.dataToCoord;
  RadiusAxis.prototype.radiusToData = Axis_default.prototype.coordToData;
  var RadiusAxis_default = RadiusAxis;

  // node_modules/echarts/lib/coord/polar/AngleAxis.js
  var inner14 = makeInner();
  var AngleAxis = function(_super) {
    __extends(AngleAxis2, _super);
    function AngleAxis2(scale4, angleExtent) {
      return _super.call(this, "angle", scale4, angleExtent || [0, 360]) || this;
    }
    AngleAxis2.prototype.pointToData = function(point, clamp2) {
      return this.polar.pointToData(point, clamp2)[this.dim === "radius" ? 0 : 1];
    };
    AngleAxis2.prototype.calculateCategoryInterval = function() {
      var axis = this;
      var labelModel = axis.getLabelModel();
      var ordinalScale = axis.scale;
      var ordinalExtent = ordinalScale.getExtent();
      var tickCount = ordinalScale.count();
      if (ordinalExtent[1] - ordinalExtent[0] < 1) {
        return 0;
      }
      var tickValue = ordinalExtent[0];
      var unitSpan = axis.dataToCoord(tickValue + 1) - axis.dataToCoord(tickValue);
      var unitH = Math.abs(unitSpan);
      var rect = getBoundingRect(tickValue == null ? "" : tickValue + "", labelModel.getFont(), "center", "top");
      var maxH = Math.max(rect.height, 7);
      var dh = maxH / unitH;
      isNaN(dh) && (dh = Infinity);
      var interval = Math.max(0, Math.floor(dh));
      var cache = inner14(axis.model);
      var lastAutoInterval = cache.lastAutoInterval;
      var lastTickCount = cache.lastTickCount;
      if (lastAutoInterval != null && lastTickCount != null && Math.abs(lastAutoInterval - interval) <= 1 && Math.abs(lastTickCount - tickCount) <= 1 && lastAutoInterval > interval) {
        interval = lastAutoInterval;
      } else {
        cache.lastTickCount = tickCount;
        cache.lastAutoInterval = interval;
      }
      return interval;
    };
    return AngleAxis2;
  }(Axis_default);
  AngleAxis.prototype.dataToAngle = Axis_default.prototype.dataToCoord;
  AngleAxis.prototype.angleToData = Axis_default.prototype.coordToData;
  var AngleAxis_default = AngleAxis;

  // node_modules/echarts/lib/coord/polar/Polar.js
  var polarDimensions = ["radius", "angle"];
  var Polar = function() {
    function Polar2(name) {
      this.dimensions = polarDimensions;
      this.type = "polar";
      this.cx = 0;
      this.cy = 0;
      this._radiusAxis = new RadiusAxis_default();
      this._angleAxis = new AngleAxis_default();
      this.axisPointerEnabled = true;
      this.name = name || "";
      this._radiusAxis.polar = this._angleAxis.polar = this;
    }
    Polar2.prototype.containPoint = function(point) {
      var coord = this.pointToCoord(point);
      return this._radiusAxis.contain(coord[0]) && this._angleAxis.contain(coord[1]);
    };
    Polar2.prototype.containData = function(data) {
      return this._radiusAxis.containData(data[0]) && this._angleAxis.containData(data[1]);
    };
    Polar2.prototype.getAxis = function(dim) {
      var key = "_" + dim + "Axis";
      return this[key];
    };
    Polar2.prototype.getAxes = function() {
      return [this._radiusAxis, this._angleAxis];
    };
    Polar2.prototype.getAxesByScale = function(scaleType) {
      var axes = [];
      var angleAxis = this._angleAxis;
      var radiusAxis = this._radiusAxis;
      angleAxis.scale.type === scaleType && axes.push(angleAxis);
      radiusAxis.scale.type === scaleType && axes.push(radiusAxis);
      return axes;
    };
    Polar2.prototype.getAngleAxis = function() {
      return this._angleAxis;
    };
    Polar2.prototype.getRadiusAxis = function() {
      return this._radiusAxis;
    };
    Polar2.prototype.getOtherAxis = function(axis) {
      var angleAxis = this._angleAxis;
      return axis === angleAxis ? this._radiusAxis : angleAxis;
    };
    Polar2.prototype.getBaseAxis = function() {
      return this.getAxesByScale("ordinal")[0] || this.getAxesByScale("time")[0] || this.getAngleAxis();
    };
    Polar2.prototype.getTooltipAxes = function(dim) {
      var baseAxis = dim != null && dim !== "auto" ? this.getAxis(dim) : this.getBaseAxis();
      return {
        baseAxes: [baseAxis],
        otherAxes: [this.getOtherAxis(baseAxis)]
      };
    };
    Polar2.prototype.dataToPoint = function(data, clamp2) {
      return this.coordToPoint([this._radiusAxis.dataToRadius(data[0], clamp2), this._angleAxis.dataToAngle(data[1], clamp2)]);
    };
    Polar2.prototype.pointToData = function(point, clamp2) {
      var coord = this.pointToCoord(point);
      return [this._radiusAxis.radiusToData(coord[0], clamp2), this._angleAxis.angleToData(coord[1], clamp2)];
    };
    Polar2.prototype.pointToCoord = function(point) {
      var dx = point[0] - this.cx;
      var dy = point[1] - this.cy;
      var angleAxis = this.getAngleAxis();
      var extent3 = angleAxis.getExtent();
      var minAngle = Math.min(extent3[0], extent3[1]);
      var maxAngle = Math.max(extent3[0], extent3[1]);
      angleAxis.inverse ? minAngle = maxAngle - 360 : maxAngle = minAngle + 360;
      var radius = Math.sqrt(dx * dx + dy * dy);
      dx /= radius;
      dy /= radius;
      var radian = Math.atan2(-dy, dx) / Math.PI * 180;
      var dir3 = radian < minAngle ? 1 : -1;
      while (radian < minAngle || radian > maxAngle) {
        radian += dir3 * 360;
      }
      return [radius, radian];
    };
    Polar2.prototype.coordToPoint = function(coord) {
      var radius = coord[0];
      var radian = coord[1] / 180 * Math.PI;
      var x = Math.cos(radian) * radius + this.cx;
      var y = -Math.sin(radian) * radius + this.cy;
      return [x, y];
    };
    Polar2.prototype.getArea = function() {
      var angleAxis = this.getAngleAxis();
      var radiusAxis = this.getRadiusAxis();
      var radiusExtent = radiusAxis.getExtent().slice();
      radiusExtent[0] > radiusExtent[1] && radiusExtent.reverse();
      var angleExtent = angleAxis.getExtent();
      var RADIAN4 = Math.PI / 180;
      return {
        cx: this.cx,
        cy: this.cy,
        r0: radiusExtent[0],
        r: radiusExtent[1],
        startAngle: -angleExtent[0] * RADIAN4,
        endAngle: -angleExtent[1] * RADIAN4,
        clockwise: angleAxis.inverse,
        contain: function(x, y) {
          var dx = x - this.cx;
          var dy = y - this.cy;
          var d2 = dx * dx + dy * dy - 1e-4;
          var r = this.r;
          var r0 = this.r0;
          return d2 <= r * r && d2 >= r0 * r0;
        }
      };
    };
    Polar2.prototype.convertToPixel = function(ecModel, finder, value) {
      var coordSys = getCoordSys3(finder);
      return coordSys === this ? this.dataToPoint(value) : null;
    };
    Polar2.prototype.convertFromPixel = function(ecModel, finder, pixel) {
      var coordSys = getCoordSys3(finder);
      return coordSys === this ? this.pointToData(pixel) : null;
    };
    return Polar2;
  }();
  function getCoordSys3(finder) {
    var seriesModel = finder.seriesModel;
    var polarModel = finder.polarModel;
    return polarModel && polarModel.coordinateSystem || seriesModel && seriesModel.coordinateSystem;
  }
  var Polar_default = Polar;

  // node_modules/echarts/lib/coord/polar/polarCreator.js
  function resizePolar(polar, polarModel, api) {
    var center3 = polarModel.get("center");
    var width = api.getWidth();
    var height = api.getHeight();
    polar.cx = parsePercent2(center3[0], width);
    polar.cy = parsePercent2(center3[1], height);
    var radiusAxis = polar.getRadiusAxis();
    var size = Math.min(width, height) / 2;
    var radius = polarModel.get("radius");
    if (radius == null) {
      radius = [0, "100%"];
    } else if (!isArray(radius)) {
      radius = [0, radius];
    }
    var parsedRadius = [parsePercent2(radius[0], size), parsePercent2(radius[1], size)];
    radiusAxis.inverse ? radiusAxis.setExtent(parsedRadius[1], parsedRadius[0]) : radiusAxis.setExtent(parsedRadius[0], parsedRadius[1]);
  }
  function updatePolarScale(ecModel, api) {
    var polar = this;
    var angleAxis = polar.getAngleAxis();
    var radiusAxis = polar.getRadiusAxis();
    angleAxis.scale.setExtent(Infinity, -Infinity);
    radiusAxis.scale.setExtent(Infinity, -Infinity);
    ecModel.eachSeries(function(seriesModel) {
      if (seriesModel.coordinateSystem === polar) {
        var data_1 = seriesModel.getData();
        each(getDataDimensionsOnAxis(data_1, "radius"), function(dim) {
          radiusAxis.scale.unionExtentFromData(data_1, dim);
        });
        each(getDataDimensionsOnAxis(data_1, "angle"), function(dim) {
          angleAxis.scale.unionExtentFromData(data_1, dim);
        });
      }
    });
    niceScaleExtent(angleAxis.scale, angleAxis.model);
    niceScaleExtent(radiusAxis.scale, radiusAxis.model);
    if (angleAxis.type === "category" && !angleAxis.onBand) {
      var extent3 = angleAxis.getExtent();
      var diff = 360 / angleAxis.scale.count();
      angleAxis.inverse ? extent3[1] += diff : extent3[1] -= diff;
      angleAxis.setExtent(extent3[0], extent3[1]);
    }
  }
  function isAngleAxisModel(axisModel) {
    return axisModel.mainType === "angleAxis";
  }
  function setAxis(axis, axisModel) {
    axis.type = axisModel.get("type");
    axis.scale = createScaleByModel(axisModel);
    axis.onBand = axisModel.get("boundaryGap") && axis.type === "category";
    axis.inverse = axisModel.get("inverse");
    if (isAngleAxisModel(axisModel)) {
      axis.inverse = axis.inverse !== axisModel.get("clockwise");
      var startAngle = axisModel.get("startAngle");
      axis.setExtent(startAngle, startAngle + (axis.inverse ? -360 : 360));
    }
    axisModel.axis = axis;
    axis.model = axisModel;
  }
  var polarCreator = {
    dimensions: polarDimensions,
    create: function(ecModel, api) {
      var polarList = [];
      ecModel.eachComponent("polar", function(polarModel, idx) {
        var polar = new Polar_default(idx + "");
        polar.update = updatePolarScale;
        var radiusAxis = polar.getRadiusAxis();
        var angleAxis = polar.getAngleAxis();
        var radiusAxisModel = polarModel.findAxisModel("radiusAxis");
        var angleAxisModel = polarModel.findAxisModel("angleAxis");
        setAxis(radiusAxis, radiusAxisModel);
        setAxis(angleAxis, angleAxisModel);
        resizePolar(polar, polarModel, api);
        polarList.push(polar);
        polarModel.coordinateSystem = polar;
        polar.model = polarModel;
      });
      ecModel.eachSeries(function(seriesModel) {
        if (seriesModel.get("coordinateSystem") === "polar") {
          var polarModel = seriesModel.getReferringComponents("polar", SINGLE_REFERRING).models[0];
          if (true) {
            if (!polarModel) {
              throw new Error('Polar "' + retrieve(seriesModel.get("polarIndex"), seriesModel.get("polarId"), 0) + '" not found');
            }
          }
          seriesModel.coordinateSystem = polarModel.coordinateSystem;
        }
      });
      return polarList;
    }
  };
  var polarCreator_default = polarCreator;

  // node_modules/echarts/lib/component/axis/AngleAxisView.js
  var elementList2 = ["axisLine", "axisLabel", "axisTick", "minorTick", "splitLine", "minorSplitLine", "splitArea"];
  function getAxisLineShape(polar, rExtent, angle) {
    rExtent[1] > rExtent[0] && (rExtent = rExtent.slice().reverse());
    var start2 = polar.coordToPoint([rExtent[0], angle]);
    var end2 = polar.coordToPoint([rExtent[1], angle]);
    return {
      x1: start2[0],
      y1: start2[1],
      x2: end2[0],
      y2: end2[1]
    };
  }
  function getRadiusIdx(polar) {
    var radiusAxis = polar.getRadiusAxis();
    return radiusAxis.inverse ? 0 : 1;
  }
  function fixAngleOverlap(list) {
    var firstItem = list[0];
    var lastItem = list[list.length - 1];
    if (firstItem && lastItem && Math.abs(Math.abs(firstItem.coord - lastItem.coord) - 360) < 1e-4) {
      list.pop();
    }
  }
  var AngleAxisView = function(_super) {
    __extends(AngleAxisView2, _super);
    function AngleAxisView2() {
      var _this = _super !== null && _super.apply(this, arguments) || this;
      _this.type = AngleAxisView2.type;
      _this.axisPointerClass = "PolarAxisPointer";
      return _this;
    }
    AngleAxisView2.prototype.render = function(angleAxisModel, ecModel) {
      this.group.removeAll();
      if (!angleAxisModel.get("show")) {
        return;
      }
      var angleAxis = angleAxisModel.axis;
      var polar = angleAxis.polar;
      var radiusExtent = polar.getRadiusAxis().getExtent();
      var ticksAngles = angleAxis.getTicksCoords();
      var minorTickAngles = angleAxis.getMinorTicksCoords();
      var labels = map(angleAxis.getViewLabels(), function(labelItem) {
        labelItem = clone(labelItem);
        var scale4 = angleAxis.scale;
        var tickValue = scale4.type === "ordinal" ? scale4.getRawOrdinalNumber(labelItem.tickValue) : labelItem.tickValue;
        labelItem.coord = angleAxis.dataToCoord(tickValue);
        return labelItem;
      });
      fixAngleOverlap(labels);
      fixAngleOverlap(ticksAngles);
      each(elementList2, function(name) {
        if (angleAxisModel.get([name, "show"]) && (!angleAxis.scale.isBlank() || name === "axisLine")) {
          angelAxisElementsBuilders[name](this.group, angleAxisModel, polar, ticksAngles, minorTickAngles, radiusExtent, labels);
        }
      }, this);
    };
    AngleAxisView2.type = "angleAxis";
    return AngleAxisView2;
  }(AxisView_default);
  var angelAxisElementsBuilders = {
    axisLine: function(group, angleAxisModel, polar, ticksAngles, minorTickAngles, radiusExtent) {
      var lineStyleModel = angleAxisModel.getModel(["axisLine", "lineStyle"]);
      var rId = getRadiusIdx(polar);
      var r0Id = rId ? 0 : 1;
      var shape;
      if (radiusExtent[r0Id] === 0) {
        shape = new Circle_default({
          shape: {
            cx: polar.cx,
            cy: polar.cy,
            r: radiusExtent[rId]
          },
          style: lineStyleModel.getLineStyle(),
          z2: 1,
          silent: true
        });
      } else {
        shape = new Ring_default({
          shape: {
            cx: polar.cx,
            cy: polar.cy,
            r: radiusExtent[rId],
            r0: radiusExtent[r0Id]
          },
          style: lineStyleModel.getLineStyle(),
          z2: 1,
          silent: true
        });
      }
      shape.style.fill = null;
      group.add(shape);
    },
    axisTick: function(group, angleAxisModel, polar, ticksAngles, minorTickAngles, radiusExtent) {
      var tickModel = angleAxisModel.getModel("axisTick");
      var tickLen = (tickModel.get("inside") ? -1 : 1) * tickModel.get("length");
      var radius = radiusExtent[getRadiusIdx(polar)];
      var lines = map(ticksAngles, function(tickAngleItem) {
        return new Line_default({
          shape: getAxisLineShape(polar, [radius, radius + tickLen], tickAngleItem.coord)
        });
      });
      group.add(mergePath2(lines, {
        style: defaults(tickModel.getModel("lineStyle").getLineStyle(), {
          stroke: angleAxisModel.get(["axisLine", "lineStyle", "color"])
        })
      }));
    },
    minorTick: function(group, angleAxisModel, polar, tickAngles, minorTickAngles, radiusExtent) {
      if (!minorTickAngles.length) {
        return;
      }
      var tickModel = angleAxisModel.getModel("axisTick");
      var minorTickModel = angleAxisModel.getModel("minorTick");
      var tickLen = (tickModel.get("inside") ? -1 : 1) * minorTickModel.get("length");
      var radius = radiusExtent[getRadiusIdx(polar)];
      var lines = [];
      for (var i = 0; i < minorTickAngles.length; i++) {
        for (var k = 0; k < minorTickAngles[i].length; k++) {
          lines.push(new Line_default({
            shape: getAxisLineShape(polar, [radius, radius + tickLen], minorTickAngles[i][k].coord)
          }));
        }
      }
      group.add(mergePath2(lines, {
        style: defaults(minorTickModel.getModel("lineStyle").getLineStyle(), defaults(tickModel.getLineStyle(), {
          stroke: angleAxisModel.get(["axisLine", "lineStyle", "color"])
        }))
      }));
    },
    axisLabel: function(group, angleAxisModel, polar, ticksAngles, minorTickAngles, radiusExtent, labels) {
      var rawCategoryData = angleAxisModel.getCategories(true);
      var commonLabelModel = angleAxisModel.getModel("axisLabel");
      var labelMargin = commonLabelModel.get("margin");
      var triggerEvent = angleAxisModel.get("triggerEvent");
      each(labels, function(labelItem, idx) {
        var labelModel = commonLabelModel;
        var tickValue = labelItem.tickValue;
        var r = radiusExtent[getRadiusIdx(polar)];
        var p = polar.coordToPoint([r + labelMargin, labelItem.coord]);
        var cx = polar.cx;
        var cy = polar.cy;
        var labelTextAlign = Math.abs(p[0] - cx) / r < 0.3 ? "center" : p[0] > cx ? "left" : "right";
        var labelTextVerticalAlign = Math.abs(p[1] - cy) / r < 0.3 ? "middle" : p[1] > cy ? "top" : "bottom";
        if (rawCategoryData && rawCategoryData[tickValue]) {
          var rawCategoryItem = rawCategoryData[tickValue];
          if (isObject(rawCategoryItem) && rawCategoryItem.textStyle) {
            labelModel = new Model_default(rawCategoryItem.textStyle, commonLabelModel, commonLabelModel.ecModel);
          }
        }
        var textEl = new Text_default({
          silent: AxisBuilder_default.isLabelSilent(angleAxisModel),
          style: createTextStyle(labelModel, {
            x: p[0],
            y: p[1],
            fill: labelModel.getTextColor() || angleAxisModel.get(["axisLine", "lineStyle", "color"]),
            text: labelItem.formattedLabel,
            align: labelTextAlign,
            verticalAlign: labelTextVerticalAlign
          })
        });
        group.add(textEl);
        if (triggerEvent) {
          var eventData = AxisBuilder_default.makeAxisEventDataBase(angleAxisModel);
          eventData.targetType = "axisLabel";
          eventData.value = labelItem.rawLabel;
          getECData(textEl).eventData = eventData;
        }
      }, this);
    },
    splitLine: function(group, angleAxisModel, polar, ticksAngles, minorTickAngles, radiusExtent) {
      var splitLineModel = angleAxisModel.getModel("splitLine");
      var lineStyleModel = splitLineModel.getModel("lineStyle");
      var lineColors = lineStyleModel.get("color");
      var lineCount = 0;
      lineColors = lineColors instanceof Array ? lineColors : [lineColors];
      var splitLines = [];
      for (var i = 0; i < ticksAngles.length; i++) {
        var colorIndex = lineCount++ % lineColors.length;
        splitLines[colorIndex] = splitLines[colorIndex] || [];
        splitLines[colorIndex].push(new Line_default({
          shape: getAxisLineShape(polar, radiusExtent, ticksAngles[i].coord)
        }));
      }
      for (var i = 0; i < splitLines.length; i++) {
        group.add(mergePath2(splitLines[i], {
          style: defaults({
            stroke: lineColors[i % lineColors.length]
          }, lineStyleModel.getLineStyle()),
          silent: true,
          z: angleAxisModel.get("z")
        }));
      }
    },
    minorSplitLine: function(group, angleAxisModel, polar, ticksAngles, minorTickAngles, radiusExtent) {
      if (!minorTickAngles.length) {
        return;
      }
      var minorSplitLineModel = angleAxisModel.getModel("minorSplitLine");
      var lineStyleModel = minorSplitLineModel.getModel("lineStyle");
      var lines = [];
      for (var i = 0; i < minorTickAngles.length; i++) {
        for (var k = 0; k < minorTickAngles[i].length; k++) {
          lines.push(new Line_default({
            shape: getAxisLineShape(polar, radiusExtent, minorTickAngles[i][k].coord)
          }));
        }
      }
      group.add(mergePath2(lines, {
        style: lineStyleModel.getLineStyle(),
        silent: true,
        z: angleAxisModel.get("z")
      }));
    },
    splitArea: function(group, angleAxisModel, polar, ticksAngles, minorTickAngles, radiusExtent) {
      if (!ticksAngles.length) {
        return;
      }
      var splitAreaModel = angleAxisModel.getModel("splitArea");
      var areaStyleModel = splitAreaModel.getModel("areaStyle");
      var areaColors = areaStyleModel.get("color");
      var lineCount = 0;
      areaColors = areaColors instanceof Array ? areaColors : [areaColors];
      var splitAreas = [];
      var RADIAN4 = Math.PI / 180;
      var prevAngle = -ticksAngles[0].coord * RADIAN4;
      var r0 = Math.min(radiusExtent[0], radiusExtent[1]);
      var r1 = Math.max(radiusExtent[0], radiusExtent[1]);
      var clockwise = angleAxisModel.get("clockwise");
      for (var i = 1, len2 = ticksAngles.length; i <= len2; i++) {
        var coord = i === len2 ? ticksAngles[0].coord : ticksAngles[i].coord;
        var colorIndex = lineCount++ % areaColors.length;
        splitAreas[colorIndex] = splitAreas[colorIndex] || [];
        splitAreas[colorIndex].push(new Sector_default({
          shape: {
            cx: polar.cx,
            cy: polar.cy,
            r0,
            r: r1,
            startAngle: prevAngle,
            endAngle: -coord * RADIAN4,
            clockwise
          },
          silent: true
        }));
        prevAngle = -coord * RADIAN4;
      }
      for (var i = 0; i < splitAreas.length; i++) {
        group.add(mergePath2(splitAreas[i], {
          style: defaults({
            fill: areaColors[i % areaColors.length]
          }, areaStyleModel.getAreaStyle()),
          silent: true
        }));
      }
    }
  };
  var AngleAxisView_default = AngleAxisView;

  // node_modules/echarts/lib/component/axis/RadiusAxisView.js
  var axisBuilderAttrs3 = ["axisLine", "axisTickLabel", "axisName"];
  var selfBuilderAttrs2 = ["splitLine", "splitArea", "minorSplitLine"];
  var RadiusAxisView = function(_super) {
    __extends(RadiusAxisView2, _super);
    function RadiusAxisView2() {
      var _this = _super !== null && _super.apply(this, arguments) || this;
      _this.type = RadiusAxisView2.type;
      _this.axisPointerClass = "PolarAxisPointer";
      return _this;
    }
    RadiusAxisView2.prototype.render = function(radiusAxisModel, ecModel) {
      this.group.removeAll();
      if (!radiusAxisModel.get("show")) {
        return;
      }
      var oldAxisGroup = this._axisGroup;
      var newAxisGroup = this._axisGroup = new Group_default();
      this.group.add(newAxisGroup);
      var radiusAxis = radiusAxisModel.axis;
      var polar = radiusAxis.polar;
      var angleAxis = polar.getAngleAxis();
      var ticksCoords = radiusAxis.getTicksCoords();
      var minorTicksCoords = radiusAxis.getMinorTicksCoords();
      var axisAngle = angleAxis.getExtent()[0];
      var radiusExtent = radiusAxis.getExtent();
      var layout5 = layoutAxis(polar, radiusAxisModel, axisAngle);
      var axisBuilder = new AxisBuilder_default(radiusAxisModel, layout5);
      each(axisBuilderAttrs3, axisBuilder.add, axisBuilder);
      newAxisGroup.add(axisBuilder.getGroup());
      groupTransition(oldAxisGroup, newAxisGroup, radiusAxisModel);
      each(selfBuilderAttrs2, function(name) {
        if (radiusAxisModel.get([name, "show"]) && !radiusAxis.scale.isBlank()) {
          axisElementBuilders2[name](this.group, radiusAxisModel, polar, axisAngle, radiusExtent, ticksCoords, minorTicksCoords);
        }
      }, this);
    };
    RadiusAxisView2.type = "radiusAxis";
    return RadiusAxisView2;
  }(AxisView_default);
  var axisElementBuilders2 = {
    splitLine: function(group, radiusAxisModel, polar, axisAngle, radiusExtent, ticksCoords) {
      var splitLineModel = radiusAxisModel.getModel("splitLine");
      var lineStyleModel = splitLineModel.getModel("lineStyle");
      var lineColors = lineStyleModel.get("color");
      var lineCount = 0;
      lineColors = lineColors instanceof Array ? lineColors : [lineColors];
      var splitLines = [];
      for (var i = 0; i < ticksCoords.length; i++) {
        var colorIndex = lineCount++ % lineColors.length;
        splitLines[colorIndex] = splitLines[colorIndex] || [];
        splitLines[colorIndex].push(new Circle_default({
          shape: {
            cx: polar.cx,
            cy: polar.cy,
            r: Math.max(ticksCoords[i].coord, 0)
          }
        }));
      }
      for (var i = 0; i < splitLines.length; i++) {
        group.add(mergePath2(splitLines[i], {
          style: defaults({
            stroke: lineColors[i % lineColors.length],
            fill: null
          }, lineStyleModel.getLineStyle()),
          silent: true
        }));
      }
    },
    minorSplitLine: function(group, radiusAxisModel, polar, axisAngle, radiusExtent, ticksCoords, minorTicksCoords) {
      if (!minorTicksCoords.length) {
        return;
      }
      var minorSplitLineModel = radiusAxisModel.getModel("minorSplitLine");
      var lineStyleModel = minorSplitLineModel.getModel("lineStyle");
      var lines = [];
      for (var i = 0; i < minorTicksCoords.length; i++) {
        for (var k = 0; k < minorTicksCoords[i].length; k++) {
          lines.push(new Circle_default({
            shape: {
              cx: polar.cx,
              cy: polar.cy,
              r: minorTicksCoords[i][k].coord
            }
          }));
        }
      }
      group.add(mergePath2(lines, {
        style: defaults({
          fill: null
        }, lineStyleModel.getLineStyle()),
        silent: true
      }));
    },
    splitArea: function(group, radiusAxisModel, polar, axisAngle, radiusExtent, ticksCoords) {
      if (!ticksCoords.length) {
        return;
      }
      var splitAreaModel = radiusAxisModel.getModel("splitArea");
      var areaStyleModel = splitAreaModel.getModel("areaStyle");
      var areaColors = areaStyleModel.get("color");
      var lineCount = 0;
      areaColors = areaColors instanceof Array ? areaColors : [areaColors];
      var splitAreas = [];
      var prevRadius = ticksCoords[0].coord;
      for (var i = 1; i < ticksCoords.length; i++) {
        var colorIndex = lineCount++ % areaColors.length;
        splitAreas[colorIndex] = splitAreas[colorIndex] || [];
        splitAreas[colorIndex].push(new Sector_default({
          shape: {
            cx: polar.cx,
            cy: polar.cy,
            r0: prevRadius,
            r: ticksCoords[i].coord,
            startAngle: 0,
            endAngle: Math.PI * 2
          },
          silent: true
        }));
        prevRadius = ticksCoords[i].coord;
      }
      for (var i = 0; i < splitAreas.length; i++) {
        group.add(mergePath2(splitAreas[i], {
          style: defaults({
            fill: areaColors[i % areaColors.length]
          }, areaStyleModel.getAreaStyle()),
          silent: true
        }));
      }
    }
  };
  function layoutAxis(polar, radiusAxisModel, axisAngle) {
    return {
      position: [polar.cx, polar.cy],
      rotation: axisAngle / 180 * Math.PI,
      labelDirection: -1,
      tickDirection: -1,
      nameDirection: 1,
      labelRotate: radiusAxisModel.getModel("axisLabel").get("rotate"),
      z2: 1
    };
  }
  var RadiusAxisView_default = RadiusAxisView;

  // node_modules/echarts/lib/layout/barPolar.js
  function getSeriesStackId2(seriesModel) {
    return seriesModel.get("stack") || "__ec_stack_" + seriesModel.seriesIndex;
  }
  function getAxisKey2(polar, axis) {
    return axis.dim + polar.model.componentIndex;
  }
  function barLayoutPolar(seriesType2, ecModel, api) {
    var lastStackCoords = {};
    var barWidthAndOffset = calRadialBar(filter(ecModel.getSeriesByType(seriesType2), function(seriesModel) {
      return !ecModel.isSeriesFiltered(seriesModel) && seriesModel.coordinateSystem && seriesModel.coordinateSystem.type === "polar";
    }));
    ecModel.eachSeriesByType(seriesType2, function(seriesModel) {
      if (seriesModel.coordinateSystem.type !== "polar") {
        return;
      }
      var data = seriesModel.getData();
      var polar = seriesModel.coordinateSystem;
      var baseAxis = polar.getBaseAxis();
      var axisKey = getAxisKey2(polar, baseAxis);
      var stackId = getSeriesStackId2(seriesModel);
      var columnLayoutInfo = barWidthAndOffset[axisKey][stackId];
      var columnOffset = columnLayoutInfo.offset;
      var columnWidth = columnLayoutInfo.width;
      var valueAxis2 = polar.getOtherAxis(baseAxis);
      var cx = seriesModel.coordinateSystem.cx;
      var cy = seriesModel.coordinateSystem.cy;
      var barMinHeight = seriesModel.get("barMinHeight") || 0;
      var barMinAngle = seriesModel.get("barMinAngle") || 0;
      lastStackCoords[stackId] = lastStackCoords[stackId] || [];
      var valueDim = data.mapDimension(valueAxis2.dim);
      var baseDim = data.mapDimension(baseAxis.dim);
      var stacked = isDimensionStacked(data, valueDim);
      var clampLayout = baseAxis.dim !== "radius" || !seriesModel.get("roundCap", true);
      var valueAxisStart = valueAxis2.dataToCoord(0);
      for (var idx = 0, len2 = data.count(); idx < len2; idx++) {
        var value = data.get(valueDim, idx);
        var baseValue = data.get(baseDim, idx);
        var sign = value >= 0 ? "p" : "n";
        var baseCoord = valueAxisStart;
        if (stacked) {
          if (!lastStackCoords[stackId][baseValue]) {
            lastStackCoords[stackId][baseValue] = {
              p: valueAxisStart,
              n: valueAxisStart
            };
          }
          baseCoord = lastStackCoords[stackId][baseValue][sign];
        }
        var r0 = void 0;
        var r = void 0;
        var startAngle = void 0;
        var endAngle = void 0;
        if (valueAxis2.dim === "radius") {
          var radiusSpan = valueAxis2.dataToCoord(value) - valueAxisStart;
          var angle = baseAxis.dataToCoord(baseValue);
          if (Math.abs(radiusSpan) < barMinHeight) {
            radiusSpan = (radiusSpan < 0 ? -1 : 1) * barMinHeight;
          }
          r0 = baseCoord;
          r = baseCoord + radiusSpan;
          startAngle = angle - columnOffset;
          endAngle = startAngle - columnWidth;
          stacked && (lastStackCoords[stackId][baseValue][sign] = r);
        } else {
          var angleSpan = valueAxis2.dataToCoord(value, clampLayout) - valueAxisStart;
          var radius = baseAxis.dataToCoord(baseValue);
          if (Math.abs(angleSpan) < barMinAngle) {
            angleSpan = (angleSpan < 0 ? -1 : 1) * barMinAngle;
          }
          r0 = radius + columnOffset;
          r = r0 + columnWidth;
          startAngle = baseCoord;
          endAngle = baseCoord + angleSpan;
          stacked && (lastStackCoords[stackId][baseValue][sign] = endAngle);
        }
        data.setItemLayout(idx, {
          cx,
          cy,
          r0,
          r,
          startAngle: -startAngle * Math.PI / 180,
          endAngle: -endAngle * Math.PI / 180,
          clockwise: startAngle >= endAngle
        });
      }
    });
  }
  function calRadialBar(barSeries) {
    var columnsMap = {};
    each(barSeries, function(seriesModel, idx) {
      var data = seriesModel.getData();
      var polar = seriesModel.coordinateSystem;
      var baseAxis = polar.getBaseAxis();
      var axisKey = getAxisKey2(polar, baseAxis);
      var axisExtent = baseAxis.getExtent();
      var bandWidth = baseAxis.type === "category" ? baseAxis.getBandWidth() : Math.abs(axisExtent[1] - axisExtent[0]) / data.count();
      var columnsOnAxis = columnsMap[axisKey] || {
        bandWidth,
        remainedWidth: bandWidth,
        autoWidthCount: 0,
        categoryGap: "20%",
        gap: "30%",
        stacks: {}
      };
      var stacks = columnsOnAxis.stacks;
      columnsMap[axisKey] = columnsOnAxis;
      var stackId = getSeriesStackId2(seriesModel);
      if (!stacks[stackId]) {
        columnsOnAxis.autoWidthCount++;
      }
      stacks[stackId] = stacks[stackId] || {
        width: 0,
        maxWidth: 0
      };
      var barWidth = parsePercent2(seriesModel.get("barWidth"), bandWidth);
      var barMaxWidth = parsePercent2(seriesModel.get("barMaxWidth"), bandWidth);
      var barGap = seriesModel.get("barGap");
      var barCategoryGap = seriesModel.get("barCategoryGap");
      if (barWidth && !stacks[stackId].width) {
        barWidth = Math.min(columnsOnAxis.remainedWidth, barWidth);
        stacks[stackId].width = barWidth;
        columnsOnAxis.remainedWidth -= barWidth;
      }
      barMaxWidth && (stacks[stackId].maxWidth = barMaxWidth);
      barGap != null && (columnsOnAxis.gap = barGap);
      barCategoryGap != null && (columnsOnAxis.categoryGap = barCategoryGap);
    });
    var result = {};
    each(columnsMap, function(columnsOnAxis, coordSysName) {
      result[coordSysName] = {};
      var stacks = columnsOnAxis.stacks;
      var bandWidth = columnsOnAxis.bandWidth;
      var categoryGap = parsePercent2(columnsOnAxis.categoryGap, bandWidth);
      var barGapPercent = parsePercent2(columnsOnAxis.gap, 1);
      var remainedWidth = columnsOnAxis.remainedWidth;
      var autoWidthCount = columnsOnAxis.autoWidthCount;
      var autoWidth = (remainedWidth - categoryGap) / (autoWidthCount + (autoWidthCount - 1) * barGapPercent);
      autoWidth = Math.max(autoWidth, 0);
      each(stacks, function(column, stack) {
        var maxWidth = column.maxWidth;
        if (maxWidth && maxWidth < autoWidth) {
          maxWidth = Math.min(maxWidth, remainedWidth);
          if (column.width) {
            maxWidth = Math.min(maxWidth, column.width);
          }
          remainedWidth -= maxWidth;
          column.width = maxWidth;
          autoWidthCount--;
        }
      });
      autoWidth = (remainedWidth - categoryGap) / (autoWidthCount + (autoWidthCount - 1) * barGapPercent);
      autoWidth = Math.max(autoWidth, 0);
      var widthSum = 0;
      var lastColumn;
      each(stacks, function(column, idx) {
        if (!column.width) {
          column.width = autoWidth;
        }
        lastColumn = column;
        widthSum += column.width * (1 + barGapPercent);
      });
      if (lastColumn) {
        widthSum -= lastColumn.width * barGapPercent;
      }
      var offset = -widthSum / 2;
      each(stacks, function(column, stackId) {
        result[coordSysName][stackId] = result[coordSysName][stackId] || {
          offset,
          width: column.width
        };
        offset += column.width * (1 + barGapPercent);
      });
    });
    return result;
  }
  var barPolar_default = barLayoutPolar;

  // node_modules/echarts/lib/component/polar/install.js
  var angleAxisExtraOption = {
    startAngle: 90,
    clockwise: true,
    splitNumber: 12,
    axisLabel: {
      rotate: 0
    }
  };
  var radiusAxisExtraOption = {
    splitNumber: 5
  };
  var PolarView = function(_super) {
    __extends(PolarView2, _super);
    function PolarView2() {
      var _this = _super !== null && _super.apply(this, arguments) || this;
      _this.type = PolarView2.type;
      return _this;
    }
    PolarView2.type = "polar";
    return PolarView2;
  }(Component_default2);
  function install31(registers) {
    use(install29);
    AxisView_default.registerAxisPointerClass("PolarAxisPointer", PolarAxisPointer_default);
    registers.registerCoordinateSystem("polar", polarCreator_default);
    registers.registerComponentModel(PolarModel_default);
    registers.registerComponentView(PolarView);
    axisModelCreator(registers, "angle", AngleAxisModel, angleAxisExtraOption);
    axisModelCreator(registers, "radius", RadiusAxisModel, radiusAxisExtraOption);
    registers.registerComponentView(AngleAxisView_default);
    registers.registerComponentView(RadiusAxisView_default);
    registers.registerLayout(curry(barPolar_default, "bar"));
  }

  // node_modules/echarts/lib/coord/single/singleAxisHelper.js
  function layout3(axisModel, opt) {
    opt = opt || {};
    var single = axisModel.coordinateSystem;
    var axis = axisModel.axis;
    var layout5 = {};
    var axisPosition = axis.position;
    var orient = axis.orient;
    var rect = single.getRect();
    var rectBound = [rect.x, rect.x + rect.width, rect.y, rect.y + rect.height];
    var positionMap = {
      horizontal: {
        top: rectBound[2],
        bottom: rectBound[3]
      },
      vertical: {
        left: rectBound[0],
        right: rectBound[1]
      }
    };
    layout5.position = [orient === "vertical" ? positionMap.vertical[axisPosition] : rectBound[0], orient === "horizontal" ? positionMap.horizontal[axisPosition] : rectBound[3]];
    var r = {
      horizontal: 0,
      vertical: 1
    };
    layout5.rotation = Math.PI / 2 * r[orient];
    var directionMap = {
      top: -1,
      bottom: 1,
      right: 1,
      left: -1
    };
    layout5.labelDirection = layout5.tickDirection = layout5.nameDirection = directionMap[axisPosition];
    if (axisModel.get(["axisTick", "inside"])) {
      layout5.tickDirection = -layout5.tickDirection;
    }
    if (retrieve(opt.labelInside, axisModel.get(["axisLabel", "inside"]))) {
      layout5.labelDirection = -layout5.labelDirection;
    }
    var labelRotation = opt.rotate;
    labelRotation == null && (labelRotation = axisModel.get(["axisLabel", "rotate"]));
    layout5.labelRotation = axisPosition === "top" ? -labelRotation : labelRotation;
    layout5.z2 = 1;
    return layout5;
  }

  // node_modules/echarts/lib/component/axis/SingleAxisView.js
  var axisBuilderAttrs4 = ["axisLine", "axisTickLabel", "axisName"];
  var selfBuilderAttrs3 = ["splitArea", "splitLine"];
  var SingleAxisView = function(_super) {
    __extends(SingleAxisView2, _super);
    function SingleAxisView2() {
      var _this = _super !== null && _super.apply(this, arguments) || this;
      _this.type = SingleAxisView2.type;
      _this.axisPointerClass = "SingleAxisPointer";
      return _this;
    }
    SingleAxisView2.prototype.render = function(axisModel, ecModel, api, payload) {
      var group = this.group;
      group.removeAll();
      var oldAxisGroup = this._axisGroup;
      this._axisGroup = new Group_default();
      var layout5 = layout3(axisModel);
      var axisBuilder = new AxisBuilder_default(axisModel, layout5);
      each(axisBuilderAttrs4, axisBuilder.add, axisBuilder);
      group.add(this._axisGroup);
      group.add(axisBuilder.getGroup());
      each(selfBuilderAttrs3, function(name) {
        if (axisModel.get([name, "show"])) {
          axisElementBuilders3[name](this, this.group, this._axisGroup, axisModel);
        }
      }, this);
      groupTransition(oldAxisGroup, this._axisGroup, axisModel);
      _super.prototype.render.call(this, axisModel, ecModel, api, payload);
    };
    SingleAxisView2.prototype.remove = function() {
      rectCoordAxisHandleRemove(this);
    };
    SingleAxisView2.type = "singleAxis";
    return SingleAxisView2;
  }(AxisView_default);
  var axisElementBuilders3 = {
    splitLine: function(axisView, group, axisGroup, axisModel) {
      var axis = axisModel.axis;
      if (axis.scale.isBlank()) {
        return;
      }
      var splitLineModel = axisModel.getModel("splitLine");
      var lineStyleModel = splitLineModel.getModel("lineStyle");
      var lineColors = lineStyleModel.get("color");
      lineColors = lineColors instanceof Array ? lineColors : [lineColors];
      var gridRect = axisModel.coordinateSystem.getRect();
      var isHorizontal = axis.isHorizontal();
      var splitLines = [];
      var lineCount = 0;
      var ticksCoords = axis.getTicksCoords({
        tickModel: splitLineModel
      });
      var p1 = [];
      var p2 = [];
      for (var i = 0; i < ticksCoords.length; ++i) {
        var tickCoord = axis.toGlobalCoord(ticksCoords[i].coord);
        if (isHorizontal) {
          p1[0] = tickCoord;
          p1[1] = gridRect.y;
          p2[0] = tickCoord;
          p2[1] = gridRect.y + gridRect.height;
        } else {
          p1[0] = gridRect.x;
          p1[1] = tickCoord;
          p2[0] = gridRect.x + gridRect.width;
          p2[1] = tickCoord;
        }
        var colorIndex = lineCount++ % lineColors.length;
        splitLines[colorIndex] = splitLines[colorIndex] || [];
        splitLines[colorIndex].push(new Line_default({
          subPixelOptimize: true,
          shape: {
            x1: p1[0],
            y1: p1[1],
            x2: p2[0],
            y2: p2[1]
          },
          silent: true
        }));
      }
      var lineStyle = lineStyleModel.getLineStyle(["color"]);
      for (var i = 0; i < splitLines.length; ++i) {
        group.add(mergePath2(splitLines[i], {
          style: defaults({
            stroke: lineColors[i % lineColors.length]
          }, lineStyle),
          silent: true
        }));
      }
    },
    splitArea: function(axisView, group, axisGroup, axisModel) {
      rectCoordAxisBuildSplitArea(axisView, axisGroup, axisModel, axisModel);
    }
  };
  var SingleAxisView_default = SingleAxisView;

  // node_modules/echarts/lib/coord/single/AxisModel.js
  var SingleAxisModel = function(_super) {
    __extends(SingleAxisModel2, _super);
    function SingleAxisModel2() {
      var _this = _super !== null && _super.apply(this, arguments) || this;
      _this.type = SingleAxisModel2.type;
      return _this;
    }
    SingleAxisModel2.prototype.getCoordSysModel = function() {
      return this;
    };
    SingleAxisModel2.type = "singleAxis";
    SingleAxisModel2.layoutMode = "box";
    SingleAxisModel2.defaultOption = {
      left: "5%",
      top: "5%",
      right: "5%",
      bottom: "5%",
      type: "value",
      position: "bottom",
      orient: "horizontal",
      axisLine: {
        show: true,
        lineStyle: {
          width: 1,
          type: "solid"
        }
      },
      tooltip: {
        show: true
      },
      axisTick: {
        show: true,
        length: 6,
        lineStyle: {
          width: 1
        }
      },
      axisLabel: {
        show: true,
        interval: "auto"
      },
      splitLine: {
        show: true,
        lineStyle: {
          type: "dashed",
          opacity: 0.2
        }
      }
    };
    return SingleAxisModel2;
  }(Component_default);
  mixin(SingleAxisModel, AxisModelCommonMixin.prototype);
  var AxisModel_default2 = SingleAxisModel;

  // node_modules/echarts/lib/coord/single/SingleAxis.js
  var SingleAxis = function(_super) {
    __extends(SingleAxis2, _super);
    function SingleAxis2(dim, scale4, coordExtent, axisType, position2) {
      var _this = _super.call(this, dim, scale4, coordExtent) || this;
      _this.type = axisType || "value";
      _this.position = position2 || "bottom";
      return _this;
    }
    SingleAxis2.prototype.isHorizontal = function() {
      var position2 = this.position;
      return position2 === "top" || position2 === "bottom";
    };
    SingleAxis2.prototype.pointToData = function(point, clamp2) {
      return this.coordinateSystem.pointToData(point)[0];
    };
    return SingleAxis2;
  }(Axis_default);
  var SingleAxis_default = SingleAxis;

  // node_modules/echarts/lib/coord/single/Single.js
  var singleDimensions = ["single"];
  var Single = function() {
    function Single2(axisModel, ecModel, api) {
      this.type = "single";
      this.dimension = "single";
      this.dimensions = singleDimensions;
      this.axisPointerEnabled = true;
      this.model = axisModel;
      this._init(axisModel, ecModel, api);
    }
    Single2.prototype._init = function(axisModel, ecModel, api) {
      var dim = this.dimension;
      var axis = new SingleAxis_default(dim, createScaleByModel(axisModel), [0, 0], axisModel.get("type"), axisModel.get("position"));
      var isCategory2 = axis.type === "category";
      axis.onBand = isCategory2 && axisModel.get("boundaryGap");
      axis.inverse = axisModel.get("inverse");
      axis.orient = axisModel.get("orient");
      axisModel.axis = axis;
      axis.model = axisModel;
      axis.coordinateSystem = this;
      this._axis = axis;
    };
    Single2.prototype.update = function(ecModel, api) {
      ecModel.eachSeries(function(seriesModel) {
        if (seriesModel.coordinateSystem === this) {
          var data_1 = seriesModel.getData();
          each(data_1.mapDimensionsAll(this.dimension), function(dim) {
            this._axis.scale.unionExtentFromData(data_1, dim);
          }, this);
          niceScaleExtent(this._axis.scale, this._axis.model);
        }
      }, this);
    };
    Single2.prototype.resize = function(axisModel, api) {
      this._rect = getLayoutRect({
        left: axisModel.get("left"),
        top: axisModel.get("top"),
        right: axisModel.get("right"),
        bottom: axisModel.get("bottom"),
        width: axisModel.get("width"),
        height: axisModel.get("height")
      }, {
        width: api.getWidth(),
        height: api.getHeight()
      });
      this._adjustAxis();
    };
    Single2.prototype.getRect = function() {
      return this._rect;
    };
    Single2.prototype._adjustAxis = function() {
      var rect = this._rect;
      var axis = this._axis;
      var isHorizontal = axis.isHorizontal();
      var extent3 = isHorizontal ? [0, rect.width] : [0, rect.height];
      var idx = axis.reverse ? 1 : 0;
      axis.setExtent(extent3[idx], extent3[1 - idx]);
      this._updateAxisTransform(axis, isHorizontal ? rect.x : rect.y);
    };
    Single2.prototype._updateAxisTransform = function(axis, coordBase) {
      var axisExtent = axis.getExtent();
      var extentSum = axisExtent[0] + axisExtent[1];
      var isHorizontal = axis.isHorizontal();
      axis.toGlobalCoord = isHorizontal ? function(coord) {
        return coord + coordBase;
      } : function(coord) {
        return extentSum - coord + coordBase;
      };
      axis.toLocalCoord = isHorizontal ? function(coord) {
        return coord - coordBase;
      } : function(coord) {
        return extentSum - coord + coordBase;
      };
    };
    Single2.prototype.getAxis = function() {
      return this._axis;
    };
    Single2.prototype.getBaseAxis = function() {
      return this._axis;
    };
    Single2.prototype.getAxes = function() {
      return [this._axis];
    };
    Single2.prototype.getTooltipAxes = function() {
      return {
        baseAxes: [this.getAxis()],
        otherAxes: []
      };
    };
    Single2.prototype.containPoint = function(point) {
      var rect = this.getRect();
      var axis = this.getAxis();
      var orient = axis.orient;
      if (orient === "horizontal") {
        return axis.contain(axis.toLocalCoord(point[0])) && point[1] >= rect.y && point[1] <= rect.y + rect.height;
      } else {
        return axis.contain(axis.toLocalCoord(point[1])) && point[0] >= rect.y && point[0] <= rect.y + rect.height;
      }
    };
    Single2.prototype.pointToData = function(point) {
      var axis = this.getAxis();
      return [axis.coordToData(axis.toLocalCoord(point[axis.orient === "horizontal" ? 0 : 1]))];
    };
    Single2.prototype.dataToPoint = function(val) {
      var axis = this.getAxis();
      var rect = this.getRect();
      var pt = [];
      var idx = axis.orient === "horizontal" ? 0 : 1;
      if (val instanceof Array) {
        val = val[0];
      }
      pt[idx] = axis.toGlobalCoord(axis.dataToCoord(+val));
      pt[1 - idx] = idx === 0 ? rect.y + rect.height / 2 : rect.x + rect.width / 2;
      return pt;
    };
    Single2.prototype.convertToPixel = function(ecModel, finder, value) {
      var coordSys = getCoordSys4(finder);
      return coordSys === this ? this.dataToPoint(value) : null;
    };
    Single2.prototype.convertFromPixel = function(ecModel, finder, pixel) {
      var coordSys = getCoordSys4(finder);
      return coordSys === this ? this.pointToData(pixel) : null;
    };
    return Single2;
  }();
  function getCoordSys4(finder) {
    var seriesModel = finder.seriesModel;
    var singleModel = finder.singleAxisModel;
    return singleModel && singleModel.coordinateSystem || seriesModel && seriesModel.coordinateSystem;
  }
  var Single_default = Single;

  // node_modules/echarts/lib/coord/single/singleCreator.js
  function create3(ecModel, api) {
    var singles = [];
    ecModel.eachComponent("singleAxis", function(axisModel, idx) {
      var single = new Single_default(axisModel, ecModel, api);
      single.name = "single_" + idx;
      single.resize(axisModel, api);
      axisModel.coordinateSystem = single;
      singles.push(single);
    });
    ecModel.eachSeries(function(seriesModel) {
      if (seriesModel.get("coordinateSystem") === "singleAxis") {
        var singleAxisModel = seriesModel.getReferringComponents("singleAxis", SINGLE_REFERRING).models[0];
        seriesModel.coordinateSystem = singleAxisModel && singleAxisModel.coordinateSystem;
      }
    });
    return singles;
  }
  var singleCreator = {
    create: create3,
    dimensions: singleDimensions
  };
  var singleCreator_default = singleCreator;

  // node_modules/echarts/lib/component/axisPointer/SingleAxisPointer.js
  var XY = ["x", "y"];
  var WH = ["width", "height"];
  var SingleAxisPointer = function(_super) {
    __extends(SingleAxisPointer2, _super);
    function SingleAxisPointer2() {
      return _super !== null && _super.apply(this, arguments) || this;
    }
    SingleAxisPointer2.prototype.makeElOption = function(elOption, value, axisModel, axisPointerModel, api) {
      var axis = axisModel.axis;
      var coordSys = axis.coordinateSystem;
      var otherExtent = getGlobalExtent(coordSys, 1 - getPointDimIndex(axis));
      var pixelValue = coordSys.dataToPoint(value)[0];
      var axisPointerType = axisPointerModel.get("type");
      if (axisPointerType && axisPointerType !== "none") {
        var elStyle = buildElStyle(axisPointerModel);
        var pointerOption = pointerShapeBuilder3[axisPointerType](axis, pixelValue, otherExtent);
        pointerOption.style = elStyle;
        elOption.graphicKey = pointerOption.type;
        elOption.pointer = pointerOption;
      }
      var layoutInfo = layout3(axisModel);
      buildCartesianSingleLabelElOption(value, elOption, layoutInfo, axisModel, axisPointerModel, api);
    };
    SingleAxisPointer2.prototype.getHandleTransform = function(value, axisModel, axisPointerModel) {
      var layoutInfo = layout3(axisModel, {
        labelInside: false
      });
      layoutInfo.labelMargin = axisPointerModel.get(["handle", "margin"]);
      var position2 = getTransformedPosition(axisModel.axis, value, layoutInfo);
      return {
        x: position2[0],
        y: position2[1],
        rotation: layoutInfo.rotation + (layoutInfo.labelDirection < 0 ? Math.PI : 0)
      };
    };
    SingleAxisPointer2.prototype.updateHandleTransform = function(transform2, delta, axisModel, axisPointerModel) {
      var axis = axisModel.axis;
      var coordSys = axis.coordinateSystem;
      var dimIndex = getPointDimIndex(axis);
      var axisExtent = getGlobalExtent(coordSys, dimIndex);
      var currPosition = [transform2.x, transform2.y];
      currPosition[dimIndex] += delta[dimIndex];
      currPosition[dimIndex] = Math.min(axisExtent[1], currPosition[dimIndex]);
      currPosition[dimIndex] = Math.max(axisExtent[0], currPosition[dimIndex]);
      var otherExtent = getGlobalExtent(coordSys, 1 - dimIndex);
      var cursorOtherValue = (otherExtent[1] + otherExtent[0]) / 2;
      var cursorPoint = [cursorOtherValue, cursorOtherValue];
      cursorPoint[dimIndex] = currPosition[dimIndex];
      return {
        x: currPosition[0],
        y: currPosition[1],
        rotation: transform2.rotation,
        cursorPoint,
        tooltipOption: {
          verticalAlign: "middle"
        }
      };
    };
    return SingleAxisPointer2;
  }(BaseAxisPointer_default);
  var pointerShapeBuilder3 = {
    line: function(axis, pixelValue, otherExtent) {
      var targetShape = makeLineShape([pixelValue, otherExtent[0]], [pixelValue, otherExtent[1]], getPointDimIndex(axis));
      return {
        type: "Line",
        subPixelOptimize: true,
        shape: targetShape
      };
    },
    shadow: function(axis, pixelValue, otherExtent) {
      var bandWidth = axis.getBandWidth();
      var span = otherExtent[1] - otherExtent[0];
      return {
        type: "Rect",
        shape: makeRectShape([pixelValue - bandWidth / 2, otherExtent[0]], [bandWidth, span], getPointDimIndex(axis))
      };
    }
  };
  function getPointDimIndex(axis) {
    return axis.isHorizontal() ? 0 : 1;
  }
  function getGlobalExtent(coordSys, dimIndex) {
    var rect = coordSys.getRect();
    return [rect[XY[dimIndex]], rect[XY[dimIndex]] + rect[WH[dimIndex]]];
  }
  var SingleAxisPointer_default = SingleAxisPointer;

  // node_modules/echarts/lib/component/singleAxis/install.js
  var SingleView = function(_super) {
    __extends(SingleView2, _super);
    function SingleView2() {
      var _this = _super !== null && _super.apply(this, arguments) || this;
      _this.type = SingleView2.type;
      return _this;
    }
    SingleView2.type = "single";
    return SingleView2;
  }(Component_default2);
  function install32(registers) {
    use(install29);
    AxisView_default.registerAxisPointerClass("SingleAxisPointer", SingleAxisPointer_default);
    registers.registerComponentView(SingleView);
    registers.registerComponentView(SingleAxisView_default);
    registers.registerComponentModel(AxisModel_default2);
    axisModelCreator(registers, "single", AxisModel_default2, AxisModel_default2.defaultOption);
    registers.registerCoordinateSystem("single", singleCreator_default);
  }

  // node_modules/echarts/lib/coord/calendar/CalendarModel.js
  var CalendarModel = function(_super) {
    __extends(CalendarModel2, _super);
    function CalendarModel2() {
      var _this = _super !== null && _super.apply(this, arguments) || this;
      _this.type = CalendarModel2.type;
      return _this;
    }
    CalendarModel2.prototype.init = function(option, parentModel, ecModel) {
      var inputPositionParams = getLayoutParams(option);
      _super.prototype.init.apply(this, arguments);
      mergeAndNormalizeLayoutParams(option, inputPositionParams);
    };
    CalendarModel2.prototype.mergeOption = function(option) {
      _super.prototype.mergeOption.apply(this, arguments);
      mergeAndNormalizeLayoutParams(this.option, option);
    };
    CalendarModel2.prototype.getCellSize = function() {
      return this.option.cellSize;
    };
    CalendarModel2.type = "calendar";
    CalendarModel2.defaultOption = {
      z: 2,
      left: 80,
      top: 60,
      cellSize: 20,
      orient: "horizontal",
      splitLine: {
        show: true,
        lineStyle: {
          color: "#000",
          width: 1,
          type: "solid"
        }
      },
      itemStyle: {
        color: "#fff",
        borderWidth: 1,
        borderColor: "#ccc"
      },
      dayLabel: {
        show: true,
        firstDay: 0,
        position: "start",
        margin: "50%",
        color: "#000"
      },
      monthLabel: {
        show: true,
        position: "start",
        margin: 5,
        align: "center",
        formatter: null,
        color: "#000"
      },
      yearLabel: {
        show: true,
        position: null,
        margin: 30,
        formatter: null,
        color: "#ccc",
        fontFamily: "sans-serif",
        fontWeight: "bolder",
        fontSize: 20
      }
    };
    return CalendarModel2;
  }(Component_default);
  function mergeAndNormalizeLayoutParams(target, raw) {
    var cellSize = target.cellSize;
    var cellSizeArr;
    if (!isArray(cellSize)) {
      cellSizeArr = target.cellSize = [cellSize, cellSize];
    } else {
      cellSizeArr = cellSize;
    }
    if (cellSizeArr.length === 1) {
      cellSizeArr[1] = cellSizeArr[0];
    }
    var ignoreSize = map([0, 1], function(hvIdx) {
      if (sizeCalculable(raw, hvIdx)) {
        cellSizeArr[hvIdx] = "auto";
      }
      return cellSizeArr[hvIdx] != null && cellSizeArr[hvIdx] !== "auto";
    });
    mergeLayoutParam(target, raw, {
      type: "box",
      ignoreSize
    });
  }
  var CalendarModel_default = CalendarModel;

  // node_modules/echarts/lib/component/calendar/CalendarView.js
  var CalendarView = function(_super) {
    __extends(CalendarView2, _super);
    function CalendarView2() {
      var _this = _super !== null && _super.apply(this, arguments) || this;
      _this.type = CalendarView2.type;
      return _this;
    }
    CalendarView2.prototype.render = function(calendarModel, ecModel, api) {
      var group = this.group;
      group.removeAll();
      var coordSys = calendarModel.coordinateSystem;
      var rangeData = coordSys.getRangeInfo();
      var orient = coordSys.getOrient();
      var localeModel = ecModel.getLocaleModel();
      this._renderDayRect(calendarModel, rangeData, group);
      this._renderLines(calendarModel, rangeData, orient, group);
      this._renderYearText(calendarModel, rangeData, orient, group);
      this._renderMonthText(calendarModel, localeModel, orient, group);
      this._renderWeekText(calendarModel, localeModel, rangeData, orient, group);
    };
    CalendarView2.prototype._renderDayRect = function(calendarModel, rangeData, group) {
      var coordSys = calendarModel.coordinateSystem;
      var itemRectStyleModel = calendarModel.getModel("itemStyle").getItemStyle();
      var sw = coordSys.getCellWidth();
      var sh = coordSys.getCellHeight();
      for (var i = rangeData.start.time; i <= rangeData.end.time; i = coordSys.getNextNDay(i, 1).time) {
        var point = coordSys.dataToRect([i], false).tl;
        var rect = new Rect_default({
          shape: {
            x: point[0],
            y: point[1],
            width: sw,
            height: sh
          },
          cursor: "default",
          style: itemRectStyleModel
        });
        group.add(rect);
      }
    };
    CalendarView2.prototype._renderLines = function(calendarModel, rangeData, orient, group) {
      var self2 = this;
      var coordSys = calendarModel.coordinateSystem;
      var lineStyleModel = calendarModel.getModel(["splitLine", "lineStyle"]).getLineStyle();
      var show = calendarModel.get(["splitLine", "show"]);
      var lineWidth = lineStyleModel.lineWidth;
      this._tlpoints = [];
      this._blpoints = [];
      this._firstDayOfMonth = [];
      this._firstDayPoints = [];
      var firstDay = rangeData.start;
      for (var i = 0; firstDay.time <= rangeData.end.time; i++) {
        addPoints(firstDay.formatedDate);
        if (i === 0) {
          firstDay = coordSys.getDateInfo(rangeData.start.y + "-" + rangeData.start.m);
        }
        var date = firstDay.date;
        date.setMonth(date.getMonth() + 1);
        firstDay = coordSys.getDateInfo(date);
      }
      addPoints(coordSys.getNextNDay(rangeData.end.time, 1).formatedDate);
      function addPoints(date2) {
        self2._firstDayOfMonth.push(coordSys.getDateInfo(date2));
        self2._firstDayPoints.push(coordSys.dataToRect([date2], false).tl);
        var points4 = self2._getLinePointsOfOneWeek(calendarModel, date2, orient);
        self2._tlpoints.push(points4[0]);
        self2._blpoints.push(points4[points4.length - 1]);
        show && self2._drawSplitline(points4, lineStyleModel, group);
      }
      show && this._drawSplitline(self2._getEdgesPoints(self2._tlpoints, lineWidth, orient), lineStyleModel, group);
      show && this._drawSplitline(self2._getEdgesPoints(self2._blpoints, lineWidth, orient), lineStyleModel, group);
    };
    CalendarView2.prototype._getEdgesPoints = function(points4, lineWidth, orient) {
      var rs = [points4[0].slice(), points4[points4.length - 1].slice()];
      var idx = orient === "horizontal" ? 0 : 1;
      rs[0][idx] = rs[0][idx] - lineWidth / 2;
      rs[1][idx] = rs[1][idx] + lineWidth / 2;
      return rs;
    };
    CalendarView2.prototype._drawSplitline = function(points4, lineStyle, group) {
      var poyline = new Polyline_default({
        z2: 20,
        shape: {
          points: points4
        },
        style: lineStyle
      });
      group.add(poyline);
    };
    CalendarView2.prototype._getLinePointsOfOneWeek = function(calendarModel, date, orient) {
      var coordSys = calendarModel.coordinateSystem;
      var parsedDate = coordSys.getDateInfo(date);
      var points4 = [];
      for (var i = 0; i < 7; i++) {
        var tmpD = coordSys.getNextNDay(parsedDate.time, i);
        var point = coordSys.dataToRect([tmpD.time], false);
        points4[2 * tmpD.day] = point.tl;
        points4[2 * tmpD.day + 1] = point[orient === "horizontal" ? "bl" : "tr"];
      }
      return points4;
    };
    CalendarView2.prototype._formatterLabel = function(formatter, params) {
      if (isString(formatter) && formatter) {
        return formatTplSimple(formatter, params);
      }
      if (isFunction(formatter)) {
        return formatter(params);
      }
      return params.nameMap;
    };
    CalendarView2.prototype._yearTextPositionControl = function(textEl, point, orient, position2, margin) {
      var x = point[0];
      var y = point[1];
      var aligns = ["center", "bottom"];
      if (position2 === "bottom") {
        y += margin;
        aligns = ["center", "top"];
      } else if (position2 === "left") {
        x -= margin;
      } else if (position2 === "right") {
        x += margin;
        aligns = ["center", "top"];
      } else {
        y -= margin;
      }
      var rotate2 = 0;
      if (position2 === "left" || position2 === "right") {
        rotate2 = Math.PI / 2;
      }
      return {
        rotation: rotate2,
        x,
        y,
        style: {
          align: aligns[0],
          verticalAlign: aligns[1]
        }
      };
    };
    CalendarView2.prototype._renderYearText = function(calendarModel, rangeData, orient, group) {
      var yearLabel = calendarModel.getModel("yearLabel");
      if (!yearLabel.get("show")) {
        return;
      }
      var margin = yearLabel.get("margin");
      var pos = yearLabel.get("position");
      if (!pos) {
        pos = orient !== "horizontal" ? "top" : "left";
      }
      var points4 = [this._tlpoints[this._tlpoints.length - 1], this._blpoints[0]];
      var xc = (points4[0][0] + points4[1][0]) / 2;
      var yc = (points4[0][1] + points4[1][1]) / 2;
      var idx = orient === "horizontal" ? 0 : 1;
      var posPoints = {
        top: [xc, points4[idx][1]],
        bottom: [xc, points4[1 - idx][1]],
        left: [points4[1 - idx][0], yc],
        right: [points4[idx][0], yc]
      };
      var name = rangeData.start.y;
      if (+rangeData.end.y > +rangeData.start.y) {
        name = name + "-" + rangeData.end.y;
      }
      var formatter = yearLabel.get("formatter");
      var params = {
        start: rangeData.start.y,
        end: rangeData.end.y,
        nameMap: name
      };
      var content = this._formatterLabel(formatter, params);
      var yearText = new Text_default({
        z2: 30,
        style: createTextStyle(yearLabel, {
          text: content
        })
      });
      yearText.attr(this._yearTextPositionControl(yearText, posPoints[pos], orient, pos, margin));
      group.add(yearText);
    };
    CalendarView2.prototype._monthTextPositionControl = function(point, isCenter, orient, position2, margin) {
      var align = "left";
      var vAlign = "top";
      var x = point[0];
      var y = point[1];
      if (orient === "horizontal") {
        y = y + margin;
        if (isCenter) {
          align = "center";
        }
        if (position2 === "start") {
          vAlign = "bottom";
        }
      } else {
        x = x + margin;
        if (isCenter) {
          vAlign = "middle";
        }
        if (position2 === "start") {
          align = "right";
        }
      }
      return {
        x,
        y,
        align,
        verticalAlign: vAlign
      };
    };
    CalendarView2.prototype._renderMonthText = function(calendarModel, localeModel, orient, group) {
      var monthLabel = calendarModel.getModel("monthLabel");
      if (!monthLabel.get("show")) {
        return;
      }
      var nameMap = monthLabel.get("nameMap");
      var margin = monthLabel.get("margin");
      var pos = monthLabel.get("position");
      var align = monthLabel.get("align");
      var termPoints = [this._tlpoints, this._blpoints];
      if (!nameMap || isString(nameMap)) {
        if (nameMap) {
          localeModel = getLocaleModel(nameMap) || localeModel;
        }
        nameMap = localeModel.get(["time", "monthAbbr"]) || [];
      }
      var idx = pos === "start" ? 0 : 1;
      var axis = orient === "horizontal" ? 0 : 1;
      margin = pos === "start" ? -margin : margin;
      var isCenter = align === "center";
      for (var i = 0; i < termPoints[idx].length - 1; i++) {
        var tmp = termPoints[idx][i].slice();
        var firstDay = this._firstDayOfMonth[i];
        if (isCenter) {
          var firstDayPoints = this._firstDayPoints[i];
          tmp[axis] = (firstDayPoints[axis] + termPoints[0][i + 1][axis]) / 2;
        }
        var formatter = monthLabel.get("formatter");
        var name_1 = nameMap[+firstDay.m - 1];
        var params = {
          yyyy: firstDay.y,
          yy: (firstDay.y + "").slice(2),
          MM: firstDay.m,
          M: +firstDay.m,
          nameMap: name_1
        };
        var content = this._formatterLabel(formatter, params);
        var monthText = new Text_default({
          z2: 30,
          style: extend(createTextStyle(monthLabel, {
            text: content
          }), this._monthTextPositionControl(tmp, isCenter, orient, pos, margin))
        });
        group.add(monthText);
      }
    };
    CalendarView2.prototype._weekTextPositionControl = function(point, orient, position2, margin, cellSize) {
      var align = "center";
      var vAlign = "middle";
      var x = point[0];
      var y = point[1];
      var isStart = position2 === "start";
      if (orient === "horizontal") {
        x = x + margin + (isStart ? 1 : -1) * cellSize[0] / 2;
        align = isStart ? "right" : "left";
      } else {
        y = y + margin + (isStart ? 1 : -1) * cellSize[1] / 2;
        vAlign = isStart ? "bottom" : "top";
      }
      return {
        x,
        y,
        align,
        verticalAlign: vAlign
      };
    };
    CalendarView2.prototype._renderWeekText = function(calendarModel, localeModel, rangeData, orient, group) {
      var dayLabel = calendarModel.getModel("dayLabel");
      if (!dayLabel.get("show")) {
        return;
      }
      var coordSys = calendarModel.coordinateSystem;
      var pos = dayLabel.get("position");
      var nameMap = dayLabel.get("nameMap");
      var margin = dayLabel.get("margin");
      var firstDayOfWeek = coordSys.getFirstDayOfWeek();
      if (!nameMap || isString(nameMap)) {
        if (nameMap) {
          localeModel = getLocaleModel(nameMap) || localeModel;
        }
        var dayOfWeekShort = localeModel.get(["time", "dayOfWeekShort"]);
        nameMap = dayOfWeekShort || map(localeModel.get(["time", "dayOfWeekAbbr"]), function(val) {
          return val[0];
        });
      }
      var start2 = coordSys.getNextNDay(rangeData.end.time, 7 - rangeData.lweek).time;
      var cellSize = [coordSys.getCellWidth(), coordSys.getCellHeight()];
      margin = parsePercent2(margin, Math.min(cellSize[1], cellSize[0]));
      if (pos === "start") {
        start2 = coordSys.getNextNDay(rangeData.start.time, -(7 + rangeData.fweek)).time;
        margin = -margin;
      }
      for (var i = 0; i < 7; i++) {
        var tmpD = coordSys.getNextNDay(start2, i);
        var point = coordSys.dataToRect([tmpD.time], false).center;
        var day = i;
        day = Math.abs((i + firstDayOfWeek) % 7);
        var weekText = new Text_default({
          z2: 30,
          style: extend(createTextStyle(dayLabel, {
            text: nameMap[day]
          }), this._weekTextPositionControl(point, orient, pos, margin, cellSize))
        });
        group.add(weekText);
      }
    };
    CalendarView2.type = "calendar";
    return CalendarView2;
  }(Component_default2);
  var CalendarView_default = CalendarView;

  // node_modules/echarts/lib/coord/calendar/Calendar.js
  var PROXIMATE_ONE_DAY = 864e5;
  var Calendar = function() {
    function Calendar2(calendarModel, ecModel, api) {
      this.type = "calendar";
      this.dimensions = Calendar2.dimensions;
      this.getDimensionsInfo = Calendar2.getDimensionsInfo;
      this._model = calendarModel;
    }
    Calendar2.getDimensionsInfo = function() {
      return [{
        name: "time",
        type: "time"
      }, "value"];
    };
    Calendar2.prototype.getRangeInfo = function() {
      return this._rangeInfo;
    };
    Calendar2.prototype.getModel = function() {
      return this._model;
    };
    Calendar2.prototype.getRect = function() {
      return this._rect;
    };
    Calendar2.prototype.getCellWidth = function() {
      return this._sw;
    };
    Calendar2.prototype.getCellHeight = function() {
      return this._sh;
    };
    Calendar2.prototype.getOrient = function() {
      return this._orient;
    };
    Calendar2.prototype.getFirstDayOfWeek = function() {
      return this._firstDayOfWeek;
    };
    Calendar2.prototype.getDateInfo = function(date) {
      date = parseDate(date);
      var y = date.getFullYear();
      var m2 = date.getMonth() + 1;
      var mStr = m2 < 10 ? "0" + m2 : "" + m2;
      var d = date.getDate();
      var dStr = d < 10 ? "0" + d : "" + d;
      var day = date.getDay();
      day = Math.abs((day + 7 - this.getFirstDayOfWeek()) % 7);
      return {
        y: y + "",
        m: mStr,
        d: dStr,
        day,
        time: date.getTime(),
        formatedDate: y + "-" + mStr + "-" + dStr,
        date
      };
    };
    Calendar2.prototype.getNextNDay = function(date, n) {
      n = n || 0;
      if (n === 0) {
        return this.getDateInfo(date);
      }
      date = new Date(this.getDateInfo(date).time);
      date.setDate(date.getDate() + n);
      return this.getDateInfo(date);
    };
    Calendar2.prototype.update = function(ecModel, api) {
      this._firstDayOfWeek = +this._model.getModel("dayLabel").get("firstDay");
      this._orient = this._model.get("orient");
      this._lineWidth = this._model.getModel("itemStyle").getItemStyle().lineWidth || 0;
      this._rangeInfo = this._getRangeInfo(this._initRangeOption());
      var weeks = this._rangeInfo.weeks || 1;
      var whNames = ["width", "height"];
      var cellSize = this._model.getCellSize().slice();
      var layoutParams = this._model.getBoxLayoutParams();
      var cellNumbers = this._orient === "horizontal" ? [weeks, 7] : [7, weeks];
      each([0, 1], function(idx) {
        if (cellSizeSpecified(cellSize, idx)) {
          layoutParams[whNames[idx]] = cellSize[idx] * cellNumbers[idx];
        }
      });
      var whGlobal = {
        width: api.getWidth(),
        height: api.getHeight()
      };
      var calendarRect = this._rect = getLayoutRect(layoutParams, whGlobal);
      each([0, 1], function(idx) {
        if (!cellSizeSpecified(cellSize, idx)) {
          cellSize[idx] = calendarRect[whNames[idx]] / cellNumbers[idx];
        }
      });
      function cellSizeSpecified(cellSize2, idx) {
        return cellSize2[idx] != null && cellSize2[idx] !== "auto";
      }
      this._sw = cellSize[0];
      this._sh = cellSize[1];
    };
    Calendar2.prototype.dataToPoint = function(data, clamp2) {
      isArray(data) && (data = data[0]);
      clamp2 == null && (clamp2 = true);
      var dayInfo = this.getDateInfo(data);
      var range = this._rangeInfo;
      var date = dayInfo.formatedDate;
      if (clamp2 && !(dayInfo.time >= range.start.time && dayInfo.time < range.end.time + PROXIMATE_ONE_DAY)) {
        return [NaN, NaN];
      }
      var week = dayInfo.day;
      var nthWeek = this._getRangeInfo([range.start.time, date]).nthWeek;
      if (this._orient === "vertical") {
        return [this._rect.x + week * this._sw + this._sw / 2, this._rect.y + nthWeek * this._sh + this._sh / 2];
      }
      return [this._rect.x + nthWeek * this._sw + this._sw / 2, this._rect.y + week * this._sh + this._sh / 2];
    };
    Calendar2.prototype.pointToData = function(point) {
      var date = this.pointToDate(point);
      return date && date.time;
    };
    Calendar2.prototype.dataToRect = function(data, clamp2) {
      var point = this.dataToPoint(data, clamp2);
      return {
        contentShape: {
          x: point[0] - (this._sw - this._lineWidth) / 2,
          y: point[1] - (this._sh - this._lineWidth) / 2,
          width: this._sw - this._lineWidth,
          height: this._sh - this._lineWidth
        },
        center: point,
        tl: [point[0] - this._sw / 2, point[1] - this._sh / 2],
        tr: [point[0] + this._sw / 2, point[1] - this._sh / 2],
        br: [point[0] + this._sw / 2, point[1] + this._sh / 2],
        bl: [point[0] - this._sw / 2, point[1] + this._sh / 2]
      };
    };
    Calendar2.prototype.pointToDate = function(point) {
      var nthX = Math.floor((point[0] - this._rect.x) / this._sw) + 1;
      var nthY = Math.floor((point[1] - this._rect.y) / this._sh) + 1;
      var range = this._rangeInfo.range;
      if (this._orient === "vertical") {
        return this._getDateByWeeksAndDay(nthY, nthX - 1, range);
      }
      return this._getDateByWeeksAndDay(nthX, nthY - 1, range);
    };
    Calendar2.prototype.convertToPixel = function(ecModel, finder, value) {
      var coordSys = getCoordSys5(finder);
      return coordSys === this ? coordSys.dataToPoint(value) : null;
    };
    Calendar2.prototype.convertFromPixel = function(ecModel, finder, pixel) {
      var coordSys = getCoordSys5(finder);
      return coordSys === this ? coordSys.pointToData(pixel) : null;
    };
    Calendar2.prototype.containPoint = function(point) {
      console.warn("Not implemented.");
      return false;
    };
    Calendar2.prototype._initRangeOption = function() {
      var range = this._model.get("range");
      var normalizedRange;
      if (isArray(range) && range.length === 1) {
        range = range[0];
      }
      if (!isArray(range)) {
        var rangeStr = range.toString();
        if (/^\d{4}$/.test(rangeStr)) {
          normalizedRange = [rangeStr + "-01-01", rangeStr + "-12-31"];
        }
        if (/^\d{4}[\/|-]\d{1,2}$/.test(rangeStr)) {
          var start2 = this.getDateInfo(rangeStr);
          var firstDay = start2.date;
          firstDay.setMonth(firstDay.getMonth() + 1);
          var end2 = this.getNextNDay(firstDay, -1);
          normalizedRange = [start2.formatedDate, end2.formatedDate];
        }
        if (/^\d{4}[\/|-]\d{1,2}[\/|-]\d{1,2}$/.test(rangeStr)) {
          normalizedRange = [rangeStr, rangeStr];
        }
      } else {
        normalizedRange = range;
      }
      if (!normalizedRange) {
        if (true) {
          logError("Invalid date range.");
        }
        return range;
      }
      var tmp = this._getRangeInfo(normalizedRange);
      if (tmp.start.time > tmp.end.time) {
        normalizedRange.reverse();
      }
      return normalizedRange;
    };
    Calendar2.prototype._getRangeInfo = function(range) {
      var parsedRange = [this.getDateInfo(range[0]), this.getDateInfo(range[1])];
      var reversed;
      if (parsedRange[0].time > parsedRange[1].time) {
        reversed = true;
        parsedRange.reverse();
      }
      var allDay = Math.floor(parsedRange[1].time / PROXIMATE_ONE_DAY) - Math.floor(parsedRange[0].time / PROXIMATE_ONE_DAY) + 1;
      var date = new Date(parsedRange[0].time);
      var startDateNum = date.getDate();
      var endDateNum = parsedRange[1].date.getDate();
      date.setDate(startDateNum + allDay - 1);
      var dateNum = date.getDate();
      if (dateNum !== endDateNum) {
        var sign = date.getTime() - parsedRange[1].time > 0 ? 1 : -1;
        while ((dateNum = date.getDate()) !== endDateNum && (date.getTime() - parsedRange[1].time) * sign > 0) {
          allDay -= sign;
          date.setDate(dateNum - sign);
        }
      }
      var weeks = Math.floor((allDay + parsedRange[0].day + 6) / 7);
      var nthWeek = reversed ? -weeks + 1 : weeks - 1;
      reversed && parsedRange.reverse();
      return {
        range: [parsedRange[0].formatedDate, parsedRange[1].formatedDate],
        start: parsedRange[0],
        end: parsedRange[1],
        allDay,
        weeks,
        nthWeek,
        fweek: parsedRange[0].day,
        lweek: parsedRange[1].day
      };
    };
    Calendar2.prototype._getDateByWeeksAndDay = function(nthWeek, day, range) {
      var rangeInfo = this._getRangeInfo(range);
      if (nthWeek > rangeInfo.weeks || nthWeek === 0 && day < rangeInfo.fweek || nthWeek === rangeInfo.weeks && day > rangeInfo.lweek) {
        return null;
      }
      var nthDay = (nthWeek - 1) * 7 - rangeInfo.fweek + day;
      var date = new Date(rangeInfo.start.time);
      date.setDate(+rangeInfo.start.d + nthDay);
      return this.getDateInfo(date);
    };
    Calendar2.create = function(ecModel, api) {
      var calendarList = [];
      ecModel.eachComponent("calendar", function(calendarModel) {
        var calendar = new Calendar2(calendarModel, ecModel, api);
        calendarList.push(calendar);
        calendarModel.coordinateSystem = calendar;
      });
      ecModel.eachSeries(function(calendarSeries) {
        if (calendarSeries.get("coordinateSystem") === "calendar") {
          calendarSeries.coordinateSystem = calendarList[calendarSeries.get("calendarIndex") || 0];
        }
      });
      return calendarList;
    };
    Calendar2.dimensions = ["time", "value"];
    return Calendar2;
  }();
  function getCoordSys5(finder) {
    var calendarModel = finder.calendarModel;
    var seriesModel = finder.seriesModel;
    var coordSys = calendarModel ? calendarModel.coordinateSystem : seriesModel ? seriesModel.coordinateSystem : null;
    return coordSys;
  }
  var Calendar_default = Calendar;

  // node_modules/echarts/lib/component/calendar/install.js
  function install33(registers) {
    registers.registerComponentModel(CalendarModel_default);
    registers.registerComponentView(CalendarView_default);
    registers.registerCoordinateSystem("calendar", Calendar_default);
  }

  // node_modules/echarts/lib/component/graphic/GraphicModel.js
  function setKeyInfoToNewElOption(resultItem, newElOption) {
    var existElOption = resultItem.existing;
    newElOption.id = resultItem.keyInfo.id;
    !newElOption.type && existElOption && (newElOption.type = existElOption.type);
    if (newElOption.parentId == null) {
      var newElParentOption = newElOption.parentOption;
      if (newElParentOption) {
        newElOption.parentId = newElParentOption.id;
      } else if (existElOption) {
        newElOption.parentId = existElOption.parentId;
      }
    }
    newElOption.parentOption = null;
  }
  function isSetLoc(obj, props) {
    var isSet;
    each(props, function(prop) {
      obj[prop] != null && obj[prop] !== "auto" && (isSet = true);
    });
    return isSet;
  }
  function mergeNewElOptionToExist(existList, index, newElOption) {
    var newElOptCopy = extend({}, newElOption);
    var existElOption = existList[index];
    var $action = newElOption.$action || "merge";
    if ($action === "merge") {
      if (existElOption) {
        if (true) {
          var newType = newElOption.type;
          assert(!newType || existElOption.type === newType, 'Please set $action: "replace" to change `type`');
        }
        merge(existElOption, newElOptCopy, true);
        mergeLayoutParam(existElOption, newElOptCopy, {
          ignoreSize: true
        });
        copyLayoutParams(newElOption, existElOption);
        copyTransitionInfo(newElOption, existElOption);
        copyTransitionInfo(newElOption, existElOption, "shape");
        copyTransitionInfo(newElOption, existElOption, "style");
        copyTransitionInfo(newElOption, existElOption, "extra");
        newElOption.clipPath = existElOption.clipPath;
      } else {
        existList[index] = newElOptCopy;
      }
    } else if ($action === "replace") {
      existList[index] = newElOptCopy;
    } else if ($action === "remove") {
      existElOption && (existList[index] = null);
    }
  }
  var TRANSITION_PROPS_TO_COPY = ["transition", "enterFrom", "leaveTo"];
  var ROOT_TRANSITION_PROPS_TO_COPY = TRANSITION_PROPS_TO_COPY.concat(["enterAnimation", "updateAnimation", "leaveAnimation"]);
  function copyTransitionInfo(target, source, targetProp) {
    if (targetProp) {
      if (!target[targetProp] && source[targetProp]) {
        target[targetProp] = {};
      }
      target = target[targetProp];
      source = source[targetProp];
    }
    if (!target || !source) {
      return;
    }
    var props = targetProp ? TRANSITION_PROPS_TO_COPY : ROOT_TRANSITION_PROPS_TO_COPY;
    for (var i = 0; i < props.length; i++) {
      var prop = props[i];
      if (target[prop] == null && source[prop] != null) {
        target[prop] = source[prop];
      }
    }
  }
  function setLayoutInfoToExist(existItem, newElOption) {
    if (!existItem) {
      return;
    }
    existItem.hv = newElOption.hv = [
      isSetLoc(newElOption, ["left", "right"]),
      isSetLoc(newElOption, ["top", "bottom"])
    ];
    if (existItem.type === "group") {
      var existingGroupOpt = existItem;
      var newGroupOpt = newElOption;
      existingGroupOpt.width == null && (existingGroupOpt.width = newGroupOpt.width = 0);
      existingGroupOpt.height == null && (existingGroupOpt.height = newGroupOpt.height = 0);
    }
  }
  var GraphicComponentModel = function(_super) {
    __extends(GraphicComponentModel2, _super);
    function GraphicComponentModel2() {
      var _this = _super !== null && _super.apply(this, arguments) || this;
      _this.type = GraphicComponentModel2.type;
      _this.preventAutoZ = true;
      return _this;
    }
    GraphicComponentModel2.prototype.mergeOption = function(option, ecModel) {
      var elements = this.option.elements;
      this.option.elements = null;
      _super.prototype.mergeOption.call(this, option, ecModel);
      this.option.elements = elements;
    };
    GraphicComponentModel2.prototype.optionUpdated = function(newOption, isInit) {
      var thisOption = this.option;
      var newList = (isInit ? thisOption : newOption).elements;
      var existList = thisOption.elements = isInit ? [] : thisOption.elements;
      var flattenedList = [];
      this._flatten(newList, flattenedList, null);
      var mappingResult = mappingToExists(existList, flattenedList, "normalMerge");
      var elOptionsToUpdate = this._elOptionsToUpdate = [];
      each(mappingResult, function(resultItem, index) {
        var newElOption = resultItem.newOption;
        if (true) {
          assert(isObject(newElOption) || resultItem.existing, "Empty graphic option definition");
        }
        if (!newElOption) {
          return;
        }
        elOptionsToUpdate.push(newElOption);
        setKeyInfoToNewElOption(resultItem, newElOption);
        mergeNewElOptionToExist(existList, index, newElOption);
        setLayoutInfoToExist(existList[index], newElOption);
      }, this);
      thisOption.elements = filter(existList, function(item) {
        item && delete item.$action;
        return item != null;
      });
    };
    GraphicComponentModel2.prototype._flatten = function(optionList, result, parentOption) {
      each(optionList, function(option) {
        if (!option) {
          return;
        }
        if (parentOption) {
          option.parentOption = parentOption;
        }
        result.push(option);
        var children = option.children;
        if (children && children.length) {
          this._flatten(children, result, option);
        }
        delete option.children;
      }, this);
    };
    GraphicComponentModel2.prototype.useElOptionsToUpdate = function() {
      var els = this._elOptionsToUpdate;
      this._elOptionsToUpdate = null;
      return els;
    };
    GraphicComponentModel2.type = "graphic";
    GraphicComponentModel2.defaultOption = {
      elements: []
    };
    return GraphicComponentModel2;
  }(Component_default);

  // node_modules/echarts/lib/component/graphic/GraphicView.js
  var nonShapeGraphicElements = {
    path: null,
    compoundPath: null,
    group: Group_default,
    image: Image_default,
    text: Text_default
  };
  var inner15 = makeInner();
  var GraphicComponentView = function(_super) {
    __extends(GraphicComponentView2, _super);
    function GraphicComponentView2() {
      var _this = _super !== null && _super.apply(this, arguments) || this;
      _this.type = GraphicComponentView2.type;
      return _this;
    }
    GraphicComponentView2.prototype.init = function() {
      this._elMap = createHashMap();
    };
    GraphicComponentView2.prototype.render = function(graphicModel, ecModel, api) {
      if (graphicModel !== this._lastGraphicModel) {
        this._clear();
      }
      this._lastGraphicModel = graphicModel;
      this._updateElements(graphicModel);
      this._relocate(graphicModel, api);
    };
    GraphicComponentView2.prototype._updateElements = function(graphicModel) {
      var elOptionsToUpdate = graphicModel.useElOptionsToUpdate();
      if (!elOptionsToUpdate) {
        return;
      }
      var elMap = this._elMap;
      var rootGroup = this.group;
      var globalZ = graphicModel.get("z");
      var globalZLevel = graphicModel.get("zlevel");
      each(elOptionsToUpdate, function(elOption) {
        var id = convertOptionIdName(elOption.id, null);
        var elExisting = id != null ? elMap.get(id) : null;
        var parentId = convertOptionIdName(elOption.parentId, null);
        var targetElParent = parentId != null ? elMap.get(parentId) : rootGroup;
        var elType = elOption.type;
        var elOptionStyle = elOption.style;
        if (elType === "text" && elOptionStyle) {
          if (elOption.hv && elOption.hv[1]) {
            elOptionStyle.textVerticalAlign = elOptionStyle.textBaseline = elOptionStyle.verticalAlign = elOptionStyle.align = null;
          }
        }
        var textContentOption = elOption.textContent;
        var textConfig = elOption.textConfig;
        if (elOptionStyle && isEC4CompatibleStyle(elOptionStyle, elType, !!textConfig, !!textContentOption)) {
          var convertResult = convertFromEC4CompatibleStyle(elOptionStyle, elType, true);
          if (!textConfig && convertResult.textConfig) {
            textConfig = elOption.textConfig = convertResult.textConfig;
          }
          if (!textContentOption && convertResult.textContent) {
            textContentOption = convertResult.textContent;
          }
        }
        var elOptionCleaned = getCleanedElOption(elOption);
        if (true) {
          elExisting && assert(targetElParent === elExisting.parent, "Changing parent is not supported.");
        }
        var $action = elOption.$action || "merge";
        var isMerge = $action === "merge";
        var isReplace = $action === "replace";
        if (isMerge) {
          var isInit = !elExisting;
          var el_1 = elExisting;
          if (isInit) {
            el_1 = createEl2(id, targetElParent, elOption.type, elMap);
          } else {
            el_1 && (inner15(el_1).isNew = false);
            stopPreviousKeyframeAnimationAndRestore(el_1);
          }
          if (el_1) {
            applyUpdateTransition(el_1, elOptionCleaned, graphicModel, {
              isInit
            });
            updateCommonAttrs(el_1, elOption, globalZ, globalZLevel);
          }
        } else if (isReplace) {
          removeEl(elExisting, elOption, elMap, graphicModel);
          var el_2 = createEl2(id, targetElParent, elOption.type, elMap);
          if (el_2) {
            applyUpdateTransition(el_2, elOptionCleaned, graphicModel, {
              isInit: true
            });
            updateCommonAttrs(el_2, elOption, globalZ, globalZLevel);
          }
        } else if ($action === "remove") {
          updateLeaveTo(elExisting, elOption);
          removeEl(elExisting, elOption, elMap, graphicModel);
        }
        var el = elMap.get(id);
        if (el && textContentOption) {
          if (isMerge) {
            var textContentExisting = el.getTextContent();
            textContentExisting ? textContentExisting.attr(textContentOption) : el.setTextContent(new Text_default(textContentOption));
          } else if (isReplace) {
            el.setTextContent(new Text_default(textContentOption));
          }
        }
        if (el) {
          var clipPathOption = elOption.clipPath;
          if (clipPathOption) {
            var clipPathType = clipPathOption.type;
            var clipPath = void 0;
            var isInit = false;
            if (isMerge) {
              var oldClipPath = el.getClipPath();
              isInit = !oldClipPath || inner15(oldClipPath).type !== clipPathType;
              clipPath = isInit ? newEl(clipPathType) : oldClipPath;
            } else if (isReplace) {
              isInit = true;
              clipPath = newEl(clipPathType);
            }
            el.setClipPath(clipPath);
            applyUpdateTransition(clipPath, clipPathOption, graphicModel, {
              isInit
            });
            applyKeyframeAnimation(clipPath, clipPathOption.keyframeAnimation, graphicModel);
          }
          var elInner = inner15(el);
          el.setTextConfig(textConfig);
          elInner.option = elOption;
          setEventData(el, graphicModel, elOption);
          setTooltipConfig({
            el,
            componentModel: graphicModel,
            itemName: el.name,
            itemTooltipOption: elOption.tooltip
          });
          applyKeyframeAnimation(el, elOption.keyframeAnimation, graphicModel);
        }
      });
    };
    GraphicComponentView2.prototype._relocate = function(graphicModel, api) {
      var elOptions = graphicModel.option.elements;
      var rootGroup = this.group;
      var elMap = this._elMap;
      var apiWidth = api.getWidth();
      var apiHeight = api.getHeight();
      var xy = ["x", "y"];
      for (var i = 0; i < elOptions.length; i++) {
        var elOption = elOptions[i];
        var id = convertOptionIdName(elOption.id, null);
        var el = id != null ? elMap.get(id) : null;
        if (!el || !el.isGroup) {
          continue;
        }
        var parentEl = el.parent;
        var isParentRoot = parentEl === rootGroup;
        var elInner = inner15(el);
        var parentElInner = inner15(parentEl);
        elInner.width = parsePercent2(elInner.option.width, isParentRoot ? apiWidth : parentElInner.width) || 0;
        elInner.height = parsePercent2(elInner.option.height, isParentRoot ? apiHeight : parentElInner.height) || 0;
      }
      for (var i = elOptions.length - 1; i >= 0; i--) {
        var elOption = elOptions[i];
        var id = convertOptionIdName(elOption.id, null);
        var el = id != null ? elMap.get(id) : null;
        if (!el) {
          continue;
        }
        var parentEl = el.parent;
        var parentElInner = inner15(parentEl);
        var containerInfo = parentEl === rootGroup ? {
          width: apiWidth,
          height: apiHeight
        } : {
          width: parentElInner.width,
          height: parentElInner.height
        };
        var layoutPos = {};
        var layouted = positionElement(el, elOption, containerInfo, null, {
          hv: elOption.hv,
          boundingMode: elOption.bounding
        }, layoutPos);
        if (!inner15(el).isNew && layouted) {
          var transition = elOption.transition;
          var animatePos = {};
          for (var k = 0; k < xy.length; k++) {
            var key = xy[k];
            var val = layoutPos[key];
            if (transition && (isTransitionAll(transition) || indexOf(transition, key) >= 0)) {
              animatePos[key] = val;
            } else {
              el[key] = val;
            }
          }
          updateProps(el, animatePos, graphicModel, 0);
        } else {
          el.attr(layoutPos);
        }
      }
    };
    GraphicComponentView2.prototype._clear = function() {
      var _this = this;
      var elMap = this._elMap;
      elMap.each(function(el) {
        removeEl(el, inner15(el).option, elMap, _this._lastGraphicModel);
      });
      this._elMap = createHashMap();
    };
    GraphicComponentView2.prototype.dispose = function() {
      this._clear();
    };
    GraphicComponentView2.type = "graphic";
    return GraphicComponentView2;
  }(Component_default2);
  function newEl(graphicType) {
    if (true) {
      assert(graphicType, "graphic type MUST be set");
    }
    var Clz = hasOwn(nonShapeGraphicElements, graphicType) ? nonShapeGraphicElements[graphicType] : getShapeClass(graphicType);
    if (true) {
      assert(Clz, "graphic type " + graphicType + " can not be found");
    }
    var el = new Clz({});
    inner15(el).type = graphicType;
    return el;
  }
  function createEl2(id, targetElParent, graphicType, elMap) {
    var el = newEl(graphicType);
    targetElParent.add(el);
    elMap.set(id, el);
    inner15(el).id = id;
    inner15(el).isNew = true;
    return el;
  }
  function removeEl(elExisting, elOption, elMap, graphicModel) {
    var existElParent = elExisting && elExisting.parent;
    if (existElParent) {
      elExisting.type === "group" && elExisting.traverse(function(el) {
        removeEl(el, elOption, elMap, graphicModel);
      });
      applyLeaveTransition(elExisting, elOption, graphicModel);
      elMap.removeKey(inner15(elExisting).id);
    }
  }
  function updateCommonAttrs(el, elOption, defaultZ, defaultZlevel) {
    if (!el.isGroup) {
      each([
        ["cursor", Displayable_default.prototype.cursor],
        ["zlevel", defaultZlevel || 0],
        ["z", defaultZ || 0],
        ["z2", 0]
      ], function(item) {
        var prop = item[0];
        if (hasOwn(elOption, prop)) {
          el[prop] = retrieve2(elOption[prop], item[1]);
        } else if (el[prop] == null) {
          el[prop] = item[1];
        }
      });
    }
    each(keys(elOption), function(key) {
      if (key.indexOf("on") === 0) {
        var val = elOption[key];
        el[key] = isFunction(val) ? val : null;
      }
    });
    if (hasOwn(elOption, "draggable")) {
      el.draggable = elOption.draggable;
    }
    elOption.name != null && (el.name = elOption.name);
    elOption.id != null && (el.id = elOption.id);
  }
  function getCleanedElOption(elOption) {
    elOption = extend({}, elOption);
    each(["id", "parentId", "$action", "hv", "bounding", "textContent", "clipPath"].concat(LOCATION_PARAMS), function(name) {
      delete elOption[name];
    });
    return elOption;
  }
  function setEventData(el, graphicModel, elOption) {
    var eventData = getECData(el).eventData;
    if (!el.silent && !el.ignore && !eventData) {
      eventData = getECData(el).eventData = {
        componentType: "graphic",
        componentIndex: graphicModel.componentIndex,
        name: el.name
      };
    }
    if (eventData) {
      eventData.info = elOption.info;
    }
  }

  // node_modules/echarts/lib/component/graphic/install.js
  function install34(registers) {
    registers.registerComponentModel(GraphicComponentModel);
    registers.registerComponentView(GraphicComponentView);
    registers.registerPreprocessor(function(option) {
      var graphicOption = option.graphic;
      if (isArray(graphicOption)) {
        if (!graphicOption[0] || !graphicOption[0].elements) {
          option.graphic = [{
            elements: graphicOption
          }];
        } else {
          option.graphic = [option.graphic[0]];
        }
      } else if (graphicOption && !graphicOption.elements) {
        option.graphic = [{
          elements: [graphicOption]
        }];
      }
    });
  }

  // node_modules/echarts/lib/component/dataZoom/helper.js
  var DATA_ZOOM_AXIS_DIMENSIONS = ["x", "y", "radius", "angle", "single"];
  var SERIES_COORDS = ["cartesian2d", "polar", "singleAxis"];
  function isCoordSupported(seriesModel) {
    var coordType = seriesModel.get("coordinateSystem");
    return indexOf(SERIES_COORDS, coordType) >= 0;
  }
  function getAxisMainType(axisDim) {
    if (true) {
      assert(axisDim);
    }
    return axisDim + "Axis";
  }
  function findEffectedDataZooms(ecModel, payload) {
    var axisRecords = createHashMap();
    var effectedModels = [];
    var effectedModelMap = createHashMap();
    ecModel.eachComponent({
      mainType: "dataZoom",
      query: payload
    }, function(dataZoomModel) {
      if (!effectedModelMap.get(dataZoomModel.uid)) {
        addToEffected(dataZoomModel);
      }
    });
    var foundNewLink;
    do {
      foundNewLink = false;
      ecModel.eachComponent("dataZoom", processSingle);
    } while (foundNewLink);
    function processSingle(dataZoomModel) {
      if (!effectedModelMap.get(dataZoomModel.uid) && isLinked(dataZoomModel)) {
        addToEffected(dataZoomModel);
        foundNewLink = true;
      }
    }
    function addToEffected(dataZoom) {
      effectedModelMap.set(dataZoom.uid, true);
      effectedModels.push(dataZoom);
      markAxisControlled(dataZoom);
    }
    function isLinked(dataZoomModel) {
      var isLink = false;
      dataZoomModel.eachTargetAxis(function(axisDim, axisIndex) {
        var axisIdxArr = axisRecords.get(axisDim);
        if (axisIdxArr && axisIdxArr[axisIndex]) {
          isLink = true;
        }
      });
      return isLink;
    }
    function markAxisControlled(dataZoomModel) {
      dataZoomModel.eachTargetAxis(function(axisDim, axisIndex) {
        (axisRecords.get(axisDim) || axisRecords.set(axisDim, []))[axisIndex] = true;
      });
    }
    return effectedModels;
  }
  function collectReferCoordSysModelInfo(dataZoomModel) {
    var ecModel = dataZoomModel.ecModel;
    var coordSysInfoWrap = {
      infoList: [],
      infoMap: createHashMap()
    };
    dataZoomModel.eachTargetAxis(function(axisDim, axisIndex) {
      var axisModel = ecModel.getComponent(getAxisMainType(axisDim), axisIndex);
      if (!axisModel) {
        return;
      }
      var coordSysModel = axisModel.getCoordSysModel();
      if (!coordSysModel) {
        return;
      }
      var coordSysUid = coordSysModel.uid;
      var coordSysInfo = coordSysInfoWrap.infoMap.get(coordSysUid);
      if (!coordSysInfo) {
        coordSysInfo = {
          model: coordSysModel,
          axisModels: []
        };
        coordSysInfoWrap.infoList.push(coordSysInfo);
        coordSysInfoWrap.infoMap.set(coordSysUid, coordSysInfo);
      }
      coordSysInfo.axisModels.push(axisModel);
    });
    return coordSysInfoWrap;
  }

  // node_modules/echarts/lib/component/dataZoom/DataZoomModel.js
  var DataZoomAxisInfo = function() {
    function DataZoomAxisInfo2() {
      this.indexList = [];
      this.indexMap = [];
    }
    DataZoomAxisInfo2.prototype.add = function(axisCmptIdx) {
      if (!this.indexMap[axisCmptIdx]) {
        this.indexList.push(axisCmptIdx);
        this.indexMap[axisCmptIdx] = true;
      }
    };
    return DataZoomAxisInfo2;
  }();
  var DataZoomModel = function(_super) {
    __extends(DataZoomModel2, _super);
    function DataZoomModel2() {
      var _this = _super !== null && _super.apply(this, arguments) || this;
      _this.type = DataZoomModel2.type;
      _this._autoThrottle = true;
      _this._noTarget = true;
      _this._rangePropMode = ["percent", "percent"];
      return _this;
    }
    DataZoomModel2.prototype.init = function(option, parentModel, ecModel) {
      var inputRawOption = retrieveRawOption(option);
      this.settledOption = inputRawOption;
      this.mergeDefaultAndTheme(option, ecModel);
      this._doInit(inputRawOption);
    };
    DataZoomModel2.prototype.mergeOption = function(newOption) {
      var inputRawOption = retrieveRawOption(newOption);
      merge(this.option, newOption, true);
      merge(this.settledOption, inputRawOption, true);
      this._doInit(inputRawOption);
    };
    DataZoomModel2.prototype._doInit = function(inputRawOption) {
      var thisOption = this.option;
      this._setDefaultThrottle(inputRawOption);
      this._updateRangeUse(inputRawOption);
      var settledOption = this.settledOption;
      each([["start", "startValue"], ["end", "endValue"]], function(names, index) {
        if (this._rangePropMode[index] === "value") {
          thisOption[names[0]] = settledOption[names[0]] = null;
        }
      }, this);
      this._resetTarget();
    };
    DataZoomModel2.prototype._resetTarget = function() {
      var optionOrient = this.get("orient", true);
      var targetAxisIndexMap = this._targetAxisInfoMap = createHashMap();
      var hasAxisSpecified = this._fillSpecifiedTargetAxis(targetAxisIndexMap);
      if (hasAxisSpecified) {
        this._orient = optionOrient || this._makeAutoOrientByTargetAxis();
      } else {
        this._orient = optionOrient || "horizontal";
        this._fillAutoTargetAxisByOrient(targetAxisIndexMap, this._orient);
      }
      this._noTarget = true;
      targetAxisIndexMap.each(function(axisInfo) {
        if (axisInfo.indexList.length) {
          this._noTarget = false;
        }
      }, this);
    };
    DataZoomModel2.prototype._fillSpecifiedTargetAxis = function(targetAxisIndexMap) {
      var hasAxisSpecified = false;
      each(DATA_ZOOM_AXIS_DIMENSIONS, function(axisDim) {
        var refering = this.getReferringComponents(getAxisMainType(axisDim), MULTIPLE_REFERRING);
        if (!refering.specified) {
          return;
        }
        hasAxisSpecified = true;
        var axisInfo = new DataZoomAxisInfo();
        each(refering.models, function(axisModel) {
          axisInfo.add(axisModel.componentIndex);
        });
        targetAxisIndexMap.set(axisDim, axisInfo);
      }, this);
      return hasAxisSpecified;
    };
    DataZoomModel2.prototype._fillAutoTargetAxisByOrient = function(targetAxisIndexMap, orient) {
      var ecModel = this.ecModel;
      var needAuto = true;
      if (needAuto) {
        var axisDim = orient === "vertical" ? "y" : "x";
        var axisModels = ecModel.findComponents({
          mainType: axisDim + "Axis"
        });
        setParallelAxis(axisModels, axisDim);
      }
      if (needAuto) {
        var axisModels = ecModel.findComponents({
          mainType: "singleAxis",
          filter: function(axisModel) {
            return axisModel.get("orient", true) === orient;
          }
        });
        setParallelAxis(axisModels, "single");
      }
      function setParallelAxis(axisModels2, axisDim2) {
        var axisModel = axisModels2[0];
        if (!axisModel) {
          return;
        }
        var axisInfo = new DataZoomAxisInfo();
        axisInfo.add(axisModel.componentIndex);
        targetAxisIndexMap.set(axisDim2, axisInfo);
        needAuto = false;
        if (axisDim2 === "x" || axisDim2 === "y") {
          var gridModel_1 = axisModel.getReferringComponents("grid", SINGLE_REFERRING).models[0];
          gridModel_1 && each(axisModels2, function(axModel) {
            if (axisModel.componentIndex !== axModel.componentIndex && gridModel_1 === axModel.getReferringComponents("grid", SINGLE_REFERRING).models[0]) {
              axisInfo.add(axModel.componentIndex);
            }
          });
        }
      }
      if (needAuto) {
        each(DATA_ZOOM_AXIS_DIMENSIONS, function(axisDim2) {
          if (!needAuto) {
            return;
          }
          var axisModels2 = ecModel.findComponents({
            mainType: getAxisMainType(axisDim2),
            filter: function(axisModel) {
              return axisModel.get("type", true) === "category";
            }
          });
          if (axisModels2[0]) {
            var axisInfo = new DataZoomAxisInfo();
            axisInfo.add(axisModels2[0].componentIndex);
            targetAxisIndexMap.set(axisDim2, axisInfo);
            needAuto = false;
          }
        }, this);
      }
    };
    DataZoomModel2.prototype._makeAutoOrientByTargetAxis = function() {
      var dim;
      this.eachTargetAxis(function(axisDim) {
        !dim && (dim = axisDim);
      }, this);
      return dim === "y" ? "vertical" : "horizontal";
    };
    DataZoomModel2.prototype._setDefaultThrottle = function(inputRawOption) {
      if (inputRawOption.hasOwnProperty("throttle")) {
        this._autoThrottle = false;
      }
      if (this._autoThrottle) {
        var globalOption = this.ecModel.option;
        this.option.throttle = globalOption.animation && globalOption.animationDurationUpdate > 0 ? 100 : 20;
      }
    };
    DataZoomModel2.prototype._updateRangeUse = function(inputRawOption) {
      var rangePropMode = this._rangePropMode;
      var rangeModeInOption = this.get("rangeMode");
      each([["start", "startValue"], ["end", "endValue"]], function(names, index) {
        var percentSpecified = inputRawOption[names[0]] != null;
        var valueSpecified = inputRawOption[names[1]] != null;
        if (percentSpecified && !valueSpecified) {
          rangePropMode[index] = "percent";
        } else if (!percentSpecified && valueSpecified) {
          rangePropMode[index] = "value";
        } else if (rangeModeInOption) {
          rangePropMode[index] = rangeModeInOption[index];
        } else if (percentSpecified) {
          rangePropMode[index] = "percent";
        }
      });
    };
    DataZoomModel2.prototype.noTarget = function() {
      return this._noTarget;
    };
    DataZoomModel2.prototype.getFirstTargetAxisModel = function() {
      var firstAxisModel;
      this.eachTargetAxis(function(axisDim, axisIndex) {
        if (firstAxisModel == null) {
          firstAxisModel = this.ecModel.getComponent(getAxisMainType(axisDim), axisIndex);
        }
      }, this);
      return firstAxisModel;
    };
    DataZoomModel2.prototype.eachTargetAxis = function(callback, context) {
      this._targetAxisInfoMap.each(function(axisInfo, axisDim) {
        each(axisInfo.indexList, function(axisIndex) {
          callback.call(context, axisDim, axisIndex);
        });
      });
    };
    DataZoomModel2.prototype.getAxisProxy = function(axisDim, axisIndex) {
      var axisModel = this.getAxisModel(axisDim, axisIndex);
      if (axisModel) {
        return axisModel.__dzAxisProxy;
      }
    };
    DataZoomModel2.prototype.getAxisModel = function(axisDim, axisIndex) {
      if (true) {
        assert(axisDim && axisIndex != null);
      }
      var axisInfo = this._targetAxisInfoMap.get(axisDim);
      if (axisInfo && axisInfo.indexMap[axisIndex]) {
        return this.ecModel.getComponent(getAxisMainType(axisDim), axisIndex);
      }
    };
    DataZoomModel2.prototype.setRawRange = function(opt) {
      var thisOption = this.option;
      var settledOption = this.settledOption;
      each([["start", "startValue"], ["end", "endValue"]], function(names) {
        if (opt[names[0]] != null || opt[names[1]] != null) {
          thisOption[names[0]] = settledOption[names[0]] = opt[names[0]];
          thisOption[names[1]] = settledOption[names[1]] = opt[names[1]];
        }
      }, this);
      this._updateRangeUse(opt);
    };
    DataZoomModel2.prototype.setCalculatedRange = function(opt) {
      var option = this.option;
      each(["start", "startValue", "end", "endValue"], function(name) {
        option[name] = opt[name];
      });
    };
    DataZoomModel2.prototype.getPercentRange = function() {
      var axisProxy = this.findRepresentativeAxisProxy();
      if (axisProxy) {
        return axisProxy.getDataPercentWindow();
      }
    };
    DataZoomModel2.prototype.getValueRange = function(axisDim, axisIndex) {
      if (axisDim == null && axisIndex == null) {
        var axisProxy = this.findRepresentativeAxisProxy();
        if (axisProxy) {
          return axisProxy.getDataValueWindow();
        }
      } else {
        return this.getAxisProxy(axisDim, axisIndex).getDataValueWindow();
      }
    };
    DataZoomModel2.prototype.findRepresentativeAxisProxy = function(axisModel) {
      if (axisModel) {
        return axisModel.__dzAxisProxy;
      }
      var firstProxy;
      var axisDimList = this._targetAxisInfoMap.keys();
      for (var i = 0; i < axisDimList.length; i++) {
        var axisDim = axisDimList[i];
        var axisInfo = this._targetAxisInfoMap.get(axisDim);
        for (var j = 0; j < axisInfo.indexList.length; j++) {
          var proxy = this.getAxisProxy(axisDim, axisInfo.indexList[j]);
          if (proxy.hostedBy(this)) {
            return proxy;
          }
          if (!firstProxy) {
            firstProxy = proxy;
          }
        }
      }
      return firstProxy;
    };
    DataZoomModel2.prototype.getRangePropMode = function() {
      return this._rangePropMode.slice();
    };
    DataZoomModel2.prototype.getOrient = function() {
      if (true) {
        assert(this._orient);
      }
      return this._orient;
    };
    DataZoomModel2.type = "dataZoom";
    DataZoomModel2.dependencies = ["xAxis", "yAxis", "radiusAxis", "angleAxis", "singleAxis", "series", "toolbox"];
    DataZoomModel2.defaultOption = {
      z: 4,
      filterMode: "filter",
      start: 0,
      end: 100
    };
    return DataZoomModel2;
  }(Component_default);
  function retrieveRawOption(option) {
    var ret = {};
    each(["start", "end", "startValue", "endValue", "throttle"], function(name) {
      option.hasOwnProperty(name) && (ret[name] = option[name]);
    });
    return ret;
  }
  var DataZoomModel_default = DataZoomModel;

  // node_modules/echarts/lib/component/dataZoom/SelectZoomModel.js
  var SelectDataZoomModel = function(_super) {
    __extends(SelectDataZoomModel2, _super);
    function SelectDataZoomModel2() {
      var _this = _super !== null && _super.apply(this, arguments) || this;
      _this.type = SelectDataZoomModel2.type;
      return _this;
    }
    SelectDataZoomModel2.type = "dataZoom.select";
    return SelectDataZoomModel2;
  }(DataZoomModel_default);
  var SelectZoomModel_default = SelectDataZoomModel;

  // node_modules/echarts/lib/component/dataZoom/DataZoomView.js
  var DataZoomView = function(_super) {
    __extends(DataZoomView2, _super);
    function DataZoomView2() {
      var _this = _super !== null && _super.apply(this, arguments) || this;
      _this.type = DataZoomView2.type;
      return _this;
    }
    DataZoomView2.prototype.render = function(dataZoomModel, ecModel, api, payload) {
      this.dataZoomModel = dataZoomModel;
      this.ecModel = ecModel;
      this.api = api;
    };
    DataZoomView2.type = "dataZoom";
    return DataZoomView2;
  }(Component_default2);
  var DataZoomView_default = DataZoomView;

  // node_modules/echarts/lib/component/dataZoom/SelectZoomView.js
  var SelectDataZoomView = function(_super) {
    __extends(SelectDataZoomView2, _super);
    function SelectDataZoomView2() {
      var _this = _super !== null && _super.apply(this, arguments) || this;
      _this.type = SelectDataZoomView2.type;
      return _this;
    }
    SelectDataZoomView2.type = "dataZoom.select";
    return SelectDataZoomView2;
  }(DataZoomView_default);
  var SelectZoomView_default = SelectDataZoomView;

  // node_modules/echarts/lib/component/dataZoom/AxisProxy.js
  var each9 = each;
  var asc2 = asc;
  var AxisProxy = function() {
    function AxisProxy2(dimName, axisIndex, dataZoomModel, ecModel) {
      this._dimName = dimName;
      this._axisIndex = axisIndex;
      this.ecModel = ecModel;
      this._dataZoomModel = dataZoomModel;
    }
    AxisProxy2.prototype.hostedBy = function(dataZoomModel) {
      return this._dataZoomModel === dataZoomModel;
    };
    AxisProxy2.prototype.getDataValueWindow = function() {
      return this._valueWindow.slice();
    };
    AxisProxy2.prototype.getDataPercentWindow = function() {
      return this._percentWindow.slice();
    };
    AxisProxy2.prototype.getTargetSeriesModels = function() {
      var seriesModels = [];
      this.ecModel.eachSeries(function(seriesModel) {
        if (isCoordSupported(seriesModel)) {
          var axisMainType = getAxisMainType(this._dimName);
          var axisModel = seriesModel.getReferringComponents(axisMainType, SINGLE_REFERRING).models[0];
          if (axisModel && this._axisIndex === axisModel.componentIndex) {
            seriesModels.push(seriesModel);
          }
        }
      }, this);
      return seriesModels;
    };
    AxisProxy2.prototype.getAxisModel = function() {
      return this.ecModel.getComponent(this._dimName + "Axis", this._axisIndex);
    };
    AxisProxy2.prototype.getMinMaxSpan = function() {
      return clone(this._minMaxSpan);
    };
    AxisProxy2.prototype.calculateDataWindow = function(opt) {
      var dataExtent = this._dataExtent;
      var axisModel = this.getAxisModel();
      var scale4 = axisModel.axis.scale;
      var rangePropMode = this._dataZoomModel.getRangePropMode();
      var percentExtent = [0, 100];
      var percentWindow = [];
      var valueWindow = [];
      var hasPropModeValue;
      each9(["start", "end"], function(prop, idx) {
        var boundPercent = opt[prop];
        var boundValue = opt[prop + "Value"];
        if (rangePropMode[idx] === "percent") {
          boundPercent == null && (boundPercent = percentExtent[idx]);
          boundValue = scale4.parse(linearMap(boundPercent, percentExtent, dataExtent));
        } else {
          hasPropModeValue = true;
          boundValue = boundValue == null ? dataExtent[idx] : scale4.parse(boundValue);
          boundPercent = linearMap(boundValue, dataExtent, percentExtent);
        }
        valueWindow[idx] = boundValue;
        percentWindow[idx] = boundPercent;
      });
      asc2(valueWindow);
      asc2(percentWindow);
      var spans = this._minMaxSpan;
      hasPropModeValue ? restrictSet(valueWindow, percentWindow, dataExtent, percentExtent, false) : restrictSet(percentWindow, valueWindow, percentExtent, dataExtent, true);
      function restrictSet(fromWindow, toWindow, fromExtent, toExtent, toValue) {
        var suffix = toValue ? "Span" : "ValueSpan";
        sliderMove(0, fromWindow, fromExtent, "all", spans["min" + suffix], spans["max" + suffix]);
        for (var i = 0; i < 2; i++) {
          toWindow[i] = linearMap(fromWindow[i], fromExtent, toExtent, true);
          toValue && (toWindow[i] = scale4.parse(toWindow[i]));
        }
      }
      return {
        valueWindow,
        percentWindow
      };
    };
    AxisProxy2.prototype.reset = function(dataZoomModel) {
      if (dataZoomModel !== this._dataZoomModel) {
        return;
      }
      var targetSeries = this.getTargetSeriesModels();
      this._dataExtent = calculateDataExtent(this, this._dimName, targetSeries);
      this._updateMinMaxSpan();
      var dataWindow = this.calculateDataWindow(dataZoomModel.settledOption);
      this._valueWindow = dataWindow.valueWindow;
      this._percentWindow = dataWindow.percentWindow;
      this._setAxisModel();
    };
    AxisProxy2.prototype.filterData = function(dataZoomModel, api) {
      if (dataZoomModel !== this._dataZoomModel) {
        return;
      }
      var axisDim = this._dimName;
      var seriesModels = this.getTargetSeriesModels();
      var filterMode = dataZoomModel.get("filterMode");
      var valueWindow = this._valueWindow;
      if (filterMode === "none") {
        return;
      }
      each9(seriesModels, function(seriesModel) {
        var seriesData = seriesModel.getData();
        var dataDims = seriesData.mapDimensionsAll(axisDim);
        if (!dataDims.length) {
          return;
        }
        if (filterMode === "weakFilter") {
          var store_1 = seriesData.getStore();
          var dataDimIndices_1 = map(dataDims, function(dim) {
            return seriesData.getDimensionIndex(dim);
          }, seriesData);
          seriesData.filterSelf(function(dataIndex) {
            var leftOut;
            var rightOut;
            var hasValue;
            for (var i = 0; i < dataDims.length; i++) {
              var value = store_1.get(dataDimIndices_1[i], dataIndex);
              var thisHasValue = !isNaN(value);
              var thisLeftOut = value < valueWindow[0];
              var thisRightOut = value > valueWindow[1];
              if (thisHasValue && !thisLeftOut && !thisRightOut) {
                return true;
              }
              thisHasValue && (hasValue = true);
              thisLeftOut && (leftOut = true);
              thisRightOut && (rightOut = true);
            }
            return hasValue && leftOut && rightOut;
          });
        } else {
          each9(dataDims, function(dim) {
            if (filterMode === "empty") {
              seriesModel.setData(seriesData = seriesData.map(dim, function(value) {
                return !isInWindow(value) ? NaN : value;
              }));
            } else {
              var range = {};
              range[dim] = valueWindow;
              seriesData.selectRange(range);
            }
          });
        }
        each9(dataDims, function(dim) {
          seriesData.setApproximateExtent(valueWindow, dim);
        });
      });
      function isInWindow(value) {
        return value >= valueWindow[0] && value <= valueWindow[1];
      }
    };
    AxisProxy2.prototype._updateMinMaxSpan = function() {
      var minMaxSpan = this._minMaxSpan = {};
      var dataZoomModel = this._dataZoomModel;
      var dataExtent = this._dataExtent;
      each9(["min", "max"], function(minMax) {
        var percentSpan = dataZoomModel.get(minMax + "Span");
        var valueSpan = dataZoomModel.get(minMax + "ValueSpan");
        valueSpan != null && (valueSpan = this.getAxisModel().axis.scale.parse(valueSpan));
        if (valueSpan != null) {
          percentSpan = linearMap(dataExtent[0] + valueSpan, dataExtent, [0, 100], true);
        } else if (percentSpan != null) {
          valueSpan = linearMap(percentSpan, [0, 100], dataExtent, true) - dataExtent[0];
        }
        minMaxSpan[minMax + "Span"] = percentSpan;
        minMaxSpan[minMax + "ValueSpan"] = valueSpan;
      }, this);
    };
    AxisProxy2.prototype._setAxisModel = function() {
      var axisModel = this.getAxisModel();
      var percentWindow = this._percentWindow;
      var valueWindow = this._valueWindow;
      if (!percentWindow) {
        return;
      }
      var precision = getPixelPrecision(valueWindow, [0, 500]);
      precision = Math.min(precision, 20);
      var rawExtentInfo = axisModel.axis.scale.rawExtentInfo;
      if (percentWindow[0] !== 0) {
        rawExtentInfo.setDeterminedMinMax("min", +valueWindow[0].toFixed(precision));
      }
      if (percentWindow[1] !== 100) {
        rawExtentInfo.setDeterminedMinMax("max", +valueWindow[1].toFixed(precision));
      }
      rawExtentInfo.freeze();
    };
    return AxisProxy2;
  }();
  function calculateDataExtent(axisProxy, axisDim, seriesModels) {
    var dataExtent = [Infinity, -Infinity];
    each9(seriesModels, function(seriesModel) {
      unionAxisExtentFromData(dataExtent, seriesModel.getData(), axisDim);
    });
    var axisModel = axisProxy.getAxisModel();
    var rawExtentResult = ensureScaleRawExtentInfo(axisModel.axis.scale, axisModel, dataExtent).calculate();
    return [rawExtentResult.min, rawExtentResult.max];
  }
  var AxisProxy_default = AxisProxy;

  // node_modules/echarts/lib/component/dataZoom/dataZoomProcessor.js
  var dataZoomProcessor = {
    getTargetSeries: function(ecModel) {
      function eachAxisModel(cb) {
        ecModel.eachComponent("dataZoom", function(dataZoomModel) {
          dataZoomModel.eachTargetAxis(function(axisDim, axisIndex) {
            var axisModel = ecModel.getComponent(getAxisMainType(axisDim), axisIndex);
            cb(axisDim, axisIndex, axisModel, dataZoomModel);
          });
        });
      }
      eachAxisModel(function(axisDim, axisIndex, axisModel, dataZoomModel) {
        axisModel.__dzAxisProxy = null;
      });
      var proxyList = [];
      eachAxisModel(function(axisDim, axisIndex, axisModel, dataZoomModel) {
        if (!axisModel.__dzAxisProxy) {
          axisModel.__dzAxisProxy = new AxisProxy_default(axisDim, axisIndex, dataZoomModel, ecModel);
          proxyList.push(axisModel.__dzAxisProxy);
        }
      });
      var seriesModelMap = createHashMap();
      each(proxyList, function(axisProxy) {
        each(axisProxy.getTargetSeriesModels(), function(seriesModel) {
          seriesModelMap.set(seriesModel.uid, seriesModel);
        });
      });
      return seriesModelMap;
    },
    overallReset: function(ecModel, api) {
      ecModel.eachComponent("dataZoom", function(dataZoomModel) {
        dataZoomModel.eachTargetAxis(function(axisDim, axisIndex) {
          dataZoomModel.getAxisProxy(axisDim, axisIndex).reset(dataZoomModel);
        });
        dataZoomModel.eachTargetAxis(function(axisDim, axisIndex) {
          dataZoomModel.getAxisProxy(axisDim, axisIndex).filterData(dataZoomModel, api);
        });
      });
      ecModel.eachComponent("dataZoom", function(dataZoomModel) {
        var axisProxy = dataZoomModel.findRepresentativeAxisProxy();
        if (axisProxy) {
          var percentRange = axisProxy.getDataPercentWindow();
          var valueRange = axisProxy.getDataValueWindow();
          dataZoomModel.setCalculatedRange({
            start: percentRange[0],
            end: percentRange[1],
            startValue: valueRange[0],
            endValue: valueRange[1]
          });
        }
      });
    }
  };
  var dataZoomProcessor_default = dataZoomProcessor;

  // node_modules/echarts/lib/component/dataZoom/dataZoomAction.js
  function installDataZoomAction(registers) {
    registers.registerAction("dataZoom", function(payload, ecModel) {
      var effectedModels = findEffectedDataZooms(ecModel, payload);
      each(effectedModels, function(dataZoomModel) {
        dataZoomModel.setRawRange({
          start: payload.start,
          end: payload.end,
          startValue: payload.startValue,
          endValue: payload.endValue
        });
      });
    });
  }

  // node_modules/echarts/lib/component/dataZoom/installCommon.js
  var installed = false;
  function installCommon(registers) {
    if (installed) {
      return;
    }
    installed = true;
    registers.registerProcessor(registers.PRIORITY.PROCESSOR.FILTER, dataZoomProcessor_default);
    installDataZoomAction(registers);
    registers.registerSubTypeDefaulter("dataZoom", function() {
      return "slider";
    });
  }

  // node_modules/echarts/lib/component/dataZoom/installDataZoomSelect.js
  function install35(registers) {
    registers.registerComponentModel(SelectZoomModel_default);
    registers.registerComponentView(SelectZoomView_default);
    installCommon(registers);
  }

  // node_modules/echarts/lib/component/toolbox/featureManager.js
  var ToolboxFeature = function() {
    function ToolboxFeature2() {
    }
    return ToolboxFeature2;
  }();
  var features = {};
  function registerFeature(name, ctor) {
    features[name] = ctor;
  }
  function getFeature(name) {
    return features[name];
  }

  // node_modules/echarts/lib/component/toolbox/ToolboxModel.js
  var ToolboxModel = function(_super) {
    __extends(ToolboxModel2, _super);
    function ToolboxModel2() {
      var _this = _super !== null && _super.apply(this, arguments) || this;
      _this.type = ToolboxModel2.type;
      return _this;
    }
    ToolboxModel2.prototype.optionUpdated = function() {
      _super.prototype.optionUpdated.apply(this, arguments);
      var ecModel = this.ecModel;
      each(this.option.feature, function(featureOpt, featureName) {
        var Feature = getFeature(featureName);
        if (Feature) {
          if (Feature.getDefaultOption) {
            Feature.defaultOption = Feature.getDefaultOption(ecModel);
          }
          merge(featureOpt, Feature.defaultOption);
        }
      });
    };
    ToolboxModel2.type = "toolbox";
    ToolboxModel2.layoutMode = {
      type: "box",
      ignoreSize: true
    };
    ToolboxModel2.defaultOption = {
      show: true,
      z: 6,
      orient: "horizontal",
      left: "right",
      top: "top",
      backgroundColor: "transparent",
      borderColor: "#ccc",
      borderRadius: 0,
      borderWidth: 0,
      padding: 5,
      itemSize: 15,
      itemGap: 8,
      showTitle: true,
      iconStyle: {
        borderColor: "#666",
        color: "none"
      },
      emphasis: {
        iconStyle: {
          borderColor: "#3E98C5"
        }
      },
      tooltip: {
        show: false,
        position: "bottom"
      }
    };
    return ToolboxModel2;
  }(Component_default);
  var ToolboxModel_default = ToolboxModel;

  // node_modules/echarts/lib/component/helper/listComponent.js
  function layout4(group, componentModel, api) {
    var boxLayoutParams = componentModel.getBoxLayoutParams();
    var padding = componentModel.get("padding");
    var viewportSize = {
      width: api.getWidth(),
      height: api.getHeight()
    };
    var rect = getLayoutRect(boxLayoutParams, viewportSize, padding);
    box(componentModel.get("orient"), group, componentModel.get("itemGap"), rect.width, rect.height);
    positionElement(group, boxLayoutParams, viewportSize, padding);
  }
  function makeBackground(rect, componentModel) {
    var padding = normalizeCssArray2(componentModel.get("padding"));
    var style = componentModel.getItemStyle(["color", "opacity"]);
    style.fill = componentModel.get("backgroundColor");
    rect = new Rect_default({
      shape: {
        x: rect.x - padding[3],
        y: rect.y - padding[0],
        width: rect.width + padding[1] + padding[3],
        height: rect.height + padding[0] + padding[2],
        r: componentModel.get("borderRadius")
      },
      style,
      silent: true,
      z2: -1
    });
    return rect;
  }

  // node_modules/echarts/lib/component/toolbox/ToolboxView.js
  var ToolboxView = function(_super) {
    __extends(ToolboxView2, _super);
    function ToolboxView2() {
      return _super !== null && _super.apply(this, arguments) || this;
    }
    ToolboxView2.prototype.render = function(toolboxModel, ecModel, api, payload) {
      var group = this.group;
      group.removeAll();
      if (!toolboxModel.get("show")) {
        return;
      }
      var itemSize = +toolboxModel.get("itemSize");
      var isVertical = toolboxModel.get("orient") === "vertical";
      var featureOpts = toolboxModel.get("feature") || {};
      var features2 = this._features || (this._features = {});
      var featureNames = [];
      each(featureOpts, function(opt, name) {
        featureNames.push(name);
      });
      new DataDiffer_default(this._featureNames || [], featureNames).add(processFeature).update(processFeature).remove(curry(processFeature, null)).execute();
      this._featureNames = featureNames;
      function processFeature(newIndex, oldIndex) {
        var featureName = featureNames[newIndex];
        var oldName = featureNames[oldIndex];
        var featureOpt = featureOpts[featureName];
        var featureModel = new Model_default(featureOpt, toolboxModel, toolboxModel.ecModel);
        var feature;
        if (payload && payload.newTitle != null && payload.featureName === featureName) {
          featureOpt.title = payload.newTitle;
        }
        if (featureName && !oldName) {
          if (isUserFeatureName(featureName)) {
            feature = {
              onclick: featureModel.option.onclick,
              featureName
            };
          } else {
            var Feature = getFeature(featureName);
            if (!Feature) {
              return;
            }
            feature = new Feature();
          }
          features2[featureName] = feature;
        } else {
          feature = features2[oldName];
          if (!feature) {
            return;
          }
        }
        feature.uid = getUID("toolbox-feature");
        feature.model = featureModel;
        feature.ecModel = ecModel;
        feature.api = api;
        var isToolboxFeature = feature instanceof ToolboxFeature;
        if (!featureName && oldName) {
          isToolboxFeature && feature.dispose && feature.dispose(ecModel, api);
          return;
        }
        if (!featureModel.get("show") || isToolboxFeature && feature.unusable) {
          isToolboxFeature && feature.remove && feature.remove(ecModel, api);
          return;
        }
        createIconPaths(featureModel, feature, featureName);
        featureModel.setIconStatus = function(iconName, status) {
          var option = this.option;
          var iconPaths = this.iconPaths;
          option.iconStatus = option.iconStatus || {};
          option.iconStatus[iconName] = status;
          if (iconPaths[iconName]) {
            (status === "emphasis" ? enterEmphasis : leaveEmphasis)(iconPaths[iconName]);
          }
        };
        if (feature instanceof ToolboxFeature) {
          if (feature.render) {
            feature.render(featureModel, ecModel, api, payload);
          }
        }
      }
      function createIconPaths(featureModel, feature, featureName) {
        var iconStyleModel = featureModel.getModel("iconStyle");
        var iconStyleEmphasisModel = featureModel.getModel(["emphasis", "iconStyle"]);
        var icons = feature instanceof ToolboxFeature && feature.getIcons ? feature.getIcons() : featureModel.get("icon");
        var titles = featureModel.get("title") || {};
        var iconsMap;
        var titlesMap;
        if (isString(icons)) {
          iconsMap = {};
          iconsMap[featureName] = icons;
        } else {
          iconsMap = icons;
        }
        if (isString(titles)) {
          titlesMap = {};
          titlesMap[featureName] = titles;
        } else {
          titlesMap = titles;
        }
        var iconPaths = featureModel.iconPaths = {};
        each(iconsMap, function(iconStr, iconName) {
          var path = createIcon(iconStr, {}, {
            x: -itemSize / 2,
            y: -itemSize / 2,
            width: itemSize,
            height: itemSize
          });
          path.setStyle(iconStyleModel.getItemStyle());
          var pathEmphasisState = path.ensureState("emphasis");
          pathEmphasisState.style = iconStyleEmphasisModel.getItemStyle();
          var textContent = new Text_default({
            style: {
              text: titlesMap[iconName],
              align: iconStyleEmphasisModel.get("textAlign"),
              borderRadius: iconStyleEmphasisModel.get("textBorderRadius"),
              padding: iconStyleEmphasisModel.get("textPadding"),
              fill: null
            },
            ignore: true
          });
          path.setTextContent(textContent);
          setTooltipConfig({
            el: path,
            componentModel: toolboxModel,
            itemName: iconName,
            formatterParamsExtra: {
              title: titlesMap[iconName]
            }
          });
          path.__title = titlesMap[iconName];
          path.on("mouseover", function() {
            var hoverStyle = iconStyleEmphasisModel.getItemStyle();
            var defaultTextPosition = isVertical ? toolboxModel.get("right") == null && toolboxModel.get("left") !== "right" ? "right" : "left" : toolboxModel.get("bottom") == null && toolboxModel.get("top") !== "bottom" ? "bottom" : "top";
            textContent.setStyle({
              fill: iconStyleEmphasisModel.get("textFill") || hoverStyle.fill || hoverStyle.stroke || "#000",
              backgroundColor: iconStyleEmphasisModel.get("textBackgroundColor")
            });
            path.setTextConfig({
              position: iconStyleEmphasisModel.get("textPosition") || defaultTextPosition
            });
            textContent.ignore = !toolboxModel.get("showTitle");
            api.enterEmphasis(this);
          }).on("mouseout", function() {
            if (featureModel.get(["iconStatus", iconName]) !== "emphasis") {
              api.leaveEmphasis(this);
            }
            textContent.hide();
          });
          (featureModel.get(["iconStatus", iconName]) === "emphasis" ? enterEmphasis : leaveEmphasis)(path);
          group.add(path);
          path.on("click", bind(feature.onclick, feature, ecModel, api, iconName));
          iconPaths[iconName] = path;
        });
      }
      layout4(group, toolboxModel, api);
      group.add(makeBackground(group.getBoundingRect(), toolboxModel));
      isVertical || group.eachChild(function(icon) {
        var titleText = icon.__title;
        var emphasisState = icon.ensureState("emphasis");
        var emphasisTextConfig = emphasisState.textConfig || (emphasisState.textConfig = {});
        var textContent = icon.getTextContent();
        var emphasisTextState = textContent && textContent.ensureState("emphasis");
        if (emphasisTextState && !isFunction(emphasisTextState) && titleText) {
          var emphasisTextStyle = emphasisTextState.style || (emphasisTextState.style = {});
          var rect = getBoundingRect(titleText, Text_default.makeFont(emphasisTextStyle));
          var offsetX = icon.x + group.x;
          var offsetY = icon.y + group.y + itemSize;
          var needPutOnTop = false;
          if (offsetY + rect.height > api.getHeight()) {
            emphasisTextConfig.position = "top";
            needPutOnTop = true;
          }
          var topOffset = needPutOnTop ? -5 - rect.height : itemSize + 10;
          if (offsetX + rect.width / 2 > api.getWidth()) {
            emphasisTextConfig.position = ["100%", topOffset];
            emphasisTextStyle.align = "right";
          } else if (offsetX - rect.width / 2 < 0) {
            emphasisTextConfig.position = [0, topOffset];
            emphasisTextStyle.align = "left";
          }
        }
      });
    };
    ToolboxView2.prototype.updateView = function(toolboxModel, ecModel, api, payload) {
      each(this._features, function(feature) {
        feature instanceof ToolboxFeature && feature.updateView && feature.updateView(feature.model, ecModel, api, payload);
      });
    };
    ToolboxView2.prototype.remove = function(ecModel, api) {
      each(this._features, function(feature) {
        feature instanceof ToolboxFeature && feature.remove && feature.remove(ecModel, api);
      });
      this.group.removeAll();
    };
    ToolboxView2.prototype.dispose = function(ecModel, api) {
      each(this._features, function(feature) {
        feature instanceof ToolboxFeature && feature.dispose && feature.dispose(ecModel, api);
      });
    };
    ToolboxView2.type = "toolbox";
    return ToolboxView2;
  }(Component_default2);
  function isUserFeatureName(featureName) {
    return featureName.indexOf("my") === 0;
  }
  var ToolboxView_default = ToolboxView;

  // node_modules/echarts/lib/component/toolbox/feature/SaveAsImage.js
  var SaveAsImage = function(_super) {
    __extends(SaveAsImage2, _super);
    function SaveAsImage2() {
      return _super !== null && _super.apply(this, arguments) || this;
    }
    SaveAsImage2.prototype.onclick = function(ecModel, api) {
      var model = this.model;
      var title = model.get("name") || ecModel.get("title.0.text") || "echarts";
      var isSvg = api.getZr().painter.getType() === "svg";
      var type = isSvg ? "svg" : model.get("type", true) || "png";
      var url = api.getConnectedDataURL({
        type,
        backgroundColor: model.get("backgroundColor", true) || ecModel.get("backgroundColor") || "#fff",
        connectedBackgroundColor: model.get("connectedBackgroundColor"),
        excludeComponents: model.get("excludeComponents"),
        pixelRatio: model.get("pixelRatio")
      });
      var browser = env_default.browser;
      if (isFunction(MouseEvent) && (browser.newEdge || !browser.ie && !browser.edge)) {
        var $a = document.createElement("a");
        $a.download = title + "." + type;
        $a.target = "_blank";
        $a.href = url;
        var evt = new MouseEvent("click", {
          view: document.defaultView,
          bubbles: true,
          cancelable: false
        });
        $a.dispatchEvent(evt);
      } else {
        if (window.navigator.msSaveOrOpenBlob || isSvg) {
          var parts = url.split(",");
          var base64Encoded = parts[0].indexOf("base64") > -1;
          var bstr = isSvg ? decodeURIComponent(parts[1]) : parts[1];
          base64Encoded && (bstr = window.atob(bstr));
          var filename = title + "." + type;
          if (window.navigator.msSaveOrOpenBlob) {
            var n = bstr.length;
            var u8arr = new Uint8Array(n);
            while (n--) {
              u8arr[n] = bstr.charCodeAt(n);
            }
            var blob = new Blob([u8arr]);
            window.navigator.msSaveOrOpenBlob(blob, filename);
          } else {
            var frame = document.createElement("iframe");
            document.body.appendChild(frame);
            var cw = frame.contentWindow;
            var doc = cw.document;
            doc.open("image/svg+xml", "replace");
            doc.write(bstr);
            doc.close();
            cw.focus();
            doc.execCommand("SaveAs", true, filename);
            document.body.removeChild(frame);
          }
        } else {
          var lang = model.get("lang");
          var html = '<body style="margin:0;"><img src="' + url + '" style="max-width:100%;" title="' + (lang && lang[0] || "") + '" /></body>';
          var tab = window.open();
          tab.document.write(html);
          tab.document.title = title;
        }
      }
    };
    SaveAsImage2.getDefaultOption = function(ecModel) {
      var defaultOption3 = {
        show: true,
        icon: "M4.7,22.9L29.3,45.5L54.7,23.4M4.6,43.6L4.6,58L53.8,58L53.8,43.6M29.2,45.1L29.2,0",
        title: ecModel.getLocaleModel().get(["toolbox", "saveAsImage", "title"]),
        type: "png",
        connectedBackgroundColor: "#fff",
        name: "",
        excludeComponents: ["toolbox"],
        lang: ecModel.getLocaleModel().get(["toolbox", "saveAsImage", "lang"])
      };
      return defaultOption3;
    };
    return SaveAsImage2;
  }(ToolboxFeature);
  var SaveAsImage_default = SaveAsImage;

  // node_modules/echarts/lib/component/toolbox/feature/MagicType.js
  var INNER_STACK_KEYWORD = "__ec_magicType_stack__";
  var radioTypes = [["line", "bar"], ["stack"]];
  var MagicType = function(_super) {
    __extends(MagicType2, _super);
    function MagicType2() {
      return _super !== null && _super.apply(this, arguments) || this;
    }
    MagicType2.prototype.getIcons = function() {
      var model = this.model;
      var availableIcons = model.get("icon");
      var icons = {};
      each(model.get("type"), function(type) {
        if (availableIcons[type]) {
          icons[type] = availableIcons[type];
        }
      });
      return icons;
    };
    MagicType2.getDefaultOption = function(ecModel) {
      var defaultOption3 = {
        show: true,
        type: [],
        icon: {
          line: "M4.1,28.9h7.1l9.3-22l7.4,38l9.7-19.7l3,12.8h14.9M4.1,58h51.4",
          bar: "M6.7,22.9h10V48h-10V22.9zM24.9,13h10v35h-10V13zM43.2,2h10v46h-10V2zM3.1,58h53.7",
          stack: "M8.2,38.4l-8.4,4.1l30.6,15.3L60,42.5l-8.1-4.1l-21.5,11L8.2,38.4z M51.9,30l-8.1,4.2l-13.4,6.9l-13.9-6.9L8.2,30l-8.4,4.2l8.4,4.2l22.2,11l21.5-11l8.1-4.2L51.9,30z M51.9,21.7l-8.1,4.2L35.7,30l-5.3,2.8L24.9,30l-8.4-4.1l-8.3-4.2l-8.4,4.2L8.2,30l8.3,4.2l13.9,6.9l13.4-6.9l8.1-4.2l8.1-4.1L51.9,21.7zM30.4,2.2L-0.2,17.5l8.4,4.1l8.3,4.2l8.4,4.2l5.5,2.7l5.3-2.7l8.1-4.2l8.1-4.2l8.1-4.1L30.4,2.2z"
        },
        title: ecModel.getLocaleModel().get(["toolbox", "magicType", "title"]),
        option: {},
        seriesIndex: {}
      };
      return defaultOption3;
    };
    MagicType2.prototype.onclick = function(ecModel, api, type) {
      var model = this.model;
      var seriesIndex = model.get(["seriesIndex", type]);
      if (!seriesOptGenreator[type]) {
        return;
      }
      var newOption = {
        series: []
      };
      var generateNewSeriesTypes = function(seriesModel) {
        var seriesType2 = seriesModel.subType;
        var seriesId = seriesModel.id;
        var newSeriesOpt = seriesOptGenreator[type](seriesType2, seriesId, seriesModel, model);
        if (newSeriesOpt) {
          defaults(newSeriesOpt, seriesModel.option);
          newOption.series.push(newSeriesOpt);
        }
        var coordSys = seriesModel.coordinateSystem;
        if (coordSys && coordSys.type === "cartesian2d" && (type === "line" || type === "bar")) {
          var categoryAxis2 = coordSys.getAxesByScale("ordinal")[0];
          if (categoryAxis2) {
            var axisDim = categoryAxis2.dim;
            var axisType = axisDim + "Axis";
            var axisModel = seriesModel.getReferringComponents(axisType, SINGLE_REFERRING).models[0];
            var axisIndex = axisModel.componentIndex;
            newOption[axisType] = newOption[axisType] || [];
            for (var i = 0; i <= axisIndex; i++) {
              newOption[axisType][axisIndex] = newOption[axisType][axisIndex] || {};
            }
            newOption[axisType][axisIndex].boundaryGap = type === "bar";
          }
        }
      };
      each(radioTypes, function(radio) {
        if (indexOf(radio, type) >= 0) {
          each(radio, function(item) {
            model.setIconStatus(item, "normal");
          });
        }
      });
      model.setIconStatus(type, "emphasis");
      ecModel.eachComponent({
        mainType: "series",
        query: seriesIndex == null ? null : {
          seriesIndex
        }
      }, generateNewSeriesTypes);
      var newTitle;
      var currentType = type;
      if (type === "stack") {
        newTitle = merge({
          stack: model.option.title.tiled,
          tiled: model.option.title.stack
        }, model.option.title);
        if (model.get(["iconStatus", type]) !== "emphasis") {
          currentType = "tiled";
        }
      }
      api.dispatchAction({
        type: "changeMagicType",
        currentType,
        newOption,
        newTitle,
        featureName: "magicType"
      });
    };
    return MagicType2;
  }(ToolboxFeature);
  var seriesOptGenreator = {
    "line": function(seriesType2, seriesId, seriesModel, model) {
      if (seriesType2 === "bar") {
        return merge({
          id: seriesId,
          type: "line",
          data: seriesModel.get("data"),
          stack: seriesModel.get("stack"),
          markPoint: seriesModel.get("markPoint"),
          markLine: seriesModel.get("markLine")
        }, model.get(["option", "line"]) || {}, true);
      }
    },
    "bar": function(seriesType2, seriesId, seriesModel, model) {
      if (seriesType2 === "line") {
        return merge({
          id: seriesId,
          type: "bar",
          data: seriesModel.get("data"),
          stack: seriesModel.get("stack"),
          markPoint: seriesModel.get("markPoint"),
          markLine: seriesModel.get("markLine")
        }, model.get(["option", "bar"]) || {}, true);
      }
    },
    "stack": function(seriesType2, seriesId, seriesModel, model) {
      var isStack = seriesModel.get("stack") === INNER_STACK_KEYWORD;
      if (seriesType2 === "line" || seriesType2 === "bar") {
        model.setIconStatus("stack", isStack ? "normal" : "emphasis");
        return merge({
          id: seriesId,
          stack: isStack ? "" : INNER_STACK_KEYWORD
        }, model.get(["option", "stack"]) || {}, true);
      }
    }
  };
  registerAction({
    type: "changeMagicType",
    event: "magicTypeChanged",
    update: "prepareAndUpdate"
  }, function(payload, ecModel) {
    ecModel.mergeOption(payload.newOption);
  });
  var MagicType_default = MagicType;

  // node_modules/echarts/lib/component/toolbox/feature/DataView.js
  var BLOCK_SPLITER = new Array(60).join("-");
  var ITEM_SPLITER = "	";
  function groupSeries(ecModel) {
    var seriesGroupByCategoryAxis = {};
    var otherSeries = [];
    var meta = [];
    ecModel.eachRawSeries(function(seriesModel) {
      var coordSys = seriesModel.coordinateSystem;
      if (coordSys && (coordSys.type === "cartesian2d" || coordSys.type === "polar")) {
        var baseAxis = coordSys.getBaseAxis();
        if (baseAxis.type === "category") {
          var key = baseAxis.dim + "_" + baseAxis.index;
          if (!seriesGroupByCategoryAxis[key]) {
            seriesGroupByCategoryAxis[key] = {
              categoryAxis: baseAxis,
              valueAxis: coordSys.getOtherAxis(baseAxis),
              series: []
            };
            meta.push({
              axisDim: baseAxis.dim,
              axisIndex: baseAxis.index
            });
          }
          seriesGroupByCategoryAxis[key].series.push(seriesModel);
        } else {
          otherSeries.push(seriesModel);
        }
      } else {
        otherSeries.push(seriesModel);
      }
    });
    return {
      seriesGroupByCategoryAxis,
      other: otherSeries,
      meta
    };
  }
  function assembleSeriesWithCategoryAxis(groups) {
    var tables = [];
    each(groups, function(group, key) {
      var categoryAxis2 = group.categoryAxis;
      var valueAxis2 = group.valueAxis;
      var valueAxisDim = valueAxis2.dim;
      var headers = [" "].concat(map(group.series, function(series) {
        return series.name;
      }));
      var columns = [categoryAxis2.model.getCategories()];
      each(group.series, function(series) {
        var rawData = series.getRawData();
        columns.push(series.getRawData().mapArray(rawData.mapDimension(valueAxisDim), function(val) {
          return val;
        }));
      });
      var lines = [headers.join(ITEM_SPLITER)];
      for (var i = 0; i < columns[0].length; i++) {
        var items = [];
        for (var j = 0; j < columns.length; j++) {
          items.push(columns[j][i]);
        }
        lines.push(items.join(ITEM_SPLITER));
      }
      tables.push(lines.join("\n"));
    });
    return tables.join("\n\n" + BLOCK_SPLITER + "\n\n");
  }
  function assembleOtherSeries(series) {
    return map(series, function(series2) {
      var data = series2.getRawData();
      var lines = [series2.name];
      var vals = [];
      data.each(data.dimensions, function() {
        var argLen = arguments.length;
        var dataIndex = arguments[argLen - 1];
        var name = data.getName(dataIndex);
        for (var i = 0; i < argLen - 1; i++) {
          vals[i] = arguments[i];
        }
        lines.push((name ? name + ITEM_SPLITER : "") + vals.join(ITEM_SPLITER));
      });
      return lines.join("\n");
    }).join("\n\n" + BLOCK_SPLITER + "\n\n");
  }
  function getContentFromModel(ecModel) {
    var result = groupSeries(ecModel);
    return {
      value: filter([assembleSeriesWithCategoryAxis(result.seriesGroupByCategoryAxis), assembleOtherSeries(result.other)], function(str) {
        return !!str.replace(/[\n\t\s]/g, "");
      }).join("\n\n" + BLOCK_SPLITER + "\n\n"),
      meta: result.meta
    };
  }
  function trim2(str) {
    return str.replace(/^\s\s*/, "").replace(/\s\s*$/, "");
  }
  function isTSVFormat(block) {
    var firstLine = block.slice(0, block.indexOf("\n"));
    if (firstLine.indexOf(ITEM_SPLITER) >= 0) {
      return true;
    }
  }
  var itemSplitRegex = new RegExp("[" + ITEM_SPLITER + "]+", "g");
  function parseTSVContents(tsv) {
    var tsvLines = tsv.split(/\n+/g);
    var headers = trim2(tsvLines.shift()).split(itemSplitRegex);
    var categories = [];
    var series = map(headers, function(header) {
      return {
        name: header,
        data: []
      };
    });
    for (var i = 0; i < tsvLines.length; i++) {
      var items = trim2(tsvLines[i]).split(itemSplitRegex);
      categories.push(items.shift());
      for (var j = 0; j < items.length; j++) {
        series[j] && (series[j].data[i] = items[j]);
      }
    }
    return {
      series,
      categories
    };
  }
  function parseListContents(str) {
    var lines = str.split(/\n+/g);
    var seriesName = trim2(lines.shift());
    var data = [];
    for (var i = 0; i < lines.length; i++) {
      var line = trim2(lines[i]);
      if (!line) {
        continue;
      }
      var items = line.split(itemSplitRegex);
      var name_1 = "";
      var value = void 0;
      var hasName = false;
      if (isNaN(items[0])) {
        hasName = true;
        name_1 = items[0];
        items = items.slice(1);
        data[i] = {
          name: name_1,
          value: []
        };
        value = data[i].value;
      } else {
        value = data[i] = [];
      }
      for (var j = 0; j < items.length; j++) {
        value.push(+items[j]);
      }
      if (value.length === 1) {
        hasName ? data[i].value = value[0] : data[i] = value[0];
      }
    }
    return {
      name: seriesName,
      data
    };
  }
  function parseContents(str, blockMetaList) {
    var blocks = str.split(new RegExp("\n*" + BLOCK_SPLITER + "\n*", "g"));
    var newOption = {
      series: []
    };
    each(blocks, function(block, idx) {
      if (isTSVFormat(block)) {
        var result = parseTSVContents(block);
        var blockMeta = blockMetaList[idx];
        var axisKey = blockMeta.axisDim + "Axis";
        if (blockMeta) {
          newOption[axisKey] = newOption[axisKey] || [];
          newOption[axisKey][blockMeta.axisIndex] = {
            data: result.categories
          };
          newOption.series = newOption.series.concat(result.series);
        }
      } else {
        var result = parseListContents(block);
        newOption.series.push(result);
      }
    });
    return newOption;
  }
  var DataView = function(_super) {
    __extends(DataView2, _super);
    function DataView2() {
      return _super !== null && _super.apply(this, arguments) || this;
    }
    DataView2.prototype.onclick = function(ecModel, api) {
      setTimeout(function() {
        api.dispatchAction({
          type: "hideTip"
        });
      });
      var container = api.getDom();
      var model = this.model;
      if (this._dom) {
        container.removeChild(this._dom);
      }
      var root = document.createElement("div");
      root.style.cssText = "position:absolute;top:0;bottom:0;left:0;right:0;padding:5px";
      root.style.backgroundColor = model.get("backgroundColor") || "#fff";
      var header = document.createElement("h4");
      var lang = model.get("lang") || [];
      header.innerHTML = lang[0] || model.get("title");
      header.style.cssText = "margin:10px 20px";
      header.style.color = model.get("textColor");
      var viewMain = document.createElement("div");
      var textarea = document.createElement("textarea");
      viewMain.style.cssText = "overflow:auto";
      var optionToContent = model.get("optionToContent");
      var contentToOption = model.get("contentToOption");
      var result = getContentFromModel(ecModel);
      if (isFunction(optionToContent)) {
        var htmlOrDom = optionToContent(api.getOption());
        if (isString(htmlOrDom)) {
          viewMain.innerHTML = htmlOrDom;
        } else if (isDom(htmlOrDom)) {
          viewMain.appendChild(htmlOrDom);
        }
      } else {
        textarea.readOnly = model.get("readOnly");
        var style = textarea.style;
        style.cssText = "display:block;width:100%;height:100%;font-family:monospace;font-size:14px;line-height:1.6rem;resize:none;box-sizing:border-box;outline:none";
        style.color = model.get("textColor");
        style.borderColor = model.get("textareaBorderColor");
        style.backgroundColor = model.get("textareaColor");
        textarea.value = result.value;
        viewMain.appendChild(textarea);
      }
      var blockMetaList = result.meta;
      var buttonContainer = document.createElement("div");
      buttonContainer.style.cssText = "position:absolute;bottom:5px;left:0;right:0";
      var buttonStyle = "float:right;margin-right:20px;border:none;cursor:pointer;padding:2px 5px;font-size:12px;border-radius:3px";
      var closeButton = document.createElement("div");
      var refreshButton = document.createElement("div");
      buttonStyle += ";background-color:" + model.get("buttonColor");
      buttonStyle += ";color:" + model.get("buttonTextColor");
      var self2 = this;
      function close() {
        container.removeChild(root);
        self2._dom = null;
      }
      addEventListener(closeButton, "click", close);
      addEventListener(refreshButton, "click", function() {
        if (contentToOption == null && optionToContent != null || contentToOption != null && optionToContent == null) {
          if (true) {
            warn("It seems you have just provided one of `contentToOption` and `optionToContent` functions but missed the other one. Data change is ignored.");
          }
          close();
          return;
        }
        var newOption;
        try {
          if (isFunction(contentToOption)) {
            newOption = contentToOption(viewMain, api.getOption());
          } else {
            newOption = parseContents(textarea.value, blockMetaList);
          }
        } catch (e2) {
          close();
          throw new Error("Data view format error " + e2);
        }
        if (newOption) {
          api.dispatchAction({
            type: "changeDataView",
            newOption
          });
        }
        close();
      });
      closeButton.innerHTML = lang[1];
      refreshButton.innerHTML = lang[2];
      refreshButton.style.cssText = closeButton.style.cssText = buttonStyle;
      !model.get("readOnly") && buttonContainer.appendChild(refreshButton);
      buttonContainer.appendChild(closeButton);
      root.appendChild(header);
      root.appendChild(viewMain);
      root.appendChild(buttonContainer);
      viewMain.style.height = container.clientHeight - 80 + "px";
      container.appendChild(root);
      this._dom = root;
    };
    DataView2.prototype.remove = function(ecModel, api) {
      this._dom && api.getDom().removeChild(this._dom);
    };
    DataView2.prototype.dispose = function(ecModel, api) {
      this.remove(ecModel, api);
    };
    DataView2.getDefaultOption = function(ecModel) {
      var defaultOption3 = {
        show: true,
        readOnly: false,
        optionToContent: null,
        contentToOption: null,
        icon: "M17.5,17.3H33 M17.5,17.3H33 M45.4,29.5h-28 M11.5,2v56H51V14.8L38.4,2H11.5z M38.4,2.2v12.7H51 M45.4,41.7h-28",
        title: ecModel.getLocaleModel().get(["toolbox", "dataView", "title"]),
        lang: ecModel.getLocaleModel().get(["toolbox", "dataView", "lang"]),
        backgroundColor: "#fff",
        textColor: "#000",
        textareaColor: "#fff",
        textareaBorderColor: "#333",
        buttonColor: "#c23531",
        buttonTextColor: "#fff"
      };
      return defaultOption3;
    };
    return DataView2;
  }(ToolboxFeature);
  function tryMergeDataOption(newData, originalData) {
    return map(newData, function(newVal, idx) {
      var original = originalData && originalData[idx];
      if (isObject(original) && !isArray(original)) {
        var newValIsObject = isObject(newVal) && !isArray(newVal);
        if (!newValIsObject) {
          newVal = {
            value: newVal
          };
        }
        var shouldDeleteName = original.name != null && newVal.name == null;
        newVal = defaults(newVal, original);
        shouldDeleteName && delete newVal.name;
        return newVal;
      } else {
        return newVal;
      }
    });
  }
  registerAction({
    type: "changeDataView",
    event: "dataViewChanged",
    update: "prepareAndUpdate"
  }, function(payload, ecModel) {
    var newSeriesOptList = [];
    each(payload.newOption.series, function(seriesOpt) {
      var seriesModel = ecModel.getSeriesByName(seriesOpt.name)[0];
      if (!seriesModel) {
        newSeriesOptList.push(extend({
          type: "scatter"
        }, seriesOpt));
      } else {
        var originalData = seriesModel.get("data");
        newSeriesOptList.push({
          name: seriesOpt.name,
          data: tryMergeDataOption(seriesOpt.data, originalData)
        });
      }
    });
    ecModel.mergeOption(defaults({
      series: newSeriesOptList
    }, payload.newOption));
  });
  var DataView_default = DataView;

  // node_modules/echarts/lib/component/dataZoom/history.js
  var each10 = each;
  var inner16 = makeInner();
  function push(ecModel, newSnapshot) {
    var storedSnapshots = getStoreSnapshots(ecModel);
    each10(newSnapshot, function(batchItem, dataZoomId) {
      var i = storedSnapshots.length - 1;
      for (; i >= 0; i--) {
        var snapshot = storedSnapshots[i];
        if (snapshot[dataZoomId]) {
          break;
        }
      }
      if (i < 0) {
        var dataZoomModel = ecModel.queryComponents({
          mainType: "dataZoom",
          subType: "select",
          id: dataZoomId
        })[0];
        if (dataZoomModel) {
          var percentRange = dataZoomModel.getPercentRange();
          storedSnapshots[0][dataZoomId] = {
            dataZoomId,
            start: percentRange[0],
            end: percentRange[1]
          };
        }
      }
    });
    storedSnapshots.push(newSnapshot);
  }
  function pop(ecModel) {
    var storedSnapshots = getStoreSnapshots(ecModel);
    var head = storedSnapshots[storedSnapshots.length - 1];
    storedSnapshots.length > 1 && storedSnapshots.pop();
    var snapshot = {};
    each10(head, function(batchItem, dataZoomId) {
      for (var i = storedSnapshots.length - 1; i >= 0; i--) {
        batchItem = storedSnapshots[i][dataZoomId];
        if (batchItem) {
          snapshot[dataZoomId] = batchItem;
          break;
        }
      }
    });
    return snapshot;
  }
  function clear2(ecModel) {
    inner16(ecModel).snapshots = null;
  }
  function count(ecModel) {
    return getStoreSnapshots(ecModel).length;
  }
  function getStoreSnapshots(ecModel) {
    var store = inner16(ecModel);
    if (!store.snapshots) {
      store.snapshots = [{}];
    }
    return store.snapshots;
  }

  // node_modules/echarts/lib/component/toolbox/feature/Restore.js
  var RestoreOption = function(_super) {
    __extends(RestoreOption2, _super);
    function RestoreOption2() {
      return _super !== null && _super.apply(this, arguments) || this;
    }
    RestoreOption2.prototype.onclick = function(ecModel, api) {
      clear2(ecModel);
      api.dispatchAction({
        type: "restore",
        from: this.uid
      });
    };
    RestoreOption2.getDefaultOption = function(ecModel) {
      var defaultOption3 = {
        show: true,
        icon: "M3.8,33.4 M47,18.9h9.8V8.7 M56.3,20.1 C52.1,9,40.5,0.6,26.8,2.1C12.6,3.7,1.6,16.2,2.1,30.6 M13,41.1H3.1v10.2 M3.7,39.9c4.2,11.1,15.8,19.5,29.5,18 c14.2-1.6,25.2-14.1,24.7-28.5",
        title: ecModel.getLocaleModel().get(["toolbox", "restore", "title"])
      };
      return defaultOption3;
    };
    return RestoreOption2;
  }(ToolboxFeature);
  registerAction({
    type: "restore",
    event: "restore",
    update: "prepareAndUpdate"
  }, function(payload, ecModel) {
    ecModel.resetOption("recreate");
  });
  var Restore_default = RestoreOption;

  // node_modules/echarts/lib/component/helper/BrushTargetManager.js
  var INCLUDE_FINDER_MAIN_TYPES = ["grid", "xAxis", "yAxis", "geo", "graph", "polar", "radiusAxis", "angleAxis", "bmap"];
  var BrushTargetManager = function() {
    function BrushTargetManager2(finder, ecModel, opt) {
      var _this = this;
      this._targetInfoList = [];
      var foundCpts = parseFinder2(ecModel, finder);
      each(targetInfoBuilders, function(builder, type) {
        if (!opt || !opt.include || indexOf(opt.include, type) >= 0) {
          builder(foundCpts, _this._targetInfoList);
        }
      });
    }
    BrushTargetManager2.prototype.setOutputRanges = function(areas, ecModel) {
      this.matchOutputRanges(areas, ecModel, function(area, coordRange, coordSys) {
        (area.coordRanges || (area.coordRanges = [])).push(coordRange);
        if (!area.coordRange) {
          area.coordRange = coordRange;
          var result = coordConvert[area.brushType](0, coordSys, coordRange);
          area.__rangeOffset = {
            offset: diffProcessor[area.brushType](result.values, area.range, [1, 1]),
            xyMinMax: result.xyMinMax
          };
        }
      });
      return areas;
    };
    BrushTargetManager2.prototype.matchOutputRanges = function(areas, ecModel, cb) {
      each(areas, function(area) {
        var targetInfo = this.findTargetInfo(area, ecModel);
        if (targetInfo && targetInfo !== true) {
          each(targetInfo.coordSyses, function(coordSys) {
            var result = coordConvert[area.brushType](1, coordSys, area.range, true);
            cb(area, result.values, coordSys, ecModel);
          });
        }
      }, this);
    };
    BrushTargetManager2.prototype.setInputRanges = function(areas, ecModel) {
      each(areas, function(area) {
        var targetInfo = this.findTargetInfo(area, ecModel);
        if (true) {
          assert(!targetInfo || targetInfo === true || area.coordRange, "coordRange must be specified when coord index specified.");
          assert(!targetInfo || targetInfo !== true || area.range, "range must be specified in global brush.");
        }
        area.range = area.range || [];
        if (targetInfo && targetInfo !== true) {
          area.panelId = targetInfo.panelId;
          var result = coordConvert[area.brushType](0, targetInfo.coordSys, area.coordRange);
          var rangeOffset = area.__rangeOffset;
          area.range = rangeOffset ? diffProcessor[area.brushType](result.values, rangeOffset.offset, getScales(result.xyMinMax, rangeOffset.xyMinMax)) : result.values;
        }
      }, this);
    };
    BrushTargetManager2.prototype.makePanelOpts = function(api, getDefaultBrushType) {
      return map(this._targetInfoList, function(targetInfo) {
        var rect = targetInfo.getPanelRect();
        return {
          panelId: targetInfo.panelId,
          defaultBrushType: getDefaultBrushType ? getDefaultBrushType(targetInfo) : null,
          clipPath: makeRectPanelClipPath(rect),
          isTargetByCursor: makeRectIsTargetByCursor(rect, api, targetInfo.coordSysModel),
          getLinearBrushOtherExtent: makeLinearBrushOtherExtent(rect)
        };
      });
    };
    BrushTargetManager2.prototype.controlSeries = function(area, seriesModel, ecModel) {
      var targetInfo = this.findTargetInfo(area, ecModel);
      return targetInfo === true || targetInfo && indexOf(targetInfo.coordSyses, seriesModel.coordinateSystem) >= 0;
    };
    BrushTargetManager2.prototype.findTargetInfo = function(area, ecModel) {
      var targetInfoList = this._targetInfoList;
      var foundCpts = parseFinder2(ecModel, area);
      for (var i = 0; i < targetInfoList.length; i++) {
        var targetInfo = targetInfoList[i];
        var areaPanelId = area.panelId;
        if (areaPanelId) {
          if (targetInfo.panelId === areaPanelId) {
            return targetInfo;
          }
        } else {
          for (var j = 0; j < targetInfoMatchers.length; j++) {
            if (targetInfoMatchers[j](foundCpts, targetInfo)) {
              return targetInfo;
            }
          }
        }
      }
      return true;
    };
    return BrushTargetManager2;
  }();
  function formatMinMax(minMax) {
    minMax[0] > minMax[1] && minMax.reverse();
    return minMax;
  }
  function parseFinder2(ecModel, finder) {
    return parseFinder(ecModel, finder, {
      includeMainTypes: INCLUDE_FINDER_MAIN_TYPES
    });
  }
  var targetInfoBuilders = {
    grid: function(foundCpts, targetInfoList) {
      var xAxisModels = foundCpts.xAxisModels;
      var yAxisModels = foundCpts.yAxisModels;
      var gridModels = foundCpts.gridModels;
      var gridModelMap = createHashMap();
      var xAxesHas = {};
      var yAxesHas = {};
      if (!xAxisModels && !yAxisModels && !gridModels) {
        return;
      }
      each(xAxisModels, function(axisModel) {
        var gridModel = axisModel.axis.grid.model;
        gridModelMap.set(gridModel.id, gridModel);
        xAxesHas[gridModel.id] = true;
      });
      each(yAxisModels, function(axisModel) {
        var gridModel = axisModel.axis.grid.model;
        gridModelMap.set(gridModel.id, gridModel);
        yAxesHas[gridModel.id] = true;
      });
      each(gridModels, function(gridModel) {
        gridModelMap.set(gridModel.id, gridModel);
        xAxesHas[gridModel.id] = true;
        yAxesHas[gridModel.id] = true;
      });
      gridModelMap.each(function(gridModel) {
        var grid = gridModel.coordinateSystem;
        var cartesians = [];
        each(grid.getCartesians(), function(cartesian, index) {
          if (indexOf(xAxisModels, cartesian.getAxis("x").model) >= 0 || indexOf(yAxisModels, cartesian.getAxis("y").model) >= 0) {
            cartesians.push(cartesian);
          }
        });
        targetInfoList.push({
          panelId: "grid--" + gridModel.id,
          gridModel,
          coordSysModel: gridModel,
          coordSys: cartesians[0],
          coordSyses: cartesians,
          getPanelRect: panelRectBuilders.grid,
          xAxisDeclared: xAxesHas[gridModel.id],
          yAxisDeclared: yAxesHas[gridModel.id]
        });
      });
    },
    geo: function(foundCpts, targetInfoList) {
      each(foundCpts.geoModels, function(geoModel) {
        var coordSys = geoModel.coordinateSystem;
        targetInfoList.push({
          panelId: "geo--" + geoModel.id,
          geoModel,
          coordSysModel: geoModel,
          coordSys,
          coordSyses: [coordSys],
          getPanelRect: panelRectBuilders.geo
        });
      });
    }
  };
  var targetInfoMatchers = [
    function(foundCpts, targetInfo) {
      var xAxisModel = foundCpts.xAxisModel;
      var yAxisModel = foundCpts.yAxisModel;
      var gridModel = foundCpts.gridModel;
      !gridModel && xAxisModel && (gridModel = xAxisModel.axis.grid.model);
      !gridModel && yAxisModel && (gridModel = yAxisModel.axis.grid.model);
      return gridModel && gridModel === targetInfo.gridModel;
    },
    function(foundCpts, targetInfo) {
      var geoModel = foundCpts.geoModel;
      return geoModel && geoModel === targetInfo.geoModel;
    }
  ];
  var panelRectBuilders = {
    grid: function() {
      return this.coordSys.master.getRect().clone();
    },
    geo: function() {
      var coordSys = this.coordSys;
      var rect = coordSys.getBoundingRect().clone();
      rect.applyTransform(getTransform(coordSys));
      return rect;
    }
  };
  var coordConvert = {
    lineX: curry(axisConvert, 0),
    lineY: curry(axisConvert, 1),
    rect: function(to, coordSys, rangeOrCoordRange, clamp2) {
      var xminymin = to ? coordSys.pointToData([rangeOrCoordRange[0][0], rangeOrCoordRange[1][0]], clamp2) : coordSys.dataToPoint([rangeOrCoordRange[0][0], rangeOrCoordRange[1][0]], clamp2);
      var xmaxymax = to ? coordSys.pointToData([rangeOrCoordRange[0][1], rangeOrCoordRange[1][1]], clamp2) : coordSys.dataToPoint([rangeOrCoordRange[0][1], rangeOrCoordRange[1][1]], clamp2);
      var values = [formatMinMax([xminymin[0], xmaxymax[0]]), formatMinMax([xminymin[1], xmaxymax[1]])];
      return {
        values,
        xyMinMax: values
      };
    },
    polygon: function(to, coordSys, rangeOrCoordRange, clamp2) {
      var xyMinMax = [[Infinity, -Infinity], [Infinity, -Infinity]];
      var values = map(rangeOrCoordRange, function(item) {
        var p = to ? coordSys.pointToData(item, clamp2) : coordSys.dataToPoint(item, clamp2);
        xyMinMax[0][0] = Math.min(xyMinMax[0][0], p[0]);
        xyMinMax[1][0] = Math.min(xyMinMax[1][0], p[1]);
        xyMinMax[0][1] = Math.max(xyMinMax[0][1], p[0]);
        xyMinMax[1][1] = Math.max(xyMinMax[1][1], p[1]);
        return p;
      });
      return {
        values,
        xyMinMax
      };
    }
  };
  function axisConvert(axisNameIndex, to, coordSys, rangeOrCoordRange) {
    if (true) {
      assert(coordSys.type === "cartesian2d", "lineX/lineY brush is available only in cartesian2d.");
    }
    var axis = coordSys.getAxis(["x", "y"][axisNameIndex]);
    var values = formatMinMax(map([0, 1], function(i) {
      return to ? axis.coordToData(axis.toLocalCoord(rangeOrCoordRange[i]), true) : axis.toGlobalCoord(axis.dataToCoord(rangeOrCoordRange[i]));
    }));
    var xyMinMax = [];
    xyMinMax[axisNameIndex] = values;
    xyMinMax[1 - axisNameIndex] = [NaN, NaN];
    return {
      values,
      xyMinMax
    };
  }
  var diffProcessor = {
    lineX: curry(axisDiffProcessor, 0),
    lineY: curry(axisDiffProcessor, 1),
    rect: function(values, refer, scales) {
      return [[values[0][0] - scales[0] * refer[0][0], values[0][1] - scales[0] * refer[0][1]], [values[1][0] - scales[1] * refer[1][0], values[1][1] - scales[1] * refer[1][1]]];
    },
    polygon: function(values, refer, scales) {
      return map(values, function(item, idx) {
        return [item[0] - scales[0] * refer[idx][0], item[1] - scales[1] * refer[idx][1]];
      });
    }
  };
  function axisDiffProcessor(axisNameIndex, values, refer, scales) {
    return [values[0] - scales[axisNameIndex] * refer[0], values[1] - scales[axisNameIndex] * refer[1]];
  }
  function getScales(xyMinMaxCurr, xyMinMaxOrigin) {
    var sizeCurr = getSize2(xyMinMaxCurr);
    var sizeOrigin = getSize2(xyMinMaxOrigin);
    var scales = [sizeCurr[0] / sizeOrigin[0], sizeCurr[1] / sizeOrigin[1]];
    isNaN(scales[0]) && (scales[0] = 1);
    isNaN(scales[1]) && (scales[1] = 1);
    return scales;
  }
  function getSize2(xyMinMax) {
    return xyMinMax ? [xyMinMax[0][1] - xyMinMax[0][0], xyMinMax[1][1] - xyMinMax[1][0]] : [NaN, NaN];
  }
  var BrushTargetManager_default = BrushTargetManager;

  // node_modules/echarts/lib/component/toolbox/feature/DataZoom.js
  var each11 = each;
  var DATA_ZOOM_ID_BASE = makeInternalComponentId("toolbox-dataZoom_");
  var DataZoomFeature = function(_super) {
    __extends(DataZoomFeature2, _super);
    function DataZoomFeature2() {
      return _super !== null && _super.apply(this, arguments) || this;
    }
    DataZoomFeature2.prototype.render = function(featureModel, ecModel, api, payload) {
      if (!this._brushController) {
        this._brushController = new BrushController_default(api.getZr());
        this._brushController.on("brush", bind(this._onBrush, this)).mount();
      }
      updateZoomBtnStatus(featureModel, ecModel, this, payload, api);
      updateBackBtnStatus(featureModel, ecModel);
    };
    DataZoomFeature2.prototype.onclick = function(ecModel, api, type) {
      handlers2[type].call(this);
    };
    DataZoomFeature2.prototype.remove = function(ecModel, api) {
      this._brushController && this._brushController.unmount();
    };
    DataZoomFeature2.prototype.dispose = function(ecModel, api) {
      this._brushController && this._brushController.dispose();
    };
    DataZoomFeature2.prototype._onBrush = function(eventParam) {
      var areas = eventParam.areas;
      if (!eventParam.isEnd || !areas.length) {
        return;
      }
      var snapshot = {};
      var ecModel = this.ecModel;
      this._brushController.updateCovers([]);
      var brushTargetManager = new BrushTargetManager_default(makeAxisFinder(this.model), ecModel, {
        include: ["grid"]
      });
      brushTargetManager.matchOutputRanges(areas, ecModel, function(area, coordRange, coordSys) {
        if (coordSys.type !== "cartesian2d") {
          return;
        }
        var brushType = area.brushType;
        if (brushType === "rect") {
          setBatch("x", coordSys, coordRange[0]);
          setBatch("y", coordSys, coordRange[1]);
        } else {
          setBatch({
            lineX: "x",
            lineY: "y"
          }[brushType], coordSys, coordRange);
        }
      });
      push(ecModel, snapshot);
      this._dispatchZoomAction(snapshot);
      function setBatch(dimName, coordSys, minMax) {
        var axis = coordSys.getAxis(dimName);
        var axisModel = axis.model;
        var dataZoomModel = findDataZoom(dimName, axisModel, ecModel);
        var minMaxSpan = dataZoomModel.findRepresentativeAxisProxy(axisModel).getMinMaxSpan();
        if (minMaxSpan.minValueSpan != null || minMaxSpan.maxValueSpan != null) {
          minMax = sliderMove(0, minMax.slice(), axis.scale.getExtent(), 0, minMaxSpan.minValueSpan, minMaxSpan.maxValueSpan);
        }
        dataZoomModel && (snapshot[dataZoomModel.id] = {
          dataZoomId: dataZoomModel.id,
          startValue: minMax[0],
          endValue: minMax[1]
        });
      }
      function findDataZoom(dimName, axisModel, ecModel2) {
        var found;
        ecModel2.eachComponent({
          mainType: "dataZoom",
          subType: "select"
        }, function(dzModel) {
          var has3 = dzModel.getAxisModel(dimName, axisModel.componentIndex);
          has3 && (found = dzModel);
        });
        return found;
      }
    };
    ;
    DataZoomFeature2.prototype._dispatchZoomAction = function(snapshot) {
      var batch = [];
      each11(snapshot, function(batchItem, dataZoomId) {
        batch.push(clone(batchItem));
      });
      batch.length && this.api.dispatchAction({
        type: "dataZoom",
        from: this.uid,
        batch
      });
    };
    DataZoomFeature2.getDefaultOption = function(ecModel) {
      var defaultOption3 = {
        show: true,
        filterMode: "filter",
        icon: {
          zoom: "M0,13.5h26.9 M13.5,26.9V0 M32.1,13.5H58V58H13.5 V32.1",
          back: "M22,1.4L9.9,13.5l12.3,12.3 M10.3,13.5H54.9v44.6 H10.3v-26"
        },
        title: ecModel.getLocaleModel().get(["toolbox", "dataZoom", "title"]),
        brushStyle: {
          borderWidth: 0,
          color: "rgba(210,219,238,0.2)"
        }
      };
      return defaultOption3;
    };
    return DataZoomFeature2;
  }(ToolboxFeature);
  var handlers2 = {
    zoom: function() {
      var nextActive = !this._isZoomActive;
      this.api.dispatchAction({
        type: "takeGlobalCursor",
        key: "dataZoomSelect",
        dataZoomSelectActive: nextActive
      });
    },
    back: function() {
      this._dispatchZoomAction(pop(this.ecModel));
    }
  };
  function makeAxisFinder(dzFeatureModel) {
    var setting = {
      xAxisIndex: dzFeatureModel.get("xAxisIndex", true),
      yAxisIndex: dzFeatureModel.get("yAxisIndex", true),
      xAxisId: dzFeatureModel.get("xAxisId", true),
      yAxisId: dzFeatureModel.get("yAxisId", true)
    };
    if (setting.xAxisIndex == null && setting.xAxisId == null) {
      setting.xAxisIndex = "all";
    }
    if (setting.yAxisIndex == null && setting.yAxisId == null) {
      setting.yAxisIndex = "all";
    }
    return setting;
  }
  function updateBackBtnStatus(featureModel, ecModel) {
    featureModel.setIconStatus("back", count(ecModel) > 1 ? "emphasis" : "normal");
  }
  function updateZoomBtnStatus(featureModel, ecModel, view, payload, api) {
    var zoomActive = view._isZoomActive;
    if (payload && payload.type === "takeGlobalCursor") {
      zoomActive = payload.key === "dataZoomSelect" ? payload.dataZoomSelectActive : false;
    }
    view._isZoomActive = zoomActive;
    featureModel.setIconStatus("zoom", zoomActive ? "emphasis" : "normal");
    var brushTargetManager = new BrushTargetManager_default(makeAxisFinder(featureModel), ecModel, {
      include: ["grid"]
    });
    var panels = brushTargetManager.makePanelOpts(api, function(targetInfo) {
      return targetInfo.xAxisDeclared && !targetInfo.yAxisDeclared ? "lineX" : !targetInfo.xAxisDeclared && targetInfo.yAxisDeclared ? "lineY" : "rect";
    });
    view._brushController.setPanels(panels).enableBrush(zoomActive && panels.length ? {
      brushType: "auto",
      brushStyle: featureModel.getModel("brushStyle").getItemStyle()
    } : false);
  }
  registerInternalOptionCreator("dataZoom", function(ecModel) {
    var toolboxModel = ecModel.getComponent("toolbox", 0);
    var featureDataZoomPath = ["feature", "dataZoom"];
    if (!toolboxModel || toolboxModel.get(featureDataZoomPath) == null) {
      return;
    }
    var dzFeatureModel = toolboxModel.getModel(featureDataZoomPath);
    var dzOptions = [];
    var finder = makeAxisFinder(dzFeatureModel);
    var finderResult = parseFinder(ecModel, finder);
    each11(finderResult.xAxisModels, function(axisModel) {
      return buildInternalOptions(axisModel, "xAxis", "xAxisIndex");
    });
    each11(finderResult.yAxisModels, function(axisModel) {
      return buildInternalOptions(axisModel, "yAxis", "yAxisIndex");
    });
    function buildInternalOptions(axisModel, axisMainType, axisIndexPropName) {
      var axisIndex = axisModel.componentIndex;
      var newOpt = {
        type: "select",
        $fromToolbox: true,
        filterMode: dzFeatureModel.get("filterMode", true) || "filter",
        id: DATA_ZOOM_ID_BASE + axisMainType + axisIndex
      };
      newOpt[axisIndexPropName] = axisIndex;
      dzOptions.push(newOpt);
    }
    return dzOptions;
  });
  var DataZoom_default = DataZoomFeature;

  // node_modules/echarts/lib/component/toolbox/install.js
  function install36(registers) {
    registers.registerComponentModel(ToolboxModel_default);
    registers.registerComponentView(ToolboxView_default);
    registerFeature("saveAsImage", SaveAsImage_default);
    registerFeature("magicType", MagicType_default);
    registerFeature("dataView", DataView_default);
    registerFeature("dataZoom", DataZoom_default);
    registerFeature("restore", Restore_default);
    use(install35);
  }

  // node_modules/echarts/lib/component/tooltip/TooltipModel.js
  var TooltipModel = function(_super) {
    __extends(TooltipModel2, _super);
    function TooltipModel2() {
      var _this = _super !== null && _super.apply(this, arguments) || this;
      _this.type = TooltipModel2.type;
      return _this;
    }
    TooltipModel2.type = "tooltip";
    TooltipModel2.dependencies = ["axisPointer"];
    TooltipModel2.defaultOption = {
      z: 60,
      show: true,
      showContent: true,
      trigger: "item",
      triggerOn: "mousemove|click",
      alwaysShowContent: false,
      displayMode: "single",
      renderMode: "auto",
      confine: null,
      showDelay: 0,
      hideDelay: 100,
      transitionDuration: 0.4,
      enterable: false,
      backgroundColor: "#fff",
      shadowBlur: 10,
      shadowColor: "rgba(0, 0, 0, .2)",
      shadowOffsetX: 1,
      shadowOffsetY: 2,
      borderRadius: 4,
      borderWidth: 1,
      padding: null,
      extraCssText: "",
      axisPointer: {
        type: "line",
        axis: "auto",
        animation: "auto",
        animationDurationUpdate: 200,
        animationEasingUpdate: "exponentialOut",
        crossStyle: {
          color: "#999",
          width: 1,
          type: "dashed",
          textStyle: {}
        }
      },
      textStyle: {
        color: "#666",
        fontSize: 14
      }
    };
    return TooltipModel2;
  }(Component_default);
  var TooltipModel_default = TooltipModel;

  // node_modules/echarts/lib/component/tooltip/helper.js
  function shouldTooltipConfine(tooltipModel) {
    var confineOption = tooltipModel.get("confine");
    return confineOption != null ? !!confineOption : tooltipModel.get("renderMode") === "richText";
  }
  function testStyle(styleProps) {
    if (!env_default.domSupported) {
      return;
    }
    var style = document.documentElement.style;
    for (var i = 0, len2 = styleProps.length; i < len2; i++) {
      if (styleProps[i] in style) {
        return styleProps[i];
      }
    }
  }
  var TRANSFORM_VENDOR = testStyle(["transform", "webkitTransform", "OTransform", "MozTransform", "msTransform"]);
  var TRANSITION_VENDOR = testStyle(["webkitTransition", "transition", "OTransition", "MozTransition", "msTransition"]);
  function toCSSVendorPrefix(styleVendor, styleProp) {
    if (!styleVendor) {
      return styleProp;
    }
    styleProp = toCamelCase(styleProp, true);
    var idx = styleVendor.indexOf(styleProp);
    styleVendor = idx === -1 ? styleProp : "-" + styleVendor.slice(0, idx) + "-" + styleProp;
    return styleVendor.toLowerCase();
  }
  function getComputedStyle2(el, style) {
    var stl = el.currentStyle || document.defaultView && document.defaultView.getComputedStyle(el);
    return stl ? style ? stl[style] : stl : null;
  }

  // node_modules/echarts/lib/component/tooltip/TooltipHTMLContent.js
  var CSS_TRANSITION_VENDOR = toCSSVendorPrefix(TRANSITION_VENDOR, "transition");
  var CSS_TRANSFORM_VENDOR = toCSSVendorPrefix(TRANSFORM_VENDOR, "transform");
  var gCssText = "position:absolute;display:block;border-style:solid;white-space:nowrap;z-index:9999999;" + (env_default.transform3dSupported ? "will-change:transform;" : "");
  function mirrorPos(pos) {
    pos = pos === "left" ? "right" : pos === "right" ? "left" : pos === "top" ? "bottom" : "top";
    return pos;
  }
  function assembleArrow(tooltipModel, borderColor, arrowPosition) {
    if (!isString(arrowPosition) || arrowPosition === "inside") {
      return "";
    }
    var backgroundColor2 = tooltipModel.get("backgroundColor");
    var borderWidth = tooltipModel.get("borderWidth");
    borderColor = convertToColorString(borderColor);
    var arrowPos = mirrorPos(arrowPosition);
    var arrowSize = Math.max(Math.round(borderWidth) * 1.5, 6);
    var positionStyle = "";
    var transformStyle = CSS_TRANSFORM_VENDOR + ":";
    var rotateDeg;
    if (indexOf(["left", "right"], arrowPos) > -1) {
      positionStyle += "top:50%";
      transformStyle += "translateY(-50%) rotate(" + (rotateDeg = arrowPos === "left" ? -225 : -45) + "deg)";
    } else {
      positionStyle += "left:50%";
      transformStyle += "translateX(-50%) rotate(" + (rotateDeg = arrowPos === "top" ? 225 : 45) + "deg)";
    }
    var rotateRadian = rotateDeg * Math.PI / 180;
    var arrowWH = arrowSize + borderWidth;
    var rotatedWH = arrowWH * Math.abs(Math.cos(rotateRadian)) + arrowWH * Math.abs(Math.sin(rotateRadian));
    var arrowOffset = Math.round(((rotatedWH - Math.SQRT2 * borderWidth) / 2 + Math.SQRT2 * borderWidth - (rotatedWH - arrowWH) / 2) * 100) / 100;
    positionStyle += ";" + arrowPos + ":-" + arrowOffset + "px";
    var borderStyle = borderColor + " solid " + borderWidth + "px;";
    var styleCss = ["position:absolute;width:" + arrowSize + "px;height:" + arrowSize + "px;", positionStyle + ";" + transformStyle + ";", "border-bottom:" + borderStyle, "border-right:" + borderStyle, "background-color:" + backgroundColor2 + ";"];
    return '<div style="' + styleCss.join("") + '"></div>';
  }
  function assembleTransition(duration, onlyFade) {
    var transitionCurve = "cubic-bezier(0.23,1,0.32,1)";
    var transitionOption = " " + duration / 2 + "s " + transitionCurve;
    var transitionText = "opacity" + transitionOption + ",visibility" + transitionOption;
    if (!onlyFade) {
      transitionOption = " " + duration + "s " + transitionCurve;
      transitionText += env_default.transformSupported ? "," + CSS_TRANSFORM_VENDOR + transitionOption : ",left" + transitionOption + ",top" + transitionOption;
    }
    return CSS_TRANSITION_VENDOR + ":" + transitionText;
  }
  function assembleTransform(x, y, toString) {
    var x0 = x.toFixed(0) + "px";
    var y0 = y.toFixed(0) + "px";
    if (!env_default.transformSupported) {
      return toString ? "top:" + y0 + ";left:" + x0 + ";" : [["top", y0], ["left", x0]];
    }
    var is3d = env_default.transform3dSupported;
    var translate2 = "translate" + (is3d ? "3d" : "") + "(" + x0 + "," + y0 + (is3d ? ",0" : "") + ")";
    return toString ? "top:0;left:0;" + CSS_TRANSFORM_VENDOR + ":" + translate2 + ";" : [["top", 0], ["left", 0], [TRANSFORM_VENDOR, translate2]];
  }
  function assembleFont(textStyleModel) {
    var cssText = [];
    var fontSize = textStyleModel.get("fontSize");
    var color = textStyleModel.getTextColor();
    color && cssText.push("color:" + color);
    cssText.push("font:" + textStyleModel.getFont());
    fontSize && cssText.push("line-height:" + Math.round(fontSize * 3 / 2) + "px");
    var shadowColor = textStyleModel.get("textShadowColor");
    var shadowBlur = textStyleModel.get("textShadowBlur") || 0;
    var shadowOffsetX = textStyleModel.get("textShadowOffsetX") || 0;
    var shadowOffsetY = textStyleModel.get("textShadowOffsetY") || 0;
    shadowColor && shadowBlur && cssText.push("text-shadow:" + shadowOffsetX + "px " + shadowOffsetY + "px " + shadowBlur + "px " + shadowColor);
    each(["decoration", "align"], function(name) {
      var val = textStyleModel.get(name);
      val && cssText.push("text-" + name + ":" + val);
    });
    return cssText.join(";");
  }
  function assembleCssText(tooltipModel, enableTransition, onlyFade) {
    var cssText = [];
    var transitionDuration = tooltipModel.get("transitionDuration");
    var backgroundColor2 = tooltipModel.get("backgroundColor");
    var shadowBlur = tooltipModel.get("shadowBlur");
    var shadowColor = tooltipModel.get("shadowColor");
    var shadowOffsetX = tooltipModel.get("shadowOffsetX");
    var shadowOffsetY = tooltipModel.get("shadowOffsetY");
    var textStyleModel = tooltipModel.getModel("textStyle");
    var padding = getPaddingFromTooltipModel(tooltipModel, "html");
    var boxShadow = shadowOffsetX + "px " + shadowOffsetY + "px " + shadowBlur + "px " + shadowColor;
    cssText.push("box-shadow:" + boxShadow);
    enableTransition && transitionDuration && cssText.push(assembleTransition(transitionDuration, onlyFade));
    if (backgroundColor2) {
      cssText.push("background-color:" + backgroundColor2);
    }
    each(["width", "color", "radius"], function(name) {
      var borderName = "border-" + name;
      var camelCase = toCamelCase(borderName);
      var val = tooltipModel.get(camelCase);
      val != null && cssText.push(borderName + ":" + val + (name === "color" ? "" : "px"));
    });
    cssText.push(assembleFont(textStyleModel));
    if (padding != null) {
      cssText.push("padding:" + normalizeCssArray2(padding).join("px ") + "px");
    }
    return cssText.join(";") + ";";
  }
  function makeStyleCoord(out2, zr, appendToBody, zrX, zrY) {
    var zrPainter = zr && zr.painter;
    if (appendToBody) {
      var zrViewportRoot = zrPainter && zrPainter.getViewportRoot();
      if (zrViewportRoot) {
        transformLocalCoord(out2, zrViewportRoot, document.body, zrX, zrY);
      }
    } else {
      out2[0] = zrX;
      out2[1] = zrY;
      var viewportRootOffset = zrPainter && zrPainter.getViewportRootOffset();
      if (viewportRootOffset) {
        out2[0] += viewportRootOffset.offsetLeft;
        out2[1] += viewportRootOffset.offsetTop;
      }
    }
    out2[2] = out2[0] / zr.getWidth();
    out2[3] = out2[1] / zr.getHeight();
  }
  var TooltipHTMLContent = function() {
    function TooltipHTMLContent2(container, api, opt) {
      this._show = false;
      this._styleCoord = [0, 0, 0, 0];
      this._enterable = true;
      this._firstShow = true;
      this._longHide = true;
      if (env_default.wxa) {
        return null;
      }
      var el = document.createElement("div");
      el.domBelongToZr = true;
      this.el = el;
      var zr = this._zr = api.getZr();
      var appendToBody = this._appendToBody = opt && opt.appendToBody;
      makeStyleCoord(this._styleCoord, zr, appendToBody, api.getWidth() / 2, api.getHeight() / 2);
      if (appendToBody) {
        document.body.appendChild(el);
      } else {
        container.appendChild(el);
      }
      this._container = container;
      var self2 = this;
      el.onmouseenter = function() {
        if (self2._enterable) {
          clearTimeout(self2._hideTimeout);
          self2._show = true;
        }
        self2._inContent = true;
      };
      el.onmousemove = function(e2) {
        e2 = e2 || window.event;
        if (!self2._enterable) {
          var handler = zr.handler;
          var zrViewportRoot = zr.painter.getViewportRoot();
          normalizeEvent(zrViewportRoot, e2, true);
          handler.dispatch("mousemove", e2);
        }
      };
      el.onmouseleave = function() {
        self2._inContent = false;
        if (self2._enterable) {
          if (self2._show) {
            self2.hideLater(self2._hideDelay);
          }
        }
      };
    }
    TooltipHTMLContent2.prototype.update = function(tooltipModel) {
      var container = this._container;
      var position2 = getComputedStyle2(container, "position");
      var domStyle = container.style;
      if (domStyle.position !== "absolute" && position2 !== "absolute") {
        domStyle.position = "relative";
      }
      var alwaysShowContent = tooltipModel.get("alwaysShowContent");
      alwaysShowContent && this._moveIfResized();
      this.el.className = tooltipModel.get("className") || "";
    };
    TooltipHTMLContent2.prototype.show = function(tooltipModel, nearPointColor) {
      clearTimeout(this._hideTimeout);
      clearTimeout(this._longHideTimeout);
      var el = this.el;
      var style = el.style;
      var styleCoord = this._styleCoord;
      if (!el.innerHTML) {
        style.display = "none";
      } else {
        style.cssText = gCssText + assembleCssText(tooltipModel, !this._firstShow, this._longHide) + assembleTransform(styleCoord[0], styleCoord[1], true) + ("border-color:" + convertToColorString(nearPointColor) + ";") + (tooltipModel.get("extraCssText") || "") + (";pointer-events:" + (this._enterable ? "auto" : "none"));
      }
      this._show = true;
      this._firstShow = false;
      this._longHide = false;
    };
    TooltipHTMLContent2.prototype.setContent = function(content, markers, tooltipModel, borderColor, arrowPosition) {
      var el = this.el;
      if (content == null) {
        el.innerHTML = "";
        return;
      }
      var arrow = "";
      if (isString(arrowPosition) && tooltipModel.get("trigger") === "item" && !shouldTooltipConfine(tooltipModel)) {
        arrow = assembleArrow(tooltipModel, borderColor, arrowPosition);
      }
      if (isString(content)) {
        el.innerHTML = content + arrow;
      } else if (content) {
        el.innerHTML = "";
        if (!isArray(content)) {
          content = [content];
        }
        for (var i = 0; i < content.length; i++) {
          if (isDom(content[i]) && content[i].parentNode !== el) {
            el.appendChild(content[i]);
          }
        }
        if (arrow && el.childNodes.length) {
          var arrowEl = document.createElement("div");
          arrowEl.innerHTML = arrow;
          el.appendChild(arrowEl);
        }
      }
    };
    TooltipHTMLContent2.prototype.setEnterable = function(enterable) {
      this._enterable = enterable;
    };
    TooltipHTMLContent2.prototype.getSize = function() {
      var el = this.el;
      return [el.offsetWidth, el.offsetHeight];
    };
    TooltipHTMLContent2.prototype.moveTo = function(zrX, zrY) {
      var styleCoord = this._styleCoord;
      makeStyleCoord(styleCoord, this._zr, this._appendToBody, zrX, zrY);
      if (styleCoord[0] != null && styleCoord[1] != null) {
        var style_1 = this.el.style;
        var transforms = assembleTransform(styleCoord[0], styleCoord[1]);
        each(transforms, function(transform2) {
          style_1[transform2[0]] = transform2[1];
        });
      }
    };
    TooltipHTMLContent2.prototype._moveIfResized = function() {
      var ratioX = this._styleCoord[2];
      var ratioY = this._styleCoord[3];
      this.moveTo(ratioX * this._zr.getWidth(), ratioY * this._zr.getHeight());
    };
    TooltipHTMLContent2.prototype.hide = function() {
      var _this = this;
      var style = this.el.style;
      style.visibility = "hidden";
      style.opacity = "0";
      env_default.transform3dSupported && (style.willChange = "");
      this._show = false;
      this._longHideTimeout = setTimeout(function() {
        return _this._longHide = true;
      }, 500);
    };
    TooltipHTMLContent2.prototype.hideLater = function(time) {
      if (this._show && !(this._inContent && this._enterable)) {
        if (time) {
          this._hideDelay = time;
          this._show = false;
          this._hideTimeout = setTimeout(bind(this.hide, this), time);
        } else {
          this.hide();
        }
      }
    };
    TooltipHTMLContent2.prototype.isShow = function() {
      return this._show;
    };
    TooltipHTMLContent2.prototype.dispose = function() {
      this.el.parentNode.removeChild(this.el);
    };
    return TooltipHTMLContent2;
  }();
  var TooltipHTMLContent_default = TooltipHTMLContent;

  // node_modules/echarts/lib/component/tooltip/TooltipRichContent.js
  var TooltipRichContent = function() {
    function TooltipRichContent2(api) {
      this._show = false;
      this._styleCoord = [0, 0, 0, 0];
      this._enterable = true;
      this._zr = api.getZr();
      makeStyleCoord2(this._styleCoord, this._zr, api.getWidth() / 2, api.getHeight() / 2);
    }
    TooltipRichContent2.prototype.update = function(tooltipModel) {
      var alwaysShowContent = tooltipModel.get("alwaysShowContent");
      alwaysShowContent && this._moveIfResized();
    };
    TooltipRichContent2.prototype.show = function() {
      if (this._hideTimeout) {
        clearTimeout(this._hideTimeout);
      }
      this.el.show();
      this._show = true;
    };
    TooltipRichContent2.prototype.setContent = function(content, markupStyleCreator, tooltipModel, borderColor, arrowPosition) {
      var _this = this;
      if (isObject(content)) {
        throwError(true ? "Passing DOM nodes as content is not supported in richText tooltip!" : "");
      }
      if (this.el) {
        this._zr.remove(this.el);
      }
      var textStyleModel = tooltipModel.getModel("textStyle");
      this.el = new Text_default({
        style: {
          rich: markupStyleCreator.richTextStyles,
          text: content,
          lineHeight: 22,
          borderWidth: 1,
          borderColor,
          textShadowColor: textStyleModel.get("textShadowColor"),
          fill: tooltipModel.get(["textStyle", "color"]),
          padding: getPaddingFromTooltipModel(tooltipModel, "richText"),
          verticalAlign: "top",
          align: "left"
        },
        z: tooltipModel.get("z")
      });
      each(["backgroundColor", "borderRadius", "shadowColor", "shadowBlur", "shadowOffsetX", "shadowOffsetY"], function(propName) {
        _this.el.style[propName] = tooltipModel.get(propName);
      });
      each(["textShadowBlur", "textShadowOffsetX", "textShadowOffsetY"], function(propName) {
        _this.el.style[propName] = textStyleModel.get(propName) || 0;
      });
      this._zr.add(this.el);
      var self2 = this;
      this.el.on("mouseover", function() {
        if (self2._enterable) {
          clearTimeout(self2._hideTimeout);
          self2._show = true;
        }
        self2._inContent = true;
      });
      this.el.on("mouseout", function() {
        if (self2._enterable) {
          if (self2._show) {
            self2.hideLater(self2._hideDelay);
          }
        }
        self2._inContent = false;
      });
    };
    TooltipRichContent2.prototype.setEnterable = function(enterable) {
      this._enterable = enterable;
    };
    TooltipRichContent2.prototype.getSize = function() {
      var el = this.el;
      var bounding = this.el.getBoundingRect();
      var shadowOuterSize = calcShadowOuterSize(el.style);
      return [bounding.width + shadowOuterSize.left + shadowOuterSize.right, bounding.height + shadowOuterSize.top + shadowOuterSize.bottom];
    };
    TooltipRichContent2.prototype.moveTo = function(x, y) {
      var el = this.el;
      if (el) {
        var styleCoord = this._styleCoord;
        makeStyleCoord2(styleCoord, this._zr, x, y);
        x = styleCoord[0];
        y = styleCoord[1];
        var style = el.style;
        var borderWidth = mathMaxWith0(style.borderWidth || 0);
        var shadowOuterSize = calcShadowOuterSize(style);
        el.x = x + borderWidth + shadowOuterSize.left;
        el.y = y + borderWidth + shadowOuterSize.top;
        el.markRedraw();
      }
    };
    TooltipRichContent2.prototype._moveIfResized = function() {
      var ratioX = this._styleCoord[2];
      var ratioY = this._styleCoord[3];
      this.moveTo(ratioX * this._zr.getWidth(), ratioY * this._zr.getHeight());
    };
    TooltipRichContent2.prototype.hide = function() {
      if (this.el) {
        this.el.hide();
      }
      this._show = false;
    };
    TooltipRichContent2.prototype.hideLater = function(time) {
      if (this._show && !(this._inContent && this._enterable)) {
        if (time) {
          this._hideDelay = time;
          this._show = false;
          this._hideTimeout = setTimeout(bind(this.hide, this), time);
        } else {
          this.hide();
        }
      }
    };
    TooltipRichContent2.prototype.isShow = function() {
      return this._show;
    };
    TooltipRichContent2.prototype.dispose = function() {
      this._zr.remove(this.el);
    };
    return TooltipRichContent2;
  }();
  function mathMaxWith0(val) {
    return Math.max(0, val);
  }
  function calcShadowOuterSize(style) {
    var shadowBlur = mathMaxWith0(style.shadowBlur || 0);
    var shadowOffsetX = mathMaxWith0(style.shadowOffsetX || 0);
    var shadowOffsetY = mathMaxWith0(style.shadowOffsetY || 0);
    return {
      left: mathMaxWith0(shadowBlur - shadowOffsetX),
      right: mathMaxWith0(shadowBlur + shadowOffsetX),
      top: mathMaxWith0(shadowBlur - shadowOffsetY),
      bottom: mathMaxWith0(shadowBlur + shadowOffsetY)
    };
  }
  function makeStyleCoord2(out2, zr, zrX, zrY) {
    out2[0] = zrX;
    out2[1] = zrY;
    out2[2] = out2[0] / zr.getWidth();
    out2[3] = out2[1] / zr.getHeight();
  }
  var TooltipRichContent_default = TooltipRichContent;

  // node_modules/echarts/lib/component/tooltip/TooltipView.js
  var proxyRect = new Rect_default({
    shape: {
      x: -1,
      y: -1,
      width: 2,
      height: 2
    }
  });
  var TooltipView = function(_super) {
    __extends(TooltipView2, _super);
    function TooltipView2() {
      var _this = _super !== null && _super.apply(this, arguments) || this;
      _this.type = TooltipView2.type;
      return _this;
    }
    TooltipView2.prototype.init = function(ecModel, api) {
      if (env_default.node || !api.getDom()) {
        return;
      }
      var tooltipModel = ecModel.getComponent("tooltip");
      var renderMode = this._renderMode = getTooltipRenderMode(tooltipModel.get("renderMode"));
      this._tooltipContent = renderMode === "richText" ? new TooltipRichContent_default(api) : new TooltipHTMLContent_default(api.getDom(), api, {
        appendToBody: tooltipModel.get("appendToBody", true)
      });
    };
    TooltipView2.prototype.render = function(tooltipModel, ecModel, api) {
      if (env_default.node || !api.getDom()) {
        return;
      }
      this.group.removeAll();
      this._tooltipModel = tooltipModel;
      this._ecModel = ecModel;
      this._api = api;
      this._alwaysShowContent = tooltipModel.get("alwaysShowContent");
      var tooltipContent = this._tooltipContent;
      tooltipContent.update(tooltipModel);
      tooltipContent.setEnterable(tooltipModel.get("enterable"));
      this._initGlobalListener();
      this._keepShow();
      if (this._renderMode !== "richText" && tooltipModel.get("transitionDuration")) {
        createOrUpdate(this, "_updatePosition", 50, "fixRate");
      } else {
        clear(this, "_updatePosition");
      }
    };
    TooltipView2.prototype._initGlobalListener = function() {
      var tooltipModel = this._tooltipModel;
      var triggerOn = tooltipModel.get("triggerOn");
      register("itemTooltip", this._api, bind(function(currTrigger, e2, dispatchAction3) {
        if (triggerOn !== "none") {
          if (triggerOn.indexOf(currTrigger) >= 0) {
            this._tryShow(e2, dispatchAction3);
          } else if (currTrigger === "leave") {
            this._hide(dispatchAction3);
          }
        }
      }, this));
    };
    TooltipView2.prototype._keepShow = function() {
      var tooltipModel = this._tooltipModel;
      var ecModel = this._ecModel;
      var api = this._api;
      var triggerOn = tooltipModel.get("triggerOn");
      if (this._lastX != null && this._lastY != null && triggerOn !== "none" && triggerOn !== "click") {
        var self_1 = this;
        clearTimeout(this._refreshUpdateTimeout);
        this._refreshUpdateTimeout = setTimeout(function() {
          !api.isDisposed() && self_1.manuallyShowTip(tooltipModel, ecModel, api, {
            x: self_1._lastX,
            y: self_1._lastY,
            dataByCoordSys: self_1._lastDataByCoordSys
          });
        });
      }
    };
    TooltipView2.prototype.manuallyShowTip = function(tooltipModel, ecModel, api, payload) {
      if (payload.from === this.uid || env_default.node || !api.getDom()) {
        return;
      }
      var dispatchAction3 = makeDispatchAction2(payload, api);
      this._ticket = "";
      var dataByCoordSys = payload.dataByCoordSys;
      var cmptRef = findComponentReference(payload, ecModel, api);
      if (cmptRef) {
        var rect = cmptRef.el.getBoundingRect().clone();
        rect.applyTransform(cmptRef.el.transform);
        this._tryShow({
          offsetX: rect.x + rect.width / 2,
          offsetY: rect.y + rect.height / 2,
          target: cmptRef.el,
          position: payload.position,
          positionDefault: "bottom"
        }, dispatchAction3);
      } else if (payload.tooltip && payload.x != null && payload.y != null) {
        var el = proxyRect;
        el.x = payload.x;
        el.y = payload.y;
        el.update();
        getECData(el).tooltipConfig = {
          name: null,
          option: payload.tooltip
        };
        this._tryShow({
          offsetX: payload.x,
          offsetY: payload.y,
          target: el
        }, dispatchAction3);
      } else if (dataByCoordSys) {
        this._tryShow({
          offsetX: payload.x,
          offsetY: payload.y,
          position: payload.position,
          dataByCoordSys,
          tooltipOption: payload.tooltipOption
        }, dispatchAction3);
      } else if (payload.seriesIndex != null) {
        if (this._manuallyAxisShowTip(tooltipModel, ecModel, api, payload)) {
          return;
        }
        var pointInfo = findPointFromSeries(payload, ecModel);
        var cx = pointInfo.point[0];
        var cy = pointInfo.point[1];
        if (cx != null && cy != null) {
          this._tryShow({
            offsetX: cx,
            offsetY: cy,
            target: pointInfo.el,
            position: payload.position,
            positionDefault: "bottom"
          }, dispatchAction3);
        }
      } else if (payload.x != null && payload.y != null) {
        api.dispatchAction({
          type: "updateAxisPointer",
          x: payload.x,
          y: payload.y
        });
        this._tryShow({
          offsetX: payload.x,
          offsetY: payload.y,
          position: payload.position,
          target: api.getZr().findHover(payload.x, payload.y).target
        }, dispatchAction3);
      }
    };
    TooltipView2.prototype.manuallyHideTip = function(tooltipModel, ecModel, api, payload) {
      var tooltipContent = this._tooltipContent;
      if (!this._alwaysShowContent && this._tooltipModel) {
        tooltipContent.hideLater(this._tooltipModel.get("hideDelay"));
      }
      this._lastX = this._lastY = this._lastDataByCoordSys = null;
      if (payload.from !== this.uid) {
        this._hide(makeDispatchAction2(payload, api));
      }
    };
    TooltipView2.prototype._manuallyAxisShowTip = function(tooltipModel, ecModel, api, payload) {
      var seriesIndex = payload.seriesIndex;
      var dataIndex = payload.dataIndex;
      var coordSysAxesInfo = ecModel.getComponent("axisPointer").coordSysAxesInfo;
      if (seriesIndex == null || dataIndex == null || coordSysAxesInfo == null) {
        return;
      }
      var seriesModel = ecModel.getSeriesByIndex(seriesIndex);
      if (!seriesModel) {
        return;
      }
      var data = seriesModel.getData();
      var tooltipCascadedModel = buildTooltipModel([data.getItemModel(dataIndex), seriesModel, (seriesModel.coordinateSystem || {}).model], this._tooltipModel);
      if (tooltipCascadedModel.get("trigger") !== "axis") {
        return;
      }
      api.dispatchAction({
        type: "updateAxisPointer",
        seriesIndex,
        dataIndex,
        position: payload.position
      });
      return true;
    };
    TooltipView2.prototype._tryShow = function(e2, dispatchAction3) {
      var el = e2.target;
      var tooltipModel = this._tooltipModel;
      if (!tooltipModel) {
        return;
      }
      this._lastX = e2.offsetX;
      this._lastY = e2.offsetY;
      var dataByCoordSys = e2.dataByCoordSys;
      if (dataByCoordSys && dataByCoordSys.length) {
        this._showAxisTooltip(dataByCoordSys, e2);
      } else if (el) {
        this._lastDataByCoordSys = null;
        var seriesDispatcher_1;
        var cmptDispatcher_1;
        findEventDispatcher(el, function(target) {
          if (getECData(target).dataIndex != null) {
            seriesDispatcher_1 = target;
            return true;
          }
          if (getECData(target).tooltipConfig != null) {
            cmptDispatcher_1 = target;
            return true;
          }
        }, true);
        if (seriesDispatcher_1) {
          this._showSeriesItemTooltip(e2, seriesDispatcher_1, dispatchAction3);
        } else if (cmptDispatcher_1) {
          this._showComponentItemTooltip(e2, cmptDispatcher_1, dispatchAction3);
        } else {
          this._hide(dispatchAction3);
        }
      } else {
        this._lastDataByCoordSys = null;
        this._hide(dispatchAction3);
      }
    };
    TooltipView2.prototype._showOrMove = function(tooltipModel, cb) {
      var delay = tooltipModel.get("showDelay");
      cb = bind(cb, this);
      clearTimeout(this._showTimout);
      delay > 0 ? this._showTimout = setTimeout(cb, delay) : cb();
    };
    TooltipView2.prototype._showAxisTooltip = function(dataByCoordSys, e2) {
      var ecModel = this._ecModel;
      var globalTooltipModel = this._tooltipModel;
      var point = [e2.offsetX, e2.offsetY];
      var singleTooltipModel = buildTooltipModel([e2.tooltipOption], globalTooltipModel);
      var renderMode = this._renderMode;
      var cbParamsList = [];
      var articleMarkup = createTooltipMarkup("section", {
        blocks: [],
        noHeader: true
      });
      var markupTextArrLegacy = [];
      var markupStyleCreator = new TooltipMarkupStyleCreator();
      each(dataByCoordSys, function(itemCoordSys) {
        each(itemCoordSys.dataByAxis, function(axisItem) {
          var axisModel = ecModel.getComponent(axisItem.axisDim + "Axis", axisItem.axisIndex);
          var axisValue = axisItem.value;
          if (!axisModel || axisValue == null) {
            return;
          }
          var axisValueLabel = getValueLabel(axisValue, axisModel.axis, ecModel, axisItem.seriesDataIndices, axisItem.valueLabelOpt);
          var axisSectionMarkup = createTooltipMarkup("section", {
            header: axisValueLabel,
            noHeader: !trim(axisValueLabel),
            sortBlocks: true,
            blocks: []
          });
          articleMarkup.blocks.push(axisSectionMarkup);
          each(axisItem.seriesDataIndices, function(idxItem) {
            var series = ecModel.getSeriesByIndex(idxItem.seriesIndex);
            var dataIndex = idxItem.dataIndexInside;
            var cbParams = series.getDataParams(dataIndex);
            if (cbParams.dataIndex < 0) {
              return;
            }
            cbParams.axisDim = axisItem.axisDim;
            cbParams.axisIndex = axisItem.axisIndex;
            cbParams.axisType = axisItem.axisType;
            cbParams.axisId = axisItem.axisId;
            cbParams.axisValue = getAxisRawValue(axisModel.axis, {
              value: axisValue
            });
            cbParams.axisValueLabel = axisValueLabel;
            cbParams.marker = markupStyleCreator.makeTooltipMarker("item", convertToColorString(cbParams.color), renderMode);
            var seriesTooltipResult = normalizeTooltipFormatResult(series.formatTooltip(dataIndex, true, null));
            var frag = seriesTooltipResult.frag;
            if (frag) {
              var valueFormatter = buildTooltipModel([series], globalTooltipModel).get("valueFormatter");
              axisSectionMarkup.blocks.push(valueFormatter ? extend({
                valueFormatter
              }, frag) : frag);
            }
            if (seriesTooltipResult.text) {
              markupTextArrLegacy.push(seriesTooltipResult.text);
            }
            cbParamsList.push(cbParams);
          });
        });
      });
      articleMarkup.blocks.reverse();
      markupTextArrLegacy.reverse();
      var positionExpr = e2.position;
      var orderMode = singleTooltipModel.get("order");
      var builtMarkupText = buildTooltipMarkup(articleMarkup, markupStyleCreator, renderMode, orderMode, ecModel.get("useUTC"), singleTooltipModel.get("textStyle"));
      builtMarkupText && markupTextArrLegacy.unshift(builtMarkupText);
      var blockBreak = renderMode === "richText" ? "\n\n" : "<br/>";
      var allMarkupText = markupTextArrLegacy.join(blockBreak);
      this._showOrMove(singleTooltipModel, function() {
        if (this._updateContentNotChangedOnAxis(dataByCoordSys, cbParamsList)) {
          this._updatePosition(singleTooltipModel, positionExpr, point[0], point[1], this._tooltipContent, cbParamsList);
        } else {
          this._showTooltipContent(singleTooltipModel, allMarkupText, cbParamsList, Math.random() + "", point[0], point[1], positionExpr, null, markupStyleCreator);
        }
      });
    };
    TooltipView2.prototype._showSeriesItemTooltip = function(e2, dispatcher, dispatchAction3) {
      var ecModel = this._ecModel;
      var ecData = getECData(dispatcher);
      var seriesIndex = ecData.seriesIndex;
      var seriesModel = ecModel.getSeriesByIndex(seriesIndex);
      var dataModel = ecData.dataModel || seriesModel;
      var dataIndex = ecData.dataIndex;
      var dataType = ecData.dataType;
      var data = dataModel.getData(dataType);
      var renderMode = this._renderMode;
      var positionDefault = e2.positionDefault;
      var tooltipModel = buildTooltipModel([data.getItemModel(dataIndex), dataModel, seriesModel && (seriesModel.coordinateSystem || {}).model], this._tooltipModel, positionDefault ? {
        position: positionDefault
      } : null);
      var tooltipTrigger = tooltipModel.get("trigger");
      if (tooltipTrigger != null && tooltipTrigger !== "item") {
        return;
      }
      var params = dataModel.getDataParams(dataIndex, dataType);
      var markupStyleCreator = new TooltipMarkupStyleCreator();
      params.marker = markupStyleCreator.makeTooltipMarker("item", convertToColorString(params.color), renderMode);
      var seriesTooltipResult = normalizeTooltipFormatResult(dataModel.formatTooltip(dataIndex, false, dataType));
      var orderMode = tooltipModel.get("order");
      var valueFormatter = tooltipModel.get("valueFormatter");
      var frag = seriesTooltipResult.frag;
      var markupText = frag ? buildTooltipMarkup(valueFormatter ? extend({
        valueFormatter
      }, frag) : frag, markupStyleCreator, renderMode, orderMode, ecModel.get("useUTC"), tooltipModel.get("textStyle")) : seriesTooltipResult.text;
      var asyncTicket = "item_" + dataModel.name + "_" + dataIndex;
      this._showOrMove(tooltipModel, function() {
        this._showTooltipContent(tooltipModel, markupText, params, asyncTicket, e2.offsetX, e2.offsetY, e2.position, e2.target, markupStyleCreator);
      });
      dispatchAction3({
        type: "showTip",
        dataIndexInside: dataIndex,
        dataIndex: data.getRawIndex(dataIndex),
        seriesIndex,
        from: this.uid
      });
    };
    TooltipView2.prototype._showComponentItemTooltip = function(e2, el, dispatchAction3) {
      var ecData = getECData(el);
      var tooltipConfig = ecData.tooltipConfig;
      var tooltipOpt = tooltipConfig.option || {};
      if (isString(tooltipOpt)) {
        var content = tooltipOpt;
        tooltipOpt = {
          content,
          formatter: content
        };
      }
      var tooltipModelCascade = [tooltipOpt];
      var cmpt = this._ecModel.getComponent(ecData.componentMainType, ecData.componentIndex);
      if (cmpt) {
        tooltipModelCascade.push(cmpt);
      }
      tooltipModelCascade.push({
        formatter: tooltipOpt.content
      });
      var positionDefault = e2.positionDefault;
      var subTooltipModel = buildTooltipModel(tooltipModelCascade, this._tooltipModel, positionDefault ? {
        position: positionDefault
      } : null);
      var defaultHtml = subTooltipModel.get("content");
      var asyncTicket = Math.random() + "";
      var markupStyleCreator = new TooltipMarkupStyleCreator();
      this._showOrMove(subTooltipModel, function() {
        var formatterParams = clone(subTooltipModel.get("formatterParams") || {});
        this._showTooltipContent(subTooltipModel, defaultHtml, formatterParams, asyncTicket, e2.offsetX, e2.offsetY, e2.position, el, markupStyleCreator);
      });
      dispatchAction3({
        type: "showTip",
        from: this.uid
      });
    };
    TooltipView2.prototype._showTooltipContent = function(tooltipModel, defaultHtml, params, asyncTicket, x, y, positionExpr, el, markupStyleCreator) {
      this._ticket = "";
      if (!tooltipModel.get("showContent") || !tooltipModel.get("show")) {
        return;
      }
      var tooltipContent = this._tooltipContent;
      tooltipContent.setEnterable(tooltipModel.get("enterable"));
      var formatter = tooltipModel.get("formatter");
      positionExpr = positionExpr || tooltipModel.get("position");
      var html = defaultHtml;
      var nearPoint = this._getNearestPoint([x, y], params, tooltipModel.get("trigger"), tooltipModel.get("borderColor"));
      var nearPointColor = nearPoint.color;
      if (formatter) {
        if (isString(formatter)) {
          var useUTC = tooltipModel.ecModel.get("useUTC");
          var params0 = isArray(params) ? params[0] : params;
          var isTimeAxis = params0 && params0.axisType && params0.axisType.indexOf("time") >= 0;
          html = formatter;
          if (isTimeAxis) {
            html = format(params0.axisValue, html, useUTC);
          }
          html = formatTpl(html, params, true);
        } else if (isFunction(formatter)) {
          var callback = bind(function(cbTicket, html2) {
            if (cbTicket === this._ticket) {
              tooltipContent.setContent(html2, markupStyleCreator, tooltipModel, nearPointColor, positionExpr);
              this._updatePosition(tooltipModel, positionExpr, x, y, tooltipContent, params, el);
            }
          }, this);
          this._ticket = asyncTicket;
          html = formatter(params, asyncTicket, callback);
        } else {
          html = formatter;
        }
      }
      tooltipContent.setContent(html, markupStyleCreator, tooltipModel, nearPointColor, positionExpr);
      tooltipContent.show(tooltipModel, nearPointColor);
      this._updatePosition(tooltipModel, positionExpr, x, y, tooltipContent, params, el);
    };
    TooltipView2.prototype._getNearestPoint = function(point, tooltipDataParams, trigger3, borderColor) {
      if (trigger3 === "axis" || isArray(tooltipDataParams)) {
        return {
          color: borderColor || (this._renderMode === "html" ? "#fff" : "none")
        };
      }
      if (!isArray(tooltipDataParams)) {
        return {
          color: borderColor || tooltipDataParams.color || tooltipDataParams.borderColor
        };
      }
    };
    TooltipView2.prototype._updatePosition = function(tooltipModel, positionExpr, x, y, content, params, el) {
      var viewWidth = this._api.getWidth();
      var viewHeight = this._api.getHeight();
      positionExpr = positionExpr || tooltipModel.get("position");
      var contentSize = content.getSize();
      var align = tooltipModel.get("align");
      var vAlign = tooltipModel.get("verticalAlign");
      var rect = el && el.getBoundingRect().clone();
      el && rect.applyTransform(el.transform);
      if (isFunction(positionExpr)) {
        positionExpr = positionExpr([x, y], params, content.el, rect, {
          viewSize: [viewWidth, viewHeight],
          contentSize: contentSize.slice()
        });
      }
      if (isArray(positionExpr)) {
        x = parsePercent2(positionExpr[0], viewWidth);
        y = parsePercent2(positionExpr[1], viewHeight);
      } else if (isObject(positionExpr)) {
        var boxLayoutPosition = positionExpr;
        boxLayoutPosition.width = contentSize[0];
        boxLayoutPosition.height = contentSize[1];
        var layoutRect = getLayoutRect(boxLayoutPosition, {
          width: viewWidth,
          height: viewHeight
        });
        x = layoutRect.x;
        y = layoutRect.y;
        align = null;
        vAlign = null;
      } else if (isString(positionExpr) && el) {
        var pos = calcTooltipPosition(positionExpr, rect, contentSize, tooltipModel.get("borderWidth"));
        x = pos[0];
        y = pos[1];
      } else {
        var pos = refixTooltipPosition(x, y, content, viewWidth, viewHeight, align ? null : 20, vAlign ? null : 20);
        x = pos[0];
        y = pos[1];
      }
      align && (x -= isCenterAlign(align) ? contentSize[0] / 2 : align === "right" ? contentSize[0] : 0);
      vAlign && (y -= isCenterAlign(vAlign) ? contentSize[1] / 2 : vAlign === "bottom" ? contentSize[1] : 0);
      if (shouldTooltipConfine(tooltipModel)) {
        var pos = confineTooltipPosition(x, y, content, viewWidth, viewHeight);
        x = pos[0];
        y = pos[1];
      }
      content.moveTo(x, y);
    };
    TooltipView2.prototype._updateContentNotChangedOnAxis = function(dataByCoordSys, cbParamsList) {
      var lastCoordSys = this._lastDataByCoordSys;
      var lastCbParamsList = this._cbParamsList;
      var contentNotChanged = !!lastCoordSys && lastCoordSys.length === dataByCoordSys.length;
      contentNotChanged && each(lastCoordSys, function(lastItemCoordSys, indexCoordSys) {
        var lastDataByAxis = lastItemCoordSys.dataByAxis || [];
        var thisItemCoordSys = dataByCoordSys[indexCoordSys] || {};
        var thisDataByAxis = thisItemCoordSys.dataByAxis || [];
        contentNotChanged = contentNotChanged && lastDataByAxis.length === thisDataByAxis.length;
        contentNotChanged && each(lastDataByAxis, function(lastItem, indexAxis) {
          var thisItem = thisDataByAxis[indexAxis] || {};
          var lastIndices = lastItem.seriesDataIndices || [];
          var newIndices = thisItem.seriesDataIndices || [];
          contentNotChanged = contentNotChanged && lastItem.value === thisItem.value && lastItem.axisType === thisItem.axisType && lastItem.axisId === thisItem.axisId && lastIndices.length === newIndices.length;
          contentNotChanged && each(lastIndices, function(lastIdxItem, j) {
            var newIdxItem = newIndices[j];
            contentNotChanged = contentNotChanged && lastIdxItem.seriesIndex === newIdxItem.seriesIndex && lastIdxItem.dataIndex === newIdxItem.dataIndex;
          });
          lastCbParamsList && each(lastItem.seriesDataIndices, function(idxItem) {
            var seriesIdx = idxItem.seriesIndex;
            var cbParams = cbParamsList[seriesIdx];
            var lastCbParams = lastCbParamsList[seriesIdx];
            if (cbParams && lastCbParams && lastCbParams.data !== cbParams.data) {
              contentNotChanged = false;
            }
          });
        });
      });
      this._lastDataByCoordSys = dataByCoordSys;
      this._cbParamsList = cbParamsList;
      return !!contentNotChanged;
    };
    TooltipView2.prototype._hide = function(dispatchAction3) {
      this._lastDataByCoordSys = null;
      dispatchAction3({
        type: "hideTip",
        from: this.uid
      });
    };
    TooltipView2.prototype.dispose = function(ecModel, api) {
      if (env_default.node || !api.getDom()) {
        return;
      }
      clear(this, "_updatePosition");
      this._tooltipContent.dispose();
      unregister("itemTooltip", api);
    };
    TooltipView2.type = "tooltip";
    return TooltipView2;
  }(Component_default2);
  function buildTooltipModel(modelCascade, globalTooltipModel, defaultTooltipOption) {
    var ecModel = globalTooltipModel.ecModel;
    var resultModel;
    if (defaultTooltipOption) {
      resultModel = new Model_default(defaultTooltipOption, ecModel, ecModel);
      resultModel = new Model_default(globalTooltipModel.option, resultModel, ecModel);
    } else {
      resultModel = globalTooltipModel;
    }
    for (var i = modelCascade.length - 1; i >= 0; i--) {
      var tooltipOpt = modelCascade[i];
      if (tooltipOpt) {
        if (tooltipOpt instanceof Model_default) {
          tooltipOpt = tooltipOpt.get("tooltip", true);
        }
        if (isString(tooltipOpt)) {
          tooltipOpt = {
            formatter: tooltipOpt
          };
        }
        if (tooltipOpt) {
          resultModel = new Model_default(tooltipOpt, resultModel, ecModel);
        }
      }
    }
    return resultModel;
  }
  function makeDispatchAction2(payload, api) {
    return payload.dispatchAction || bind(api.dispatchAction, api);
  }
  function refixTooltipPosition(x, y, content, viewWidth, viewHeight, gapH, gapV) {
    var size = content.getSize();
    var width = size[0];
    var height = size[1];
    if (gapH != null) {
      if (x + width + gapH + 2 > viewWidth) {
        x -= width + gapH;
      } else {
        x += gapH;
      }
    }
    if (gapV != null) {
      if (y + height + gapV > viewHeight) {
        y -= height + gapV;
      } else {
        y += gapV;
      }
    }
    return [x, y];
  }
  function confineTooltipPosition(x, y, content, viewWidth, viewHeight) {
    var size = content.getSize();
    var width = size[0];
    var height = size[1];
    x = Math.min(x + width, viewWidth) - width;
    y = Math.min(y + height, viewHeight) - height;
    x = Math.max(x, 0);
    y = Math.max(y, 0);
    return [x, y];
  }
  function calcTooltipPosition(position2, rect, contentSize, borderWidth) {
    var domWidth = contentSize[0];
    var domHeight = contentSize[1];
    var offset = Math.ceil(Math.SQRT2 * borderWidth) + 8;
    var x = 0;
    var y = 0;
    var rectWidth = rect.width;
    var rectHeight = rect.height;
    switch (position2) {
      case "inside":
        x = rect.x + rectWidth / 2 - domWidth / 2;
        y = rect.y + rectHeight / 2 - domHeight / 2;
        break;
      case "top":
        x = rect.x + rectWidth / 2 - domWidth / 2;
        y = rect.y - domHeight - offset;
        break;
      case "bottom":
        x = rect.x + rectWidth / 2 - domWidth / 2;
        y = rect.y + rectHeight + offset;
        break;
      case "left":
        x = rect.x - domWidth - offset;
        y = rect.y + rectHeight / 2 - domHeight / 2;
        break;
      case "right":
        x = rect.x + rectWidth + offset;
        y = rect.y + rectHeight / 2 - domHeight / 2;
    }
    return [x, y];
  }
  function isCenterAlign(align) {
    return align === "center" || align === "middle";
  }
  function findComponentReference(payload, ecModel, api) {
    var queryOptionMap = preParseFinder(payload).queryOptionMap;
    var componentMainType = queryOptionMap.keys()[0];
    if (!componentMainType || componentMainType === "series") {
      return;
    }
    var queryResult = queryReferringComponents(ecModel, componentMainType, queryOptionMap.get(componentMainType), {
      useDefault: false,
      enableAll: false,
      enableNone: false
    });
    var model = queryResult.models[0];
    if (!model) {
      return;
    }
    var view = api.getViewOfComponentModel(model);
    var el;
    view.group.traverse(function(subEl) {
      var tooltipConfig = getECData(subEl).tooltipConfig;
      if (tooltipConfig && tooltipConfig.name === payload.name) {
        el = subEl;
        return true;
      }
    });
    if (el) {
      return {
        componentMainType,
        componentIndex: model.componentIndex,
        el
      };
    }
  }
  var TooltipView_default = TooltipView;

  // node_modules/echarts/lib/component/tooltip/install.js
  function install37(registers) {
    use(install29);
    registers.registerComponentModel(TooltipModel_default);
    registers.registerComponentView(TooltipView_default);
    registers.registerAction({
      type: "showTip",
      event: "showTip",
      update: "tooltip:manuallyShowTip"
    }, noop);
    registers.registerAction({
      type: "hideTip",
      event: "hideTip",
      update: "tooltip:manuallyHideTip"
    }, noop);
  }

  // node_modules/echarts/lib/component/brush/preprocessor.js
  var DEFAULT_TOOLBOX_BTNS = ["rect", "polygon", "keep", "clear"];
  function brushPreprocessor(option, isNew) {
    var brushComponents = normalizeToArray(option ? option.brush : []);
    if (!brushComponents.length) {
      return;
    }
    var brushComponentSpecifiedBtns = [];
    each(brushComponents, function(brushOpt) {
      var tbs = brushOpt.hasOwnProperty("toolbox") ? brushOpt.toolbox : [];
      if (tbs instanceof Array) {
        brushComponentSpecifiedBtns = brushComponentSpecifiedBtns.concat(tbs);
      }
    });
    var toolbox = option && option.toolbox;
    if (isArray(toolbox)) {
      toolbox = toolbox[0];
    }
    if (!toolbox) {
      toolbox = {
        feature: {}
      };
      option.toolbox = [toolbox];
    }
    var toolboxFeature = toolbox.feature || (toolbox.feature = {});
    var toolboxBrush = toolboxFeature.brush || (toolboxFeature.brush = {});
    var brushTypes = toolboxBrush.type || (toolboxBrush.type = []);
    brushTypes.push.apply(brushTypes, brushComponentSpecifiedBtns);
    removeDuplicate(brushTypes);
    if (isNew && !brushTypes.length) {
      brushTypes.push.apply(brushTypes, DEFAULT_TOOLBOX_BTNS);
    }
  }
  function removeDuplicate(arr) {
    var map3 = {};
    each(arr, function(val) {
      map3[val] = 1;
    });
    arr.length = 0;
    each(map3, function(flag, val) {
      arr.push(val);
    });
  }

  // node_modules/echarts/lib/visual/visualSolution.js
  var each12 = each;
  function hasKeys(obj) {
    if (obj) {
      for (var name_1 in obj) {
        if (obj.hasOwnProperty(name_1)) {
          return true;
        }
      }
    }
  }
  function createVisualMappings(option, stateList, supplementVisualOption) {
    var visualMappings = {};
    each12(stateList, function(state) {
      var mappings = visualMappings[state] = createMappings();
      each12(option[state], function(visualData, visualType) {
        if (!VisualMapping_default.isValidType(visualType)) {
          return;
        }
        var mappingOption = {
          type: visualType,
          visual: visualData
        };
        supplementVisualOption && supplementVisualOption(mappingOption, state);
        mappings[visualType] = new VisualMapping_default(mappingOption);
        if (visualType === "opacity") {
          mappingOption = clone(mappingOption);
          mappingOption.type = "colorAlpha";
          mappings.__hidden.__alphaForOpacity = new VisualMapping_default(mappingOption);
        }
      });
    });
    return visualMappings;
    function createMappings() {
      var Creater = function() {
      };
      Creater.prototype.__hidden = Creater.prototype;
      var obj = new Creater();
      return obj;
    }
  }
  function replaceVisualOption(thisOption, newOption, keys2) {
    var has3;
    each(keys2, function(key) {
      if (newOption.hasOwnProperty(key) && hasKeys(newOption[key])) {
        has3 = true;
      }
    });
    has3 && each(keys2, function(key) {
      if (newOption.hasOwnProperty(key) && hasKeys(newOption[key])) {
        thisOption[key] = clone(newOption[key]);
      } else {
        delete thisOption[key];
      }
    });
  }
  function applyVisual(stateList, visualMappings, data, getValueState, scope, dimension) {
    var visualTypesMap = {};
    each(stateList, function(state) {
      var visualTypes = VisualMapping_default.prepareVisualTypes(visualMappings[state]);
      visualTypesMap[state] = visualTypes;
    });
    var dataIndex;
    function getVisual(key) {
      return getItemVisualFromData(data, dataIndex, key);
    }
    function setVisual(key, value) {
      setItemVisualFromData(data, dataIndex, key, value);
    }
    if (dimension == null) {
      data.each(eachItem);
    } else {
      data.each([dimension], eachItem);
    }
    function eachItem(valueOrIndex, index) {
      dataIndex = dimension == null ? valueOrIndex : index;
      var rawDataItem = data.getRawDataItem(dataIndex);
      if (rawDataItem && rawDataItem.visualMap === false) {
        return;
      }
      var valueState = getValueState.call(scope, valueOrIndex);
      var mappings = visualMappings[valueState];
      var visualTypes = visualTypesMap[valueState];
      for (var i = 0, len2 = visualTypes.length; i < len2; i++) {
        var type = visualTypes[i];
        mappings[type] && mappings[type].applyVisual(valueOrIndex, getVisual, setVisual);
      }
    }
  }
  function incrementalApplyVisual(stateList, visualMappings, getValueState, dim) {
    var visualTypesMap = {};
    each(stateList, function(state) {
      var visualTypes = VisualMapping_default.prepareVisualTypes(visualMappings[state]);
      visualTypesMap[state] = visualTypes;
    });
    return {
      progress: function progress(params, data) {
        var dimIndex;
        if (dim != null) {
          dimIndex = data.getDimensionIndex(dim);
        }
        function getVisual(key) {
          return getItemVisualFromData(data, dataIndex, key);
        }
        function setVisual(key, value2) {
          setItemVisualFromData(data, dataIndex, key, value2);
        }
        var dataIndex;
        var store = data.getStore();
        while ((dataIndex = params.next()) != null) {
          var rawDataItem = data.getRawDataItem(dataIndex);
          if (rawDataItem && rawDataItem.visualMap === false) {
            continue;
          }
          var value = dim != null ? store.get(dimIndex, dataIndex) : dataIndex;
          var valueState = getValueState(value);
          var mappings = visualMappings[valueState];
          var visualTypes = visualTypesMap[valueState];
          for (var i = 0, len2 = visualTypes.length; i < len2; i++) {
            var type = visualTypes[i];
            mappings[type] && mappings[type].applyVisual(value, getVisual, setVisual);
          }
        }
      }
    };
  }

  // node_modules/echarts/lib/component/brush/selector.js
  function makeBrushCommonSelectorForSeries(area) {
    var brushType = area.brushType;
    var selectors = {
      point: function(itemLayout) {
        return selector[brushType].point(itemLayout, selectors, area);
      },
      rect: function(itemLayout) {
        return selector[brushType].rect(itemLayout, selectors, area);
      }
    };
    return selectors;
  }
  var selector = {
    lineX: getLineSelectors(0),
    lineY: getLineSelectors(1),
    rect: {
      point: function(itemLayout, selectors, area) {
        return itemLayout && area.boundingRect.contain(itemLayout[0], itemLayout[1]);
      },
      rect: function(itemLayout, selectors, area) {
        return itemLayout && area.boundingRect.intersect(itemLayout);
      }
    },
    polygon: {
      point: function(itemLayout, selectors, area) {
        return itemLayout && area.boundingRect.contain(itemLayout[0], itemLayout[1]) && contain3(area.range, itemLayout[0], itemLayout[1]);
      },
      rect: function(itemLayout, selectors, area) {
        var points4 = area.range;
        if (!itemLayout || points4.length <= 1) {
          return false;
        }
        var x = itemLayout.x;
        var y = itemLayout.y;
        var width = itemLayout.width;
        var height = itemLayout.height;
        var p = points4[0];
        if (contain3(points4, x, y) || contain3(points4, x + width, y) || contain3(points4, x, y + height) || contain3(points4, x + width, y + height) || BoundingRect_default.create(itemLayout).contain(p[0], p[1]) || linePolygonIntersect(x, y, x + width, y, points4) || linePolygonIntersect(x, y, x, y + height, points4) || linePolygonIntersect(x + width, y, x + width, y + height, points4) || linePolygonIntersect(x, y + height, x + width, y + height, points4)) {
          return true;
        }
      }
    }
  };
  function getLineSelectors(xyIndex) {
    var xy = ["x", "y"];
    var wh = ["width", "height"];
    return {
      point: function(itemLayout, selectors, area) {
        if (itemLayout) {
          var range = area.range;
          var p = itemLayout[xyIndex];
          return inLineRange(p, range);
        }
      },
      rect: function(itemLayout, selectors, area) {
        if (itemLayout) {
          var range = area.range;
          var layoutRange = [itemLayout[xy[xyIndex]], itemLayout[xy[xyIndex]] + itemLayout[wh[xyIndex]]];
          layoutRange[1] < layoutRange[0] && layoutRange.reverse();
          return inLineRange(layoutRange[0], range) || inLineRange(layoutRange[1], range) || inLineRange(range[0], layoutRange) || inLineRange(range[1], layoutRange);
        }
      }
    };
  }
  function inLineRange(p, range) {
    return range[0] <= p && p <= range[1];
  }

  // node_modules/echarts/lib/component/brush/visualEncoding.js
  var STATE_LIST = ["inBrush", "outOfBrush"];
  var DISPATCH_METHOD = "__ecBrushSelect";
  var DISPATCH_FLAG = "__ecInBrushSelectEvent";
  function layoutCovers(ecModel) {
    ecModel.eachComponent({
      mainType: "brush"
    }, function(brushModel) {
      var brushTargetManager = brushModel.brushTargetManager = new BrushTargetManager_default(brushModel.option, ecModel);
      brushTargetManager.setInputRanges(brushModel.areas, ecModel);
    });
  }
  function brushVisual(ecModel, api, payload) {
    var brushSelected = [];
    var throttleType;
    var throttleDelay;
    ecModel.eachComponent({
      mainType: "brush"
    }, function(brushModel) {
      payload && payload.type === "takeGlobalCursor" && brushModel.setBrushOption(payload.key === "brush" ? payload.brushOption : {
        brushType: false
      });
    });
    layoutCovers(ecModel);
    ecModel.eachComponent({
      mainType: "brush"
    }, function(brushModel, brushIndex) {
      var thisBrushSelected = {
        brushId: brushModel.id,
        brushIndex,
        brushName: brushModel.name,
        areas: clone(brushModel.areas),
        selected: []
      };
      brushSelected.push(thisBrushSelected);
      var brushOption = brushModel.option;
      var brushLink = brushOption.brushLink;
      var linkedSeriesMap = [];
      var selectedDataIndexForLink = [];
      var rangeInfoBySeries = [];
      var hasBrushExists = false;
      if (!brushIndex) {
        throttleType = brushOption.throttleType;
        throttleDelay = brushOption.throttleDelay;
      }
      var areas = map(brushModel.areas, function(area) {
        var builder = boundingRectBuilders[area.brushType];
        var selectableArea = defaults({
          boundingRect: builder ? builder(area) : void 0
        }, area);
        selectableArea.selectors = makeBrushCommonSelectorForSeries(selectableArea);
        return selectableArea;
      });
      var visualMappings = createVisualMappings(brushModel.option, STATE_LIST, function(mappingOption) {
        mappingOption.mappingMethod = "fixed";
      });
      isArray(brushLink) && each(brushLink, function(seriesIndex) {
        linkedSeriesMap[seriesIndex] = 1;
      });
      function linkOthers(seriesIndex) {
        return brushLink === "all" || !!linkedSeriesMap[seriesIndex];
      }
      function brushed(rangeInfoList) {
        return !!rangeInfoList.length;
      }
      ecModel.eachSeries(function(seriesModel, seriesIndex) {
        var rangeInfoList = rangeInfoBySeries[seriesIndex] = [];
        seriesModel.subType === "parallel" ? stepAParallel(seriesModel, seriesIndex) : stepAOthers(seriesModel, seriesIndex, rangeInfoList);
      });
      function stepAParallel(seriesModel, seriesIndex) {
        var coordSys = seriesModel.coordinateSystem;
        hasBrushExists = hasBrushExists || coordSys.hasAxisBrushed();
        linkOthers(seriesIndex) && coordSys.eachActiveState(seriesModel.getData(), function(activeState, dataIndex) {
          activeState === "active" && (selectedDataIndexForLink[dataIndex] = 1);
        });
      }
      function stepAOthers(seriesModel, seriesIndex, rangeInfoList) {
        if (!seriesModel.brushSelector || brushModelNotControll(brushModel, seriesIndex)) {
          return;
        }
        each(areas, function(area) {
          if (brushModel.brushTargetManager.controlSeries(area, seriesModel, ecModel)) {
            rangeInfoList.push(area);
          }
          hasBrushExists = hasBrushExists || brushed(rangeInfoList);
        });
        if (linkOthers(seriesIndex) && brushed(rangeInfoList)) {
          var data_1 = seriesModel.getData();
          data_1.each(function(dataIndex) {
            if (checkInRange(seriesModel, rangeInfoList, data_1, dataIndex)) {
              selectedDataIndexForLink[dataIndex] = 1;
            }
          });
        }
      }
      ecModel.eachSeries(function(seriesModel, seriesIndex) {
        var seriesBrushSelected = {
          seriesId: seriesModel.id,
          seriesIndex,
          seriesName: seriesModel.name,
          dataIndex: []
        };
        thisBrushSelected.selected.push(seriesBrushSelected);
        var rangeInfoList = rangeInfoBySeries[seriesIndex];
        var data = seriesModel.getData();
        var getValueState = linkOthers(seriesIndex) ? function(dataIndex) {
          return selectedDataIndexForLink[dataIndex] ? (seriesBrushSelected.dataIndex.push(data.getRawIndex(dataIndex)), "inBrush") : "outOfBrush";
        } : function(dataIndex) {
          return checkInRange(seriesModel, rangeInfoList, data, dataIndex) ? (seriesBrushSelected.dataIndex.push(data.getRawIndex(dataIndex)), "inBrush") : "outOfBrush";
        };
        (linkOthers(seriesIndex) ? hasBrushExists : brushed(rangeInfoList)) && applyVisual(STATE_LIST, visualMappings, data, getValueState);
      });
    });
    dispatchAction(api, throttleType, throttleDelay, brushSelected, payload);
  }
  function dispatchAction(api, throttleType, throttleDelay, brushSelected, payload) {
    if (!payload) {
      return;
    }
    var zr = api.getZr();
    if (zr[DISPATCH_FLAG]) {
      return;
    }
    if (!zr[DISPATCH_METHOD]) {
      zr[DISPATCH_METHOD] = doDispatch;
    }
    var fn = createOrUpdate(zr, DISPATCH_METHOD, throttleDelay, throttleType);
    fn(api, brushSelected);
  }
  function doDispatch(api, brushSelected) {
    if (!api.isDisposed()) {
      var zr = api.getZr();
      zr[DISPATCH_FLAG] = true;
      api.dispatchAction({
        type: "brushSelect",
        batch: brushSelected
      });
      zr[DISPATCH_FLAG] = false;
    }
  }
  function checkInRange(seriesModel, rangeInfoList, data, dataIndex) {
    for (var i = 0, len2 = rangeInfoList.length; i < len2; i++) {
      var area = rangeInfoList[i];
      if (seriesModel.brushSelector(dataIndex, data, area.selectors, area)) {
        return true;
      }
    }
  }
  function brushModelNotControll(brushModel, seriesIndex) {
    var seriesIndices = brushModel.option.seriesIndex;
    return seriesIndices != null && seriesIndices !== "all" && (isArray(seriesIndices) ? indexOf(seriesIndices, seriesIndex) < 0 : seriesIndex !== seriesIndices);
  }
  var boundingRectBuilders = {
    rect: function(area) {
      return getBoundingRectFromMinMax(area.range);
    },
    polygon: function(area) {
      var minMax;
      var range = area.range;
      for (var i = 0, len2 = range.length; i < len2; i++) {
        minMax = minMax || [[Infinity, -Infinity], [Infinity, -Infinity]];
        var rg = range[i];
        rg[0] < minMax[0][0] && (minMax[0][0] = rg[0]);
        rg[0] > minMax[0][1] && (minMax[0][1] = rg[0]);
        rg[1] < minMax[1][0] && (minMax[1][0] = rg[1]);
        rg[1] > minMax[1][1] && (minMax[1][1] = rg[1]);
      }
      return minMax && getBoundingRectFromMinMax(minMax);
    }
  };
  function getBoundingRectFromMinMax(minMax) {
    return new BoundingRect_default(minMax[0][0], minMax[1][0], minMax[0][1] - minMax[0][0], minMax[1][1] - minMax[1][0]);
  }

  // node_modules/echarts/lib/component/brush/BrushView.js
  var BrushView = function(_super) {
    __extends(BrushView2, _super);
    function BrushView2() {
      var _this = _super !== null && _super.apply(this, arguments) || this;
      _this.type = BrushView2.type;
      return _this;
    }
    BrushView2.prototype.init = function(ecModel, api) {
      this.ecModel = ecModel;
      this.api = api;
      this.model;
      (this._brushController = new BrushController_default(api.getZr())).on("brush", bind(this._onBrush, this)).mount();
    };
    BrushView2.prototype.render = function(brushModel, ecModel, api, payload) {
      this.model = brushModel;
      this._updateController(brushModel, ecModel, api, payload);
    };
    BrushView2.prototype.updateTransform = function(brushModel, ecModel, api, payload) {
      layoutCovers(ecModel);
      this._updateController(brushModel, ecModel, api, payload);
    };
    BrushView2.prototype.updateVisual = function(brushModel, ecModel, api, payload) {
      this.updateTransform(brushModel, ecModel, api, payload);
    };
    BrushView2.prototype.updateView = function(brushModel, ecModel, api, payload) {
      this._updateController(brushModel, ecModel, api, payload);
    };
    BrushView2.prototype._updateController = function(brushModel, ecModel, api, payload) {
      (!payload || payload.$from !== brushModel.id) && this._brushController.setPanels(brushModel.brushTargetManager.makePanelOpts(api)).enableBrush(brushModel.brushOption).updateCovers(brushModel.areas.slice());
    };
    BrushView2.prototype.dispose = function() {
      this._brushController.dispose();
    };
    BrushView2.prototype._onBrush = function(eventParam) {
      var modelId = this.model.id;
      var areas = this.model.brushTargetManager.setOutputRanges(eventParam.areas, this.ecModel);
      (!eventParam.isEnd || eventParam.removeOnClick) && this.api.dispatchAction({
        type: "brush",
        brushId: modelId,
        areas: clone(areas),
        $from: modelId
      });
      eventParam.isEnd && this.api.dispatchAction({
        type: "brushEnd",
        brushId: modelId,
        areas: clone(areas),
        $from: modelId
      });
    };
    BrushView2.type = "brush";
    return BrushView2;
  }(Component_default2);
  var BrushView_default = BrushView;

  // node_modules/echarts/lib/component/brush/BrushModel.js
  var DEFAULT_OUT_OF_BRUSH_COLOR = "#ddd";
  var BrushModel = function(_super) {
    __extends(BrushModel2, _super);
    function BrushModel2() {
      var _this = _super !== null && _super.apply(this, arguments) || this;
      _this.type = BrushModel2.type;
      _this.areas = [];
      _this.brushOption = {};
      return _this;
    }
    BrushModel2.prototype.optionUpdated = function(newOption, isInit) {
      var thisOption = this.option;
      !isInit && replaceVisualOption(thisOption, newOption, ["inBrush", "outOfBrush"]);
      var inBrush = thisOption.inBrush = thisOption.inBrush || {};
      thisOption.outOfBrush = thisOption.outOfBrush || {
        color: DEFAULT_OUT_OF_BRUSH_COLOR
      };
      if (!inBrush.hasOwnProperty("liftZ")) {
        inBrush.liftZ = 5;
      }
    };
    BrushModel2.prototype.setAreas = function(areas) {
      if (true) {
        assert(isArray(areas));
        each(areas, function(area) {
          assert(area.brushType, "Illegal areas");
        });
      }
      if (!areas) {
        return;
      }
      this.areas = map(areas, function(area) {
        return generateBrushOption(this.option, area);
      }, this);
    };
    BrushModel2.prototype.setBrushOption = function(brushOption) {
      this.brushOption = generateBrushOption(this.option, brushOption);
      this.brushType = this.brushOption.brushType;
    };
    BrushModel2.type = "brush";
    BrushModel2.dependencies = ["geo", "grid", "xAxis", "yAxis", "parallel", "series"];
    BrushModel2.defaultOption = {
      seriesIndex: "all",
      brushType: "rect",
      brushMode: "single",
      transformable: true,
      brushStyle: {
        borderWidth: 1,
        color: "rgba(210,219,238,0.3)",
        borderColor: "#D2DBEE"
      },
      throttleType: "fixRate",
      throttleDelay: 0,
      removeOnClick: true,
      z: 1e4
    };
    return BrushModel2;
  }(Component_default);
  function generateBrushOption(option, brushOption) {
    return merge({
      brushType: option.brushType,
      brushMode: option.brushMode,
      transformable: option.transformable,
      brushStyle: new Model_default(option.brushStyle).getItemStyle(),
      removeOnClick: option.removeOnClick,
      z: option.z
    }, brushOption, true);
  }
  var BrushModel_default = BrushModel;

  // node_modules/echarts/lib/component/toolbox/feature/Brush.js
  var ICON_TYPES = ["rect", "polygon", "lineX", "lineY", "keep", "clear"];
  var BrushFeature = function(_super) {
    __extends(BrushFeature2, _super);
    function BrushFeature2() {
      return _super !== null && _super.apply(this, arguments) || this;
    }
    BrushFeature2.prototype.render = function(featureModel, ecModel, api) {
      var brushType;
      var brushMode;
      var isBrushed;
      ecModel.eachComponent({
        mainType: "brush"
      }, function(brushModel) {
        brushType = brushModel.brushType;
        brushMode = brushModel.brushOption.brushMode || "single";
        isBrushed = isBrushed || !!brushModel.areas.length;
      });
      this._brushType = brushType;
      this._brushMode = brushMode;
      each(featureModel.get("type", true), function(type) {
        featureModel.setIconStatus(type, (type === "keep" ? brushMode === "multiple" : type === "clear" ? isBrushed : type === brushType) ? "emphasis" : "normal");
      });
    };
    BrushFeature2.prototype.updateView = function(featureModel, ecModel, api) {
      this.render(featureModel, ecModel, api);
    };
    BrushFeature2.prototype.getIcons = function() {
      var model = this.model;
      var availableIcons = model.get("icon", true);
      var icons = {};
      each(model.get("type", true), function(type) {
        if (availableIcons[type]) {
          icons[type] = availableIcons[type];
        }
      });
      return icons;
    };
    ;
    BrushFeature2.prototype.onclick = function(ecModel, api, type) {
      var brushType = this._brushType;
      var brushMode = this._brushMode;
      if (type === "clear") {
        api.dispatchAction({
          type: "axisAreaSelect",
          intervals: []
        });
        api.dispatchAction({
          type: "brush",
          command: "clear",
          areas: []
        });
      } else {
        api.dispatchAction({
          type: "takeGlobalCursor",
          key: "brush",
          brushOption: {
            brushType: type === "keep" ? brushType : brushType === type ? false : type,
            brushMode: type === "keep" ? brushMode === "multiple" ? "single" : "multiple" : brushMode
          }
        });
      }
    };
    ;
    BrushFeature2.getDefaultOption = function(ecModel) {
      var defaultOption3 = {
        show: true,
        type: ICON_TYPES.slice(),
        icon: {
          rect: "M7.3,34.7 M0.4,10V-0.2h9.8 M89.6,10V-0.2h-9.8 M0.4,60v10.2h9.8 M89.6,60v10.2h-9.8 M12.3,22.4V10.5h13.1 M33.6,10.5h7.8 M49.1,10.5h7.8 M77.5,22.4V10.5h-13 M12.3,31.1v8.2 M77.7,31.1v8.2 M12.3,47.6v11.9h13.1 M33.6,59.5h7.6 M49.1,59.5 h7.7 M77.5,47.6v11.9h-13",
          polygon: "M55.2,34.9c1.7,0,3.1,1.4,3.1,3.1s-1.4,3.1-3.1,3.1 s-3.1-1.4-3.1-3.1S53.5,34.9,55.2,34.9z M50.4,51c1.7,0,3.1,1.4,3.1,3.1c0,1.7-1.4,3.1-3.1,3.1c-1.7,0-3.1-1.4-3.1-3.1 C47.3,52.4,48.7,51,50.4,51z M55.6,37.1l1.5-7.8 M60.1,13.5l1.6-8.7l-7.8,4 M59,19l-1,5.3 M24,16.1l6.4,4.9l6.4-3.3 M48.5,11.6 l-5.9,3.1 M19.1,12.8L9.7,5.1l1.1,7.7 M13.4,29.8l1,7.3l6.6,1.6 M11.6,18.4l1,6.1 M32.8,41.9 M26.6,40.4 M27.3,40.2l6.1,1.6 M49.9,52.1l-5.6-7.6l-4.9-1.2",
          lineX: "M15.2,30 M19.7,15.6V1.9H29 M34.8,1.9H40.4 M55.3,15.6V1.9H45.9 M19.7,44.4V58.1H29 M34.8,58.1H40.4 M55.3,44.4 V58.1H45.9 M12.5,20.3l-9.4,9.6l9.6,9.8 M3.1,29.9h16.5 M62.5,20.3l9.4,9.6L62.3,39.7 M71.9,29.9H55.4",
          lineY: "M38.8,7.7 M52.7,12h13.2v9 M65.9,26.6V32 M52.7,46.3h13.2v-9 M24.9,12H11.8v9 M11.8,26.6V32 M24.9,46.3H11.8v-9 M48.2,5.1l-9.3-9l-9.4,9.2 M38.9-3.9V12 M48.2,53.3l-9.3,9l-9.4-9.2 M38.9,62.3V46.4",
          keep: "M4,10.5V1h10.3 M20.7,1h6.1 M33,1h6.1 M55.4,10.5V1H45.2 M4,17.3v6.6 M55.6,17.3v6.6 M4,30.5V40h10.3 M20.7,40 h6.1 M33,40h6.1 M55.4,30.5V40H45.2 M21,18.9h62.9v48.6H21V18.9z",
          clear: "M22,14.7l30.9,31 M52.9,14.7L22,45.7 M4.7,16.8V4.2h13.1 M26,4.2h7.8 M41.6,4.2h7.8 M70.3,16.8V4.2H57.2 M4.7,25.9v8.6 M70.3,25.9v8.6 M4.7,43.2v12.6h13.1 M26,55.8h7.8 M41.6,55.8h7.8 M70.3,43.2v12.6H57.2"
        },
        title: ecModel.getLocaleModel().get(["toolbox", "brush", "title"])
      };
      return defaultOption3;
    };
    return BrushFeature2;
  }(ToolboxFeature);
  var Brush_default = BrushFeature;

  // node_modules/echarts/lib/component/brush/install.js
  function install38(registers) {
    registers.registerComponentView(BrushView_default);
    registers.registerComponentModel(BrushModel_default);
    registers.registerPreprocessor(brushPreprocessor);
    registers.registerVisual(registers.PRIORITY.VISUAL.BRUSH, brushVisual);
    registers.registerAction({
      type: "brush",
      event: "brush",
      update: "updateVisual"
    }, function(payload, ecModel) {
      ecModel.eachComponent({
        mainType: "brush",
        query: payload
      }, function(brushModel) {
        brushModel.setAreas(payload.areas);
      });
    });
    registers.registerAction({
      type: "brushSelect",
      event: "brushSelected",
      update: "none"
    }, noop);
    registers.registerAction({
      type: "brushEnd",
      event: "brushEnd",
      update: "none"
    }, noop);
    registerFeature("brush", Brush_default);
  }

  // node_modules/echarts/lib/component/title/install.js
  var TitleModel = function(_super) {
    __extends(TitleModel2, _super);
    function TitleModel2() {
      var _this = _super !== null && _super.apply(this, arguments) || this;
      _this.type = TitleModel2.type;
      _this.layoutMode = {
        type: "box",
        ignoreSize: true
      };
      return _this;
    }
    TitleModel2.type = "title";
    TitleModel2.defaultOption = {
      z: 6,
      show: true,
      text: "",
      target: "blank",
      subtext: "",
      subtarget: "blank",
      left: 0,
      top: 0,
      backgroundColor: "rgba(0,0,0,0)",
      borderColor: "#ccc",
      borderWidth: 0,
      padding: 5,
      itemGap: 10,
      textStyle: {
        fontSize: 18,
        fontWeight: "bold",
        color: "#464646"
      },
      subtextStyle: {
        fontSize: 12,
        color: "#6E7079"
      }
    };
    return TitleModel2;
  }(Component_default);
  var TitleView = function(_super) {
    __extends(TitleView2, _super);
    function TitleView2() {
      var _this = _super !== null && _super.apply(this, arguments) || this;
      _this.type = TitleView2.type;
      return _this;
    }
    TitleView2.prototype.render = function(titleModel, ecModel, api) {
      this.group.removeAll();
      if (!titleModel.get("show")) {
        return;
      }
      var group = this.group;
      var textStyleModel = titleModel.getModel("textStyle");
      var subtextStyleModel = titleModel.getModel("subtextStyle");
      var textAlign = titleModel.get("textAlign");
      var textVerticalAlign = retrieve2(titleModel.get("textBaseline"), titleModel.get("textVerticalAlign"));
      var textEl = new Text_default({
        style: createTextStyle(textStyleModel, {
          text: titleModel.get("text"),
          fill: textStyleModel.getTextColor()
        }, {
          disableBox: true
        }),
        z2: 10
      });
      var textRect = textEl.getBoundingRect();
      var subText = titleModel.get("subtext");
      var subTextEl = new Text_default({
        style: createTextStyle(subtextStyleModel, {
          text: subText,
          fill: subtextStyleModel.getTextColor(),
          y: textRect.height + titleModel.get("itemGap"),
          verticalAlign: "top"
        }, {
          disableBox: true
        }),
        z2: 10
      });
      var link = titleModel.get("link");
      var sublink = titleModel.get("sublink");
      var triggerEvent = titleModel.get("triggerEvent", true);
      textEl.silent = !link && !triggerEvent;
      subTextEl.silent = !sublink && !triggerEvent;
      if (link) {
        textEl.on("click", function() {
          windowOpen(link, "_" + titleModel.get("target"));
        });
      }
      if (sublink) {
        subTextEl.on("click", function() {
          windowOpen(sublink, "_" + titleModel.get("subtarget"));
        });
      }
      getECData(textEl).eventData = getECData(subTextEl).eventData = triggerEvent ? {
        componentType: "title",
        componentIndex: titleModel.componentIndex
      } : null;
      group.add(textEl);
      subText && group.add(subTextEl);
      var groupRect = group.getBoundingRect();
      var layoutOption = titleModel.getBoxLayoutParams();
      layoutOption.width = groupRect.width;
      layoutOption.height = groupRect.height;
      var layoutRect = getLayoutRect(layoutOption, {
        width: api.getWidth(),
        height: api.getHeight()
      }, titleModel.get("padding"));
      if (!textAlign) {
        textAlign = titleModel.get("left") || titleModel.get("right");
        if (textAlign === "middle") {
          textAlign = "center";
        }
        if (textAlign === "right") {
          layoutRect.x += layoutRect.width;
        } else if (textAlign === "center") {
          layoutRect.x += layoutRect.width / 2;
        }
      }
      if (!textVerticalAlign) {
        textVerticalAlign = titleModel.get("top") || titleModel.get("bottom");
        if (textVerticalAlign === "center") {
          textVerticalAlign = "middle";
        }
        if (textVerticalAlign === "bottom") {
          layoutRect.y += layoutRect.height;
        } else if (textVerticalAlign === "middle") {
          layoutRect.y += layoutRect.height / 2;
        }
        textVerticalAlign = textVerticalAlign || "top";
      }
      group.x = layoutRect.x;
      group.y = layoutRect.y;
      group.markRedraw();
      var alignStyle = {
        align: textAlign,
        verticalAlign: textVerticalAlign
      };
      textEl.setStyle(alignStyle);
      subTextEl.setStyle(alignStyle);
      groupRect = group.getBoundingRect();
      var padding = layoutRect.margin;
      var style = titleModel.getItemStyle(["color", "opacity"]);
      style.fill = titleModel.get("backgroundColor");
      var rect = new Rect_default({
        shape: {
          x: groupRect.x - padding[3],
          y: groupRect.y - padding[0],
          width: groupRect.width + padding[1] + padding[3],
          height: groupRect.height + padding[0] + padding[2],
          r: titleModel.get("borderRadius")
        },
        style,
        subPixelOptimize: true,
        silent: true
      });
      group.add(rect);
    };
    TitleView2.type = "title";
    return TitleView2;
  }(Component_default2);
  function install39(registers) {
    registers.registerComponentModel(TitleModel);
    registers.registerComponentView(TitleView);
  }

  // node_modules/echarts/lib/component/timeline/TimelineModel.js
  var TimelineModel = function(_super) {
    __extends(TimelineModel2, _super);
    function TimelineModel2() {
      var _this = _super !== null && _super.apply(this, arguments) || this;
      _this.type = TimelineModel2.type;
      _this.layoutMode = "box";
      return _this;
    }
    TimelineModel2.prototype.init = function(option, parentModel, ecModel) {
      this.mergeDefaultAndTheme(option, ecModel);
      this._initData();
    };
    TimelineModel2.prototype.mergeOption = function(option) {
      _super.prototype.mergeOption.apply(this, arguments);
      this._initData();
    };
    TimelineModel2.prototype.setCurrentIndex = function(currentIndex) {
      if (currentIndex == null) {
        currentIndex = this.option.currentIndex;
      }
      var count2 = this._data.count();
      if (this.option.loop) {
        currentIndex = (currentIndex % count2 + count2) % count2;
      } else {
        currentIndex >= count2 && (currentIndex = count2 - 1);
        currentIndex < 0 && (currentIndex = 0);
      }
      this.option.currentIndex = currentIndex;
    };
    TimelineModel2.prototype.getCurrentIndex = function() {
      return this.option.currentIndex;
    };
    TimelineModel2.prototype.isIndexMax = function() {
      return this.getCurrentIndex() >= this._data.count() - 1;
    };
    TimelineModel2.prototype.setPlayState = function(state) {
      this.option.autoPlay = !!state;
    };
    TimelineModel2.prototype.getPlayState = function() {
      return !!this.option.autoPlay;
    };
    TimelineModel2.prototype._initData = function() {
      var thisOption = this.option;
      var dataArr = thisOption.data || [];
      var axisType = thisOption.axisType;
      var names = this._names = [];
      var processedDataArr;
      if (axisType === "category") {
        processedDataArr = [];
        each(dataArr, function(item, index) {
          var value = convertOptionIdName(getDataItemValue(item), "");
          var newItem;
          if (isObject(item)) {
            newItem = clone(item);
            newItem.value = index;
          } else {
            newItem = index;
          }
          processedDataArr.push(newItem);
          names.push(value);
        });
      } else {
        processedDataArr = dataArr;
      }
      var dimType = {
        category: "ordinal",
        time: "time",
        value: "number"
      }[axisType] || "number";
      var data = this._data = new SeriesData_default([{
        name: "value",
        type: dimType
      }], this);
      data.initData(processedDataArr, names);
    };
    TimelineModel2.prototype.getData = function() {
      return this._data;
    };
    TimelineModel2.prototype.getCategories = function() {
      if (this.get("axisType") === "category") {
        return this._names.slice();
      }
    };
    TimelineModel2.type = "timeline";
    TimelineModel2.defaultOption = {
      z: 4,
      show: true,
      axisType: "time",
      realtime: true,
      left: "20%",
      top: null,
      right: "20%",
      bottom: 0,
      width: null,
      height: 40,
      padding: 5,
      controlPosition: "left",
      autoPlay: false,
      rewind: false,
      loop: true,
      playInterval: 2e3,
      currentIndex: 0,
      itemStyle: {},
      label: {
        color: "#000"
      },
      data: []
    };
    return TimelineModel2;
  }(Component_default);
  var TimelineModel_default = TimelineModel;

  // node_modules/echarts/lib/component/timeline/SliderTimelineModel.js
  var SliderTimelineModel = function(_super) {
    __extends(SliderTimelineModel2, _super);
    function SliderTimelineModel2() {
      var _this = _super !== null && _super.apply(this, arguments) || this;
      _this.type = SliderTimelineModel2.type;
      return _this;
    }
    SliderTimelineModel2.type = "timeline.slider";
    SliderTimelineModel2.defaultOption = inheritDefaultOption(TimelineModel_default.defaultOption, {
      backgroundColor: "rgba(0,0,0,0)",
      borderColor: "#ccc",
      borderWidth: 0,
      orient: "horizontal",
      inverse: false,
      tooltip: {
        trigger: "item"
      },
      symbol: "circle",
      symbolSize: 12,
      lineStyle: {
        show: true,
        width: 2,
        color: "#DAE1F5"
      },
      label: {
        position: "auto",
        show: true,
        interval: "auto",
        rotate: 0,
        color: "#A4B1D7"
      },
      itemStyle: {
        color: "#A4B1D7",
        borderWidth: 1
      },
      checkpointStyle: {
        symbol: "circle",
        symbolSize: 15,
        color: "#316bf3",
        borderColor: "#fff",
        borderWidth: 2,
        shadowBlur: 2,
        shadowOffsetX: 1,
        shadowOffsetY: 1,
        shadowColor: "rgba(0, 0, 0, 0.3)",
        animation: true,
        animationDuration: 300,
        animationEasing: "quinticInOut"
      },
      controlStyle: {
        show: true,
        showPlayBtn: true,
        showPrevBtn: true,
        showNextBtn: true,
        itemSize: 24,
        itemGap: 12,
        position: "left",
        playIcon: "path://M31.6,53C17.5,53,6,41.5,6,27.4S17.5,1.8,31.6,1.8C45.7,1.8,57.2,13.3,57.2,27.4S45.7,53,31.6,53z M31.6,3.3 C18.4,3.3,7.5,14.1,7.5,27.4c0,13.3,10.8,24.1,24.1,24.1C44.9,51.5,55.7,40.7,55.7,27.4C55.7,14.1,44.9,3.3,31.6,3.3z M24.9,21.3 c0-2.2,1.6-3.1,3.5-2l10.5,6.1c1.899,1.1,1.899,2.9,0,4l-10.5,6.1c-1.9,1.1-3.5,0.2-3.5-2V21.3z",
        stopIcon: "path://M30.9,53.2C16.8,53.2,5.3,41.7,5.3,27.6S16.8,2,30.9,2C45,2,56.4,13.5,56.4,27.6S45,53.2,30.9,53.2z M30.9,3.5C17.6,3.5,6.8,14.4,6.8,27.6c0,13.3,10.8,24.1,24.101,24.1C44.2,51.7,55,40.9,55,27.6C54.9,14.4,44.1,3.5,30.9,3.5z M36.9,35.8c0,0.601-0.4,1-0.9,1h-1.3c-0.5,0-0.9-0.399-0.9-1V19.5c0-0.6,0.4-1,0.9-1H36c0.5,0,0.9,0.4,0.9,1V35.8z M27.8,35.8 c0,0.601-0.4,1-0.9,1h-1.3c-0.5,0-0.9-0.399-0.9-1V19.5c0-0.6,0.4-1,0.9-1H27c0.5,0,0.9,0.4,0.9,1L27.8,35.8L27.8,35.8z",
        nextIcon: "M2,18.5A1.52,1.52,0,0,1,.92,18a1.49,1.49,0,0,1,0-2.12L7.81,9.36,1,3.11A1.5,1.5,0,1,1,3,.89l8,7.34a1.48,1.48,0,0,1,.49,1.09,1.51,1.51,0,0,1-.46,1.1L3,18.08A1.5,1.5,0,0,1,2,18.5Z",
        prevIcon: "M10,.5A1.52,1.52,0,0,1,11.08,1a1.49,1.49,0,0,1,0,2.12L4.19,9.64,11,15.89a1.5,1.5,0,1,1-2,2.22L1,10.77A1.48,1.48,0,0,1,.5,9.68,1.51,1.51,0,0,1,1,8.58L9,.92A1.5,1.5,0,0,1,10,.5Z",
        prevBtnSize: 18,
        nextBtnSize: 18,
        color: "#A4B1D7",
        borderColor: "#A4B1D7",
        borderWidth: 1
      },
      emphasis: {
        label: {
          show: true,
          color: "#6f778d"
        },
        itemStyle: {
          color: "#316BF3"
        },
        controlStyle: {
          color: "#316BF3",
          borderColor: "#316BF3",
          borderWidth: 2
        }
      },
      progress: {
        lineStyle: {
          color: "#316BF3"
        },
        itemStyle: {
          color: "#316BF3"
        },
        label: {
          color: "#6f778d"
        }
      },
      data: []
    });
    return SliderTimelineModel2;
  }(TimelineModel_default);
  mixin(SliderTimelineModel, DataFormatMixin.prototype);
  var SliderTimelineModel_default = SliderTimelineModel;

  // node_modules/echarts/lib/component/timeline/TimelineView.js
  var TimelineView = function(_super) {
    __extends(TimelineView2, _super);
    function TimelineView2() {
      var _this = _super !== null && _super.apply(this, arguments) || this;
      _this.type = TimelineView2.type;
      return _this;
    }
    TimelineView2.type = "timeline";
    return TimelineView2;
  }(Component_default2);
  var TimelineView_default = TimelineView;

  // node_modules/echarts/lib/component/timeline/TimelineAxis.js
  var TimelineAxis = function(_super) {
    __extends(TimelineAxis2, _super);
    function TimelineAxis2(dim, scale4, coordExtent, axisType) {
      var _this = _super.call(this, dim, scale4, coordExtent) || this;
      _this.type = axisType || "value";
      return _this;
    }
    TimelineAxis2.prototype.getLabelModel = function() {
      return this.model.getModel("label");
    };
    TimelineAxis2.prototype.isHorizontal = function() {
      return this.model.get("orient") === "horizontal";
    };
    return TimelineAxis2;
  }(Axis_default);
  var TimelineAxis_default = TimelineAxis;

  // node_modules/echarts/lib/component/timeline/SliderTimelineView.js
  var PI10 = Math.PI;
  var labelDataIndexStore = makeInner();
  var SliderTimelineView = function(_super) {
    __extends(SliderTimelineView2, _super);
    function SliderTimelineView2() {
      var _this = _super !== null && _super.apply(this, arguments) || this;
      _this.type = SliderTimelineView2.type;
      return _this;
    }
    SliderTimelineView2.prototype.init = function(ecModel, api) {
      this.api = api;
    };
    SliderTimelineView2.prototype.render = function(timelineModel, ecModel, api) {
      this.model = timelineModel;
      this.api = api;
      this.ecModel = ecModel;
      this.group.removeAll();
      if (timelineModel.get("show", true)) {
        var layoutInfo_1 = this._layout(timelineModel, api);
        var mainGroup_1 = this._createGroup("_mainGroup");
        var labelGroup = this._createGroup("_labelGroup");
        var axis_1 = this._axis = this._createAxis(layoutInfo_1, timelineModel);
        timelineModel.formatTooltip = function(dataIndex) {
          var name = axis_1.scale.getLabel({
            value: dataIndex
          });
          return createTooltipMarkup("nameValue", {
            noName: true,
            value: name
          });
        };
        each(["AxisLine", "AxisTick", "Control", "CurrentPointer"], function(name) {
          this["_render" + name](layoutInfo_1, mainGroup_1, axis_1, timelineModel);
        }, this);
        this._renderAxisLabel(layoutInfo_1, labelGroup, axis_1, timelineModel);
        this._position(layoutInfo_1, timelineModel);
      }
      this._doPlayStop();
      this._updateTicksStatus();
    };
    SliderTimelineView2.prototype.remove = function() {
      this._clearTimer();
      this.group.removeAll();
    };
    SliderTimelineView2.prototype.dispose = function() {
      this._clearTimer();
    };
    SliderTimelineView2.prototype._layout = function(timelineModel, api) {
      var labelPosOpt = timelineModel.get(["label", "position"]);
      var orient = timelineModel.get("orient");
      var viewRect2 = getViewRect6(timelineModel, api);
      var parsedLabelPos;
      if (labelPosOpt == null || labelPosOpt === "auto") {
        parsedLabelPos = orient === "horizontal" ? viewRect2.y + viewRect2.height / 2 < api.getHeight() / 2 ? "-" : "+" : viewRect2.x + viewRect2.width / 2 < api.getWidth() / 2 ? "+" : "-";
      } else if (isString(labelPosOpt)) {
        parsedLabelPos = {
          horizontal: {
            top: "-",
            bottom: "+"
          },
          vertical: {
            left: "-",
            right: "+"
          }
        }[orient][labelPosOpt];
      } else {
        parsedLabelPos = labelPosOpt;
      }
      var labelAlignMap = {
        horizontal: "center",
        vertical: parsedLabelPos >= 0 || parsedLabelPos === "+" ? "left" : "right"
      };
      var labelBaselineMap = {
        horizontal: parsedLabelPos >= 0 || parsedLabelPos === "+" ? "top" : "bottom",
        vertical: "middle"
      };
      var rotationMap = {
        horizontal: 0,
        vertical: PI10 / 2
      };
      var mainLength = orient === "vertical" ? viewRect2.height : viewRect2.width;
      var controlModel = timelineModel.getModel("controlStyle");
      var showControl = controlModel.get("show", true);
      var controlSize = showControl ? controlModel.get("itemSize") : 0;
      var controlGap = showControl ? controlModel.get("itemGap") : 0;
      var sizePlusGap = controlSize + controlGap;
      var labelRotation = timelineModel.get(["label", "rotate"]) || 0;
      labelRotation = labelRotation * PI10 / 180;
      var playPosition;
      var prevBtnPosition;
      var nextBtnPosition;
      var controlPosition = controlModel.get("position", true);
      var showPlayBtn = showControl && controlModel.get("showPlayBtn", true);
      var showPrevBtn = showControl && controlModel.get("showPrevBtn", true);
      var showNextBtn = showControl && controlModel.get("showNextBtn", true);
      var xLeft = 0;
      var xRight = mainLength;
      if (controlPosition === "left" || controlPosition === "bottom") {
        showPlayBtn && (playPosition = [0, 0], xLeft += sizePlusGap);
        showPrevBtn && (prevBtnPosition = [xLeft, 0], xLeft += sizePlusGap);
        showNextBtn && (nextBtnPosition = [xRight - controlSize, 0], xRight -= sizePlusGap);
      } else {
        showPlayBtn && (playPosition = [xRight - controlSize, 0], xRight -= sizePlusGap);
        showPrevBtn && (prevBtnPosition = [0, 0], xLeft += sizePlusGap);
        showNextBtn && (nextBtnPosition = [xRight - controlSize, 0], xRight -= sizePlusGap);
      }
      var axisExtent = [xLeft, xRight];
      if (timelineModel.get("inverse")) {
        axisExtent.reverse();
      }
      return {
        viewRect: viewRect2,
        mainLength,
        orient,
        rotation: rotationMap[orient],
        labelRotation,
        labelPosOpt: parsedLabelPos,
        labelAlign: timelineModel.get(["label", "align"]) || labelAlignMap[orient],
        labelBaseline: timelineModel.get(["label", "verticalAlign"]) || timelineModel.get(["label", "baseline"]) || labelBaselineMap[orient],
        playPosition,
        prevBtnPosition,
        nextBtnPosition,
        axisExtent,
        controlSize,
        controlGap
      };
    };
    SliderTimelineView2.prototype._position = function(layoutInfo, timelineModel) {
      var mainGroup = this._mainGroup;
      var labelGroup = this._labelGroup;
      var viewRect2 = layoutInfo.viewRect;
      if (layoutInfo.orient === "vertical") {
        var m2 = create2();
        var rotateOriginX = viewRect2.x;
        var rotateOriginY = viewRect2.y + viewRect2.height;
        translate(m2, m2, [-rotateOriginX, -rotateOriginY]);
        rotate(m2, m2, -PI10 / 2);
        translate(m2, m2, [rotateOriginX, rotateOriginY]);
        viewRect2 = viewRect2.clone();
        viewRect2.applyTransform(m2);
      }
      var viewBound = getBound(viewRect2);
      var mainBound = getBound(mainGroup.getBoundingRect());
      var labelBound = getBound(labelGroup.getBoundingRect());
      var mainPosition = [mainGroup.x, mainGroup.y];
      var labelsPosition = [labelGroup.x, labelGroup.y];
      labelsPosition[0] = mainPosition[0] = viewBound[0][0];
      var labelPosOpt = layoutInfo.labelPosOpt;
      if (labelPosOpt == null || isString(labelPosOpt)) {
        var mainBoundIdx = labelPosOpt === "+" ? 0 : 1;
        toBound(mainPosition, mainBound, viewBound, 1, mainBoundIdx);
        toBound(labelsPosition, labelBound, viewBound, 1, 1 - mainBoundIdx);
      } else {
        var mainBoundIdx = labelPosOpt >= 0 ? 0 : 1;
        toBound(mainPosition, mainBound, viewBound, 1, mainBoundIdx);
        labelsPosition[1] = mainPosition[1] + labelPosOpt;
      }
      mainGroup.setPosition(mainPosition);
      labelGroup.setPosition(labelsPosition);
      mainGroup.rotation = labelGroup.rotation = layoutInfo.rotation;
      setOrigin(mainGroup);
      setOrigin(labelGroup);
      function setOrigin(targetGroup) {
        targetGroup.originX = viewBound[0][0] - targetGroup.x;
        targetGroup.originY = viewBound[1][0] - targetGroup.y;
      }
      function getBound(rect) {
        return [[rect.x, rect.x + rect.width], [rect.y, rect.y + rect.height]];
      }
      function toBound(fromPos, from, to, dimIdx, boundIdx) {
        fromPos[dimIdx] += to[dimIdx][boundIdx] - from[dimIdx][boundIdx];
      }
    };
    SliderTimelineView2.prototype._createAxis = function(layoutInfo, timelineModel) {
      var data = timelineModel.getData();
      var axisType = timelineModel.get("axisType");
      var scale4 = createScaleByModel2(timelineModel, axisType);
      scale4.getTicks = function() {
        return data.mapArray(["value"], function(value) {
          return {
            value
          };
        });
      };
      var dataExtent = data.getDataExtent("value");
      scale4.setExtent(dataExtent[0], dataExtent[1]);
      scale4.calcNiceTicks();
      var axis = new TimelineAxis_default("value", scale4, layoutInfo.axisExtent, axisType);
      axis.model = timelineModel;
      return axis;
    };
    SliderTimelineView2.prototype._createGroup = function(key) {
      var newGroup = this[key] = new Group_default();
      this.group.add(newGroup);
      return newGroup;
    };
    SliderTimelineView2.prototype._renderAxisLine = function(layoutInfo, group, axis, timelineModel) {
      var axisExtent = axis.getExtent();
      if (!timelineModel.get(["lineStyle", "show"])) {
        return;
      }
      var line = new Line_default({
        shape: {
          x1: axisExtent[0],
          y1: 0,
          x2: axisExtent[1],
          y2: 0
        },
        style: extend({
          lineCap: "round"
        }, timelineModel.getModel("lineStyle").getLineStyle()),
        silent: true,
        z2: 1
      });
      group.add(line);
      var progressLine = this._progressLine = new Line_default({
        shape: {
          x1: axisExtent[0],
          x2: this._currentPointer ? this._currentPointer.x : axisExtent[0],
          y1: 0,
          y2: 0
        },
        style: defaults({
          lineCap: "round",
          lineWidth: line.style.lineWidth
        }, timelineModel.getModel(["progress", "lineStyle"]).getLineStyle()),
        silent: true,
        z2: 1
      });
      group.add(progressLine);
    };
    SliderTimelineView2.prototype._renderAxisTick = function(layoutInfo, group, axis, timelineModel) {
      var _this = this;
      var data = timelineModel.getData();
      var ticks = axis.scale.getTicks();
      this._tickSymbols = [];
      each(ticks, function(tick) {
        var tickCoord = axis.dataToCoord(tick.value);
        var itemModel = data.getItemModel(tick.value);
        var itemStyleModel = itemModel.getModel("itemStyle");
        var hoverStyleModel = itemModel.getModel(["emphasis", "itemStyle"]);
        var progressStyleModel = itemModel.getModel(["progress", "itemStyle"]);
        var symbolOpt = {
          x: tickCoord,
          y: 0,
          onclick: bind(_this._changeTimeline, _this, tick.value)
        };
        var el = giveSymbol(itemModel, itemStyleModel, group, symbolOpt);
        el.ensureState("emphasis").style = hoverStyleModel.getItemStyle();
        el.ensureState("progress").style = progressStyleModel.getItemStyle();
        enableHoverEmphasis(el);
        var ecData = getECData(el);
        if (itemModel.get("tooltip")) {
          ecData.dataIndex = tick.value;
          ecData.dataModel = timelineModel;
        } else {
          ecData.dataIndex = ecData.dataModel = null;
        }
        _this._tickSymbols.push(el);
      });
    };
    SliderTimelineView2.prototype._renderAxisLabel = function(layoutInfo, group, axis, timelineModel) {
      var _this = this;
      var labelModel = axis.getLabelModel();
      if (!labelModel.get("show")) {
        return;
      }
      var data = timelineModel.getData();
      var labels = axis.getViewLabels();
      this._tickLabels = [];
      each(labels, function(labelItem) {
        var dataIndex = labelItem.tickValue;
        var itemModel = data.getItemModel(dataIndex);
        var normalLabelModel = itemModel.getModel("label");
        var hoverLabelModel = itemModel.getModel(["emphasis", "label"]);
        var progressLabelModel = itemModel.getModel(["progress", "label"]);
        var tickCoord = axis.dataToCoord(labelItem.tickValue);
        var textEl = new Text_default({
          x: tickCoord,
          y: 0,
          rotation: layoutInfo.labelRotation - layoutInfo.rotation,
          onclick: bind(_this._changeTimeline, _this, dataIndex),
          silent: false,
          style: createTextStyle(normalLabelModel, {
            text: labelItem.formattedLabel,
            align: layoutInfo.labelAlign,
            verticalAlign: layoutInfo.labelBaseline
          })
        });
        textEl.ensureState("emphasis").style = createTextStyle(hoverLabelModel);
        textEl.ensureState("progress").style = createTextStyle(progressLabelModel);
        group.add(textEl);
        enableHoverEmphasis(textEl);
        labelDataIndexStore(textEl).dataIndex = dataIndex;
        _this._tickLabels.push(textEl);
      });
    };
    SliderTimelineView2.prototype._renderControl = function(layoutInfo, group, axis, timelineModel) {
      var controlSize = layoutInfo.controlSize;
      var rotation = layoutInfo.rotation;
      var itemStyle = timelineModel.getModel("controlStyle").getItemStyle();
      var hoverStyle = timelineModel.getModel(["emphasis", "controlStyle"]).getItemStyle();
      var playState = timelineModel.getPlayState();
      var inverse = timelineModel.get("inverse", true);
      makeBtn(layoutInfo.nextBtnPosition, "next", bind(this._changeTimeline, this, inverse ? "-" : "+"));
      makeBtn(layoutInfo.prevBtnPosition, "prev", bind(this._changeTimeline, this, inverse ? "+" : "-"));
      makeBtn(layoutInfo.playPosition, playState ? "stop" : "play", bind(this._handlePlayClick, this, !playState), true);
      function makeBtn(position2, iconName, onclick, willRotate) {
        if (!position2) {
          return;
        }
        var iconSize = parsePercent(retrieve2(timelineModel.get(["controlStyle", iconName + "BtnSize"]), controlSize), controlSize);
        var rect = [0, -iconSize / 2, iconSize, iconSize];
        var btn = makeControlIcon(timelineModel, iconName + "Icon", rect, {
          x: position2[0],
          y: position2[1],
          originX: controlSize / 2,
          originY: 0,
          rotation: willRotate ? -rotation : 0,
          rectHover: true,
          style: itemStyle,
          onclick
        });
        btn.ensureState("emphasis").style = hoverStyle;
        group.add(btn);
        enableHoverEmphasis(btn);
      }
    };
    SliderTimelineView2.prototype._renderCurrentPointer = function(layoutInfo, group, axis, timelineModel) {
      var data = timelineModel.getData();
      var currentIndex = timelineModel.getCurrentIndex();
      var pointerModel = data.getItemModel(currentIndex).getModel("checkpointStyle");
      var me = this;
      var callback = {
        onCreate: function(pointer) {
          pointer.draggable = true;
          pointer.drift = bind(me._handlePointerDrag, me);
          pointer.ondragend = bind(me._handlePointerDragend, me);
          pointerMoveTo(pointer, me._progressLine, currentIndex, axis, timelineModel, true);
        },
        onUpdate: function(pointer) {
          pointerMoveTo(pointer, me._progressLine, currentIndex, axis, timelineModel);
        }
      };
      this._currentPointer = giveSymbol(pointerModel, pointerModel, this._mainGroup, {}, this._currentPointer, callback);
    };
    SliderTimelineView2.prototype._handlePlayClick = function(nextState) {
      this._clearTimer();
      this.api.dispatchAction({
        type: "timelinePlayChange",
        playState: nextState,
        from: this.uid
      });
    };
    SliderTimelineView2.prototype._handlePointerDrag = function(dx, dy, e2) {
      this._clearTimer();
      this._pointerChangeTimeline([e2.offsetX, e2.offsetY]);
    };
    SliderTimelineView2.prototype._handlePointerDragend = function(e2) {
      this._pointerChangeTimeline([e2.offsetX, e2.offsetY], true);
    };
    SliderTimelineView2.prototype._pointerChangeTimeline = function(mousePos, trigger3) {
      var toCoord = this._toAxisCoord(mousePos)[0];
      var axis = this._axis;
      var axisExtent = asc(axis.getExtent().slice());
      toCoord > axisExtent[1] && (toCoord = axisExtent[1]);
      toCoord < axisExtent[0] && (toCoord = axisExtent[0]);
      this._currentPointer.x = toCoord;
      this._currentPointer.markRedraw();
      this._progressLine.shape.x2 = toCoord;
      this._progressLine.dirty();
      var targetDataIndex = this._findNearestTick(toCoord);
      var timelineModel = this.model;
      if (trigger3 || targetDataIndex !== timelineModel.getCurrentIndex() && timelineModel.get("realtime")) {
        this._changeTimeline(targetDataIndex);
      }
    };
    SliderTimelineView2.prototype._doPlayStop = function() {
      var _this = this;
      this._clearTimer();
      if (this.model.getPlayState()) {
        this._timer = setTimeout(function() {
          var timelineModel = _this.model;
          _this._changeTimeline(timelineModel.getCurrentIndex() + (timelineModel.get("rewind", true) ? -1 : 1));
        }, this.model.get("playInterval"));
      }
    };
    SliderTimelineView2.prototype._toAxisCoord = function(vertex) {
      var trans = this._mainGroup.getLocalTransform();
      return applyTransform2(vertex, trans, true);
    };
    SliderTimelineView2.prototype._findNearestTick = function(axisCoord) {
      var data = this.model.getData();
      var dist3 = Infinity;
      var targetDataIndex;
      var axis = this._axis;
      data.each(["value"], function(value, dataIndex) {
        var coord = axis.dataToCoord(value);
        var d = Math.abs(coord - axisCoord);
        if (d < dist3) {
          dist3 = d;
          targetDataIndex = dataIndex;
        }
      });
      return targetDataIndex;
    };
    SliderTimelineView2.prototype._clearTimer = function() {
      if (this._timer) {
        clearTimeout(this._timer);
        this._timer = null;
      }
    };
    SliderTimelineView2.prototype._changeTimeline = function(nextIndex) {
      var currentIndex = this.model.getCurrentIndex();
      if (nextIndex === "+") {
        nextIndex = currentIndex + 1;
      } else if (nextIndex === "-") {
        nextIndex = currentIndex - 1;
      }
      this.api.dispatchAction({
        type: "timelineChange",
        currentIndex: nextIndex,
        from: this.uid
      });
    };
    SliderTimelineView2.prototype._updateTicksStatus = function() {
      var currentIndex = this.model.getCurrentIndex();
      var tickSymbols = this._tickSymbols;
      var tickLabels = this._tickLabels;
      if (tickSymbols) {
        for (var i = 0; i < tickSymbols.length; i++) {
          tickSymbols && tickSymbols[i] && tickSymbols[i].toggleState("progress", i < currentIndex);
        }
      }
      if (tickLabels) {
        for (var i = 0; i < tickLabels.length; i++) {
          tickLabels && tickLabels[i] && tickLabels[i].toggleState("progress", labelDataIndexStore(tickLabels[i]).dataIndex <= currentIndex);
        }
      }
    };
    SliderTimelineView2.type = "timeline.slider";
    return SliderTimelineView2;
  }(TimelineView_default);
  function createScaleByModel2(model, axisType) {
    axisType = axisType || model.get("type");
    if (axisType) {
      switch (axisType) {
        case "category":
          return new Ordinal_default({
            ordinalMeta: model.getCategories(),
            extent: [Infinity, -Infinity]
          });
        case "time":
          return new Time_default({
            locale: model.ecModel.getLocaleModel(),
            useUTC: model.ecModel.get("useUTC")
          });
        default:
          return new Interval_default();
      }
    }
  }
  function getViewRect6(model, api) {
    return getLayoutRect(model.getBoxLayoutParams(), {
      width: api.getWidth(),
      height: api.getHeight()
    }, model.get("padding"));
  }
  function makeControlIcon(timelineModel, objPath, rect, opts) {
    var style = opts.style;
    var icon = createIcon(timelineModel.get(["controlStyle", objPath]), opts || {}, new BoundingRect_default(rect[0], rect[1], rect[2], rect[3]));
    if (style) {
      icon.setStyle(style);
    }
    return icon;
  }
  function giveSymbol(hostModel, itemStyleModel, group, opt, symbol, callback) {
    var color = itemStyleModel.get("color");
    if (!symbol) {
      var symbolType = hostModel.get("symbol");
      symbol = createSymbol(symbolType, -1, -1, 2, 2, color);
      symbol.setStyle("strokeNoScale", true);
      group.add(symbol);
      callback && callback.onCreate(symbol);
    } else {
      symbol.setColor(color);
      group.add(symbol);
      callback && callback.onUpdate(symbol);
    }
    var itemStyle = itemStyleModel.getItemStyle(["color"]);
    symbol.setStyle(itemStyle);
    opt = merge({
      rectHover: true,
      z2: 100
    }, opt, true);
    var symbolSize = normalizeSymbolSize(hostModel.get("symbolSize"));
    opt.scaleX = symbolSize[0] / 2;
    opt.scaleY = symbolSize[1] / 2;
    var symbolOffset = normalizeSymbolOffset(hostModel.get("symbolOffset"), symbolSize);
    if (symbolOffset) {
      opt.x = (opt.x || 0) + symbolOffset[0];
      opt.y = (opt.y || 0) + symbolOffset[1];
    }
    var symbolRotate = hostModel.get("symbolRotate");
    opt.rotation = (symbolRotate || 0) * Math.PI / 180 || 0;
    symbol.attr(opt);
    symbol.updateTransform();
    return symbol;
  }
  function pointerMoveTo(pointer, progressLine, dataIndex, axis, timelineModel, noAnimation) {
    if (pointer.dragging) {
      return;
    }
    var pointerModel = timelineModel.getModel("checkpointStyle");
    var toCoord = axis.dataToCoord(timelineModel.getData().get("value", dataIndex));
    if (noAnimation || !pointerModel.get("animation", true)) {
      pointer.attr({
        x: toCoord,
        y: 0
      });
      progressLine && progressLine.attr({
        shape: {
          x2: toCoord
        }
      });
    } else {
      var animationCfg = {
        duration: pointerModel.get("animationDuration", true),
        easing: pointerModel.get("animationEasing", true)
      };
      pointer.stopAnimation(null, true);
      pointer.animateTo({
        x: toCoord,
        y: 0
      }, animationCfg);
      progressLine && progressLine.animateTo({
        shape: {
          x2: toCoord
        }
      }, animationCfg);
    }
  }
  var SliderTimelineView_default = SliderTimelineView;

  // node_modules/echarts/lib/component/timeline/timelineAction.js
  function installTimelineAction(registers) {
    registers.registerAction({
      type: "timelineChange",
      event: "timelineChanged",
      update: "prepareAndUpdate"
    }, function(payload, ecModel, api) {
      var timelineModel = ecModel.getComponent("timeline");
      if (timelineModel && payload.currentIndex != null) {
        timelineModel.setCurrentIndex(payload.currentIndex);
        if (!timelineModel.get("loop", true) && timelineModel.isIndexMax() && timelineModel.getPlayState()) {
          timelineModel.setPlayState(false);
          api.dispatchAction({
            type: "timelinePlayChange",
            playState: false,
            from: payload.from
          });
        }
      }
      ecModel.resetOption("timeline", {
        replaceMerge: timelineModel.get("replaceMerge", true)
      });
      return defaults({
        currentIndex: timelineModel.option.currentIndex
      }, payload);
    });
    registers.registerAction({
      type: "timelinePlayChange",
      event: "timelinePlayChanged",
      update: "update"
    }, function(payload, ecModel) {
      var timelineModel = ecModel.getComponent("timeline");
      if (timelineModel && payload.playState != null) {
        timelineModel.setPlayState(payload.playState);
      }
    });
  }

  // node_modules/echarts/lib/component/timeline/preprocessor.js
  function timelinePreprocessor(option) {
    var timelineOpt = option && option.timeline;
    if (!isArray(timelineOpt)) {
      timelineOpt = timelineOpt ? [timelineOpt] : [];
    }
    each(timelineOpt, function(opt) {
      if (!opt) {
        return;
      }
      compatibleEC2(opt);
    });
  }
  function compatibleEC2(opt) {
    var type = opt.type;
    var ec2Types = {
      "number": "value",
      "time": "time"
    };
    if (ec2Types[type]) {
      opt.axisType = ec2Types[type];
      delete opt.type;
    }
    transferItem(opt);
    if (has(opt, "controlPosition")) {
      var controlStyle = opt.controlStyle || (opt.controlStyle = {});
      if (!has(controlStyle, "position")) {
        controlStyle.position = opt.controlPosition;
      }
      if (controlStyle.position === "none" && !has(controlStyle, "show")) {
        controlStyle.show = false;
        delete controlStyle.position;
      }
      delete opt.controlPosition;
    }
    each(opt.data || [], function(dataItem) {
      if (isObject(dataItem) && !isArray(dataItem)) {
        if (!has(dataItem, "value") && has(dataItem, "name")) {
          dataItem.value = dataItem.name;
        }
        transferItem(dataItem);
      }
    });
  }
  function transferItem(opt) {
    var itemStyle = opt.itemStyle || (opt.itemStyle = {});
    var itemStyleEmphasis = itemStyle.emphasis || (itemStyle.emphasis = {});
    var label = opt.label || opt.label || {};
    var labelNormal = label.normal || (label.normal = {});
    var excludeLabelAttr = {
      normal: 1,
      emphasis: 1
    };
    each(label, function(value, name) {
      if (!excludeLabelAttr[name] && !has(labelNormal, name)) {
        labelNormal[name] = value;
      }
    });
    if (itemStyleEmphasis.label && !has(label, "emphasis")) {
      label.emphasis = itemStyleEmphasis.label;
      delete itemStyleEmphasis.label;
    }
  }
  function has(obj, attr) {
    return obj.hasOwnProperty(attr);
  }

  // node_modules/echarts/lib/component/timeline/install.js
  function install40(registers) {
    registers.registerComponentModel(SliderTimelineModel_default);
    registers.registerComponentView(SliderTimelineView_default);
    registers.registerSubTypeDefaulter("timeline", function() {
      return "slider";
    });
    installTimelineAction(registers);
    registers.registerPreprocessor(timelinePreprocessor);
  }

  // node_modules/echarts/lib/component/marker/checkMarkerInSeries.js
  function checkMarkerInSeries(seriesOpts, markerType) {
    if (!seriesOpts) {
      return false;
    }
    var seriesOptArr = isArray(seriesOpts) ? seriesOpts : [seriesOpts];
    for (var idx = 0; idx < seriesOptArr.length; idx++) {
      if (seriesOptArr[idx] && seriesOptArr[idx][markerType]) {
        return true;
      }
    }
    return false;
  }

  // node_modules/echarts/lib/component/marker/MarkerModel.js
  function fillLabel(opt) {
    defaultEmphasis(opt, "label", ["show"]);
  }
  var inner17 = makeInner();
  var MarkerModel = function(_super) {
    __extends(MarkerModel2, _super);
    function MarkerModel2() {
      var _this = _super !== null && _super.apply(this, arguments) || this;
      _this.type = MarkerModel2.type;
      _this.createdBySelf = false;
      return _this;
    }
    MarkerModel2.prototype.init = function(option, parentModel, ecModel) {
      if (true) {
        if (this.type === "marker") {
          throw new Error("Marker component is abstract component. Use markLine, markPoint, markArea instead.");
        }
      }
      this.mergeDefaultAndTheme(option, ecModel);
      this._mergeOption(option, ecModel, false, true);
    };
    MarkerModel2.prototype.isAnimationEnabled = function() {
      if (env_default.node) {
        return false;
      }
      var hostSeries = this.__hostSeries;
      return this.getShallow("animation") && hostSeries && hostSeries.isAnimationEnabled();
    };
    MarkerModel2.prototype.mergeOption = function(newOpt, ecModel) {
      this._mergeOption(newOpt, ecModel, false, false);
    };
    MarkerModel2.prototype._mergeOption = function(newOpt, ecModel, createdBySelf, isInit) {
      var componentType = this.mainType;
      if (!createdBySelf) {
        ecModel.eachSeries(function(seriesModel) {
          var markerOpt = seriesModel.get(this.mainType, true);
          var markerModel = inner17(seriesModel)[componentType];
          if (!markerOpt || !markerOpt.data) {
            inner17(seriesModel)[componentType] = null;
            return;
          }
          if (!markerModel) {
            if (isInit) {
              fillLabel(markerOpt);
            }
            each(markerOpt.data, function(item) {
              if (item instanceof Array) {
                fillLabel(item[0]);
                fillLabel(item[1]);
              } else {
                fillLabel(item);
              }
            });
            markerModel = this.createMarkerModelFromSeries(markerOpt, this, ecModel);
            extend(markerModel, {
              mainType: this.mainType,
              seriesIndex: seriesModel.seriesIndex,
              name: seriesModel.name,
              createdBySelf: true
            });
            markerModel.__hostSeries = seriesModel;
          } else {
            markerModel._mergeOption(markerOpt, ecModel, true);
          }
          inner17(seriesModel)[componentType] = markerModel;
        }, this);
      }
    };
    MarkerModel2.prototype.formatTooltip = function(dataIndex, multipleSeries, dataType) {
      var data = this.getData();
      var value = this.getRawValue(dataIndex);
      var itemName = data.getName(dataIndex);
      return createTooltipMarkup("section", {
        header: this.name,
        blocks: [createTooltipMarkup("nameValue", {
          name: itemName,
          value,
          noName: !itemName,
          noValue: value == null
        })]
      });
    };
    MarkerModel2.prototype.getData = function() {
      return this._data;
    };
    MarkerModel2.prototype.setData = function(data) {
      this._data = data;
    };
    MarkerModel2.getMarkerModelFromSeries = function(seriesModel, componentType) {
      return inner17(seriesModel)[componentType];
    };
    MarkerModel2.type = "marker";
    MarkerModel2.dependencies = ["series", "grid", "polar", "geo"];
    return MarkerModel2;
  }(Component_default);
  mixin(MarkerModel, DataFormatMixin.prototype);
  var MarkerModel_default = MarkerModel;

  // node_modules/echarts/lib/component/marker/MarkPointModel.js
  var MarkPointModel = function(_super) {
    __extends(MarkPointModel2, _super);
    function MarkPointModel2() {
      var _this = _super !== null && _super.apply(this, arguments) || this;
      _this.type = MarkPointModel2.type;
      return _this;
    }
    MarkPointModel2.prototype.createMarkerModelFromSeries = function(markerOpt, masterMarkerModel, ecModel) {
      return new MarkPointModel2(markerOpt, masterMarkerModel, ecModel);
    };
    MarkPointModel2.type = "markPoint";
    MarkPointModel2.defaultOption = {
      z: 5,
      symbol: "pin",
      symbolSize: 50,
      tooltip: {
        trigger: "item"
      },
      label: {
        show: true,
        position: "inside"
      },
      itemStyle: {
        borderWidth: 2
      },
      emphasis: {
        label: {
          show: true
        }
      }
    };
    return MarkPointModel2;
  }(MarkerModel_default);
  var MarkPointModel_default = MarkPointModel;

  // node_modules/echarts/lib/component/marker/markerHelper.js
  function hasXOrY(item) {
    return !(isNaN(parseFloat(item.x)) && isNaN(parseFloat(item.y)));
  }
  function hasXAndY(item) {
    return !isNaN(parseFloat(item.x)) && !isNaN(parseFloat(item.y));
  }
  function markerTypeCalculatorWithExtent(markerType, data, otherDataDim, targetDataDim, otherCoordIndex, targetCoordIndex) {
    var coordArr = [];
    var stacked = isDimensionStacked(data, targetDataDim);
    var calcDataDim = stacked ? data.getCalculationInfo("stackResultDimension") : targetDataDim;
    var value = numCalculate(data, calcDataDim, markerType);
    var dataIndex = data.indicesOfNearest(calcDataDim, value)[0];
    coordArr[otherCoordIndex] = data.get(otherDataDim, dataIndex);
    coordArr[targetCoordIndex] = data.get(calcDataDim, dataIndex);
    var coordArrValue = data.get(targetDataDim, dataIndex);
    var precision = getPrecision(data.get(targetDataDim, dataIndex));
    precision = Math.min(precision, 20);
    if (precision >= 0) {
      coordArr[targetCoordIndex] = +coordArr[targetCoordIndex].toFixed(precision);
    }
    return [coordArr, coordArrValue];
  }
  var markerTypeCalculator = {
    min: curry(markerTypeCalculatorWithExtent, "min"),
    max: curry(markerTypeCalculatorWithExtent, "max"),
    average: curry(markerTypeCalculatorWithExtent, "average"),
    median: curry(markerTypeCalculatorWithExtent, "median")
  };
  function dataTransform(seriesModel, item) {
    var data = seriesModel.getData();
    var coordSys = seriesModel.coordinateSystem;
    if (item && !hasXAndY(item) && !isArray(item.coord) && coordSys) {
      var dims = coordSys.dimensions;
      var axisInfo = getAxisInfo2(item, data, coordSys, seriesModel);
      item = clone(item);
      if (item.type && markerTypeCalculator[item.type] && axisInfo.baseAxis && axisInfo.valueAxis) {
        var otherCoordIndex = indexOf(dims, axisInfo.baseAxis.dim);
        var targetCoordIndex = indexOf(dims, axisInfo.valueAxis.dim);
        var coordInfo = markerTypeCalculator[item.type](data, axisInfo.baseDataDim, axisInfo.valueDataDim, otherCoordIndex, targetCoordIndex);
        item.coord = coordInfo[0];
        item.value = coordInfo[1];
      } else {
        var coord = [item.xAxis != null ? item.xAxis : item.radiusAxis, item.yAxis != null ? item.yAxis : item.angleAxis];
        for (var i = 0; i < 2; i++) {
          if (markerTypeCalculator[coord[i]]) {
            coord[i] = numCalculate(data, data.mapDimension(dims[i]), coord[i]);
          }
        }
        item.coord = coord;
      }
    }
    return item;
  }
  function getAxisInfo2(item, data, coordSys, seriesModel) {
    var ret = {};
    if (item.valueIndex != null || item.valueDim != null) {
      ret.valueDataDim = item.valueIndex != null ? data.getDimension(item.valueIndex) : item.valueDim;
      ret.valueAxis = coordSys.getAxis(dataDimToCoordDim(seriesModel, ret.valueDataDim));
      ret.baseAxis = coordSys.getOtherAxis(ret.valueAxis);
      ret.baseDataDim = data.mapDimension(ret.baseAxis.dim);
    } else {
      ret.baseAxis = seriesModel.getBaseAxis();
      ret.valueAxis = coordSys.getOtherAxis(ret.baseAxis);
      ret.baseDataDim = data.mapDimension(ret.baseAxis.dim);
      ret.valueDataDim = data.mapDimension(ret.valueAxis.dim);
    }
    return ret;
  }
  function dataDimToCoordDim(seriesModel, dataDim) {
    var dimItem = seriesModel.getData().getDimensionInfo(dataDim);
    return dimItem && dimItem.coordDim;
  }
  function dataFilter2(coordSys, item) {
    return coordSys && coordSys.containData && item.coord && !hasXOrY(item) ? coordSys.containData(item.coord) : true;
  }
  function zoneFilter(coordSys, item1, item2) {
    return coordSys && coordSys.containZone && item1.coord && item2.coord && !hasXOrY(item1) && !hasXOrY(item2) ? coordSys.containZone(item1.coord, item2.coord) : true;
  }
  function createMarkerDimValueGetter(inCoordSys, dims) {
    return inCoordSys ? function(item, dimName, dataIndex, dimIndex) {
      var rawVal = dimIndex < 2 ? item.coord && item.coord[dimIndex] : item.value;
      return parseDataValue(rawVal, dims[dimIndex]);
    } : function(item, dimName, dataIndex, dimIndex) {
      return parseDataValue(item.value, dims[dimIndex]);
    };
  }
  function numCalculate(data, valueDataDim, type) {
    if (type === "average") {
      var sum_1 = 0;
      var count_1 = 0;
      data.each(valueDataDim, function(val, idx) {
        if (!isNaN(val)) {
          sum_1 += val;
          count_1++;
        }
      });
      return sum_1 / count_1;
    } else if (type === "median") {
      return data.getMedian(valueDataDim);
    } else {
      return data.getDataExtent(valueDataDim)[type === "max" ? 1 : 0];
    }
  }

  // node_modules/echarts/lib/component/marker/MarkerView.js
  var inner18 = makeInner();
  var MarkerView = function(_super) {
    __extends(MarkerView2, _super);
    function MarkerView2() {
      var _this = _super !== null && _super.apply(this, arguments) || this;
      _this.type = MarkerView2.type;
      return _this;
    }
    MarkerView2.prototype.init = function() {
      this.markerGroupMap = createHashMap();
    };
    MarkerView2.prototype.render = function(markerModel, ecModel, api) {
      var _this = this;
      var markerGroupMap = this.markerGroupMap;
      markerGroupMap.each(function(item) {
        inner18(item).keep = false;
      });
      ecModel.eachSeries(function(seriesModel) {
        var markerModel2 = MarkerModel_default.getMarkerModelFromSeries(seriesModel, _this.type);
        markerModel2 && _this.renderSeries(seriesModel, markerModel2, ecModel, api);
      });
      markerGroupMap.each(function(item) {
        !inner18(item).keep && _this.group.remove(item.group);
      });
    };
    MarkerView2.prototype.markKeep = function(drawGroup) {
      inner18(drawGroup).keep = true;
    };
    MarkerView2.prototype.toggleBlurSeries = function(seriesModelList, isBlur) {
      var _this = this;
      each(seriesModelList, function(seriesModel) {
        var markerModel = MarkerModel_default.getMarkerModelFromSeries(seriesModel, _this.type);
        if (markerModel) {
          var data = markerModel.getData();
          data.eachItemGraphicEl(function(el) {
            if (el) {
              isBlur ? enterBlur(el) : leaveBlur(el);
            }
          });
        }
      });
    };
    MarkerView2.type = "marker";
    return MarkerView2;
  }(Component_default2);
  var MarkerView_default = MarkerView;

  // node_modules/echarts/lib/component/marker/MarkPointView.js
  function updateMarkerLayout(mpData, seriesModel, api) {
    var coordSys = seriesModel.coordinateSystem;
    mpData.each(function(idx) {
      var itemModel = mpData.getItemModel(idx);
      var point;
      var xPx = parsePercent2(itemModel.get("x"), api.getWidth());
      var yPx = parsePercent2(itemModel.get("y"), api.getHeight());
      if (!isNaN(xPx) && !isNaN(yPx)) {
        point = [xPx, yPx];
      } else if (seriesModel.getMarkerPosition) {
        point = seriesModel.getMarkerPosition(mpData.getValues(mpData.dimensions, idx));
      } else if (coordSys) {
        var x = mpData.get(coordSys.dimensions[0], idx);
        var y = mpData.get(coordSys.dimensions[1], idx);
        point = coordSys.dataToPoint([x, y]);
      }
      if (!isNaN(xPx)) {
        point[0] = xPx;
      }
      if (!isNaN(yPx)) {
        point[1] = yPx;
      }
      mpData.setItemLayout(idx, point);
    });
  }
  var MarkPointView = function(_super) {
    __extends(MarkPointView2, _super);
    function MarkPointView2() {
      var _this = _super !== null && _super.apply(this, arguments) || this;
      _this.type = MarkPointView2.type;
      return _this;
    }
    MarkPointView2.prototype.updateTransform = function(markPointModel, ecModel, api) {
      ecModel.eachSeries(function(seriesModel) {
        var mpModel = MarkerModel_default.getMarkerModelFromSeries(seriesModel, "markPoint");
        if (mpModel) {
          updateMarkerLayout(mpModel.getData(), seriesModel, api);
          this.markerGroupMap.get(seriesModel.id).updateLayout();
        }
      }, this);
    };
    MarkPointView2.prototype.renderSeries = function(seriesModel, mpModel, ecModel, api) {
      var coordSys = seriesModel.coordinateSystem;
      var seriesId = seriesModel.id;
      var seriesData = seriesModel.getData();
      var symbolDrawMap = this.markerGroupMap;
      var symbolDraw = symbolDrawMap.get(seriesId) || symbolDrawMap.set(seriesId, new SymbolDraw_default());
      var mpData = createData(coordSys, seriesModel, mpModel);
      mpModel.setData(mpData);
      updateMarkerLayout(mpModel.getData(), seriesModel, api);
      mpData.each(function(idx) {
        var itemModel = mpData.getItemModel(idx);
        var symbol = itemModel.getShallow("symbol");
        var symbolSize = itemModel.getShallow("symbolSize");
        var symbolRotate = itemModel.getShallow("symbolRotate");
        var symbolOffset = itemModel.getShallow("symbolOffset");
        var symbolKeepAspect = itemModel.getShallow("symbolKeepAspect");
        if (isFunction(symbol) || isFunction(symbolSize) || isFunction(symbolRotate) || isFunction(symbolOffset)) {
          var rawIdx = mpModel.getRawValue(idx);
          var dataParams = mpModel.getDataParams(idx);
          if (isFunction(symbol)) {
            symbol = symbol(rawIdx, dataParams);
          }
          if (isFunction(symbolSize)) {
            symbolSize = symbolSize(rawIdx, dataParams);
          }
          if (isFunction(symbolRotate)) {
            symbolRotate = symbolRotate(rawIdx, dataParams);
          }
          if (isFunction(symbolOffset)) {
            symbolOffset = symbolOffset(rawIdx, dataParams);
          }
        }
        var style = itemModel.getModel("itemStyle").getItemStyle();
        var color = getVisualFromData(seriesData, "color");
        if (!style.fill) {
          style.fill = color;
        }
        mpData.setItemVisual(idx, {
          symbol,
          symbolSize,
          symbolRotate,
          symbolOffset,
          symbolKeepAspect,
          style
        });
      });
      symbolDraw.updateData(mpData);
      this.group.add(symbolDraw.group);
      mpData.eachItemGraphicEl(function(el) {
        el.traverse(function(child) {
          getECData(child).dataModel = mpModel;
        });
      });
      this.markKeep(symbolDraw);
      symbolDraw.group.silent = mpModel.get("silent") || seriesModel.get("silent");
    };
    MarkPointView2.type = "markPoint";
    return MarkPointView2;
  }(MarkerView_default);
  function createData(coordSys, seriesModel, mpModel) {
    var coordDimsInfos;
    if (coordSys) {
      coordDimsInfos = map(coordSys && coordSys.dimensions, function(coordDim) {
        var info = seriesModel.getData().getDimensionInfo(seriesModel.getData().mapDimension(coordDim)) || {};
        return extend(extend({}, info), {
          name: coordDim,
          ordinalMeta: null
        });
      });
    } else {
      coordDimsInfos = [{
        name: "value",
        type: "float"
      }];
    }
    var mpData = new SeriesData_default(coordDimsInfos, mpModel);
    var dataOpt = map(mpModel.get("data"), curry(dataTransform, seriesModel));
    if (coordSys) {
      dataOpt = filter(dataOpt, curry(dataFilter2, coordSys));
    }
    var dimValueGetter = createMarkerDimValueGetter(!!coordSys, coordDimsInfos);
    mpData.initData(dataOpt, null, dimValueGetter);
    return mpData;
  }
  var MarkPointView_default = MarkPointView;

  // node_modules/echarts/lib/component/marker/installMarkPoint.js
  function install41(registers) {
    registers.registerComponentModel(MarkPointModel_default);
    registers.registerComponentView(MarkPointView_default);
    registers.registerPreprocessor(function(opt) {
      if (checkMarkerInSeries(opt.series, "markPoint")) {
        opt.markPoint = opt.markPoint || {};
      }
    });
  }

  // node_modules/echarts/lib/component/marker/MarkLineModel.js
  var MarkLineModel = function(_super) {
    __extends(MarkLineModel2, _super);
    function MarkLineModel2() {
      var _this = _super !== null && _super.apply(this, arguments) || this;
      _this.type = MarkLineModel2.type;
      return _this;
    }
    MarkLineModel2.prototype.createMarkerModelFromSeries = function(markerOpt, masterMarkerModel, ecModel) {
      return new MarkLineModel2(markerOpt, masterMarkerModel, ecModel);
    };
    MarkLineModel2.type = "markLine";
    MarkLineModel2.defaultOption = {
      z: 5,
      symbol: ["circle", "arrow"],
      symbolSize: [8, 16],
      symbolOffset: 0,
      precision: 2,
      tooltip: {
        trigger: "item"
      },
      label: {
        show: true,
        position: "end",
        distance: 5
      },
      lineStyle: {
        type: "dashed"
      },
      emphasis: {
        label: {
          show: true
        },
        lineStyle: {
          width: 3
        }
      },
      animationEasing: "linear"
    };
    return MarkLineModel2;
  }(MarkerModel_default);
  var MarkLineModel_default = MarkLineModel;

  // node_modules/echarts/lib/component/marker/MarkLineView.js
  var inner19 = makeInner();
  var markLineTransform = function(seriesModel, coordSys, mlModel, item) {
    var data = seriesModel.getData();
    var itemArray;
    if (!isArray(item)) {
      var mlType = item.type;
      if (mlType === "min" || mlType === "max" || mlType === "average" || mlType === "median" || item.xAxis != null || item.yAxis != null) {
        var valueAxis2 = void 0;
        var value = void 0;
        if (item.yAxis != null || item.xAxis != null) {
          valueAxis2 = coordSys.getAxis(item.yAxis != null ? "y" : "x");
          value = retrieve(item.yAxis, item.xAxis);
        } else {
          var axisInfo = getAxisInfo2(item, data, coordSys, seriesModel);
          valueAxis2 = axisInfo.valueAxis;
          var valueDataDim = getStackedDimension(data, axisInfo.valueDataDim);
          value = numCalculate(data, valueDataDim, mlType);
        }
        var valueIndex = valueAxis2.dim === "x" ? 0 : 1;
        var baseIndex = 1 - valueIndex;
        var mlFrom = clone(item);
        var mlTo = {
          coord: []
        };
        mlFrom.type = null;
        mlFrom.coord = [];
        mlFrom.coord[baseIndex] = -Infinity;
        mlTo.coord[baseIndex] = Infinity;
        var precision = mlModel.get("precision");
        if (precision >= 0 && isNumber(value)) {
          value = +value.toFixed(Math.min(precision, 20));
        }
        mlFrom.coord[valueIndex] = mlTo.coord[valueIndex] = value;
        itemArray = [mlFrom, mlTo, {
          type: mlType,
          valueIndex: item.valueIndex,
          value
        }];
      } else {
        if (true) {
          logError("Invalid markLine data.");
        }
        itemArray = [];
      }
    } else {
      itemArray = item;
    }
    var normalizedItem = [dataTransform(seriesModel, itemArray[0]), dataTransform(seriesModel, itemArray[1]), extend({}, itemArray[2])];
    normalizedItem[2].type = normalizedItem[2].type || null;
    merge(normalizedItem[2], normalizedItem[0]);
    merge(normalizedItem[2], normalizedItem[1]);
    return normalizedItem;
  };
  function isInifinity(val) {
    return !isNaN(val) && !isFinite(val);
  }
  function ifMarkLineHasOnlyDim(dimIndex, fromCoord, toCoord, coordSys) {
    var otherDimIndex = 1 - dimIndex;
    var dimName = coordSys.dimensions[dimIndex];
    return isInifinity(fromCoord[otherDimIndex]) && isInifinity(toCoord[otherDimIndex]) && fromCoord[dimIndex] === toCoord[dimIndex] && coordSys.getAxis(dimName).containData(fromCoord[dimIndex]);
  }
  function markLineFilter(coordSys, item) {
    if (coordSys.type === "cartesian2d") {
      var fromCoord = item[0].coord;
      var toCoord = item[1].coord;
      if (fromCoord && toCoord && (ifMarkLineHasOnlyDim(1, fromCoord, toCoord, coordSys) || ifMarkLineHasOnlyDim(0, fromCoord, toCoord, coordSys))) {
        return true;
      }
    }
    return dataFilter2(coordSys, item[0]) && dataFilter2(coordSys, item[1]);
  }
  function updateSingleMarkerEndLayout(data, idx, isFrom, seriesModel, api) {
    var coordSys = seriesModel.coordinateSystem;
    var itemModel = data.getItemModel(idx);
    var point;
    var xPx = parsePercent2(itemModel.get("x"), api.getWidth());
    var yPx = parsePercent2(itemModel.get("y"), api.getHeight());
    if (!isNaN(xPx) && !isNaN(yPx)) {
      point = [xPx, yPx];
    } else {
      if (seriesModel.getMarkerPosition) {
        point = seriesModel.getMarkerPosition(data.getValues(data.dimensions, idx));
      } else {
        var dims = coordSys.dimensions;
        var x = data.get(dims[0], idx);
        var y = data.get(dims[1], idx);
        point = coordSys.dataToPoint([x, y]);
      }
      if (isCoordinateSystemType(coordSys, "cartesian2d")) {
        var xAxis = coordSys.getAxis("x");
        var yAxis = coordSys.getAxis("y");
        var dims = coordSys.dimensions;
        if (isInifinity(data.get(dims[0], idx))) {
          point[0] = xAxis.toGlobalCoord(xAxis.getExtent()[isFrom ? 0 : 1]);
        } else if (isInifinity(data.get(dims[1], idx))) {
          point[1] = yAxis.toGlobalCoord(yAxis.getExtent()[isFrom ? 0 : 1]);
        }
      }
      if (!isNaN(xPx)) {
        point[0] = xPx;
      }
      if (!isNaN(yPx)) {
        point[1] = yPx;
      }
    }
    data.setItemLayout(idx, point);
  }
  var MarkLineView = function(_super) {
    __extends(MarkLineView2, _super);
    function MarkLineView2() {
      var _this = _super !== null && _super.apply(this, arguments) || this;
      _this.type = MarkLineView2.type;
      return _this;
    }
    MarkLineView2.prototype.updateTransform = function(markLineModel, ecModel, api) {
      ecModel.eachSeries(function(seriesModel) {
        var mlModel = MarkerModel_default.getMarkerModelFromSeries(seriesModel, "markLine");
        if (mlModel) {
          var mlData_1 = mlModel.getData();
          var fromData_1 = inner19(mlModel).from;
          var toData_1 = inner19(mlModel).to;
          fromData_1.each(function(idx) {
            updateSingleMarkerEndLayout(fromData_1, idx, true, seriesModel, api);
            updateSingleMarkerEndLayout(toData_1, idx, false, seriesModel, api);
          });
          mlData_1.each(function(idx) {
            mlData_1.setItemLayout(idx, [fromData_1.getItemLayout(idx), toData_1.getItemLayout(idx)]);
          });
          this.markerGroupMap.get(seriesModel.id).updateLayout();
        }
      }, this);
    };
    MarkLineView2.prototype.renderSeries = function(seriesModel, mlModel, ecModel, api) {
      var coordSys = seriesModel.coordinateSystem;
      var seriesId = seriesModel.id;
      var seriesData = seriesModel.getData();
      var lineDrawMap = this.markerGroupMap;
      var lineDraw = lineDrawMap.get(seriesId) || lineDrawMap.set(seriesId, new LineDraw_default());
      this.group.add(lineDraw.group);
      var mlData = createList2(coordSys, seriesModel, mlModel);
      var fromData = mlData.from;
      var toData = mlData.to;
      var lineData = mlData.line;
      inner19(mlModel).from = fromData;
      inner19(mlModel).to = toData;
      mlModel.setData(lineData);
      var symbolType = mlModel.get("symbol");
      var symbolSize = mlModel.get("symbolSize");
      var symbolRotate = mlModel.get("symbolRotate");
      var symbolOffset = mlModel.get("symbolOffset");
      if (!isArray(symbolType)) {
        symbolType = [symbolType, symbolType];
      }
      if (!isArray(symbolSize)) {
        symbolSize = [symbolSize, symbolSize];
      }
      if (!isArray(symbolRotate)) {
        symbolRotate = [symbolRotate, symbolRotate];
      }
      if (!isArray(symbolOffset)) {
        symbolOffset = [symbolOffset, symbolOffset];
      }
      mlData.from.each(function(idx) {
        updateDataVisualAndLayout(fromData, idx, true);
        updateDataVisualAndLayout(toData, idx, false);
      });
      lineData.each(function(idx) {
        var lineStyle = lineData.getItemModel(idx).getModel("lineStyle").getLineStyle();
        lineData.setItemLayout(idx, [fromData.getItemLayout(idx), toData.getItemLayout(idx)]);
        if (lineStyle.stroke == null) {
          lineStyle.stroke = fromData.getItemVisual(idx, "style").fill;
        }
        lineData.setItemVisual(idx, {
          fromSymbolKeepAspect: fromData.getItemVisual(idx, "symbolKeepAspect"),
          fromSymbolOffset: fromData.getItemVisual(idx, "symbolOffset"),
          fromSymbolRotate: fromData.getItemVisual(idx, "symbolRotate"),
          fromSymbolSize: fromData.getItemVisual(idx, "symbolSize"),
          fromSymbol: fromData.getItemVisual(idx, "symbol"),
          toSymbolKeepAspect: toData.getItemVisual(idx, "symbolKeepAspect"),
          toSymbolOffset: toData.getItemVisual(idx, "symbolOffset"),
          toSymbolRotate: toData.getItemVisual(idx, "symbolRotate"),
          toSymbolSize: toData.getItemVisual(idx, "symbolSize"),
          toSymbol: toData.getItemVisual(idx, "symbol"),
          style: lineStyle
        });
      });
      lineDraw.updateData(lineData);
      mlData.line.eachItemGraphicEl(function(el) {
        getECData(el).dataModel = mlModel;
        el.traverse(function(child) {
          getECData(child).dataModel = mlModel;
        });
      });
      function updateDataVisualAndLayout(data, idx, isFrom) {
        var itemModel = data.getItemModel(idx);
        updateSingleMarkerEndLayout(data, idx, isFrom, seriesModel, api);
        var style = itemModel.getModel("itemStyle").getItemStyle();
        if (style.fill == null) {
          style.fill = getVisualFromData(seriesData, "color");
        }
        data.setItemVisual(idx, {
          symbolKeepAspect: itemModel.get("symbolKeepAspect"),
          symbolOffset: retrieve2(itemModel.get("symbolOffset", true), symbolOffset[isFrom ? 0 : 1]),
          symbolRotate: retrieve2(itemModel.get("symbolRotate", true), symbolRotate[isFrom ? 0 : 1]),
          symbolSize: retrieve2(itemModel.get("symbolSize"), symbolSize[isFrom ? 0 : 1]),
          symbol: retrieve2(itemModel.get("symbol", true), symbolType[isFrom ? 0 : 1]),
          style
        });
      }
      this.markKeep(lineDraw);
      lineDraw.group.silent = mlModel.get("silent") || seriesModel.get("silent");
    };
    MarkLineView2.type = "markLine";
    return MarkLineView2;
  }(MarkerView_default);
  function createList2(coordSys, seriesModel, mlModel) {
    var coordDimsInfos;
    if (coordSys) {
      coordDimsInfos = map(coordSys && coordSys.dimensions, function(coordDim) {
        var info = seriesModel.getData().getDimensionInfo(seriesModel.getData().mapDimension(coordDim)) || {};
        return extend(extend({}, info), {
          name: coordDim,
          ordinalMeta: null
        });
      });
    } else {
      coordDimsInfos = [{
        name: "value",
        type: "float"
      }];
    }
    var fromData = new SeriesData_default(coordDimsInfos, mlModel);
    var toData = new SeriesData_default(coordDimsInfos, mlModel);
    var lineData = new SeriesData_default([], mlModel);
    var optData = map(mlModel.get("data"), curry(markLineTransform, seriesModel, coordSys, mlModel));
    if (coordSys) {
      optData = filter(optData, curry(markLineFilter, coordSys));
    }
    var dimValueGetter = createMarkerDimValueGetter(!!coordSys, coordDimsInfos);
    fromData.initData(map(optData, function(item) {
      return item[0];
    }), null, dimValueGetter);
    toData.initData(map(optData, function(item) {
      return item[1];
    }), null, dimValueGetter);
    lineData.initData(map(optData, function(item) {
      return item[2];
    }));
    lineData.hasItemOption = true;
    return {
      from: fromData,
      to: toData,
      line: lineData
    };
  }
  var MarkLineView_default = MarkLineView;

  // node_modules/echarts/lib/component/marker/installMarkLine.js
  function install42(registers) {
    registers.registerComponentModel(MarkLineModel_default);
    registers.registerComponentView(MarkLineView_default);
    registers.registerPreprocessor(function(opt) {
      if (checkMarkerInSeries(opt.series, "markLine")) {
        opt.markLine = opt.markLine || {};
      }
    });
  }

  // node_modules/echarts/lib/component/marker/MarkAreaModel.js
  var MarkAreaModel = function(_super) {
    __extends(MarkAreaModel2, _super);
    function MarkAreaModel2() {
      var _this = _super !== null && _super.apply(this, arguments) || this;
      _this.type = MarkAreaModel2.type;
      return _this;
    }
    MarkAreaModel2.prototype.createMarkerModelFromSeries = function(markerOpt, masterMarkerModel, ecModel) {
      return new MarkAreaModel2(markerOpt, masterMarkerModel, ecModel);
    };
    MarkAreaModel2.type = "markArea";
    MarkAreaModel2.defaultOption = {
      z: 1,
      tooltip: {
        trigger: "item"
      },
      animation: false,
      label: {
        show: true,
        position: "top"
      },
      itemStyle: {
        borderWidth: 0
      },
      emphasis: {
        label: {
          show: true,
          position: "top"
        }
      }
    };
    return MarkAreaModel2;
  }(MarkerModel_default);
  var MarkAreaModel_default = MarkAreaModel;

  // node_modules/echarts/lib/component/marker/MarkAreaView.js
  var inner20 = makeInner();
  var markAreaTransform = function(seriesModel, coordSys, maModel, item) {
    var lt2 = dataTransform(seriesModel, item[0]);
    var rb2 = dataTransform(seriesModel, item[1]);
    var ltCoord = lt2.coord;
    var rbCoord = rb2.coord;
    ltCoord[0] = retrieve(ltCoord[0], -Infinity);
    ltCoord[1] = retrieve(ltCoord[1], -Infinity);
    rbCoord[0] = retrieve(rbCoord[0], Infinity);
    rbCoord[1] = retrieve(rbCoord[1], Infinity);
    var result = mergeAll([{}, lt2, rb2]);
    result.coord = [lt2.coord, rb2.coord];
    result.x0 = lt2.x;
    result.y0 = lt2.y;
    result.x1 = rb2.x;
    result.y1 = rb2.y;
    return result;
  };
  function isInifinity2(val) {
    return !isNaN(val) && !isFinite(val);
  }
  function ifMarkAreaHasOnlyDim(dimIndex, fromCoord, toCoord, coordSys) {
    var otherDimIndex = 1 - dimIndex;
    return isInifinity2(fromCoord[otherDimIndex]) && isInifinity2(toCoord[otherDimIndex]);
  }
  function markAreaFilter(coordSys, item) {
    var fromCoord = item.coord[0];
    var toCoord = item.coord[1];
    var item0 = {
      coord: fromCoord,
      x: item.x0,
      y: item.y0
    };
    var item1 = {
      coord: toCoord,
      x: item.x1,
      y: item.y1
    };
    if (isCoordinateSystemType(coordSys, "cartesian2d")) {
      if (fromCoord && toCoord && (ifMarkAreaHasOnlyDim(1, fromCoord, toCoord, coordSys) || ifMarkAreaHasOnlyDim(0, fromCoord, toCoord, coordSys))) {
        return true;
      }
      return zoneFilter(coordSys, item0, item1);
    }
    return dataFilter2(coordSys, item0) || dataFilter2(coordSys, item1);
  }
  function getSingleMarkerEndPoint(data, idx, dims, seriesModel, api) {
    var coordSys = seriesModel.coordinateSystem;
    var itemModel = data.getItemModel(idx);
    var point;
    var xPx = parsePercent2(itemModel.get(dims[0]), api.getWidth());
    var yPx = parsePercent2(itemModel.get(dims[1]), api.getHeight());
    if (!isNaN(xPx) && !isNaN(yPx)) {
      point = [xPx, yPx];
    } else {
      if (seriesModel.getMarkerPosition) {
        point = seriesModel.getMarkerPosition(data.getValues(dims, idx));
      } else {
        var x = data.get(dims[0], idx);
        var y = data.get(dims[1], idx);
        var pt = [x, y];
        coordSys.clampData && coordSys.clampData(pt, pt);
        point = coordSys.dataToPoint(pt, true);
      }
      if (isCoordinateSystemType(coordSys, "cartesian2d")) {
        var xAxis = coordSys.getAxis("x");
        var yAxis = coordSys.getAxis("y");
        var x = data.get(dims[0], idx);
        var y = data.get(dims[1], idx);
        if (isInifinity2(x)) {
          point[0] = xAxis.toGlobalCoord(xAxis.getExtent()[dims[0] === "x0" ? 0 : 1]);
        } else if (isInifinity2(y)) {
          point[1] = yAxis.toGlobalCoord(yAxis.getExtent()[dims[1] === "y0" ? 0 : 1]);
        }
      }
      if (!isNaN(xPx)) {
        point[0] = xPx;
      }
      if (!isNaN(yPx)) {
        point[1] = yPx;
      }
    }
    return point;
  }
  var dimPermutations = [["x0", "y0"], ["x1", "y0"], ["x1", "y1"], ["x0", "y1"]];
  var MarkAreaView = function(_super) {
    __extends(MarkAreaView2, _super);
    function MarkAreaView2() {
      var _this = _super !== null && _super.apply(this, arguments) || this;
      _this.type = MarkAreaView2.type;
      return _this;
    }
    MarkAreaView2.prototype.updateTransform = function(markAreaModel, ecModel, api) {
      ecModel.eachSeries(function(seriesModel) {
        var maModel = MarkerModel_default.getMarkerModelFromSeries(seriesModel, "markArea");
        if (maModel) {
          var areaData_1 = maModel.getData();
          areaData_1.each(function(idx) {
            var points4 = map(dimPermutations, function(dim) {
              return getSingleMarkerEndPoint(areaData_1, idx, dim, seriesModel, api);
            });
            areaData_1.setItemLayout(idx, points4);
            var el = areaData_1.getItemGraphicEl(idx);
            el.setShape("points", points4);
          });
        }
      }, this);
    };
    MarkAreaView2.prototype.renderSeries = function(seriesModel, maModel, ecModel, api) {
      var coordSys = seriesModel.coordinateSystem;
      var seriesId = seriesModel.id;
      var seriesData = seriesModel.getData();
      var areaGroupMap = this.markerGroupMap;
      var polygonGroup = areaGroupMap.get(seriesId) || areaGroupMap.set(seriesId, {
        group: new Group_default()
      });
      this.group.add(polygonGroup.group);
      this.markKeep(polygonGroup);
      var areaData = createList3(coordSys, seriesModel, maModel);
      maModel.setData(areaData);
      areaData.each(function(idx) {
        var points4 = map(dimPermutations, function(dim) {
          return getSingleMarkerEndPoint(areaData, idx, dim, seriesModel, api);
        });
        var xAxisScale = coordSys.getAxis("x").scale;
        var yAxisScale = coordSys.getAxis("y").scale;
        var xAxisExtent = xAxisScale.getExtent();
        var yAxisExtent = yAxisScale.getExtent();
        var xPointExtent = [xAxisScale.parse(areaData.get("x0", idx)), xAxisScale.parse(areaData.get("x1", idx))];
        var yPointExtent = [yAxisScale.parse(areaData.get("y0", idx)), yAxisScale.parse(areaData.get("y1", idx))];
        asc(xPointExtent);
        asc(yPointExtent);
        var overlapped = !(xAxisExtent[0] > xPointExtent[1] || xAxisExtent[1] < xPointExtent[0] || yAxisExtent[0] > yPointExtent[1] || yAxisExtent[1] < yPointExtent[0]);
        var allClipped = !overlapped;
        areaData.setItemLayout(idx, {
          points: points4,
          allClipped
        });
        var style = areaData.getItemModel(idx).getModel("itemStyle").getItemStyle();
        var color = getVisualFromData(seriesData, "color");
        if (!style.fill) {
          style.fill = color;
          if (isString(style.fill)) {
            style.fill = modifyAlpha(style.fill, 0.4);
          }
        }
        if (!style.stroke) {
          style.stroke = color;
        }
        areaData.setItemVisual(idx, "style", style);
      });
      areaData.diff(inner20(polygonGroup).data).add(function(idx) {
        var layout5 = areaData.getItemLayout(idx);
        if (!layout5.allClipped) {
          var polygon = new Polygon_default({
            shape: {
              points: layout5.points
            }
          });
          areaData.setItemGraphicEl(idx, polygon);
          polygonGroup.group.add(polygon);
        }
      }).update(function(newIdx, oldIdx) {
        var polygon = inner20(polygonGroup).data.getItemGraphicEl(oldIdx);
        var layout5 = areaData.getItemLayout(newIdx);
        if (!layout5.allClipped) {
          if (polygon) {
            updateProps(polygon, {
              shape: {
                points: layout5.points
              }
            }, maModel, newIdx);
          } else {
            polygon = new Polygon_default({
              shape: {
                points: layout5.points
              }
            });
          }
          areaData.setItemGraphicEl(newIdx, polygon);
          polygonGroup.group.add(polygon);
        } else if (polygon) {
          polygonGroup.group.remove(polygon);
        }
      }).remove(function(idx) {
        var polygon = inner20(polygonGroup).data.getItemGraphicEl(idx);
        polygonGroup.group.remove(polygon);
      }).execute();
      areaData.eachItemGraphicEl(function(polygon, idx) {
        var itemModel = areaData.getItemModel(idx);
        var style = areaData.getItemVisual(idx, "style");
        polygon.useStyle(areaData.getItemVisual(idx, "style"));
        setLabelStyle(polygon, getLabelStatesModels(itemModel), {
          labelFetcher: maModel,
          labelDataIndex: idx,
          defaultText: areaData.getName(idx) || "",
          inheritColor: isString(style.fill) ? modifyAlpha(style.fill, 1) : "#000"
        });
        setStatesStylesFromModel(polygon, itemModel);
        toggleHoverEmphasis(polygon, null, null, itemModel.get(["emphasis", "disabled"]));
        getECData(polygon).dataModel = maModel;
      });
      inner20(polygonGroup).data = areaData;
      polygonGroup.group.silent = maModel.get("silent") || seriesModel.get("silent");
    };
    MarkAreaView2.type = "markArea";
    return MarkAreaView2;
  }(MarkerView_default);
  function createList3(coordSys, seriesModel, maModel) {
    var areaData;
    var dataDims;
    var dims = ["x0", "y0", "x1", "y1"];
    if (coordSys) {
      var coordDimsInfos_1 = map(coordSys && coordSys.dimensions, function(coordDim) {
        var data = seriesModel.getData();
        var info = data.getDimensionInfo(data.mapDimension(coordDim)) || {};
        return extend(extend({}, info), {
          name: coordDim,
          ordinalMeta: null
        });
      });
      dataDims = map(dims, function(dim, idx) {
        return {
          name: dim,
          type: coordDimsInfos_1[idx % 2].type
        };
      });
      areaData = new SeriesData_default(dataDims, maModel);
    } else {
      dataDims = [{
        name: "value",
        type: "float"
      }];
      areaData = new SeriesData_default(dataDims, maModel);
    }
    var optData = map(maModel.get("data"), curry(markAreaTransform, seriesModel, coordSys, maModel));
    if (coordSys) {
      optData = filter(optData, curry(markAreaFilter, coordSys));
    }
    var dimValueGetter = coordSys ? function(item, dimName, dataIndex, dimIndex) {
      var rawVal = item.coord[Math.floor(dimIndex / 2)][dimIndex % 2];
      return parseDataValue(rawVal, dataDims[dimIndex]);
    } : function(item, dimName, dataIndex, dimIndex) {
      return parseDataValue(item.value, dataDims[dimIndex]);
    };
    areaData.initData(optData, null, dimValueGetter);
    areaData.hasItemOption = true;
    return areaData;
  }
  var MarkAreaView_default = MarkAreaView;

  // node_modules/echarts/lib/component/marker/installMarkArea.js
  function install43(registers) {
    registers.registerComponentModel(MarkAreaModel_default);
    registers.registerComponentView(MarkAreaView_default);
    registers.registerPreprocessor(function(opt) {
      if (checkMarkerInSeries(opt.series, "markArea")) {
        opt.markArea = opt.markArea || {};
      }
    });
  }

  // node_modules/echarts/lib/component/legend/LegendModel.js
  var getDefaultSelectorOptions = function(ecModel, type) {
    if (type === "all") {
      return {
        type: "all",
        title: ecModel.getLocaleModel().get(["legend", "selector", "all"])
      };
    } else if (type === "inverse") {
      return {
        type: "inverse",
        title: ecModel.getLocaleModel().get(["legend", "selector", "inverse"])
      };
    }
  };
  var LegendModel = function(_super) {
    __extends(LegendModel2, _super);
    function LegendModel2() {
      var _this = _super !== null && _super.apply(this, arguments) || this;
      _this.type = LegendModel2.type;
      _this.layoutMode = {
        type: "box",
        ignoreSize: true
      };
      return _this;
    }
    LegendModel2.prototype.init = function(option, parentModel, ecModel) {
      this.mergeDefaultAndTheme(option, ecModel);
      option.selected = option.selected || {};
      this._updateSelector(option);
    };
    LegendModel2.prototype.mergeOption = function(option, ecModel) {
      _super.prototype.mergeOption.call(this, option, ecModel);
      this._updateSelector(option);
    };
    LegendModel2.prototype._updateSelector = function(option) {
      var selector2 = option.selector;
      var ecModel = this.ecModel;
      if (selector2 === true) {
        selector2 = option.selector = ["all", "inverse"];
      }
      if (isArray(selector2)) {
        each(selector2, function(item, index) {
          isString(item) && (item = {
            type: item
          });
          selector2[index] = merge(item, getDefaultSelectorOptions(ecModel, item.type));
        });
      }
    };
    LegendModel2.prototype.optionUpdated = function() {
      this._updateData(this.ecModel);
      var legendData = this._data;
      if (legendData[0] && this.get("selectedMode") === "single") {
        var hasSelected = false;
        for (var i = 0; i < legendData.length; i++) {
          var name_1 = legendData[i].get("name");
          if (this.isSelected(name_1)) {
            this.select(name_1);
            hasSelected = true;
            break;
          }
        }
        !hasSelected && this.select(legendData[0].get("name"));
      }
    };
    LegendModel2.prototype._updateData = function(ecModel) {
      var potentialData = [];
      var availableNames = [];
      ecModel.eachRawSeries(function(seriesModel) {
        var seriesName = seriesModel.name;
        availableNames.push(seriesName);
        var isPotential;
        if (seriesModel.legendVisualProvider) {
          var provider = seriesModel.legendVisualProvider;
          var names = provider.getAllNames();
          if (!ecModel.isSeriesFiltered(seriesModel)) {
            availableNames = availableNames.concat(names);
          }
          if (names.length) {
            potentialData = potentialData.concat(names);
          } else {
            isPotential = true;
          }
        } else {
          isPotential = true;
        }
        if (isPotential && isNameSpecified(seriesModel)) {
          potentialData.push(seriesModel.name);
        }
      });
      this._availableNames = availableNames;
      var rawData = this.get("data") || potentialData;
      var legendData = map(rawData, function(dataItem) {
        if (isString(dataItem) || isNumber(dataItem)) {
          dataItem = {
            name: dataItem
          };
        }
        return new Model_default(dataItem, this, this.ecModel);
      }, this);
      this._data = legendData;
    };
    LegendModel2.prototype.getData = function() {
      return this._data;
    };
    LegendModel2.prototype.select = function(name) {
      var selected = this.option.selected;
      var selectedMode = this.get("selectedMode");
      if (selectedMode === "single") {
        var data = this._data;
        each(data, function(dataItem) {
          selected[dataItem.get("name")] = false;
        });
      }
      selected[name] = true;
    };
    LegendModel2.prototype.unSelect = function(name) {
      if (this.get("selectedMode") !== "single") {
        this.option.selected[name] = false;
      }
    };
    LegendModel2.prototype.toggleSelected = function(name) {
      var selected = this.option.selected;
      if (!selected.hasOwnProperty(name)) {
        selected[name] = true;
      }
      this[selected[name] ? "unSelect" : "select"](name);
    };
    LegendModel2.prototype.allSelect = function() {
      var data = this._data;
      var selected = this.option.selected;
      each(data, function(dataItem) {
        selected[dataItem.get("name", true)] = true;
      });
    };
    LegendModel2.prototype.inverseSelect = function() {
      var data = this._data;
      var selected = this.option.selected;
      each(data, function(dataItem) {
        var name = dataItem.get("name", true);
        if (!selected.hasOwnProperty(name)) {
          selected[name] = true;
        }
        selected[name] = !selected[name];
      });
    };
    LegendModel2.prototype.isSelected = function(name) {
      var selected = this.option.selected;
      return !(selected.hasOwnProperty(name) && !selected[name]) && indexOf(this._availableNames, name) >= 0;
    };
    LegendModel2.prototype.getOrient = function() {
      return this.get("orient") === "vertical" ? {
        index: 1,
        name: "vertical"
      } : {
        index: 0,
        name: "horizontal"
      };
    };
    LegendModel2.type = "legend.plain";
    LegendModel2.dependencies = ["series"];
    LegendModel2.defaultOption = {
      z: 4,
      show: true,
      orient: "horizontal",
      left: "center",
      top: 0,
      align: "auto",
      backgroundColor: "rgba(0,0,0,0)",
      borderColor: "#ccc",
      borderRadius: 0,
      borderWidth: 0,
      padding: 5,
      itemGap: 10,
      itemWidth: 25,
      itemHeight: 14,
      symbolRotate: "inherit",
      symbolKeepAspect: true,
      inactiveColor: "#ccc",
      inactiveBorderColor: "#ccc",
      inactiveBorderWidth: "auto",
      itemStyle: {
        color: "inherit",
        opacity: "inherit",
        borderColor: "inherit",
        borderWidth: "auto",
        borderCap: "inherit",
        borderJoin: "inherit",
        borderDashOffset: "inherit",
        borderMiterLimit: "inherit"
      },
      lineStyle: {
        width: "auto",
        color: "inherit",
        inactiveColor: "#ccc",
        inactiveWidth: 2,
        opacity: "inherit",
        type: "inherit",
        cap: "inherit",
        join: "inherit",
        dashOffset: "inherit",
        miterLimit: "inherit"
      },
      textStyle: {
        color: "#333"
      },
      selectedMode: true,
      selector: false,
      selectorLabel: {
        show: true,
        borderRadius: 10,
        padding: [3, 5, 3, 5],
        fontSize: 12,
        fontFamily: "sans-serif",
        color: "#666",
        borderWidth: 1,
        borderColor: "#666"
      },
      emphasis: {
        selectorLabel: {
          show: true,
          color: "#eee",
          backgroundColor: "#666"
        }
      },
      selectorPosition: "auto",
      selectorItemGap: 7,
      selectorButtonGap: 10,
      tooltip: {
        show: false
      }
    };
    return LegendModel2;
  }(Component_default);
  var LegendModel_default = LegendModel;

  // node_modules/echarts/lib/component/legend/LegendView.js
  var curry2 = curry;
  var each13 = each;
  var Group3 = Group_default;
  var LegendView = function(_super) {
    __extends(LegendView2, _super);
    function LegendView2() {
      var _this = _super !== null && _super.apply(this, arguments) || this;
      _this.type = LegendView2.type;
      _this.newlineDisabled = false;
      return _this;
    }
    LegendView2.prototype.init = function() {
      this.group.add(this._contentGroup = new Group3());
      this.group.add(this._selectorGroup = new Group3());
      this._isFirstRender = true;
    };
    LegendView2.prototype.getContentGroup = function() {
      return this._contentGroup;
    };
    LegendView2.prototype.getSelectorGroup = function() {
      return this._selectorGroup;
    };
    LegendView2.prototype.render = function(legendModel, ecModel, api) {
      var isFirstRender = this._isFirstRender;
      this._isFirstRender = false;
      this.resetInner();
      if (!legendModel.get("show", true)) {
        return;
      }
      var itemAlign = legendModel.get("align");
      var orient = legendModel.get("orient");
      if (!itemAlign || itemAlign === "auto") {
        itemAlign = legendModel.get("left") === "right" && orient === "vertical" ? "right" : "left";
      }
      var selector2 = legendModel.get("selector", true);
      var selectorPosition = legendModel.get("selectorPosition", true);
      if (selector2 && (!selectorPosition || selectorPosition === "auto")) {
        selectorPosition = orient === "horizontal" ? "end" : "start";
      }
      this.renderInner(itemAlign, legendModel, ecModel, api, selector2, orient, selectorPosition);
      var positionInfo = legendModel.getBoxLayoutParams();
      var viewportSize = {
        width: api.getWidth(),
        height: api.getHeight()
      };
      var padding = legendModel.get("padding");
      var maxSize = getLayoutRect(positionInfo, viewportSize, padding);
      var mainRect = this.layoutInner(legendModel, itemAlign, maxSize, isFirstRender, selector2, selectorPosition);
      var layoutRect = getLayoutRect(defaults({
        width: mainRect.width,
        height: mainRect.height
      }, positionInfo), viewportSize, padding);
      this.group.x = layoutRect.x - mainRect.x;
      this.group.y = layoutRect.y - mainRect.y;
      this.group.markRedraw();
      this.group.add(this._backgroundEl = makeBackground(mainRect, legendModel));
    };
    LegendView2.prototype.resetInner = function() {
      this.getContentGroup().removeAll();
      this._backgroundEl && this.group.remove(this._backgroundEl);
      this.getSelectorGroup().removeAll();
    };
    LegendView2.prototype.renderInner = function(itemAlign, legendModel, ecModel, api, selector2, orient, selectorPosition) {
      var contentGroup = this.getContentGroup();
      var legendDrawnMap = createHashMap();
      var selectMode = legendModel.get("selectedMode");
      var excludeSeriesId = [];
      ecModel.eachRawSeries(function(seriesModel) {
        !seriesModel.get("legendHoverLink") && excludeSeriesId.push(seriesModel.id);
      });
      each13(legendModel.getData(), function(legendItemModel, dataIndex) {
        var name = legendItemModel.get("name");
        if (!this.newlineDisabled && (name === "" || name === "\n")) {
          var g = new Group3();
          g.newline = true;
          contentGroup.add(g);
          return;
        }
        var seriesModel = ecModel.getSeriesByName(name)[0];
        if (legendDrawnMap.get(name)) {
          return;
        }
        if (seriesModel) {
          var data = seriesModel.getData();
          var lineVisualStyle = data.getVisual("legendLineStyle") || {};
          var legendIcon = data.getVisual("legendIcon");
          var style = data.getVisual("style");
          var itemGroup = this._createItem(seriesModel, name, dataIndex, legendItemModel, legendModel, itemAlign, lineVisualStyle, style, legendIcon, selectMode, api);
          itemGroup.on("click", curry2(dispatchSelectAction, name, null, api, excludeSeriesId)).on("mouseover", curry2(dispatchHighlightAction, seriesModel.name, null, api, excludeSeriesId)).on("mouseout", curry2(dispatchDownplayAction, seriesModel.name, null, api, excludeSeriesId));
          legendDrawnMap.set(name, true);
        } else {
          ecModel.eachRawSeries(function(seriesModel2) {
            if (legendDrawnMap.get(name)) {
              return;
            }
            if (seriesModel2.legendVisualProvider) {
              var provider = seriesModel2.legendVisualProvider;
              if (!provider.containName(name)) {
                return;
              }
              var idx = provider.indexOfName(name);
              var style2 = provider.getItemVisual(idx, "style");
              var legendIcon2 = provider.getItemVisual(idx, "legendIcon");
              var colorArr = parse(style2.fill);
              if (colorArr && colorArr[3] === 0) {
                colorArr[3] = 0.2;
                style2 = extend(extend({}, style2), {
                  fill: stringify(colorArr, "rgba")
                });
              }
              var itemGroup2 = this._createItem(seriesModel2, name, dataIndex, legendItemModel, legendModel, itemAlign, {}, style2, legendIcon2, selectMode, api);
              itemGroup2.on("click", curry2(dispatchSelectAction, null, name, api, excludeSeriesId)).on("mouseover", curry2(dispatchHighlightAction, null, name, api, excludeSeriesId)).on("mouseout", curry2(dispatchDownplayAction, null, name, api, excludeSeriesId));
              legendDrawnMap.set(name, true);
            }
          }, this);
        }
        if (true) {
          if (!legendDrawnMap.get(name)) {
            console.warn(name + " series not exists. Legend data should be same with series name or data name.");
          }
        }
      }, this);
      if (selector2) {
        this._createSelector(selector2, legendModel, api, orient, selectorPosition);
      }
    };
    LegendView2.prototype._createSelector = function(selector2, legendModel, api, orient, selectorPosition) {
      var selectorGroup = this.getSelectorGroup();
      each13(selector2, function createSelectorButton(selectorItem) {
        var type = selectorItem.type;
        var labelText = new Text_default({
          style: {
            x: 0,
            y: 0,
            align: "center",
            verticalAlign: "middle"
          },
          onclick: function() {
            api.dispatchAction({
              type: type === "all" ? "legendAllSelect" : "legendInverseSelect"
            });
          }
        });
        selectorGroup.add(labelText);
        var labelModel = legendModel.getModel("selectorLabel");
        var emphasisLabelModel = legendModel.getModel(["emphasis", "selectorLabel"]);
        setLabelStyle(labelText, {
          normal: labelModel,
          emphasis: emphasisLabelModel
        }, {
          defaultText: selectorItem.title
        });
        enableHoverEmphasis(labelText);
      });
    };
    LegendView2.prototype._createItem = function(seriesModel, name, dataIndex, legendItemModel, legendModel, itemAlign, lineVisualStyle, itemVisualStyle, legendIcon, selectMode, api) {
      var drawType = seriesModel.visualDrawType;
      var itemWidth = legendModel.get("itemWidth");
      var itemHeight = legendModel.get("itemHeight");
      var isSelected = legendModel.isSelected(name);
      var iconRotate = legendItemModel.get("symbolRotate");
      var symbolKeepAspect = legendItemModel.get("symbolKeepAspect");
      var legendIconType = legendItemModel.get("icon");
      legendIcon = legendIconType || legendIcon || "roundRect";
      var style = getLegendStyle(legendIcon, legendItemModel, lineVisualStyle, itemVisualStyle, drawType, isSelected, api);
      var itemGroup = new Group3();
      var textStyleModel = legendItemModel.getModel("textStyle");
      if (isFunction(seriesModel.getLegendIcon) && (!legendIconType || legendIconType === "inherit")) {
        itemGroup.add(seriesModel.getLegendIcon({
          itemWidth,
          itemHeight,
          icon: legendIcon,
          iconRotate,
          itemStyle: style.itemStyle,
          lineStyle: style.lineStyle,
          symbolKeepAspect
        }));
      } else {
        var rotate2 = legendIconType === "inherit" && seriesModel.getData().getVisual("symbol") ? iconRotate === "inherit" ? seriesModel.getData().getVisual("symbolRotate") : iconRotate : 0;
        itemGroup.add(getDefaultLegendIcon({
          itemWidth,
          itemHeight,
          icon: legendIcon,
          iconRotate: rotate2,
          itemStyle: style.itemStyle,
          lineStyle: style.lineStyle,
          symbolKeepAspect
        }));
      }
      var textX = itemAlign === "left" ? itemWidth + 5 : -5;
      var textAlign = itemAlign;
      var formatter = legendModel.get("formatter");
      var content = name;
      if (isString(formatter) && formatter) {
        content = formatter.replace("{name}", name != null ? name : "");
      } else if (isFunction(formatter)) {
        content = formatter(name);
      }
      var inactiveColor = legendItemModel.get("inactiveColor");
      itemGroup.add(new Text_default({
        style: createTextStyle(textStyleModel, {
          text: content,
          x: textX,
          y: itemHeight / 2,
          fill: isSelected ? textStyleModel.getTextColor() : inactiveColor,
          align: textAlign,
          verticalAlign: "middle"
        })
      }));
      var hitRect = new Rect_default({
        shape: itemGroup.getBoundingRect(),
        invisible: true
      });
      var tooltipModel = legendItemModel.getModel("tooltip");
      if (tooltipModel.get("show")) {
        setTooltipConfig({
          el: hitRect,
          componentModel: legendModel,
          itemName: name,
          itemTooltipOption: tooltipModel.option
        });
      }
      itemGroup.add(hitRect);
      itemGroup.eachChild(function(child) {
        child.silent = true;
      });
      hitRect.silent = !selectMode;
      this.getContentGroup().add(itemGroup);
      enableHoverEmphasis(itemGroup);
      itemGroup.__legendDataIndex = dataIndex;
      return itemGroup;
    };
    LegendView2.prototype.layoutInner = function(legendModel, itemAlign, maxSize, isFirstRender, selector2, selectorPosition) {
      var contentGroup = this.getContentGroup();
      var selectorGroup = this.getSelectorGroup();
      box(legendModel.get("orient"), contentGroup, legendModel.get("itemGap"), maxSize.width, maxSize.height);
      var contentRect = contentGroup.getBoundingRect();
      var contentPos = [-contentRect.x, -contentRect.y];
      selectorGroup.markRedraw();
      contentGroup.markRedraw();
      if (selector2) {
        box("horizontal", selectorGroup, legendModel.get("selectorItemGap", true));
        var selectorRect = selectorGroup.getBoundingRect();
        var selectorPos = [-selectorRect.x, -selectorRect.y];
        var selectorButtonGap = legendModel.get("selectorButtonGap", true);
        var orientIdx = legendModel.getOrient().index;
        var wh = orientIdx === 0 ? "width" : "height";
        var hw = orientIdx === 0 ? "height" : "width";
        var yx = orientIdx === 0 ? "y" : "x";
        if (selectorPosition === "end") {
          selectorPos[orientIdx] += contentRect[wh] + selectorButtonGap;
        } else {
          contentPos[orientIdx] += selectorRect[wh] + selectorButtonGap;
        }
        selectorPos[1 - orientIdx] += contentRect[hw] / 2 - selectorRect[hw] / 2;
        selectorGroup.x = selectorPos[0];
        selectorGroup.y = selectorPos[1];
        contentGroup.x = contentPos[0];
        contentGroup.y = contentPos[1];
        var mainRect = {
          x: 0,
          y: 0
        };
        mainRect[wh] = contentRect[wh] + selectorButtonGap + selectorRect[wh];
        mainRect[hw] = Math.max(contentRect[hw], selectorRect[hw]);
        mainRect[yx] = Math.min(0, selectorRect[yx] + selectorPos[1 - orientIdx]);
        return mainRect;
      } else {
        contentGroup.x = contentPos[0];
        contentGroup.y = contentPos[1];
        return this.group.getBoundingRect();
      }
    };
    LegendView2.prototype.remove = function() {
      this.getContentGroup().removeAll();
      this._isFirstRender = true;
    };
    LegendView2.type = "legend.plain";
    return LegendView2;
  }(Component_default2);
  function getLegendStyle(iconType, legendItemModel, lineVisualStyle, itemVisualStyle, drawType, isSelected, api) {
    function handleCommonProps(style, visualStyle) {
      if (style.lineWidth === "auto") {
        style.lineWidth = visualStyle.lineWidth > 0 ? 2 : 0;
      }
      each13(style, function(propVal, propName) {
        style[propName] === "inherit" && (style[propName] = visualStyle[propName]);
      });
    }
    var itemStyleModel = legendItemModel.getModel("itemStyle");
    var itemStyle = itemStyleModel.getItemStyle();
    var iconBrushType = iconType.lastIndexOf("empty", 0) === 0 ? "fill" : "stroke";
    var decalStyle = itemStyleModel.getShallow("decal");
    itemStyle.decal = !decalStyle || decalStyle === "inherit" ? itemVisualStyle.decal : createOrUpdatePatternFromDecal(decalStyle, api);
    if (itemStyle.fill === "inherit") {
      itemStyle.fill = itemVisualStyle[drawType];
    }
    if (itemStyle.stroke === "inherit") {
      itemStyle.stroke = itemVisualStyle[iconBrushType];
    }
    if (itemStyle.opacity === "inherit") {
      itemStyle.opacity = (drawType === "fill" ? itemVisualStyle : lineVisualStyle).opacity;
    }
    handleCommonProps(itemStyle, itemVisualStyle);
    var legendLineModel = legendItemModel.getModel("lineStyle");
    var lineStyle = legendLineModel.getLineStyle();
    handleCommonProps(lineStyle, lineVisualStyle);
    itemStyle.fill === "auto" && (itemStyle.fill = itemVisualStyle.fill);
    itemStyle.stroke === "auto" && (itemStyle.stroke = itemVisualStyle.fill);
    lineStyle.stroke === "auto" && (lineStyle.stroke = itemVisualStyle.fill);
    if (!isSelected) {
      var borderWidth = legendItemModel.get("inactiveBorderWidth");
      var visualHasBorder = itemStyle[iconBrushType];
      itemStyle.lineWidth = borderWidth === "auto" ? itemVisualStyle.lineWidth > 0 && visualHasBorder ? 2 : 0 : itemStyle.lineWidth;
      itemStyle.fill = legendItemModel.get("inactiveColor");
      itemStyle.stroke = legendItemModel.get("inactiveBorderColor");
      lineStyle.stroke = legendLineModel.get("inactiveColor");
      lineStyle.lineWidth = legendLineModel.get("inactiveWidth");
    }
    return {
      itemStyle,
      lineStyle
    };
  }
  function getDefaultLegendIcon(opt) {
    var symboType = opt.icon || "roundRect";
    var icon = createSymbol(symboType, 0, 0, opt.itemWidth, opt.itemHeight, opt.itemStyle.fill, opt.symbolKeepAspect);
    icon.setStyle(opt.itemStyle);
    icon.rotation = (opt.iconRotate || 0) * Math.PI / 180;
    icon.setOrigin([opt.itemWidth / 2, opt.itemHeight / 2]);
    if (symboType.indexOf("empty") > -1) {
      icon.style.stroke = icon.style.fill;
      icon.style.fill = "#fff";
      icon.style.lineWidth = 2;
    }
    return icon;
  }
  function dispatchSelectAction(seriesName, dataName, api, excludeSeriesId) {
    dispatchDownplayAction(seriesName, dataName, api, excludeSeriesId);
    api.dispatchAction({
      type: "legendToggleSelect",
      name: seriesName != null ? seriesName : dataName
    });
    dispatchHighlightAction(seriesName, dataName, api, excludeSeriesId);
  }
  function isUseHoverLayer(api) {
    var list = api.getZr().storage.getDisplayList();
    var emphasisState;
    var i = 0;
    var len2 = list.length;
    while (i < len2 && !(emphasisState = list[i].states.emphasis)) {
      i++;
    }
    return emphasisState && emphasisState.hoverLayer;
  }
  function dispatchHighlightAction(seriesName, dataName, api, excludeSeriesId) {
    if (!isUseHoverLayer(api)) {
      api.dispatchAction({
        type: "highlight",
        seriesName,
        name: dataName,
        excludeSeriesId
      });
    }
  }
  function dispatchDownplayAction(seriesName, dataName, api, excludeSeriesId) {
    if (!isUseHoverLayer(api)) {
      api.dispatchAction({
        type: "downplay",
        seriesName,
        name: dataName,
        excludeSeriesId
      });
    }
  }
  var LegendView_default = LegendView;

  // node_modules/echarts/lib/component/legend/legendFilter.js
  function legendFilter(ecModel) {
    var legendModels = ecModel.findComponents({
      mainType: "legend"
    });
    if (legendModels && legendModels.length) {
      ecModel.filterSeries(function(series) {
        for (var i = 0; i < legendModels.length; i++) {
          if (!legendModels[i].isSelected(series.name)) {
            return false;
          }
        }
        return true;
      });
    }
  }

  // node_modules/echarts/lib/component/legend/legendAction.js
  function legendSelectActionHandler(methodName, payload, ecModel) {
    var selectedMap = {};
    var isToggleSelect = methodName === "toggleSelected";
    var isSelected;
    ecModel.eachComponent("legend", function(legendModel) {
      if (isToggleSelect && isSelected != null) {
        legendModel[isSelected ? "select" : "unSelect"](payload.name);
      } else if (methodName === "allSelect" || methodName === "inverseSelect") {
        legendModel[methodName]();
      } else {
        legendModel[methodName](payload.name);
        isSelected = legendModel.isSelected(payload.name);
      }
      var legendData = legendModel.getData();
      each(legendData, function(model) {
        var name = model.get("name");
        if (name === "\n" || name === "") {
          return;
        }
        var isItemSelected = legendModel.isSelected(name);
        if (selectedMap.hasOwnProperty(name)) {
          selectedMap[name] = selectedMap[name] && isItemSelected;
        } else {
          selectedMap[name] = isItemSelected;
        }
      });
    });
    return methodName === "allSelect" || methodName === "inverseSelect" ? {
      selected: selectedMap
    } : {
      name: payload.name,
      selected: selectedMap
    };
  }
  function installLegendAction(registers) {
    registers.registerAction("legendToggleSelect", "legendselectchanged", curry(legendSelectActionHandler, "toggleSelected"));
    registers.registerAction("legendAllSelect", "legendselectall", curry(legendSelectActionHandler, "allSelect"));
    registers.registerAction("legendInverseSelect", "legendinverseselect", curry(legendSelectActionHandler, "inverseSelect"));
    registers.registerAction("legendSelect", "legendselected", curry(legendSelectActionHandler, "select"));
    registers.registerAction("legendUnSelect", "legendunselected", curry(legendSelectActionHandler, "unSelect"));
  }

  // node_modules/echarts/lib/component/legend/installLegendPlain.js
  function install44(registers) {
    registers.registerComponentModel(LegendModel_default);
    registers.registerComponentView(LegendView_default);
    registers.registerProcessor(registers.PRIORITY.PROCESSOR.SERIES_FILTER, legendFilter);
    registers.registerSubTypeDefaulter("legend", function() {
      return "plain";
    });
    installLegendAction(registers);
  }

  // node_modules/echarts/lib/component/legend/ScrollableLegendModel.js
  var ScrollableLegendModel = function(_super) {
    __extends(ScrollableLegendModel2, _super);
    function ScrollableLegendModel2() {
      var _this = _super !== null && _super.apply(this, arguments) || this;
      _this.type = ScrollableLegendModel2.type;
      return _this;
    }
    ScrollableLegendModel2.prototype.setScrollDataIndex = function(scrollDataIndex) {
      this.option.scrollDataIndex = scrollDataIndex;
    };
    ScrollableLegendModel2.prototype.init = function(option, parentModel, ecModel) {
      var inputPositionParams = getLayoutParams(option);
      _super.prototype.init.call(this, option, parentModel, ecModel);
      mergeAndNormalizeLayoutParams2(this, option, inputPositionParams);
    };
    ScrollableLegendModel2.prototype.mergeOption = function(option, ecModel) {
      _super.prototype.mergeOption.call(this, option, ecModel);
      mergeAndNormalizeLayoutParams2(this, this.option, option);
    };
    ScrollableLegendModel2.type = "legend.scroll";
    ScrollableLegendModel2.defaultOption = inheritDefaultOption(LegendModel_default.defaultOption, {
      scrollDataIndex: 0,
      pageButtonItemGap: 5,
      pageButtonGap: null,
      pageButtonPosition: "end",
      pageFormatter: "{current}/{total}",
      pageIcons: {
        horizontal: ["M0,0L12,-10L12,10z", "M0,0L-12,-10L-12,10z"],
        vertical: ["M0,0L20,0L10,-20z", "M0,0L20,0L10,20z"]
      },
      pageIconColor: "#2f4554",
      pageIconInactiveColor: "#aaa",
      pageIconSize: 15,
      pageTextStyle: {
        color: "#333"
      },
      animationDurationUpdate: 800
    });
    return ScrollableLegendModel2;
  }(LegendModel_default);
  function mergeAndNormalizeLayoutParams2(legendModel, target, raw) {
    var orient = legendModel.getOrient();
    var ignoreSize = [1, 1];
    ignoreSize[orient.index] = 0;
    mergeLayoutParam(target, raw, {
      type: "box",
      ignoreSize: !!ignoreSize
    });
  }
  var ScrollableLegendModel_default = ScrollableLegendModel;

  // node_modules/echarts/lib/component/legend/ScrollableLegendView.js
  var Group4 = Group_default;
  var WH2 = ["width", "height"];
  var XY2 = ["x", "y"];
  var ScrollableLegendView = function(_super) {
    __extends(ScrollableLegendView2, _super);
    function ScrollableLegendView2() {
      var _this = _super !== null && _super.apply(this, arguments) || this;
      _this.type = ScrollableLegendView2.type;
      _this.newlineDisabled = true;
      _this._currentIndex = 0;
      return _this;
    }
    ScrollableLegendView2.prototype.init = function() {
      _super.prototype.init.call(this);
      this.group.add(this._containerGroup = new Group4());
      this._containerGroup.add(this.getContentGroup());
      this.group.add(this._controllerGroup = new Group4());
    };
    ScrollableLegendView2.prototype.resetInner = function() {
      _super.prototype.resetInner.call(this);
      this._controllerGroup.removeAll();
      this._containerGroup.removeClipPath();
      this._containerGroup.__rectSize = null;
    };
    ScrollableLegendView2.prototype.renderInner = function(itemAlign, legendModel, ecModel, api, selector2, orient, selectorPosition) {
      var self2 = this;
      _super.prototype.renderInner.call(this, itemAlign, legendModel, ecModel, api, selector2, orient, selectorPosition);
      var controllerGroup = this._controllerGroup;
      var pageIconSize = legendModel.get("pageIconSize", true);
      var pageIconSizeArr = isArray(pageIconSize) ? pageIconSize : [pageIconSize, pageIconSize];
      createPageButton("pagePrev", 0);
      var pageTextStyleModel = legendModel.getModel("pageTextStyle");
      controllerGroup.add(new Text_default({
        name: "pageText",
        style: {
          text: "xx/xx",
          fill: pageTextStyleModel.getTextColor(),
          font: pageTextStyleModel.getFont(),
          verticalAlign: "middle",
          align: "center"
        },
        silent: true
      }));
      createPageButton("pageNext", 1);
      function createPageButton(name, iconIdx) {
        var pageDataIndexName = name + "DataIndex";
        var icon = createIcon(legendModel.get("pageIcons", true)[legendModel.getOrient().name][iconIdx], {
          onclick: bind(self2._pageGo, self2, pageDataIndexName, legendModel, api)
        }, {
          x: -pageIconSizeArr[0] / 2,
          y: -pageIconSizeArr[1] / 2,
          width: pageIconSizeArr[0],
          height: pageIconSizeArr[1]
        });
        icon.name = name;
        controllerGroup.add(icon);
      }
    };
    ScrollableLegendView2.prototype.layoutInner = function(legendModel, itemAlign, maxSize, isFirstRender, selector2, selectorPosition) {
      var selectorGroup = this.getSelectorGroup();
      var orientIdx = legendModel.getOrient().index;
      var wh = WH2[orientIdx];
      var xy = XY2[orientIdx];
      var hw = WH2[1 - orientIdx];
      var yx = XY2[1 - orientIdx];
      selector2 && box("horizontal", selectorGroup, legendModel.get("selectorItemGap", true));
      var selectorButtonGap = legendModel.get("selectorButtonGap", true);
      var selectorRect = selectorGroup.getBoundingRect();
      var selectorPos = [-selectorRect.x, -selectorRect.y];
      var processMaxSize = clone(maxSize);
      selector2 && (processMaxSize[wh] = maxSize[wh] - selectorRect[wh] - selectorButtonGap);
      var mainRect = this._layoutContentAndController(legendModel, isFirstRender, processMaxSize, orientIdx, wh, hw, yx, xy);
      if (selector2) {
        if (selectorPosition === "end") {
          selectorPos[orientIdx] += mainRect[wh] + selectorButtonGap;
        } else {
          var offset = selectorRect[wh] + selectorButtonGap;
          selectorPos[orientIdx] -= offset;
          mainRect[xy] -= offset;
        }
        mainRect[wh] += selectorRect[wh] + selectorButtonGap;
        selectorPos[1 - orientIdx] += mainRect[yx] + mainRect[hw] / 2 - selectorRect[hw] / 2;
        mainRect[hw] = Math.max(mainRect[hw], selectorRect[hw]);
        mainRect[yx] = Math.min(mainRect[yx], selectorRect[yx] + selectorPos[1 - orientIdx]);
        selectorGroup.x = selectorPos[0];
        selectorGroup.y = selectorPos[1];
        selectorGroup.markRedraw();
      }
      return mainRect;
    };
    ScrollableLegendView2.prototype._layoutContentAndController = function(legendModel, isFirstRender, maxSize, orientIdx, wh, hw, yx, xy) {
      var contentGroup = this.getContentGroup();
      var containerGroup = this._containerGroup;
      var controllerGroup = this._controllerGroup;
      box(legendModel.get("orient"), contentGroup, legendModel.get("itemGap"), !orientIdx ? null : maxSize.width, orientIdx ? null : maxSize.height);
      box("horizontal", controllerGroup, legendModel.get("pageButtonItemGap", true));
      var contentRect = contentGroup.getBoundingRect();
      var controllerRect = controllerGroup.getBoundingRect();
      var showController = this._showController = contentRect[wh] > maxSize[wh];
      var contentPos = [-contentRect.x, -contentRect.y];
      if (!isFirstRender) {
        contentPos[orientIdx] = contentGroup[xy];
      }
      var containerPos = [0, 0];
      var controllerPos = [-controllerRect.x, -controllerRect.y];
      var pageButtonGap = retrieve2(legendModel.get("pageButtonGap", true), legendModel.get("itemGap", true));
      if (showController) {
        var pageButtonPosition = legendModel.get("pageButtonPosition", true);
        if (pageButtonPosition === "end") {
          controllerPos[orientIdx] += maxSize[wh] - controllerRect[wh];
        } else {
          containerPos[orientIdx] += controllerRect[wh] + pageButtonGap;
        }
      }
      controllerPos[1 - orientIdx] += contentRect[hw] / 2 - controllerRect[hw] / 2;
      contentGroup.setPosition(contentPos);
      containerGroup.setPosition(containerPos);
      controllerGroup.setPosition(controllerPos);
      var mainRect = {
        x: 0,
        y: 0
      };
      mainRect[wh] = showController ? maxSize[wh] : contentRect[wh];
      mainRect[hw] = Math.max(contentRect[hw], controllerRect[hw]);
      mainRect[yx] = Math.min(0, controllerRect[yx] + controllerPos[1 - orientIdx]);
      containerGroup.__rectSize = maxSize[wh];
      if (showController) {
        var clipShape = {
          x: 0,
          y: 0
        };
        clipShape[wh] = Math.max(maxSize[wh] - controllerRect[wh] - pageButtonGap, 0);
        clipShape[hw] = mainRect[hw];
        containerGroup.setClipPath(new Rect_default({
          shape: clipShape
        }));
        containerGroup.__rectSize = clipShape[wh];
      } else {
        controllerGroup.eachChild(function(child) {
          child.attr({
            invisible: true,
            silent: true
          });
        });
      }
      var pageInfo = this._getPageInfo(legendModel);
      pageInfo.pageIndex != null && updateProps(contentGroup, {
        x: pageInfo.contentPosition[0],
        y: pageInfo.contentPosition[1]
      }, showController ? legendModel : null);
      this._updatePageInfoView(legendModel, pageInfo);
      return mainRect;
    };
    ScrollableLegendView2.prototype._pageGo = function(to, legendModel, api) {
      var scrollDataIndex = this._getPageInfo(legendModel)[to];
      scrollDataIndex != null && api.dispatchAction({
        type: "legendScroll",
        scrollDataIndex,
        legendId: legendModel.id
      });
    };
    ScrollableLegendView2.prototype._updatePageInfoView = function(legendModel, pageInfo) {
      var controllerGroup = this._controllerGroup;
      each(["pagePrev", "pageNext"], function(name) {
        var key = name + "DataIndex";
        var canJump = pageInfo[key] != null;
        var icon = controllerGroup.childOfName(name);
        if (icon) {
          icon.setStyle("fill", canJump ? legendModel.get("pageIconColor", true) : legendModel.get("pageIconInactiveColor", true));
          icon.cursor = canJump ? "pointer" : "default";
        }
      });
      var pageText = controllerGroup.childOfName("pageText");
      var pageFormatter = legendModel.get("pageFormatter");
      var pageIndex = pageInfo.pageIndex;
      var current = pageIndex != null ? pageIndex + 1 : 0;
      var total = pageInfo.pageCount;
      pageText && pageFormatter && pageText.setStyle("text", isString(pageFormatter) ? pageFormatter.replace("{current}", current == null ? "" : current + "").replace("{total}", total == null ? "" : total + "") : pageFormatter({
        current,
        total
      }));
    };
    ScrollableLegendView2.prototype._getPageInfo = function(legendModel) {
      var scrollDataIndex = legendModel.get("scrollDataIndex", true);
      var contentGroup = this.getContentGroup();
      var containerRectSize = this._containerGroup.__rectSize;
      var orientIdx = legendModel.getOrient().index;
      var wh = WH2[orientIdx];
      var xy = XY2[orientIdx];
      var targetItemIndex = this._findTargetItemIndex(scrollDataIndex);
      var children = contentGroup.children();
      var targetItem = children[targetItemIndex];
      var itemCount = children.length;
      var pCount = !itemCount ? 0 : 1;
      var result = {
        contentPosition: [contentGroup.x, contentGroup.y],
        pageCount: pCount,
        pageIndex: pCount - 1,
        pagePrevDataIndex: null,
        pageNextDataIndex: null
      };
      if (!targetItem) {
        return result;
      }
      var targetItemInfo = getItemInfo(targetItem);
      result.contentPosition[orientIdx] = -targetItemInfo.s;
      for (var i = targetItemIndex + 1, winStartItemInfo = targetItemInfo, winEndItemInfo = targetItemInfo, currItemInfo = null; i <= itemCount; ++i) {
        currItemInfo = getItemInfo(children[i]);
        if (!currItemInfo && winEndItemInfo.e > winStartItemInfo.s + containerRectSize || currItemInfo && !intersect2(currItemInfo, winStartItemInfo.s)) {
          if (winEndItemInfo.i > winStartItemInfo.i) {
            winStartItemInfo = winEndItemInfo;
          } else {
            winStartItemInfo = currItemInfo;
          }
          if (winStartItemInfo) {
            if (result.pageNextDataIndex == null) {
              result.pageNextDataIndex = winStartItemInfo.i;
            }
            ++result.pageCount;
          }
        }
        winEndItemInfo = currItemInfo;
      }
      for (var i = targetItemIndex - 1, winStartItemInfo = targetItemInfo, winEndItemInfo = targetItemInfo, currItemInfo = null; i >= -1; --i) {
        currItemInfo = getItemInfo(children[i]);
        if ((!currItemInfo || !intersect2(winEndItemInfo, currItemInfo.s)) && winStartItemInfo.i < winEndItemInfo.i) {
          winEndItemInfo = winStartItemInfo;
          if (result.pagePrevDataIndex == null) {
            result.pagePrevDataIndex = winStartItemInfo.i;
          }
          ++result.pageCount;
          ++result.pageIndex;
        }
        winStartItemInfo = currItemInfo;
      }
      return result;
      function getItemInfo(el) {
        if (el) {
          var itemRect = el.getBoundingRect();
          var start2 = itemRect[xy] + el[xy];
          return {
            s: start2,
            e: start2 + itemRect[wh],
            i: el.__legendDataIndex
          };
        }
      }
      function intersect2(itemInfo, winStart) {
        return itemInfo.e >= winStart && itemInfo.s <= winStart + containerRectSize;
      }
    };
    ScrollableLegendView2.prototype._findTargetItemIndex = function(targetDataIndex) {
      if (!this._showController) {
        return 0;
      }
      var index;
      var contentGroup = this.getContentGroup();
      var defaultIndex;
      contentGroup.eachChild(function(child, idx) {
        var legendDataIdx = child.__legendDataIndex;
        if (defaultIndex == null && legendDataIdx != null) {
          defaultIndex = idx;
        }
        if (legendDataIdx === targetDataIndex) {
          index = idx;
        }
      });
      return index != null ? index : defaultIndex;
    };
    ScrollableLegendView2.type = "legend.scroll";
    return ScrollableLegendView2;
  }(LegendView_default);
  var ScrollableLegendView_default = ScrollableLegendView;

  // node_modules/echarts/lib/component/legend/scrollableLegendAction.js
  function installScrollableLegendAction(registers) {
    registers.registerAction("legendScroll", "legendscroll", function(payload, ecModel) {
      var scrollDataIndex = payload.scrollDataIndex;
      scrollDataIndex != null && ecModel.eachComponent({
        mainType: "legend",
        subType: "scroll",
        query: payload
      }, function(legendModel) {
        legendModel.setScrollDataIndex(scrollDataIndex);
      });
    });
  }

  // node_modules/echarts/lib/component/legend/installLegendScroll.js
  function install45(registers) {
    use(install44);
    registers.registerComponentModel(ScrollableLegendModel_default);
    registers.registerComponentView(ScrollableLegendView_default);
    installScrollableLegendAction(registers);
  }

  // node_modules/echarts/lib/component/legend/install.js
  function install46(registers) {
    use(install44);
    use(install45);
  }

  // node_modules/echarts/lib/component/dataZoom/InsideZoomModel.js
  var InsideZoomModel = function(_super) {
    __extends(InsideZoomModel2, _super);
    function InsideZoomModel2() {
      var _this = _super !== null && _super.apply(this, arguments) || this;
      _this.type = InsideZoomModel2.type;
      return _this;
    }
    InsideZoomModel2.type = "dataZoom.inside";
    InsideZoomModel2.defaultOption = inheritDefaultOption(DataZoomModel_default.defaultOption, {
      disabled: false,
      zoomLock: false,
      zoomOnMouseWheel: true,
      moveOnMouseMove: true,
      moveOnMouseWheel: false,
      preventDefaultMouseMove: true
    });
    return InsideZoomModel2;
  }(DataZoomModel_default);
  var InsideZoomModel_default = InsideZoomModel;

  // node_modules/echarts/lib/component/dataZoom/roams.js
  var inner21 = makeInner();
  function setViewInfoToCoordSysRecord(api, dataZoomModel, getRange) {
    inner21(api).coordSysRecordMap.each(function(coordSysRecord) {
      var dzInfo = coordSysRecord.dataZoomInfoMap.get(dataZoomModel.uid);
      if (dzInfo) {
        dzInfo.getRange = getRange;
      }
    });
  }
  function disposeCoordSysRecordIfNeeded(api, dataZoomModel) {
    var coordSysRecordMap = inner21(api).coordSysRecordMap;
    var coordSysKeyArr = coordSysRecordMap.keys();
    for (var i = 0; i < coordSysKeyArr.length; i++) {
      var coordSysKey = coordSysKeyArr[i];
      var coordSysRecord = coordSysRecordMap.get(coordSysKey);
      var dataZoomInfoMap = coordSysRecord.dataZoomInfoMap;
      if (dataZoomInfoMap) {
        var dzUid = dataZoomModel.uid;
        var dzInfo = dataZoomInfoMap.get(dzUid);
        if (dzInfo) {
          dataZoomInfoMap.removeKey(dzUid);
          if (!dataZoomInfoMap.keys().length) {
            disposeCoordSysRecord(coordSysRecordMap, coordSysRecord);
          }
        }
      }
    }
  }
  function disposeCoordSysRecord(coordSysRecordMap, coordSysRecord) {
    if (coordSysRecord) {
      coordSysRecordMap.removeKey(coordSysRecord.model.uid);
      var controller = coordSysRecord.controller;
      controller && controller.dispose();
    }
  }
  function createCoordSysRecord(api, coordSysModel) {
    var coordSysRecord = {
      model: coordSysModel,
      containsPoint: curry(containsPoint, coordSysModel),
      dispatchAction: curry(dispatchAction2, api),
      dataZoomInfoMap: null,
      controller: null
    };
    var controller = coordSysRecord.controller = new RoamController_default(api.getZr());
    each(["pan", "zoom", "scrollMove"], function(eventName) {
      controller.on(eventName, function(event) {
        var batch = [];
        coordSysRecord.dataZoomInfoMap.each(function(dzInfo) {
          if (!event.isAvailableBehavior(dzInfo.model.option)) {
            return;
          }
          var method = (dzInfo.getRange || {})[eventName];
          var range = method && method(dzInfo.dzReferCoordSysInfo, coordSysRecord.model.mainType, coordSysRecord.controller, event);
          !dzInfo.model.get("disabled", true) && range && batch.push({
            dataZoomId: dzInfo.model.id,
            start: range[0],
            end: range[1]
          });
        });
        batch.length && coordSysRecord.dispatchAction(batch);
      });
    });
    return coordSysRecord;
  }
  function dispatchAction2(api, batch) {
    if (!api.isDisposed()) {
      api.dispatchAction({
        type: "dataZoom",
        animation: {
          easing: "cubicOut",
          duration: 100
        },
        batch
      });
    }
  }
  function containsPoint(coordSysModel, e2, x, y) {
    return coordSysModel.coordinateSystem.containPoint([x, y]);
  }
  function mergeControllerParams(dataZoomInfoMap) {
    var controlType;
    var prefix = "type_";
    var typePriority = {
      "type_true": 2,
      "type_move": 1,
      "type_false": 0,
      "type_undefined": -1
    };
    var preventDefaultMouseMove = true;
    dataZoomInfoMap.each(function(dataZoomInfo) {
      var dataZoomModel = dataZoomInfo.model;
      var oneType = dataZoomModel.get("disabled", true) ? false : dataZoomModel.get("zoomLock", true) ? "move" : true;
      if (typePriority[prefix + oneType] > typePriority[prefix + controlType]) {
        controlType = oneType;
      }
      preventDefaultMouseMove = preventDefaultMouseMove && dataZoomModel.get("preventDefaultMouseMove", true);
    });
    return {
      controlType,
      opt: {
        zoomOnMouseWheel: true,
        moveOnMouseMove: true,
        moveOnMouseWheel: true,
        preventDefaultMouseMove: !!preventDefaultMouseMove
      }
    };
  }
  function installDataZoomRoamProcessor(registers) {
    registers.registerProcessor(registers.PRIORITY.PROCESSOR.FILTER, function(ecModel, api) {
      var apiInner = inner21(api);
      var coordSysRecordMap = apiInner.coordSysRecordMap || (apiInner.coordSysRecordMap = createHashMap());
      coordSysRecordMap.each(function(coordSysRecord) {
        coordSysRecord.dataZoomInfoMap = null;
      });
      ecModel.eachComponent({
        mainType: "dataZoom",
        subType: "inside"
      }, function(dataZoomModel) {
        var dzReferCoordSysWrap = collectReferCoordSysModelInfo(dataZoomModel);
        each(dzReferCoordSysWrap.infoList, function(dzCoordSysInfo) {
          var coordSysUid = dzCoordSysInfo.model.uid;
          var coordSysRecord = coordSysRecordMap.get(coordSysUid) || coordSysRecordMap.set(coordSysUid, createCoordSysRecord(api, dzCoordSysInfo.model));
          var dataZoomInfoMap = coordSysRecord.dataZoomInfoMap || (coordSysRecord.dataZoomInfoMap = createHashMap());
          dataZoomInfoMap.set(dataZoomModel.uid, {
            dzReferCoordSysInfo: dzCoordSysInfo,
            model: dataZoomModel,
            getRange: null
          });
        });
      });
      coordSysRecordMap.each(function(coordSysRecord) {
        var controller = coordSysRecord.controller;
        var firstDzInfo;
        var dataZoomInfoMap = coordSysRecord.dataZoomInfoMap;
        if (dataZoomInfoMap) {
          var firstDzKey = dataZoomInfoMap.keys()[0];
          if (firstDzKey != null) {
            firstDzInfo = dataZoomInfoMap.get(firstDzKey);
          }
        }
        if (!firstDzInfo) {
          disposeCoordSysRecord(coordSysRecordMap, coordSysRecord);
          return;
        }
        var controllerParams = mergeControllerParams(dataZoomInfoMap);
        controller.enable(controllerParams.controlType, controllerParams.opt);
        controller.setPointerChecker(coordSysRecord.containsPoint);
        createOrUpdate(coordSysRecord, "dispatchAction", firstDzInfo.model.get("throttle", true), "fixRate");
      });
    });
  }

  // node_modules/echarts/lib/component/dataZoom/InsideZoomView.js
  var InsideZoomView = function(_super) {
    __extends(InsideZoomView2, _super);
    function InsideZoomView2() {
      var _this = _super !== null && _super.apply(this, arguments) || this;
      _this.type = "dataZoom.inside";
      return _this;
    }
    InsideZoomView2.prototype.render = function(dataZoomModel, ecModel, api) {
      _super.prototype.render.apply(this, arguments);
      if (dataZoomModel.noTarget()) {
        this._clear();
        return;
      }
      this.range = dataZoomModel.getPercentRange();
      setViewInfoToCoordSysRecord(api, dataZoomModel, {
        pan: bind(getRangeHandlers.pan, this),
        zoom: bind(getRangeHandlers.zoom, this),
        scrollMove: bind(getRangeHandlers.scrollMove, this)
      });
    };
    InsideZoomView2.prototype.dispose = function() {
      this._clear();
      _super.prototype.dispose.apply(this, arguments);
    };
    InsideZoomView2.prototype._clear = function() {
      disposeCoordSysRecordIfNeeded(this.api, this.dataZoomModel);
      this.range = null;
    };
    InsideZoomView2.type = "dataZoom.inside";
    return InsideZoomView2;
  }(DataZoomView_default);
  var getRangeHandlers = {
    zoom: function(coordSysInfo, coordSysMainType, controller, e2) {
      var lastRange = this.range;
      var range = lastRange.slice();
      var axisModel = coordSysInfo.axisModels[0];
      if (!axisModel) {
        return;
      }
      var directionInfo = getDirectionInfo[coordSysMainType](null, [e2.originX, e2.originY], axisModel, controller, coordSysInfo);
      var percentPoint = (directionInfo.signal > 0 ? directionInfo.pixelStart + directionInfo.pixelLength - directionInfo.pixel : directionInfo.pixel - directionInfo.pixelStart) / directionInfo.pixelLength * (range[1] - range[0]) + range[0];
      var scale4 = Math.max(1 / e2.scale, 0);
      range[0] = (range[0] - percentPoint) * scale4 + percentPoint;
      range[1] = (range[1] - percentPoint) * scale4 + percentPoint;
      var minMaxSpan = this.dataZoomModel.findRepresentativeAxisProxy().getMinMaxSpan();
      sliderMove(0, range, [0, 100], 0, minMaxSpan.minSpan, minMaxSpan.maxSpan);
      this.range = range;
      if (lastRange[0] !== range[0] || lastRange[1] !== range[1]) {
        return range;
      }
    },
    pan: makeMover(function(range, axisModel, coordSysInfo, coordSysMainType, controller, e2) {
      var directionInfo = getDirectionInfo[coordSysMainType]([e2.oldX, e2.oldY], [e2.newX, e2.newY], axisModel, controller, coordSysInfo);
      return directionInfo.signal * (range[1] - range[0]) * directionInfo.pixel / directionInfo.pixelLength;
    }),
    scrollMove: makeMover(function(range, axisModel, coordSysInfo, coordSysMainType, controller, e2) {
      var directionInfo = getDirectionInfo[coordSysMainType]([0, 0], [e2.scrollDelta, e2.scrollDelta], axisModel, controller, coordSysInfo);
      return directionInfo.signal * (range[1] - range[0]) * e2.scrollDelta;
    })
  };
  function makeMover(getPercentDelta) {
    return function(coordSysInfo, coordSysMainType, controller, e2) {
      var lastRange = this.range;
      var range = lastRange.slice();
      var axisModel = coordSysInfo.axisModels[0];
      if (!axisModel) {
        return;
      }
      var percentDelta = getPercentDelta(range, axisModel, coordSysInfo, coordSysMainType, controller, e2);
      sliderMove(percentDelta, range, [0, 100], "all");
      this.range = range;
      if (lastRange[0] !== range[0] || lastRange[1] !== range[1]) {
        return range;
      }
    };
  }
  var getDirectionInfo = {
    grid: function(oldPoint, newPoint, axisModel, controller, coordSysInfo) {
      var axis = axisModel.axis;
      var ret = {};
      var rect = coordSysInfo.model.coordinateSystem.getRect();
      oldPoint = oldPoint || [0, 0];
      if (axis.dim === "x") {
        ret.pixel = newPoint[0] - oldPoint[0];
        ret.pixelLength = rect.width;
        ret.pixelStart = rect.x;
        ret.signal = axis.inverse ? 1 : -1;
      } else {
        ret.pixel = newPoint[1] - oldPoint[1];
        ret.pixelLength = rect.height;
        ret.pixelStart = rect.y;
        ret.signal = axis.inverse ? -1 : 1;
      }
      return ret;
    },
    polar: function(oldPoint, newPoint, axisModel, controller, coordSysInfo) {
      var axis = axisModel.axis;
      var ret = {};
      var polar = coordSysInfo.model.coordinateSystem;
      var radiusExtent = polar.getRadiusAxis().getExtent();
      var angleExtent = polar.getAngleAxis().getExtent();
      oldPoint = oldPoint ? polar.pointToCoord(oldPoint) : [0, 0];
      newPoint = polar.pointToCoord(newPoint);
      if (axisModel.mainType === "radiusAxis") {
        ret.pixel = newPoint[0] - oldPoint[0];
        ret.pixelLength = radiusExtent[1] - radiusExtent[0];
        ret.pixelStart = radiusExtent[0];
        ret.signal = axis.inverse ? 1 : -1;
      } else {
        ret.pixel = newPoint[1] - oldPoint[1];
        ret.pixelLength = angleExtent[1] - angleExtent[0];
        ret.pixelStart = angleExtent[0];
        ret.signal = axis.inverse ? -1 : 1;
      }
      return ret;
    },
    singleAxis: function(oldPoint, newPoint, axisModel, controller, coordSysInfo) {
      var axis = axisModel.axis;
      var rect = coordSysInfo.model.coordinateSystem.getRect();
      var ret = {};
      oldPoint = oldPoint || [0, 0];
      if (axis.orient === "horizontal") {
        ret.pixel = newPoint[0] - oldPoint[0];
        ret.pixelLength = rect.width;
        ret.pixelStart = rect.x;
        ret.signal = axis.inverse ? 1 : -1;
      } else {
        ret.pixel = newPoint[1] - oldPoint[1];
        ret.pixelLength = rect.height;
        ret.pixelStart = rect.y;
        ret.signal = axis.inverse ? -1 : 1;
      }
      return ret;
    }
  };
  var InsideZoomView_default = InsideZoomView;

  // node_modules/echarts/lib/component/dataZoom/installDataZoomInside.js
  function install47(registers) {
    installCommon(registers);
    registers.registerComponentModel(InsideZoomModel_default);
    registers.registerComponentView(InsideZoomView_default);
    installDataZoomRoamProcessor(registers);
  }

  // node_modules/echarts/lib/component/dataZoom/SliderZoomModel.js
  var SliderZoomModel = function(_super) {
    __extends(SliderZoomModel2, _super);
    function SliderZoomModel2() {
      var _this = _super !== null && _super.apply(this, arguments) || this;
      _this.type = SliderZoomModel2.type;
      return _this;
    }
    SliderZoomModel2.type = "dataZoom.slider";
    SliderZoomModel2.layoutMode = "box";
    SliderZoomModel2.defaultOption = inheritDefaultOption(DataZoomModel_default.defaultOption, {
      show: true,
      right: "ph",
      top: "ph",
      width: "ph",
      height: "ph",
      left: null,
      bottom: null,
      borderColor: "#d2dbee",
      borderRadius: 3,
      backgroundColor: "rgba(47,69,84,0)",
      dataBackground: {
        lineStyle: {
          color: "#d2dbee",
          width: 0.5
        },
        areaStyle: {
          color: "#d2dbee",
          opacity: 0.2
        }
      },
      selectedDataBackground: {
        lineStyle: {
          color: "#8fb0f7",
          width: 0.5
        },
        areaStyle: {
          color: "#8fb0f7",
          opacity: 0.2
        }
      },
      fillerColor: "rgba(135,175,274,0.2)",
      handleIcon: "path://M-9.35,34.56V42m0-40V9.5m-2,0h4a2,2,0,0,1,2,2v21a2,2,0,0,1-2,2h-4a2,2,0,0,1-2-2v-21A2,2,0,0,1-11.35,9.5Z",
      handleSize: "100%",
      handleStyle: {
        color: "#fff",
        borderColor: "#ACB8D1"
      },
      moveHandleSize: 7,
      moveHandleIcon: "path://M-320.9-50L-320.9-50c18.1,0,27.1,9,27.1,27.1V85.7c0,18.1-9,27.1-27.1,27.1l0,0c-18.1,0-27.1-9-27.1-27.1V-22.9C-348-41-339-50-320.9-50z M-212.3-50L-212.3-50c18.1,0,27.1,9,27.1,27.1V85.7c0,18.1-9,27.1-27.1,27.1l0,0c-18.1,0-27.1-9-27.1-27.1V-22.9C-239.4-41-230.4-50-212.3-50z M-103.7-50L-103.7-50c18.1,0,27.1,9,27.1,27.1V85.7c0,18.1-9,27.1-27.1,27.1l0,0c-18.1,0-27.1-9-27.1-27.1V-22.9C-130.9-41-121.8-50-103.7-50z",
      moveHandleStyle: {
        color: "#D2DBEE",
        opacity: 0.7
      },
      showDetail: true,
      showDataShadow: "auto",
      realtime: true,
      zoomLock: false,
      textStyle: {
        color: "#6E7079"
      },
      brushSelect: true,
      brushStyle: {
        color: "rgba(135,175,274,0.15)"
      },
      emphasis: {
        handleStyle: {
          borderColor: "#8FB0F7"
        },
        moveHandleStyle: {
          color: "#8FB0F7"
        }
      }
    });
    return SliderZoomModel2;
  }(DataZoomModel_default);
  var SliderZoomModel_default = SliderZoomModel;

  // node_modules/echarts/lib/component/dataZoom/SliderZoomView.js
  var Rect3 = Rect_default;
  var DEFAULT_LOCATION_EDGE_GAP = 7;
  var DEFAULT_FRAME_BORDER_WIDTH = 1;
  var DEFAULT_FILLER_SIZE = 30;
  var DEFAULT_MOVE_HANDLE_SIZE = 7;
  var HORIZONTAL = "horizontal";
  var VERTICAL = "vertical";
  var LABEL_GAP = 5;
  var SHOW_DATA_SHADOW_SERIES_TYPE = ["line", "bar", "candlestick", "scatter"];
  var REALTIME_ANIMATION_CONFIG = {
    easing: "cubicOut",
    duration: 100,
    delay: 0
  };
  var SliderZoomView = function(_super) {
    __extends(SliderZoomView2, _super);
    function SliderZoomView2() {
      var _this = _super !== null && _super.apply(this, arguments) || this;
      _this.type = SliderZoomView2.type;
      _this._displayables = {};
      return _this;
    }
    SliderZoomView2.prototype.init = function(ecModel, api) {
      this.api = api;
      this._onBrush = bind(this._onBrush, this);
      this._onBrushEnd = bind(this._onBrushEnd, this);
    };
    SliderZoomView2.prototype.render = function(dataZoomModel, ecModel, api, payload) {
      _super.prototype.render.apply(this, arguments);
      createOrUpdate(this, "_dispatchZoomAction", dataZoomModel.get("throttle"), "fixRate");
      this._orient = dataZoomModel.getOrient();
      if (dataZoomModel.get("show") === false) {
        this.group.removeAll();
        return;
      }
      if (dataZoomModel.noTarget()) {
        this._clear();
        this.group.removeAll();
        return;
      }
      if (!payload || payload.type !== "dataZoom" || payload.from !== this.uid) {
        this._buildView();
      }
      this._updateView();
    };
    SliderZoomView2.prototype.dispose = function() {
      this._clear();
      _super.prototype.dispose.apply(this, arguments);
    };
    SliderZoomView2.prototype._clear = function() {
      clear(this, "_dispatchZoomAction");
      var zr = this.api.getZr();
      zr.off("mousemove", this._onBrush);
      zr.off("mouseup", this._onBrushEnd);
    };
    SliderZoomView2.prototype._buildView = function() {
      var thisGroup = this.group;
      thisGroup.removeAll();
      this._brushing = false;
      this._displayables.brushRect = null;
      this._resetLocation();
      this._resetInterval();
      var barGroup = this._displayables.sliderGroup = new Group_default();
      this._renderBackground();
      this._renderHandle();
      this._renderDataShadow();
      thisGroup.add(barGroup);
      this._positionGroup();
    };
    SliderZoomView2.prototype._resetLocation = function() {
      var dataZoomModel = this.dataZoomModel;
      var api = this.api;
      var showMoveHandle = dataZoomModel.get("brushSelect");
      var moveHandleSize = showMoveHandle ? DEFAULT_MOVE_HANDLE_SIZE : 0;
      var coordRect = this._findCoordRect();
      var ecSize = {
        width: api.getWidth(),
        height: api.getHeight()
      };
      var positionInfo = this._orient === HORIZONTAL ? {
        right: ecSize.width - coordRect.x - coordRect.width,
        top: ecSize.height - DEFAULT_FILLER_SIZE - DEFAULT_LOCATION_EDGE_GAP - moveHandleSize,
        width: coordRect.width,
        height: DEFAULT_FILLER_SIZE
      } : {
        right: DEFAULT_LOCATION_EDGE_GAP,
        top: coordRect.y,
        width: DEFAULT_FILLER_SIZE,
        height: coordRect.height
      };
      var layoutParams = getLayoutParams(dataZoomModel.option);
      each(["right", "top", "width", "height"], function(name) {
        if (layoutParams[name] === "ph") {
          layoutParams[name] = positionInfo[name];
        }
      });
      var layoutRect = getLayoutRect(layoutParams, ecSize);
      this._location = {
        x: layoutRect.x,
        y: layoutRect.y
      };
      this._size = [layoutRect.width, layoutRect.height];
      this._orient === VERTICAL && this._size.reverse();
    };
    SliderZoomView2.prototype._positionGroup = function() {
      var thisGroup = this.group;
      var location = this._location;
      var orient = this._orient;
      var targetAxisModel = this.dataZoomModel.getFirstTargetAxisModel();
      var inverse = targetAxisModel && targetAxisModel.get("inverse");
      var sliderGroup = this._displayables.sliderGroup;
      var otherAxisInverse = (this._dataShadowInfo || {}).otherAxisInverse;
      sliderGroup.attr(orient === HORIZONTAL && !inverse ? {
        scaleY: otherAxisInverse ? 1 : -1,
        scaleX: 1
      } : orient === HORIZONTAL && inverse ? {
        scaleY: otherAxisInverse ? 1 : -1,
        scaleX: -1
      } : orient === VERTICAL && !inverse ? {
        scaleY: otherAxisInverse ? -1 : 1,
        scaleX: 1,
        rotation: Math.PI / 2
      } : {
        scaleY: otherAxisInverse ? -1 : 1,
        scaleX: -1,
        rotation: Math.PI / 2
      });
      var rect = thisGroup.getBoundingRect([sliderGroup]);
      thisGroup.x = location.x - rect.x;
      thisGroup.y = location.y - rect.y;
      thisGroup.markRedraw();
    };
    SliderZoomView2.prototype._getViewExtent = function() {
      return [0, this._size[0]];
    };
    SliderZoomView2.prototype._renderBackground = function() {
      var dataZoomModel = this.dataZoomModel;
      var size = this._size;
      var barGroup = this._displayables.sliderGroup;
      var brushSelect = dataZoomModel.get("brushSelect");
      barGroup.add(new Rect3({
        silent: true,
        shape: {
          x: 0,
          y: 0,
          width: size[0],
          height: size[1]
        },
        style: {
          fill: dataZoomModel.get("backgroundColor")
        },
        z2: -40
      }));
      var clickPanel = new Rect3({
        shape: {
          x: 0,
          y: 0,
          width: size[0],
          height: size[1]
        },
        style: {
          fill: "transparent"
        },
        z2: 0,
        onclick: bind(this._onClickPanel, this)
      });
      var zr = this.api.getZr();
      if (brushSelect) {
        clickPanel.on("mousedown", this._onBrushStart, this);
        clickPanel.cursor = "crosshair";
        zr.on("mousemove", this._onBrush);
        zr.on("mouseup", this._onBrushEnd);
      } else {
        zr.off("mousemove", this._onBrush);
        zr.off("mouseup", this._onBrushEnd);
      }
      barGroup.add(clickPanel);
    };
    SliderZoomView2.prototype._renderDataShadow = function() {
      var info = this._dataShadowInfo = this._prepareDataShadowInfo();
      this._displayables.dataShadowSegs = [];
      if (!info) {
        return;
      }
      var size = this._size;
      var oldSize = this._shadowSize || [];
      var seriesModel = info.series;
      var data = seriesModel.getRawData();
      var otherDim = seriesModel.getShadowDim ? seriesModel.getShadowDim() : info.otherDim;
      if (otherDim == null) {
        return;
      }
      var polygonPts = this._shadowPolygonPts;
      var polylinePts = this._shadowPolylinePts;
      if (data !== this._shadowData || otherDim !== this._shadowDim || size[0] !== oldSize[0] || size[1] !== oldSize[1]) {
        var otherDataExtent_1 = data.getDataExtent(otherDim);
        var otherOffset = (otherDataExtent_1[1] - otherDataExtent_1[0]) * 0.3;
        otherDataExtent_1 = [otherDataExtent_1[0] - otherOffset, otherDataExtent_1[1] + otherOffset];
        var otherShadowExtent_1 = [0, size[1]];
        var thisShadowExtent = [0, size[0]];
        var areaPoints_1 = [[size[0], 0], [0, 0]];
        var linePoints_1 = [];
        var step_1 = thisShadowExtent[1] / (data.count() - 1);
        var thisCoord_1 = 0;
        var stride_1 = Math.round(data.count() / size[0]);
        var lastIsEmpty_1;
        data.each([otherDim], function(value, index) {
          if (stride_1 > 0 && index % stride_1) {
            thisCoord_1 += step_1;
            return;
          }
          var isEmpty = value == null || isNaN(value) || value === "";
          var otherCoord = isEmpty ? 0 : linearMap(value, otherDataExtent_1, otherShadowExtent_1, true);
          if (isEmpty && !lastIsEmpty_1 && index) {
            areaPoints_1.push([areaPoints_1[areaPoints_1.length - 1][0], 0]);
            linePoints_1.push([linePoints_1[linePoints_1.length - 1][0], 0]);
          } else if (!isEmpty && lastIsEmpty_1) {
            areaPoints_1.push([thisCoord_1, 0]);
            linePoints_1.push([thisCoord_1, 0]);
          }
          areaPoints_1.push([thisCoord_1, otherCoord]);
          linePoints_1.push([thisCoord_1, otherCoord]);
          thisCoord_1 += step_1;
          lastIsEmpty_1 = isEmpty;
        });
        polygonPts = this._shadowPolygonPts = areaPoints_1;
        polylinePts = this._shadowPolylinePts = linePoints_1;
      }
      this._shadowData = data;
      this._shadowDim = otherDim;
      this._shadowSize = [size[0], size[1]];
      var dataZoomModel = this.dataZoomModel;
      function createDataShadowGroup(isSelectedArea) {
        var model = dataZoomModel.getModel(isSelectedArea ? "selectedDataBackground" : "dataBackground");
        var group2 = new Group_default();
        var polygon = new Polygon_default({
          shape: {
            points: polygonPts
          },
          segmentIgnoreThreshold: 1,
          style: model.getModel("areaStyle").getAreaStyle(),
          silent: true,
          z2: -20
        });
        var polyline = new Polyline_default({
          shape: {
            points: polylinePts
          },
          segmentIgnoreThreshold: 1,
          style: model.getModel("lineStyle").getLineStyle(),
          silent: true,
          z2: -19
        });
        group2.add(polygon);
        group2.add(polyline);
        return group2;
      }
      for (var i = 0; i < 3; i++) {
        var group = createDataShadowGroup(i === 1);
        this._displayables.sliderGroup.add(group);
        this._displayables.dataShadowSegs.push(group);
      }
    };
    SliderZoomView2.prototype._prepareDataShadowInfo = function() {
      var dataZoomModel = this.dataZoomModel;
      var showDataShadow = dataZoomModel.get("showDataShadow");
      if (showDataShadow === false) {
        return;
      }
      var result;
      var ecModel = this.ecModel;
      dataZoomModel.eachTargetAxis(function(axisDim, axisIndex) {
        var seriesModels = dataZoomModel.getAxisProxy(axisDim, axisIndex).getTargetSeriesModels();
        each(seriesModels, function(seriesModel) {
          if (result) {
            return;
          }
          if (showDataShadow !== true && indexOf(SHOW_DATA_SHADOW_SERIES_TYPE, seriesModel.get("type")) < 0) {
            return;
          }
          var thisAxis = ecModel.getComponent(getAxisMainType(axisDim), axisIndex).axis;
          var otherDim = getOtherDim(axisDim);
          var otherAxisInverse;
          var coordSys = seriesModel.coordinateSystem;
          if (otherDim != null && coordSys.getOtherAxis) {
            otherAxisInverse = coordSys.getOtherAxis(thisAxis).inverse;
          }
          otherDim = seriesModel.getData().mapDimension(otherDim);
          result = {
            thisAxis,
            series: seriesModel,
            thisDim: axisDim,
            otherDim,
            otherAxisInverse
          };
        }, this);
      }, this);
      return result;
    };
    SliderZoomView2.prototype._renderHandle = function() {
      var thisGroup = this.group;
      var displayables = this._displayables;
      var handles = displayables.handles = [null, null];
      var handleLabels = displayables.handleLabels = [null, null];
      var sliderGroup = this._displayables.sliderGroup;
      var size = this._size;
      var dataZoomModel = this.dataZoomModel;
      var api = this.api;
      var borderRadius = dataZoomModel.get("borderRadius") || 0;
      var brushSelect = dataZoomModel.get("brushSelect");
      var filler = displayables.filler = new Rect3({
        silent: brushSelect,
        style: {
          fill: dataZoomModel.get("fillerColor")
        },
        textConfig: {
          position: "inside"
        }
      });
      sliderGroup.add(filler);
      sliderGroup.add(new Rect3({
        silent: true,
        subPixelOptimize: true,
        shape: {
          x: 0,
          y: 0,
          width: size[0],
          height: size[1],
          r: borderRadius
        },
        style: {
          stroke: dataZoomModel.get("dataBackgroundColor") || dataZoomModel.get("borderColor"),
          lineWidth: DEFAULT_FRAME_BORDER_WIDTH,
          fill: "rgba(0,0,0,0)"
        }
      }));
      each([0, 1], function(handleIndex) {
        var iconStr = dataZoomModel.get("handleIcon");
        if (!symbolBuildProxies[iconStr] && iconStr.indexOf("path://") < 0 && iconStr.indexOf("image://") < 0) {
          iconStr = "path://" + iconStr;
          if (true) {
            deprecateLog("handleIcon now needs 'path://' prefix when using a path string");
          }
        }
        var path = createSymbol(iconStr, -1, 0, 2, 2, null, true);
        path.attr({
          cursor: getCursor(this._orient),
          draggable: true,
          drift: bind(this._onDragMove, this, handleIndex),
          ondragend: bind(this._onDragEnd, this),
          onmouseover: bind(this._showDataInfo, this, true),
          onmouseout: bind(this._showDataInfo, this, false),
          z2: 5
        });
        var bRect = path.getBoundingRect();
        var handleSize = dataZoomModel.get("handleSize");
        this._handleHeight = parsePercent2(handleSize, this._size[1]);
        this._handleWidth = bRect.width / bRect.height * this._handleHeight;
        path.setStyle(dataZoomModel.getModel("handleStyle").getItemStyle());
        path.style.strokeNoScale = true;
        path.rectHover = true;
        path.ensureState("emphasis").style = dataZoomModel.getModel(["emphasis", "handleStyle"]).getItemStyle();
        enableHoverEmphasis(path);
        var handleColor = dataZoomModel.get("handleColor");
        if (handleColor != null) {
          path.style.fill = handleColor;
        }
        sliderGroup.add(handles[handleIndex] = path);
        var textStyleModel = dataZoomModel.getModel("textStyle");
        thisGroup.add(handleLabels[handleIndex] = new Text_default({
          silent: true,
          invisible: true,
          style: createTextStyle(textStyleModel, {
            x: 0,
            y: 0,
            text: "",
            verticalAlign: "middle",
            align: "center",
            fill: textStyleModel.getTextColor(),
            font: textStyleModel.getFont()
          }),
          z2: 10
        }));
      }, this);
      var actualMoveZone = filler;
      if (brushSelect) {
        var moveHandleHeight = parsePercent2(dataZoomModel.get("moveHandleSize"), size[1]);
        var moveHandle_1 = displayables.moveHandle = new Rect_default({
          style: dataZoomModel.getModel("moveHandleStyle").getItemStyle(),
          silent: true,
          shape: {
            r: [0, 0, 2, 2],
            y: size[1] - 0.5,
            height: moveHandleHeight
          }
        });
        var iconSize = moveHandleHeight * 0.8;
        var moveHandleIcon = displayables.moveHandleIcon = createSymbol(dataZoomModel.get("moveHandleIcon"), -iconSize / 2, -iconSize / 2, iconSize, iconSize, "#fff", true);
        moveHandleIcon.silent = true;
        moveHandleIcon.y = size[1] + moveHandleHeight / 2 - 0.5;
        moveHandle_1.ensureState("emphasis").style = dataZoomModel.getModel(["emphasis", "moveHandleStyle"]).getItemStyle();
        var moveZoneExpandSize = Math.min(size[1] / 2, Math.max(moveHandleHeight, 10));
        actualMoveZone = displayables.moveZone = new Rect_default({
          invisible: true,
          shape: {
            y: size[1] - moveZoneExpandSize,
            height: moveHandleHeight + moveZoneExpandSize
          }
        });
        actualMoveZone.on("mouseover", function() {
          api.enterEmphasis(moveHandle_1);
        }).on("mouseout", function() {
          api.leaveEmphasis(moveHandle_1);
        });
        sliderGroup.add(moveHandle_1);
        sliderGroup.add(moveHandleIcon);
        sliderGroup.add(actualMoveZone);
      }
      actualMoveZone.attr({
        draggable: true,
        cursor: getCursor(this._orient),
        drift: bind(this._onDragMove, this, "all"),
        ondragstart: bind(this._showDataInfo, this, true),
        ondragend: bind(this._onDragEnd, this),
        onmouseover: bind(this._showDataInfo, this, true),
        onmouseout: bind(this._showDataInfo, this, false)
      });
    };
    SliderZoomView2.prototype._resetInterval = function() {
      var range = this._range = this.dataZoomModel.getPercentRange();
      var viewExtent = this._getViewExtent();
      this._handleEnds = [linearMap(range[0], [0, 100], viewExtent, true), linearMap(range[1], [0, 100], viewExtent, true)];
    };
    SliderZoomView2.prototype._updateInterval = function(handleIndex, delta) {
      var dataZoomModel = this.dataZoomModel;
      var handleEnds = this._handleEnds;
      var viewExtend = this._getViewExtent();
      var minMaxSpan = dataZoomModel.findRepresentativeAxisProxy().getMinMaxSpan();
      var percentExtent = [0, 100];
      sliderMove(delta, handleEnds, viewExtend, dataZoomModel.get("zoomLock") ? "all" : handleIndex, minMaxSpan.minSpan != null ? linearMap(minMaxSpan.minSpan, percentExtent, viewExtend, true) : null, minMaxSpan.maxSpan != null ? linearMap(minMaxSpan.maxSpan, percentExtent, viewExtend, true) : null);
      var lastRange = this._range;
      var range = this._range = asc([linearMap(handleEnds[0], viewExtend, percentExtent, true), linearMap(handleEnds[1], viewExtend, percentExtent, true)]);
      return !lastRange || lastRange[0] !== range[0] || lastRange[1] !== range[1];
    };
    SliderZoomView2.prototype._updateView = function(nonRealtime) {
      var displaybles = this._displayables;
      var handleEnds = this._handleEnds;
      var handleInterval = asc(handleEnds.slice());
      var size = this._size;
      each([0, 1], function(handleIndex) {
        var handle = displaybles.handles[handleIndex];
        var handleHeight = this._handleHeight;
        handle.attr({
          scaleX: handleHeight / 2,
          scaleY: handleHeight / 2,
          x: handleEnds[handleIndex] + (handleIndex ? -1 : 1),
          y: size[1] / 2 - handleHeight / 2
        });
      }, this);
      displaybles.filler.setShape({
        x: handleInterval[0],
        y: 0,
        width: handleInterval[1] - handleInterval[0],
        height: size[1]
      });
      var viewExtent = {
        x: handleInterval[0],
        width: handleInterval[1] - handleInterval[0]
      };
      if (displaybles.moveHandle) {
        displaybles.moveHandle.setShape(viewExtent);
        displaybles.moveZone.setShape(viewExtent);
        displaybles.moveZone.getBoundingRect();
        displaybles.moveHandleIcon && displaybles.moveHandleIcon.attr("x", viewExtent.x + viewExtent.width / 2);
      }
      var dataShadowSegs = displaybles.dataShadowSegs;
      var segIntervals = [0, handleInterval[0], handleInterval[1], size[0]];
      for (var i = 0; i < dataShadowSegs.length; i++) {
        var segGroup = dataShadowSegs[i];
        var clipPath = segGroup.getClipPath();
        if (!clipPath) {
          clipPath = new Rect_default();
          segGroup.setClipPath(clipPath);
        }
        clipPath.setShape({
          x: segIntervals[i],
          y: 0,
          width: segIntervals[i + 1] - segIntervals[i],
          height: size[1]
        });
      }
      this._updateDataInfo(nonRealtime);
    };
    SliderZoomView2.prototype._updateDataInfo = function(nonRealtime) {
      var dataZoomModel = this.dataZoomModel;
      var displaybles = this._displayables;
      var handleLabels = displaybles.handleLabels;
      var orient = this._orient;
      var labelTexts = ["", ""];
      if (dataZoomModel.get("showDetail")) {
        var axisProxy = dataZoomModel.findRepresentativeAxisProxy();
        if (axisProxy) {
          var axis = axisProxy.getAxisModel().axis;
          var range = this._range;
          var dataInterval = nonRealtime ? axisProxy.calculateDataWindow({
            start: range[0],
            end: range[1]
          }).valueWindow : axisProxy.getDataValueWindow();
          labelTexts = [this._formatLabel(dataInterval[0], axis), this._formatLabel(dataInterval[1], axis)];
        }
      }
      var orderedHandleEnds = asc(this._handleEnds.slice());
      setLabel.call(this, 0);
      setLabel.call(this, 1);
      function setLabel(handleIndex) {
        var barTransform = getTransform(displaybles.handles[handleIndex].parent, this.group);
        var direction = transformDirection(handleIndex === 0 ? "right" : "left", barTransform);
        var offset = this._handleWidth / 2 + LABEL_GAP;
        var textPoint = applyTransform2([orderedHandleEnds[handleIndex] + (handleIndex === 0 ? -offset : offset), this._size[1] / 2], barTransform);
        handleLabels[handleIndex].setStyle({
          x: textPoint[0],
          y: textPoint[1],
          verticalAlign: orient === HORIZONTAL ? "middle" : direction,
          align: orient === HORIZONTAL ? direction : "center",
          text: labelTexts[handleIndex]
        });
      }
    };
    SliderZoomView2.prototype._formatLabel = function(value, axis) {
      var dataZoomModel = this.dataZoomModel;
      var labelFormatter = dataZoomModel.get("labelFormatter");
      var labelPrecision = dataZoomModel.get("labelPrecision");
      if (labelPrecision == null || labelPrecision === "auto") {
        labelPrecision = axis.getPixelPrecision();
      }
      var valueStr = value == null || isNaN(value) ? "" : axis.type === "category" || axis.type === "time" ? axis.scale.getLabel({
        value: Math.round(value)
      }) : value.toFixed(Math.min(labelPrecision, 20));
      return isFunction(labelFormatter) ? labelFormatter(value, valueStr) : isString(labelFormatter) ? labelFormatter.replace("{value}", valueStr) : valueStr;
    };
    SliderZoomView2.prototype._showDataInfo = function(showOrHide) {
      showOrHide = this._dragging || showOrHide;
      var displayables = this._displayables;
      var handleLabels = displayables.handleLabels;
      handleLabels[0].attr("invisible", !showOrHide);
      handleLabels[1].attr("invisible", !showOrHide);
      displayables.moveHandle && this.api[showOrHide ? "enterEmphasis" : "leaveEmphasis"](displayables.moveHandle, 1);
    };
    SliderZoomView2.prototype._onDragMove = function(handleIndex, dx, dy, event) {
      this._dragging = true;
      stop(event.event);
      var barTransform = this._displayables.sliderGroup.getLocalTransform();
      var vertex = applyTransform2([dx, dy], barTransform, true);
      var changed = this._updateInterval(handleIndex, vertex[0]);
      var realtime = this.dataZoomModel.get("realtime");
      this._updateView(!realtime);
      changed && realtime && this._dispatchZoomAction(true);
    };
    SliderZoomView2.prototype._onDragEnd = function() {
      this._dragging = false;
      this._showDataInfo(false);
      var realtime = this.dataZoomModel.get("realtime");
      !realtime && this._dispatchZoomAction(false);
    };
    SliderZoomView2.prototype._onClickPanel = function(e2) {
      var size = this._size;
      var localPoint = this._displayables.sliderGroup.transformCoordToLocal(e2.offsetX, e2.offsetY);
      if (localPoint[0] < 0 || localPoint[0] > size[0] || localPoint[1] < 0 || localPoint[1] > size[1]) {
        return;
      }
      var handleEnds = this._handleEnds;
      var center3 = (handleEnds[0] + handleEnds[1]) / 2;
      var changed = this._updateInterval("all", localPoint[0] - center3);
      this._updateView();
      changed && this._dispatchZoomAction(false);
    };
    SliderZoomView2.prototype._onBrushStart = function(e2) {
      var x = e2.offsetX;
      var y = e2.offsetY;
      this._brushStart = new Point_default(x, y);
      this._brushing = true;
      this._brushStartTime = +new Date();
    };
    SliderZoomView2.prototype._onBrushEnd = function(e2) {
      if (!this._brushing) {
        return;
      }
      var brushRect = this._displayables.brushRect;
      this._brushing = false;
      if (!brushRect) {
        return;
      }
      brushRect.attr("ignore", true);
      var brushShape = brushRect.shape;
      var brushEndTime = +new Date();
      if (brushEndTime - this._brushStartTime < 200 && Math.abs(brushShape.width) < 5) {
        return;
      }
      var viewExtend = this._getViewExtent();
      var percentExtent = [0, 100];
      this._range = asc([linearMap(brushShape.x, viewExtend, percentExtent, true), linearMap(brushShape.x + brushShape.width, viewExtend, percentExtent, true)]);
      this._handleEnds = [brushShape.x, brushShape.x + brushShape.width];
      this._updateView();
      this._dispatchZoomAction(false);
    };
    SliderZoomView2.prototype._onBrush = function(e2) {
      if (this._brushing) {
        stop(e2.event);
        this._updateBrushRect(e2.offsetX, e2.offsetY);
      }
    };
    SliderZoomView2.prototype._updateBrushRect = function(mouseX, mouseY) {
      var displayables = this._displayables;
      var dataZoomModel = this.dataZoomModel;
      var brushRect = displayables.brushRect;
      if (!brushRect) {
        brushRect = displayables.brushRect = new Rect3({
          silent: true,
          style: dataZoomModel.getModel("brushStyle").getItemStyle()
        });
        displayables.sliderGroup.add(brushRect);
      }
      brushRect.attr("ignore", false);
      var brushStart = this._brushStart;
      var sliderGroup = this._displayables.sliderGroup;
      var endPoint = sliderGroup.transformCoordToLocal(mouseX, mouseY);
      var startPoint = sliderGroup.transformCoordToLocal(brushStart.x, brushStart.y);
      var size = this._size;
      endPoint[0] = Math.max(Math.min(size[0], endPoint[0]), 0);
      brushRect.setShape({
        x: startPoint[0],
        y: 0,
        width: endPoint[0] - startPoint[0],
        height: size[1]
      });
    };
    SliderZoomView2.prototype._dispatchZoomAction = function(realtime) {
      var range = this._range;
      this.api.dispatchAction({
        type: "dataZoom",
        from: this.uid,
        dataZoomId: this.dataZoomModel.id,
        animation: realtime ? REALTIME_ANIMATION_CONFIG : null,
        start: range[0],
        end: range[1]
      });
    };
    SliderZoomView2.prototype._findCoordRect = function() {
      var rect;
      var coordSysInfoList = collectReferCoordSysModelInfo(this.dataZoomModel).infoList;
      if (!rect && coordSysInfoList.length) {
        var coordSys = coordSysInfoList[0].model.coordinateSystem;
        rect = coordSys.getRect && coordSys.getRect();
      }
      if (!rect) {
        var width = this.api.getWidth();
        var height = this.api.getHeight();
        rect = {
          x: width * 0.2,
          y: height * 0.2,
          width: width * 0.6,
          height: height * 0.6
        };
      }
      return rect;
    };
    SliderZoomView2.type = "dataZoom.slider";
    return SliderZoomView2;
  }(DataZoomView_default);
  function getOtherDim(thisDim) {
    var map3 = {
      x: "y",
      y: "x",
      radius: "angle",
      angle: "radius"
    };
    return map3[thisDim];
  }
  function getCursor(orient) {
    return orient === "vertical" ? "ns-resize" : "ew-resize";
  }
  var SliderZoomView_default = SliderZoomView;

  // node_modules/echarts/lib/component/dataZoom/installDataZoomSlider.js
  function install48(registers) {
    registers.registerComponentModel(SliderZoomModel_default);
    registers.registerComponentView(SliderZoomView_default);
    installCommon(registers);
  }

  // node_modules/echarts/lib/component/dataZoom/install.js
  function install49(registers) {
    use(install47);
    use(install48);
  }

  // node_modules/echarts/lib/visual/visualDefault.js
  var visualDefault = {
    get: function(visualType, key, isCategory2) {
      var value = clone((defaultOption2[visualType] || {})[key]);
      return isCategory2 ? isArray(value) ? value[value.length - 1] : value : value;
    }
  };
  var defaultOption2 = {
    color: {
      active: ["#006edd", "#e0ffff"],
      inactive: ["rgba(0,0,0,0)"]
    },
    colorHue: {
      active: [0, 360],
      inactive: [0, 0]
    },
    colorSaturation: {
      active: [0.3, 1],
      inactive: [0, 0]
    },
    colorLightness: {
      active: [0.9, 0.5],
      inactive: [0, 0]
    },
    colorAlpha: {
      active: [0.3, 1],
      inactive: [0, 0]
    },
    opacity: {
      active: [0.3, 1],
      inactive: [0, 0]
    },
    symbol: {
      active: ["circle", "roundRect", "diamond"],
      inactive: ["none"]
    },
    symbolSize: {
      active: [10, 50],
      inactive: [0, 0]
    }
  };
  var visualDefault_default = visualDefault;

  // node_modules/echarts/lib/component/visualMap/VisualMapModel.js
  var mapVisual2 = VisualMapping_default.mapVisual;
  var eachVisual = VisualMapping_default.eachVisual;
  var isArray2 = isArray;
  var each14 = each;
  var asc3 = asc;
  var linearMap2 = linearMap;
  var VisualMapModel = function(_super) {
    __extends(VisualMapModel2, _super);
    function VisualMapModel2() {
      var _this = _super !== null && _super.apply(this, arguments) || this;
      _this.type = VisualMapModel2.type;
      _this.stateList = ["inRange", "outOfRange"];
      _this.replacableOptionKeys = ["inRange", "outOfRange", "target", "controller", "color"];
      _this.layoutMode = {
        type: "box",
        ignoreSize: true
      };
      _this.dataBound = [-Infinity, Infinity];
      _this.targetVisuals = {};
      _this.controllerVisuals = {};
      return _this;
    }
    VisualMapModel2.prototype.init = function(option, parentModel, ecModel) {
      this.mergeDefaultAndTheme(option, ecModel);
    };
    VisualMapModel2.prototype.optionUpdated = function(newOption, isInit) {
      var thisOption = this.option;
      !isInit && replaceVisualOption(thisOption, newOption, this.replacableOptionKeys);
      this.textStyleModel = this.getModel("textStyle");
      this.resetItemSize();
      this.completeVisualOption();
    };
    VisualMapModel2.prototype.resetVisual = function(supplementVisualOption) {
      var stateList = this.stateList;
      supplementVisualOption = bind(supplementVisualOption, this);
      this.controllerVisuals = createVisualMappings(this.option.controller, stateList, supplementVisualOption);
      this.targetVisuals = createVisualMappings(this.option.target, stateList, supplementVisualOption);
    };
    VisualMapModel2.prototype.getItemSymbol = function() {
      return null;
    };
    VisualMapModel2.prototype.getTargetSeriesIndices = function() {
      var optionSeriesIndex = this.option.seriesIndex;
      var seriesIndices = [];
      if (optionSeriesIndex == null || optionSeriesIndex === "all") {
        this.ecModel.eachSeries(function(seriesModel, index) {
          seriesIndices.push(index);
        });
      } else {
        seriesIndices = normalizeToArray(optionSeriesIndex);
      }
      return seriesIndices;
    };
    VisualMapModel2.prototype.eachTargetSeries = function(callback, context) {
      each(this.getTargetSeriesIndices(), function(seriesIndex) {
        var seriesModel = this.ecModel.getSeriesByIndex(seriesIndex);
        if (seriesModel) {
          callback.call(context, seriesModel);
        }
      }, this);
    };
    VisualMapModel2.prototype.isTargetSeries = function(seriesModel) {
      var is = false;
      this.eachTargetSeries(function(model) {
        model === seriesModel && (is = true);
      });
      return is;
    };
    VisualMapModel2.prototype.formatValueText = function(value, isCategory2, edgeSymbols) {
      var option = this.option;
      var precision = option.precision;
      var dataBound = this.dataBound;
      var formatter = option.formatter;
      var isMinMax;
      edgeSymbols = edgeSymbols || ["<", ">"];
      if (isArray(value)) {
        value = value.slice();
        isMinMax = true;
      }
      var textValue = isCategory2 ? value : isMinMax ? [toFixed(value[0]), toFixed(value[1])] : toFixed(value);
      if (isString(formatter)) {
        return formatter.replace("{value}", isMinMax ? textValue[0] : textValue).replace("{value2}", isMinMax ? textValue[1] : textValue);
      } else if (isFunction(formatter)) {
        return isMinMax ? formatter(value[0], value[1]) : formatter(value);
      }
      if (isMinMax) {
        if (value[0] === dataBound[0]) {
          return edgeSymbols[0] + " " + textValue[1];
        } else if (value[1] === dataBound[1]) {
          return edgeSymbols[1] + " " + textValue[0];
        } else {
          return textValue[0] + " - " + textValue[1];
        }
      } else {
        return textValue;
      }
      function toFixed(val) {
        return val === dataBound[0] ? "min" : val === dataBound[1] ? "max" : (+val).toFixed(Math.min(precision, 20));
      }
    };
    VisualMapModel2.prototype.resetExtent = function() {
      var thisOption = this.option;
      var extent3 = asc3([thisOption.min, thisOption.max]);
      this._dataExtent = extent3;
    };
    VisualMapModel2.prototype.getDataDimensionIndex = function(data) {
      var optDim = this.option.dimension;
      if (optDim != null) {
        return data.getDimensionIndex(optDim);
      }
      var dimNames = data.dimensions;
      for (var i = dimNames.length - 1; i >= 0; i--) {
        var dimName = dimNames[i];
        var dimInfo = data.getDimensionInfo(dimName);
        if (!dimInfo.isCalculationCoord) {
          return dimInfo.storeDimIndex;
        }
      }
    };
    VisualMapModel2.prototype.getExtent = function() {
      return this._dataExtent.slice();
    };
    VisualMapModel2.prototype.completeVisualOption = function() {
      var ecModel = this.ecModel;
      var thisOption = this.option;
      var base2 = {
        inRange: thisOption.inRange,
        outOfRange: thisOption.outOfRange
      };
      var target = thisOption.target || (thisOption.target = {});
      var controller = thisOption.controller || (thisOption.controller = {});
      merge(target, base2);
      merge(controller, base2);
      var isCategory2 = this.isCategory();
      completeSingle.call(this, target);
      completeSingle.call(this, controller);
      completeInactive.call(this, target, "inRange", "outOfRange");
      completeController.call(this, controller);
      function completeSingle(base3) {
        if (isArray2(thisOption.color) && !base3.inRange) {
          base3.inRange = {
            color: thisOption.color.slice().reverse()
          };
        }
        base3.inRange = base3.inRange || {
          color: ecModel.get("gradientColor")
        };
      }
      function completeInactive(base3, stateExist, stateAbsent) {
        var optExist = base3[stateExist];
        var optAbsent = base3[stateAbsent];
        if (optExist && !optAbsent) {
          optAbsent = base3[stateAbsent] = {};
          each14(optExist, function(visualData, visualType) {
            if (!VisualMapping_default.isValidType(visualType)) {
              return;
            }
            var defa = visualDefault_default.get(visualType, "inactive", isCategory2);
            if (defa != null) {
              optAbsent[visualType] = defa;
              if (visualType === "color" && !optAbsent.hasOwnProperty("opacity") && !optAbsent.hasOwnProperty("colorAlpha")) {
                optAbsent.opacity = [0, 0];
              }
            }
          });
        }
      }
      function completeController(controller2) {
        var symbolExists = (controller2.inRange || {}).symbol || (controller2.outOfRange || {}).symbol;
        var symbolSizeExists = (controller2.inRange || {}).symbolSize || (controller2.outOfRange || {}).symbolSize;
        var inactiveColor = this.get("inactiveColor");
        var itemSymbol = this.getItemSymbol();
        var defaultSymbol = itemSymbol || "roundRect";
        each14(this.stateList, function(state) {
          var itemSize = this.itemSize;
          var visuals = controller2[state];
          if (!visuals) {
            visuals = controller2[state] = {
              color: isCategory2 ? inactiveColor : [inactiveColor]
            };
          }
          if (visuals.symbol == null) {
            visuals.symbol = symbolExists && clone(symbolExists) || (isCategory2 ? defaultSymbol : [defaultSymbol]);
          }
          if (visuals.symbolSize == null) {
            visuals.symbolSize = symbolSizeExists && clone(symbolSizeExists) || (isCategory2 ? itemSize[0] : [itemSize[0], itemSize[0]]);
          }
          visuals.symbol = mapVisual2(visuals.symbol, function(symbol) {
            return symbol === "none" ? defaultSymbol : symbol;
          });
          var symbolSize = visuals.symbolSize;
          if (symbolSize != null) {
            var max_1 = -Infinity;
            eachVisual(symbolSize, function(value) {
              value > max_1 && (max_1 = value);
            });
            visuals.symbolSize = mapVisual2(symbolSize, function(value) {
              return linearMap2(value, [0, max_1], [0, itemSize[0]], true);
            });
          }
        }, this);
      }
    };
    VisualMapModel2.prototype.resetItemSize = function() {
      this.itemSize = [parseFloat(this.get("itemWidth")), parseFloat(this.get("itemHeight"))];
    };
    VisualMapModel2.prototype.isCategory = function() {
      return !!this.option.categories;
    };
    VisualMapModel2.prototype.setSelected = function(selected) {
    };
    VisualMapModel2.prototype.getSelected = function() {
      return null;
    };
    VisualMapModel2.prototype.getValueState = function(value) {
      return null;
    };
    VisualMapModel2.prototype.getVisualMeta = function(getColorVisual2) {
      return null;
    };
    VisualMapModel2.type = "visualMap";
    VisualMapModel2.dependencies = ["series"];
    VisualMapModel2.defaultOption = {
      show: true,
      z: 4,
      seriesIndex: "all",
      min: 0,
      max: 200,
      left: 0,
      right: null,
      top: null,
      bottom: 0,
      itemWidth: null,
      itemHeight: null,
      inverse: false,
      orient: "vertical",
      backgroundColor: "rgba(0,0,0,0)",
      borderColor: "#ccc",
      contentColor: "#5793f3",
      inactiveColor: "#aaa",
      borderWidth: 0,
      padding: 5,
      textGap: 10,
      precision: 0,
      textStyle: {
        color: "#333"
      }
    };
    return VisualMapModel2;
  }(Component_default);
  var VisualMapModel_default = VisualMapModel;

  // node_modules/echarts/lib/component/visualMap/ContinuousModel.js
  var DEFAULT_BAR_BOUND = [20, 140];
  var ContinuousModel = function(_super) {
    __extends(ContinuousModel2, _super);
    function ContinuousModel2() {
      var _this = _super !== null && _super.apply(this, arguments) || this;
      _this.type = ContinuousModel2.type;
      return _this;
    }
    ContinuousModel2.prototype.optionUpdated = function(newOption, isInit) {
      _super.prototype.optionUpdated.apply(this, arguments);
      this.resetExtent();
      this.resetVisual(function(mappingOption) {
        mappingOption.mappingMethod = "linear";
        mappingOption.dataExtent = this.getExtent();
      });
      this._resetRange();
    };
    ContinuousModel2.prototype.resetItemSize = function() {
      _super.prototype.resetItemSize.apply(this, arguments);
      var itemSize = this.itemSize;
      (itemSize[0] == null || isNaN(itemSize[0])) && (itemSize[0] = DEFAULT_BAR_BOUND[0]);
      (itemSize[1] == null || isNaN(itemSize[1])) && (itemSize[1] = DEFAULT_BAR_BOUND[1]);
    };
    ContinuousModel2.prototype._resetRange = function() {
      var dataExtent = this.getExtent();
      var range = this.option.range;
      if (!range || range.auto) {
        dataExtent.auto = 1;
        this.option.range = dataExtent;
      } else if (isArray(range)) {
        if (range[0] > range[1]) {
          range.reverse();
        }
        range[0] = Math.max(range[0], dataExtent[0]);
        range[1] = Math.min(range[1], dataExtent[1]);
      }
    };
    ContinuousModel2.prototype.completeVisualOption = function() {
      _super.prototype.completeVisualOption.apply(this, arguments);
      each(this.stateList, function(state) {
        var symbolSize = this.option.controller[state].symbolSize;
        if (symbolSize && symbolSize[0] !== symbolSize[1]) {
          symbolSize[0] = symbolSize[1] / 3;
        }
      }, this);
    };
    ContinuousModel2.prototype.setSelected = function(selected) {
      this.option.range = selected.slice();
      this._resetRange();
    };
    ContinuousModel2.prototype.getSelected = function() {
      var dataExtent = this.getExtent();
      var dataInterval = asc((this.get("range") || []).slice());
      dataInterval[0] > dataExtent[1] && (dataInterval[0] = dataExtent[1]);
      dataInterval[1] > dataExtent[1] && (dataInterval[1] = dataExtent[1]);
      dataInterval[0] < dataExtent[0] && (dataInterval[0] = dataExtent[0]);
      dataInterval[1] < dataExtent[0] && (dataInterval[1] = dataExtent[0]);
      return dataInterval;
    };
    ContinuousModel2.prototype.getValueState = function(value) {
      var range = this.option.range;
      var dataExtent = this.getExtent();
      return (range[0] <= dataExtent[0] || range[0] <= value) && (range[1] >= dataExtent[1] || value <= range[1]) ? "inRange" : "outOfRange";
    };
    ContinuousModel2.prototype.findTargetDataIndices = function(range) {
      var result = [];
      this.eachTargetSeries(function(seriesModel) {
        var dataIndices = [];
        var data = seriesModel.getData();
        data.each(this.getDataDimensionIndex(data), function(value, dataIndex) {
          range[0] <= value && value <= range[1] && dataIndices.push(dataIndex);
        }, this);
        result.push({
          seriesId: seriesModel.id,
          dataIndex: dataIndices
        });
      }, this);
      return result;
    };
    ContinuousModel2.prototype.getVisualMeta = function(getColorVisual2) {
      var oVals = getColorStopValues(this, "outOfRange", this.getExtent());
      var iVals = getColorStopValues(this, "inRange", this.option.range.slice());
      var stops = [];
      function setStop(value, valueState) {
        stops.push({
          value,
          color: getColorVisual2(value, valueState)
        });
      }
      var iIdx = 0;
      var oIdx = 0;
      var iLen = iVals.length;
      var oLen = oVals.length;
      for (; oIdx < oLen && (!iVals.length || oVals[oIdx] <= iVals[0]); oIdx++) {
        if (oVals[oIdx] < iVals[iIdx]) {
          setStop(oVals[oIdx], "outOfRange");
        }
      }
      for (var first = 1; iIdx < iLen; iIdx++, first = 0) {
        first && stops.length && setStop(iVals[iIdx], "outOfRange");
        setStop(iVals[iIdx], "inRange");
      }
      for (var first = 1; oIdx < oLen; oIdx++) {
        if (!iVals.length || iVals[iVals.length - 1] < oVals[oIdx]) {
          if (first) {
            stops.length && setStop(stops[stops.length - 1].value, "outOfRange");
            first = 0;
          }
          setStop(oVals[oIdx], "outOfRange");
        }
      }
      var stopsLen = stops.length;
      return {
        stops,
        outerColors: [stopsLen ? stops[0].color : "transparent", stopsLen ? stops[stopsLen - 1].color : "transparent"]
      };
    };
    ContinuousModel2.type = "visualMap.continuous";
    ContinuousModel2.defaultOption = inheritDefaultOption(VisualMapModel_default.defaultOption, {
      align: "auto",
      calculable: false,
      hoverLink: true,
      realtime: true,
      handleIcon: "path://M-11.39,9.77h0a3.5,3.5,0,0,1-3.5,3.5h-22a3.5,3.5,0,0,1-3.5-3.5h0a3.5,3.5,0,0,1,3.5-3.5h22A3.5,3.5,0,0,1-11.39,9.77Z",
      handleSize: "120%",
      handleStyle: {
        borderColor: "#fff",
        borderWidth: 1
      },
      indicatorIcon: "circle",
      indicatorSize: "50%",
      indicatorStyle: {
        borderColor: "#fff",
        borderWidth: 2,
        shadowBlur: 2,
        shadowOffsetX: 1,
        shadowOffsetY: 1,
        shadowColor: "rgba(0,0,0,0.2)"
      }
    });
    return ContinuousModel2;
  }(VisualMapModel_default);
  function getColorStopValues(visualMapModel, valueState, dataExtent) {
    if (dataExtent[0] === dataExtent[1]) {
      return dataExtent.slice();
    }
    var count2 = 200;
    var step = (dataExtent[1] - dataExtent[0]) / count2;
    var value = dataExtent[0];
    var stopValues = [];
    for (var i = 0; i <= count2 && value < dataExtent[1]; i++) {
      stopValues.push(value);
      value += step;
    }
    stopValues.push(dataExtent[1]);
    return stopValues;
  }
  var ContinuousModel_default = ContinuousModel;

  // node_modules/echarts/lib/component/visualMap/VisualMapView.js
  var VisualMapView = function(_super) {
    __extends(VisualMapView2, _super);
    function VisualMapView2() {
      var _this = _super !== null && _super.apply(this, arguments) || this;
      _this.type = VisualMapView2.type;
      _this.autoPositionValues = {
        left: 1,
        right: 1,
        top: 1,
        bottom: 1
      };
      return _this;
    }
    VisualMapView2.prototype.init = function(ecModel, api) {
      this.ecModel = ecModel;
      this.api = api;
    };
    VisualMapView2.prototype.render = function(visualMapModel, ecModel, api, payload) {
      this.visualMapModel = visualMapModel;
      if (visualMapModel.get("show") === false) {
        this.group.removeAll();
        return;
      }
      this.doRender(visualMapModel, ecModel, api, payload);
    };
    VisualMapView2.prototype.renderBackground = function(group) {
      var visualMapModel = this.visualMapModel;
      var padding = normalizeCssArray2(visualMapModel.get("padding") || 0);
      var rect = group.getBoundingRect();
      group.add(new Rect_default({
        z2: -1,
        silent: true,
        shape: {
          x: rect.x - padding[3],
          y: rect.y - padding[0],
          width: rect.width + padding[3] + padding[1],
          height: rect.height + padding[0] + padding[2]
        },
        style: {
          fill: visualMapModel.get("backgroundColor"),
          stroke: visualMapModel.get("borderColor"),
          lineWidth: visualMapModel.get("borderWidth")
        }
      }));
    };
    VisualMapView2.prototype.getControllerVisual = function(targetValue, visualCluster, opts) {
      opts = opts || {};
      var forceState = opts.forceState;
      var visualMapModel = this.visualMapModel;
      var visualObj = {};
      if (visualCluster === "color") {
        var defaultColor = visualMapModel.get("contentColor");
        visualObj.color = defaultColor;
      }
      function getter(key) {
        return visualObj[key];
      }
      function setter(key, value) {
        visualObj[key] = value;
      }
      var mappings = visualMapModel.controllerVisuals[forceState || visualMapModel.getValueState(targetValue)];
      var visualTypes = VisualMapping_default.prepareVisualTypes(mappings);
      each(visualTypes, function(type) {
        var visualMapping = mappings[type];
        if (opts.convertOpacityToAlpha && type === "opacity") {
          type = "colorAlpha";
          visualMapping = mappings.__alphaForOpacity;
        }
        if (VisualMapping_default.dependsOn(type, visualCluster)) {
          visualMapping && visualMapping.applyVisual(targetValue, getter, setter);
        }
      });
      return visualObj[visualCluster];
    };
    VisualMapView2.prototype.positionGroup = function(group) {
      var model = this.visualMapModel;
      var api = this.api;
      positionElement(group, model.getBoxLayoutParams(), {
        width: api.getWidth(),
        height: api.getHeight()
      });
    };
    VisualMapView2.prototype.doRender = function(visualMapModel, ecModel, api, payload) {
    };
    VisualMapView2.type = "visualMap";
    return VisualMapView2;
  }(Component_default2);
  var VisualMapView_default = VisualMapView;

  // node_modules/echarts/lib/component/visualMap/helper.js
  var paramsSet = [["left", "right", "width"], ["top", "bottom", "height"]];
  function getItemAlign(visualMapModel, api, itemSize) {
    var modelOption = visualMapModel.option;
    var itemAlign = modelOption.align;
    if (itemAlign != null && itemAlign !== "auto") {
      return itemAlign;
    }
    var ecSize = {
      width: api.getWidth(),
      height: api.getHeight()
    };
    var realIndex = modelOption.orient === "horizontal" ? 1 : 0;
    var reals = paramsSet[realIndex];
    var fakeValue = [0, null, 10];
    var layoutInput = {};
    for (var i = 0; i < 3; i++) {
      layoutInput[paramsSet[1 - realIndex][i]] = fakeValue[i];
      layoutInput[reals[i]] = i === 2 ? itemSize[0] : modelOption[reals[i]];
    }
    var rParam = [["x", "width", 3], ["y", "height", 0]][realIndex];
    var rect = getLayoutRect(layoutInput, ecSize, modelOption.padding);
    return reals[(rect.margin[rParam[2]] || 0) + rect[rParam[0]] + rect[rParam[1]] * 0.5 < ecSize[rParam[1]] * 0.5 ? 0 : 1];
  }
  function makeHighDownBatch(batch, visualMapModel) {
    each(batch || [], function(batchItem) {
      if (batchItem.dataIndex != null) {
        batchItem.dataIndexInside = batchItem.dataIndex;
        batchItem.dataIndex = null;
      }
      batchItem.highlightKey = "visualMap" + (visualMapModel ? visualMapModel.componentIndex : "");
    });
    return batch;
  }

  // node_modules/echarts/lib/component/visualMap/ContinuousView.js
  var linearMap3 = linearMap;
  var each15 = each;
  var mathMin11 = Math.min;
  var mathMax11 = Math.max;
  var HOVER_LINK_SIZE = 12;
  var HOVER_LINK_OUT = 6;
  var ContinuousView = function(_super) {
    __extends(ContinuousView2, _super);
    function ContinuousView2() {
      var _this = _super !== null && _super.apply(this, arguments) || this;
      _this.type = ContinuousView2.type;
      _this._shapes = {};
      _this._dataInterval = [];
      _this._handleEnds = [];
      _this._hoverLinkDataIndices = [];
      return _this;
    }
    ContinuousView2.prototype.doRender = function(visualMapModel, ecModel, api, payload) {
      this._api = api;
      if (!payload || payload.type !== "selectDataRange" || payload.from !== this.uid) {
        this._buildView();
      }
    };
    ContinuousView2.prototype._buildView = function() {
      this.group.removeAll();
      var visualMapModel = this.visualMapModel;
      var thisGroup = this.group;
      this._orient = visualMapModel.get("orient");
      this._useHandle = visualMapModel.get("calculable");
      this._resetInterval();
      this._renderBar(thisGroup);
      var dataRangeText = visualMapModel.get("text");
      this._renderEndsText(thisGroup, dataRangeText, 0);
      this._renderEndsText(thisGroup, dataRangeText, 1);
      this._updateView(true);
      this.renderBackground(thisGroup);
      this._updateView();
      this._enableHoverLinkToSeries();
      this._enableHoverLinkFromSeries();
      this.positionGroup(thisGroup);
    };
    ContinuousView2.prototype._renderEndsText = function(group, dataRangeText, endsIndex) {
      if (!dataRangeText) {
        return;
      }
      var text = dataRangeText[1 - endsIndex];
      text = text != null ? text + "" : "";
      var visualMapModel = this.visualMapModel;
      var textGap = visualMapModel.get("textGap");
      var itemSize = visualMapModel.itemSize;
      var barGroup = this._shapes.mainGroup;
      var position2 = this._applyTransform([itemSize[0] / 2, endsIndex === 0 ? -textGap : itemSize[1] + textGap], barGroup);
      var align = this._applyTransform(endsIndex === 0 ? "bottom" : "top", barGroup);
      var orient = this._orient;
      var textStyleModel = this.visualMapModel.textStyleModel;
      this.group.add(new Text_default({
        style: createTextStyle(textStyleModel, {
          x: position2[0],
          y: position2[1],
          verticalAlign: orient === "horizontal" ? "middle" : align,
          align: orient === "horizontal" ? align : "center",
          text
        })
      }));
    };
    ContinuousView2.prototype._renderBar = function(targetGroup) {
      var visualMapModel = this.visualMapModel;
      var shapes = this._shapes;
      var itemSize = visualMapModel.itemSize;
      var orient = this._orient;
      var useHandle = this._useHandle;
      var itemAlign = getItemAlign(visualMapModel, this.api, itemSize);
      var mainGroup = shapes.mainGroup = this._createBarGroup(itemAlign);
      var gradientBarGroup = new Group_default();
      mainGroup.add(gradientBarGroup);
      gradientBarGroup.add(shapes.outOfRange = createPolygon());
      gradientBarGroup.add(shapes.inRange = createPolygon(null, useHandle ? getCursor2(this._orient) : null, bind(this._dragHandle, this, "all", false), bind(this._dragHandle, this, "all", true)));
      gradientBarGroup.setClipPath(new Rect_default({
        shape: {
          x: 0,
          y: 0,
          width: itemSize[0],
          height: itemSize[1],
          r: 3
        }
      }));
      var textRect = visualMapModel.textStyleModel.getTextRect("国");
      var textSize = mathMax11(textRect.width, textRect.height);
      if (useHandle) {
        shapes.handleThumbs = [];
        shapes.handleLabels = [];
        shapes.handleLabelPoints = [];
        this._createHandle(visualMapModel, mainGroup, 0, itemSize, textSize, orient);
        this._createHandle(visualMapModel, mainGroup, 1, itemSize, textSize, orient);
      }
      this._createIndicator(visualMapModel, mainGroup, itemSize, textSize, orient);
      targetGroup.add(mainGroup);
    };
    ContinuousView2.prototype._createHandle = function(visualMapModel, mainGroup, handleIndex, itemSize, textSize, orient) {
      var onDrift = bind(this._dragHandle, this, handleIndex, false);
      var onDragEnd = bind(this._dragHandle, this, handleIndex, true);
      var handleSize = parsePercent(visualMapModel.get("handleSize"), itemSize[0]);
      var handleThumb = createSymbol(visualMapModel.get("handleIcon"), -handleSize / 2, -handleSize / 2, handleSize, handleSize, null, true);
      var cursor = getCursor2(this._orient);
      handleThumb.attr({
        cursor,
        draggable: true,
        drift: onDrift,
        ondragend: onDragEnd,
        onmousemove: function(e2) {
          stop(e2.event);
        }
      });
      handleThumb.x = itemSize[0] / 2;
      handleThumb.useStyle(visualMapModel.getModel("handleStyle").getItemStyle());
      handleThumb.setStyle({
        strokeNoScale: true,
        strokeFirst: true
      });
      handleThumb.style.lineWidth *= 2;
      handleThumb.ensureState("emphasis").style = visualMapModel.getModel(["emphasis", "handleStyle"]).getItemStyle();
      setAsHighDownDispatcher(handleThumb, true);
      mainGroup.add(handleThumb);
      var textStyleModel = this.visualMapModel.textStyleModel;
      var handleLabel = new Text_default({
        cursor,
        draggable: true,
        drift: onDrift,
        onmousemove: function(e2) {
          stop(e2.event);
        },
        ondragend: onDragEnd,
        style: createTextStyle(textStyleModel, {
          x: 0,
          y: 0,
          text: ""
        })
      });
      handleLabel.ensureState("blur").style = {
        opacity: 0.1
      };
      handleLabel.stateTransition = {
        duration: 200
      };
      this.group.add(handleLabel);
      var handleLabelPoint = [handleSize, 0];
      var shapes = this._shapes;
      shapes.handleThumbs[handleIndex] = handleThumb;
      shapes.handleLabelPoints[handleIndex] = handleLabelPoint;
      shapes.handleLabels[handleIndex] = handleLabel;
    };
    ContinuousView2.prototype._createIndicator = function(visualMapModel, mainGroup, itemSize, textSize, orient) {
      var scale4 = parsePercent(visualMapModel.get("indicatorSize"), itemSize[0]);
      var indicator = createSymbol(visualMapModel.get("indicatorIcon"), -scale4 / 2, -scale4 / 2, scale4, scale4, null, true);
      indicator.attr({
        cursor: "move",
        invisible: true,
        silent: true,
        x: itemSize[0] / 2
      });
      var indicatorStyle = visualMapModel.getModel("indicatorStyle").getItemStyle();
      if (indicator instanceof Image_default) {
        var pathStyle = indicator.style;
        indicator.useStyle(extend({
          image: pathStyle.image,
          x: pathStyle.x,
          y: pathStyle.y,
          width: pathStyle.width,
          height: pathStyle.height
        }, indicatorStyle));
      } else {
        indicator.useStyle(indicatorStyle);
      }
      mainGroup.add(indicator);
      var textStyleModel = this.visualMapModel.textStyleModel;
      var indicatorLabel = new Text_default({
        silent: true,
        invisible: true,
        style: createTextStyle(textStyleModel, {
          x: 0,
          y: 0,
          text: ""
        })
      });
      this.group.add(indicatorLabel);
      var indicatorLabelPoint = [(orient === "horizontal" ? textSize / 2 : HOVER_LINK_OUT) + itemSize[0] / 2, 0];
      var shapes = this._shapes;
      shapes.indicator = indicator;
      shapes.indicatorLabel = indicatorLabel;
      shapes.indicatorLabelPoint = indicatorLabelPoint;
      this._firstShowIndicator = true;
    };
    ContinuousView2.prototype._dragHandle = function(handleIndex, isEnd, dx, dy) {
      if (!this._useHandle) {
        return;
      }
      this._dragging = !isEnd;
      if (!isEnd) {
        var vertex = this._applyTransform([dx, dy], this._shapes.mainGroup, true);
        this._updateInterval(handleIndex, vertex[1]);
        this._hideIndicator();
        this._updateView();
      }
      if (isEnd === !this.visualMapModel.get("realtime")) {
        this.api.dispatchAction({
          type: "selectDataRange",
          from: this.uid,
          visualMapId: this.visualMapModel.id,
          selected: this._dataInterval.slice()
        });
      }
      if (isEnd) {
        !this._hovering && this._clearHoverLinkToSeries();
      } else if (useHoverLinkOnHandle(this.visualMapModel)) {
        this._doHoverLinkToSeries(this._handleEnds[handleIndex], false);
      }
    };
    ContinuousView2.prototype._resetInterval = function() {
      var visualMapModel = this.visualMapModel;
      var dataInterval = this._dataInterval = visualMapModel.getSelected();
      var dataExtent = visualMapModel.getExtent();
      var sizeExtent = [0, visualMapModel.itemSize[1]];
      this._handleEnds = [linearMap3(dataInterval[0], dataExtent, sizeExtent, true), linearMap3(dataInterval[1], dataExtent, sizeExtent, true)];
    };
    ContinuousView2.prototype._updateInterval = function(handleIndex, delta) {
      delta = delta || 0;
      var visualMapModel = this.visualMapModel;
      var handleEnds = this._handleEnds;
      var sizeExtent = [0, visualMapModel.itemSize[1]];
      sliderMove(delta, handleEnds, sizeExtent, handleIndex, 0);
      var dataExtent = visualMapModel.getExtent();
      this._dataInterval = [linearMap3(handleEnds[0], sizeExtent, dataExtent, true), linearMap3(handleEnds[1], sizeExtent, dataExtent, true)];
    };
    ContinuousView2.prototype._updateView = function(forSketch) {
      var visualMapModel = this.visualMapModel;
      var dataExtent = visualMapModel.getExtent();
      var shapes = this._shapes;
      var outOfRangeHandleEnds = [0, visualMapModel.itemSize[1]];
      var inRangeHandleEnds = forSketch ? outOfRangeHandleEnds : this._handleEnds;
      var visualInRange = this._createBarVisual(this._dataInterval, dataExtent, inRangeHandleEnds, "inRange");
      var visualOutOfRange = this._createBarVisual(dataExtent, dataExtent, outOfRangeHandleEnds, "outOfRange");
      shapes.inRange.setStyle({
        fill: visualInRange.barColor
      }).setShape("points", visualInRange.barPoints);
      shapes.outOfRange.setStyle({
        fill: visualOutOfRange.barColor
      }).setShape("points", visualOutOfRange.barPoints);
      this._updateHandle(inRangeHandleEnds, visualInRange);
    };
    ContinuousView2.prototype._createBarVisual = function(dataInterval, dataExtent, handleEnds, forceState) {
      var opts = {
        forceState,
        convertOpacityToAlpha: true
      };
      var colorStops = this._makeColorGradient(dataInterval, opts);
      var symbolSizes = [this.getControllerVisual(dataInterval[0], "symbolSize", opts), this.getControllerVisual(dataInterval[1], "symbolSize", opts)];
      var barPoints = this._createBarPoints(handleEnds, symbolSizes);
      return {
        barColor: new LinearGradient_default(0, 0, 0, 1, colorStops),
        barPoints,
        handlesColor: [colorStops[0].color, colorStops[colorStops.length - 1].color]
      };
    };
    ContinuousView2.prototype._makeColorGradient = function(dataInterval, opts) {
      var sampleNumber = 100;
      var colorStops = [];
      var step = (dataInterval[1] - dataInterval[0]) / sampleNumber;
      colorStops.push({
        color: this.getControllerVisual(dataInterval[0], "color", opts),
        offset: 0
      });
      for (var i = 1; i < sampleNumber; i++) {
        var currValue = dataInterval[0] + step * i;
        if (currValue > dataInterval[1]) {
          break;
        }
        colorStops.push({
          color: this.getControllerVisual(currValue, "color", opts),
          offset: i / sampleNumber
        });
      }
      colorStops.push({
        color: this.getControllerVisual(dataInterval[1], "color", opts),
        offset: 1
      });
      return colorStops;
    };
    ContinuousView2.prototype._createBarPoints = function(handleEnds, symbolSizes) {
      var itemSize = this.visualMapModel.itemSize;
      return [[itemSize[0] - symbolSizes[0], handleEnds[0]], [itemSize[0], handleEnds[0]], [itemSize[0], handleEnds[1]], [itemSize[0] - symbolSizes[1], handleEnds[1]]];
    };
    ContinuousView2.prototype._createBarGroup = function(itemAlign) {
      var orient = this._orient;
      var inverse = this.visualMapModel.get("inverse");
      return new Group_default(orient === "horizontal" && !inverse ? {
        scaleX: itemAlign === "bottom" ? 1 : -1,
        rotation: Math.PI / 2
      } : orient === "horizontal" && inverse ? {
        scaleX: itemAlign === "bottom" ? -1 : 1,
        rotation: -Math.PI / 2
      } : orient === "vertical" && !inverse ? {
        scaleX: itemAlign === "left" ? 1 : -1,
        scaleY: -1
      } : {
        scaleX: itemAlign === "left" ? 1 : -1
      });
    };
    ContinuousView2.prototype._updateHandle = function(handleEnds, visualInRange) {
      if (!this._useHandle) {
        return;
      }
      var shapes = this._shapes;
      var visualMapModel = this.visualMapModel;
      var handleThumbs = shapes.handleThumbs;
      var handleLabels = shapes.handleLabels;
      var itemSize = visualMapModel.itemSize;
      var dataExtent = visualMapModel.getExtent();
      each15([0, 1], function(handleIndex) {
        var handleThumb = handleThumbs[handleIndex];
        handleThumb.setStyle("fill", visualInRange.handlesColor[handleIndex]);
        handleThumb.y = handleEnds[handleIndex];
        var val = linearMap3(handleEnds[handleIndex], [0, itemSize[1]], dataExtent, true);
        var symbolSize = this.getControllerVisual(val, "symbolSize");
        handleThumb.scaleX = handleThumb.scaleY = symbolSize / itemSize[0];
        handleThumb.x = itemSize[0] - symbolSize / 2;
        var textPoint = applyTransform2(shapes.handleLabelPoints[handleIndex], getTransform(handleThumb, this.group));
        handleLabels[handleIndex].setStyle({
          x: textPoint[0],
          y: textPoint[1],
          text: visualMapModel.formatValueText(this._dataInterval[handleIndex]),
          verticalAlign: "middle",
          align: this._orient === "vertical" ? this._applyTransform("left", shapes.mainGroup) : "center"
        });
      }, this);
    };
    ContinuousView2.prototype._showIndicator = function(cursorValue, textValue, rangeSymbol, halfHoverLinkSize) {
      var visualMapModel = this.visualMapModel;
      var dataExtent = visualMapModel.getExtent();
      var itemSize = visualMapModel.itemSize;
      var sizeExtent = [0, itemSize[1]];
      var shapes = this._shapes;
      var indicator = shapes.indicator;
      if (!indicator) {
        return;
      }
      indicator.attr("invisible", false);
      var opts = {
        convertOpacityToAlpha: true
      };
      var color = this.getControllerVisual(cursorValue, "color", opts);
      var symbolSize = this.getControllerVisual(cursorValue, "symbolSize");
      var y = linearMap3(cursorValue, dataExtent, sizeExtent, true);
      var x = itemSize[0] - symbolSize / 2;
      var oldIndicatorPos = {
        x: indicator.x,
        y: indicator.y
      };
      indicator.y = y;
      indicator.x = x;
      var textPoint = applyTransform2(shapes.indicatorLabelPoint, getTransform(indicator, this.group));
      var indicatorLabel = shapes.indicatorLabel;
      indicatorLabel.attr("invisible", false);
      var align = this._applyTransform("left", shapes.mainGroup);
      var orient = this._orient;
      var isHorizontal = orient === "horizontal";
      indicatorLabel.setStyle({
        text: (rangeSymbol ? rangeSymbol : "") + visualMapModel.formatValueText(textValue),
        verticalAlign: isHorizontal ? align : "middle",
        align: isHorizontal ? "center" : align
      });
      var indicatorNewProps = {
        x,
        y,
        style: {
          fill: color
        }
      };
      var labelNewProps = {
        style: {
          x: textPoint[0],
          y: textPoint[1]
        }
      };
      if (visualMapModel.ecModel.isAnimationEnabled() && !this._firstShowIndicator) {
        var animationCfg = {
          duration: 100,
          easing: "cubicInOut",
          additive: true
        };
        indicator.x = oldIndicatorPos.x;
        indicator.y = oldIndicatorPos.y;
        indicator.animateTo(indicatorNewProps, animationCfg);
        indicatorLabel.animateTo(labelNewProps, animationCfg);
      } else {
        indicator.attr(indicatorNewProps);
        indicatorLabel.attr(labelNewProps);
      }
      this._firstShowIndicator = false;
      var handleLabels = this._shapes.handleLabels;
      if (handleLabels) {
        for (var i = 0; i < handleLabels.length; i++) {
          this._api.enterBlur(handleLabels[i]);
        }
      }
    };
    ContinuousView2.prototype._enableHoverLinkToSeries = function() {
      var self2 = this;
      this._shapes.mainGroup.on("mousemove", function(e2) {
        self2._hovering = true;
        if (!self2._dragging) {
          var itemSize = self2.visualMapModel.itemSize;
          var pos = self2._applyTransform([e2.offsetX, e2.offsetY], self2._shapes.mainGroup, true, true);
          pos[1] = mathMin11(mathMax11(0, pos[1]), itemSize[1]);
          self2._doHoverLinkToSeries(pos[1], 0 <= pos[0] && pos[0] <= itemSize[0]);
        }
      }).on("mouseout", function() {
        self2._hovering = false;
        !self2._dragging && self2._clearHoverLinkToSeries();
      });
    };
    ContinuousView2.prototype._enableHoverLinkFromSeries = function() {
      var zr = this.api.getZr();
      if (this.visualMapModel.option.hoverLink) {
        zr.on("mouseover", this._hoverLinkFromSeriesMouseOver, this);
        zr.on("mouseout", this._hideIndicator, this);
      } else {
        this._clearHoverLinkFromSeries();
      }
    };
    ContinuousView2.prototype._doHoverLinkToSeries = function(cursorPos, hoverOnBar) {
      var visualMapModel = this.visualMapModel;
      var itemSize = visualMapModel.itemSize;
      if (!visualMapModel.option.hoverLink) {
        return;
      }
      var sizeExtent = [0, itemSize[1]];
      var dataExtent = visualMapModel.getExtent();
      cursorPos = mathMin11(mathMax11(sizeExtent[0], cursorPos), sizeExtent[1]);
      var halfHoverLinkSize = getHalfHoverLinkSize(visualMapModel, dataExtent, sizeExtent);
      var hoverRange = [cursorPos - halfHoverLinkSize, cursorPos + halfHoverLinkSize];
      var cursorValue = linearMap3(cursorPos, sizeExtent, dataExtent, true);
      var valueRange = [linearMap3(hoverRange[0], sizeExtent, dataExtent, true), linearMap3(hoverRange[1], sizeExtent, dataExtent, true)];
      hoverRange[0] < sizeExtent[0] && (valueRange[0] = -Infinity);
      hoverRange[1] > sizeExtent[1] && (valueRange[1] = Infinity);
      if (hoverOnBar) {
        if (valueRange[0] === -Infinity) {
          this._showIndicator(cursorValue, valueRange[1], "< ", halfHoverLinkSize);
        } else if (valueRange[1] === Infinity) {
          this._showIndicator(cursorValue, valueRange[0], "> ", halfHoverLinkSize);
        } else {
          this._showIndicator(cursorValue, cursorValue, "≈ ", halfHoverLinkSize);
        }
      }
      var oldBatch = this._hoverLinkDataIndices;
      var newBatch = [];
      if (hoverOnBar || useHoverLinkOnHandle(visualMapModel)) {
        newBatch = this._hoverLinkDataIndices = visualMapModel.findTargetDataIndices(valueRange);
      }
      var resultBatches = compressBatches(oldBatch, newBatch);
      this._dispatchHighDown("downplay", makeHighDownBatch(resultBatches[0], visualMapModel));
      this._dispatchHighDown("highlight", makeHighDownBatch(resultBatches[1], visualMapModel));
    };
    ContinuousView2.prototype._hoverLinkFromSeriesMouseOver = function(e2) {
      var el = e2.target;
      var visualMapModel = this.visualMapModel;
      if (!el || getECData(el).dataIndex == null) {
        return;
      }
      var ecData = getECData(el);
      var dataModel = this.ecModel.getSeriesByIndex(ecData.seriesIndex);
      if (!visualMapModel.isTargetSeries(dataModel)) {
        return;
      }
      var data = dataModel.getData(ecData.dataType);
      var value = data.getStore().get(visualMapModel.getDataDimensionIndex(data), ecData.dataIndex);
      if (!isNaN(value)) {
        this._showIndicator(value, value);
      }
    };
    ContinuousView2.prototype._hideIndicator = function() {
      var shapes = this._shapes;
      shapes.indicator && shapes.indicator.attr("invisible", true);
      shapes.indicatorLabel && shapes.indicatorLabel.attr("invisible", true);
      var handleLabels = this._shapes.handleLabels;
      if (handleLabels) {
        for (var i = 0; i < handleLabels.length; i++) {
          this._api.leaveBlur(handleLabels[i]);
        }
      }
    };
    ContinuousView2.prototype._clearHoverLinkToSeries = function() {
      this._hideIndicator();
      var indices = this._hoverLinkDataIndices;
      this._dispatchHighDown("downplay", makeHighDownBatch(indices, this.visualMapModel));
      indices.length = 0;
    };
    ContinuousView2.prototype._clearHoverLinkFromSeries = function() {
      this._hideIndicator();
      var zr = this.api.getZr();
      zr.off("mouseover", this._hoverLinkFromSeriesMouseOver);
      zr.off("mouseout", this._hideIndicator);
    };
    ContinuousView2.prototype._applyTransform = function(vertex, element, inverse, global2) {
      var transform2 = getTransform(element, global2 ? null : this.group);
      return isArray(vertex) ? applyTransform2(vertex, transform2, inverse) : transformDirection(vertex, transform2, inverse);
    };
    ContinuousView2.prototype._dispatchHighDown = function(type, batch) {
      batch && batch.length && this.api.dispatchAction({
        type,
        batch
      });
    };
    ContinuousView2.prototype.dispose = function() {
      this._clearHoverLinkFromSeries();
      this._clearHoverLinkToSeries();
    };
    ContinuousView2.prototype.remove = function() {
      this._clearHoverLinkFromSeries();
      this._clearHoverLinkToSeries();
    };
    ContinuousView2.type = "visualMap.continuous";
    return ContinuousView2;
  }(VisualMapView_default);
  function createPolygon(points4, cursor, onDrift, onDragEnd) {
    return new Polygon_default({
      shape: {
        points: points4
      },
      draggable: !!onDrift,
      cursor,
      drift: onDrift,
      onmousemove: function(e2) {
        stop(e2.event);
      },
      ondragend: onDragEnd
    });
  }
  function getHalfHoverLinkSize(visualMapModel, dataExtent, sizeExtent) {
    var halfHoverLinkSize = HOVER_LINK_SIZE / 2;
    var hoverLinkDataSize = visualMapModel.get("hoverLinkDataSize");
    if (hoverLinkDataSize) {
      halfHoverLinkSize = linearMap3(hoverLinkDataSize, dataExtent, sizeExtent, true) / 2;
    }
    return halfHoverLinkSize;
  }
  function useHoverLinkOnHandle(visualMapModel) {
    var hoverLinkOnHandle = visualMapModel.get("hoverLinkOnHandle");
    return !!(hoverLinkOnHandle == null ? visualMapModel.get("realtime") : hoverLinkOnHandle);
  }
  function getCursor2(orient) {
    return orient === "vertical" ? "ns-resize" : "ew-resize";
  }
  var ContinuousView_default = ContinuousView;

  // node_modules/echarts/lib/component/visualMap/visualMapAction.js
  var visualMapActionInfo = {
    type: "selectDataRange",
    event: "dataRangeSelected",
    update: "update"
  };
  var visualMapActionHander = function(payload, ecModel) {
    ecModel.eachComponent({
      mainType: "visualMap",
      query: payload
    }, function(model) {
      model.setSelected(payload.selected);
    });
  };

  // node_modules/echarts/lib/component/visualMap/visualEncoding.js
  var visualMapEncodingHandlers = [
    {
      createOnAllSeries: true,
      reset: function(seriesModel, ecModel) {
        var resetDefines = [];
        ecModel.eachComponent("visualMap", function(visualMapModel) {
          var pipelineContext = seriesModel.pipelineContext;
          if (!visualMapModel.isTargetSeries(seriesModel) || pipelineContext && pipelineContext.large) {
            return;
          }
          resetDefines.push(incrementalApplyVisual(visualMapModel.stateList, visualMapModel.targetVisuals, bind(visualMapModel.getValueState, visualMapModel), visualMapModel.getDataDimensionIndex(seriesModel.getData())));
        });
        return resetDefines;
      }
    },
    {
      createOnAllSeries: true,
      reset: function(seriesModel, ecModel) {
        var data = seriesModel.getData();
        var visualMetaList = [];
        ecModel.eachComponent("visualMap", function(visualMapModel) {
          if (visualMapModel.isTargetSeries(seriesModel)) {
            var visualMeta = visualMapModel.getVisualMeta(bind(getColorVisual, null, seriesModel, visualMapModel)) || {
              stops: [],
              outerColors: []
            };
            var dimIdx = visualMapModel.getDataDimensionIndex(data);
            if (dimIdx >= 0) {
              visualMeta.dimension = dimIdx;
              visualMetaList.push(visualMeta);
            }
          }
        });
        seriesModel.getData().setVisual("visualMeta", visualMetaList);
      }
    }
  ];
  function getColorVisual(seriesModel, visualMapModel, value, valueState) {
    var mappings = visualMapModel.targetVisuals[valueState];
    var visualTypes = VisualMapping_default.prepareVisualTypes(mappings);
    var resultVisual = {
      color: getVisualFromData(seriesModel.getData(), "color")
    };
    for (var i = 0, len2 = visualTypes.length; i < len2; i++) {
      var type = visualTypes[i];
      var mapping = mappings[type === "opacity" ? "__alphaForOpacity" : type];
      mapping && mapping.applyVisual(value, getVisual, setVisual);
    }
    return resultVisual.color;
    function getVisual(key) {
      return resultVisual[key];
    }
    function setVisual(key, value2) {
      resultVisual[key] = value2;
    }
  }

  // node_modules/echarts/lib/component/visualMap/preprocessor.js
  var each16 = each;
  function visualMapPreprocessor(option) {
    var visualMap = option && option.visualMap;
    if (!isArray(visualMap)) {
      visualMap = visualMap ? [visualMap] : [];
    }
    each16(visualMap, function(opt) {
      if (!opt) {
        return;
      }
      if (has2(opt, "splitList") && !has2(opt, "pieces")) {
        opt.pieces = opt.splitList;
        delete opt.splitList;
      }
      var pieces = opt.pieces;
      if (pieces && isArray(pieces)) {
        each16(pieces, function(piece) {
          if (isObject(piece)) {
            if (has2(piece, "start") && !has2(piece, "min")) {
              piece.min = piece.start;
            }
            if (has2(piece, "end") && !has2(piece, "max")) {
              piece.max = piece.end;
            }
          }
        });
      }
    });
  }
  function has2(obj, name) {
    return obj && obj.hasOwnProperty && obj.hasOwnProperty(name);
  }

  // node_modules/echarts/lib/component/visualMap/installCommon.js
  var installed2 = false;
  function installCommon2(registers) {
    if (installed2) {
      return;
    }
    installed2 = true;
    registers.registerSubTypeDefaulter("visualMap", function(option) {
      return !option.categories && (!(option.pieces ? option.pieces.length > 0 : option.splitNumber > 0) || option.calculable) ? "continuous" : "piecewise";
    });
    registers.registerAction(visualMapActionInfo, visualMapActionHander);
    each(visualMapEncodingHandlers, function(handler) {
      registers.registerVisual(registers.PRIORITY.VISUAL.COMPONENT, handler);
    });
    registers.registerPreprocessor(visualMapPreprocessor);
  }

  // node_modules/echarts/lib/component/visualMap/installVisualMapContinuous.js
  function install50(registers) {
    registers.registerComponentModel(ContinuousModel_default);
    registers.registerComponentView(ContinuousView_default);
    installCommon2(registers);
  }

  // node_modules/echarts/lib/component/visualMap/PiecewiseModel.js
  var PiecewiseModel = function(_super) {
    __extends(PiecewiseModel2, _super);
    function PiecewiseModel2() {
      var _this = _super !== null && _super.apply(this, arguments) || this;
      _this.type = PiecewiseModel2.type;
      _this._pieceList = [];
      return _this;
    }
    PiecewiseModel2.prototype.optionUpdated = function(newOption, isInit) {
      _super.prototype.optionUpdated.apply(this, arguments);
      this.resetExtent();
      var mode = this._mode = this._determineMode();
      this._pieceList = [];
      resetMethods[this._mode].call(this, this._pieceList);
      this._resetSelected(newOption, isInit);
      var categories = this.option.categories;
      this.resetVisual(function(mappingOption, state) {
        if (mode === "categories") {
          mappingOption.mappingMethod = "category";
          mappingOption.categories = clone(categories);
        } else {
          mappingOption.dataExtent = this.getExtent();
          mappingOption.mappingMethod = "piecewise";
          mappingOption.pieceList = map(this._pieceList, function(piece) {
            piece = clone(piece);
            if (state !== "inRange") {
              piece.visual = null;
            }
            return piece;
          });
        }
      });
    };
    PiecewiseModel2.prototype.completeVisualOption = function() {
      var option = this.option;
      var visualTypesInPieces = {};
      var visualTypes = VisualMapping_default.listVisualTypes();
      var isCategory2 = this.isCategory();
      each(option.pieces, function(piece) {
        each(visualTypes, function(visualType) {
          if (piece.hasOwnProperty(visualType)) {
            visualTypesInPieces[visualType] = 1;
          }
        });
      });
      each(visualTypesInPieces, function(v, visualType) {
        var exists = false;
        each(this.stateList, function(state) {
          exists = exists || has3(option, state, visualType) || has3(option.target, state, visualType);
        }, this);
        !exists && each(this.stateList, function(state) {
          (option[state] || (option[state] = {}))[visualType] = visualDefault_default.get(visualType, state === "inRange" ? "active" : "inactive", isCategory2);
        });
      }, this);
      function has3(obj, state, visualType) {
        return obj && obj[state] && obj[state].hasOwnProperty(visualType);
      }
      _super.prototype.completeVisualOption.apply(this, arguments);
    };
    PiecewiseModel2.prototype._resetSelected = function(newOption, isInit) {
      var thisOption = this.option;
      var pieceList = this._pieceList;
      var selected = (isInit ? thisOption : newOption).selected || {};
      thisOption.selected = selected;
      each(pieceList, function(piece, index) {
        var key = this.getSelectedMapKey(piece);
        if (!selected.hasOwnProperty(key)) {
          selected[key] = true;
        }
      }, this);
      if (thisOption.selectedMode === "single") {
        var hasSel_1 = false;
        each(pieceList, function(piece, index) {
          var key = this.getSelectedMapKey(piece);
          if (selected[key]) {
            hasSel_1 ? selected[key] = false : hasSel_1 = true;
          }
        }, this);
      }
    };
    PiecewiseModel2.prototype.getItemSymbol = function() {
      return this.get("itemSymbol");
    };
    PiecewiseModel2.prototype.getSelectedMapKey = function(piece) {
      return this._mode === "categories" ? piece.value + "" : piece.index + "";
    };
    PiecewiseModel2.prototype.getPieceList = function() {
      return this._pieceList;
    };
    PiecewiseModel2.prototype._determineMode = function() {
      var option = this.option;
      return option.pieces && option.pieces.length > 0 ? "pieces" : this.option.categories ? "categories" : "splitNumber";
    };
    PiecewiseModel2.prototype.setSelected = function(selected) {
      this.option.selected = clone(selected);
    };
    PiecewiseModel2.prototype.getValueState = function(value) {
      var index = VisualMapping_default.findPieceIndex(value, this._pieceList);
      return index != null ? this.option.selected[this.getSelectedMapKey(this._pieceList[index])] ? "inRange" : "outOfRange" : "outOfRange";
    };
    PiecewiseModel2.prototype.findTargetDataIndices = function(pieceIndex) {
      var result = [];
      var pieceList = this._pieceList;
      this.eachTargetSeries(function(seriesModel) {
        var dataIndices = [];
        var data = seriesModel.getData();
        data.each(this.getDataDimensionIndex(data), function(value, dataIndex) {
          var pIdx = VisualMapping_default.findPieceIndex(value, pieceList);
          pIdx === pieceIndex && dataIndices.push(dataIndex);
        }, this);
        result.push({
          seriesId: seriesModel.id,
          dataIndex: dataIndices
        });
      }, this);
      return result;
    };
    PiecewiseModel2.prototype.getRepresentValue = function(piece) {
      var representValue;
      if (this.isCategory()) {
        representValue = piece.value;
      } else {
        if (piece.value != null) {
          representValue = piece.value;
        } else {
          var pieceInterval = piece.interval || [];
          representValue = pieceInterval[0] === -Infinity && pieceInterval[1] === Infinity ? 0 : (pieceInterval[0] + pieceInterval[1]) / 2;
        }
      }
      return representValue;
    };
    PiecewiseModel2.prototype.getVisualMeta = function(getColorVisual2) {
      if (this.isCategory()) {
        return;
      }
      var stops = [];
      var outerColors = ["", ""];
      var visualMapModel = this;
      function setStop(interval, valueState) {
        var representValue = visualMapModel.getRepresentValue({
          interval
        });
        if (!valueState) {
          valueState = visualMapModel.getValueState(representValue);
        }
        var color = getColorVisual2(representValue, valueState);
        if (interval[0] === -Infinity) {
          outerColors[0] = color;
        } else if (interval[1] === Infinity) {
          outerColors[1] = color;
        } else {
          stops.push({
            value: interval[0],
            color
          }, {
            value: interval[1],
            color
          });
        }
      }
      var pieceList = this._pieceList.slice();
      if (!pieceList.length) {
        pieceList.push({
          interval: [-Infinity, Infinity]
        });
      } else {
        var edge = pieceList[0].interval[0];
        edge !== -Infinity && pieceList.unshift({
          interval: [-Infinity, edge]
        });
        edge = pieceList[pieceList.length - 1].interval[1];
        edge !== Infinity && pieceList.push({
          interval: [edge, Infinity]
        });
      }
      var curr = -Infinity;
      each(pieceList, function(piece) {
        var interval = piece.interval;
        if (interval) {
          interval[0] > curr && setStop([curr, interval[0]], "outOfRange");
          setStop(interval.slice());
          curr = interval[1];
        }
      }, this);
      return {
        stops,
        outerColors
      };
    };
    PiecewiseModel2.type = "visualMap.piecewise";
    PiecewiseModel2.defaultOption = inheritDefaultOption(VisualMapModel_default.defaultOption, {
      selected: null,
      minOpen: false,
      maxOpen: false,
      align: "auto",
      itemWidth: 20,
      itemHeight: 14,
      itemSymbol: "roundRect",
      pieces: null,
      categories: null,
      splitNumber: 5,
      selectedMode: "multiple",
      itemGap: 10,
      hoverLink: true
    });
    return PiecewiseModel2;
  }(VisualMapModel_default);
  var resetMethods = {
    splitNumber: function(outPieceList) {
      var thisOption = this.option;
      var precision = Math.min(thisOption.precision, 20);
      var dataExtent = this.getExtent();
      var splitNumber = thisOption.splitNumber;
      splitNumber = Math.max(parseInt(splitNumber, 10), 1);
      thisOption.splitNumber = splitNumber;
      var splitStep = (dataExtent[1] - dataExtent[0]) / splitNumber;
      while (+splitStep.toFixed(precision) !== splitStep && precision < 5) {
        precision++;
      }
      thisOption.precision = precision;
      splitStep = +splitStep.toFixed(precision);
      if (thisOption.minOpen) {
        outPieceList.push({
          interval: [-Infinity, dataExtent[0]],
          close: [0, 0]
        });
      }
      for (var index = 0, curr = dataExtent[0]; index < splitNumber; curr += splitStep, index++) {
        var max3 = index === splitNumber - 1 ? dataExtent[1] : curr + splitStep;
        outPieceList.push({
          interval: [curr, max3],
          close: [1, 1]
        });
      }
      if (thisOption.maxOpen) {
        outPieceList.push({
          interval: [dataExtent[1], Infinity],
          close: [0, 0]
        });
      }
      reformIntervals(outPieceList);
      each(outPieceList, function(piece, index2) {
        piece.index = index2;
        piece.text = this.formatValueText(piece.interval);
      }, this);
    },
    categories: function(outPieceList) {
      var thisOption = this.option;
      each(thisOption.categories, function(cate) {
        outPieceList.push({
          text: this.formatValueText(cate, true),
          value: cate
        });
      }, this);
      normalizeReverse(thisOption, outPieceList);
    },
    pieces: function(outPieceList) {
      var thisOption = this.option;
      each(thisOption.pieces, function(pieceListItem, index) {
        if (!isObject(pieceListItem)) {
          pieceListItem = {
            value: pieceListItem
          };
        }
        var item = {
          text: "",
          index
        };
        if (pieceListItem.label != null) {
          item.text = pieceListItem.label;
        }
        if (pieceListItem.hasOwnProperty("value")) {
          var value = item.value = pieceListItem.value;
          item.interval = [value, value];
          item.close = [1, 1];
        } else {
          var interval = item.interval = [];
          var close_1 = item.close = [0, 0];
          var closeList = [1, 0, 1];
          var infinityList = [-Infinity, Infinity];
          var useMinMax = [];
          for (var lg = 0; lg < 2; lg++) {
            var names = [["gte", "gt", "min"], ["lte", "lt", "max"]][lg];
            for (var i = 0; i < 3 && interval[lg] == null; i++) {
              interval[lg] = pieceListItem[names[i]];
              close_1[lg] = closeList[i];
              useMinMax[lg] = i === 2;
            }
            interval[lg] == null && (interval[lg] = infinityList[lg]);
          }
          useMinMax[0] && interval[1] === Infinity && (close_1[0] = 0);
          useMinMax[1] && interval[0] === -Infinity && (close_1[1] = 0);
          if (true) {
            if (interval[0] > interval[1]) {
              console.warn("Piece " + index + "is illegal: " + interval + " lower bound should not greater then uppper bound.");
            }
          }
          if (interval[0] === interval[1] && close_1[0] && close_1[1]) {
            item.value = interval[0];
          }
        }
        item.visual = VisualMapping_default.retrieveVisuals(pieceListItem);
        outPieceList.push(item);
      }, this);
      normalizeReverse(thisOption, outPieceList);
      reformIntervals(outPieceList);
      each(outPieceList, function(piece) {
        var close = piece.close;
        var edgeSymbols = [["<", "≤"][close[1]], [">", "≥"][close[0]]];
        piece.text = piece.text || this.formatValueText(piece.value != null ? piece.value : piece.interval, false, edgeSymbols);
      }, this);
    }
  };
  function normalizeReverse(thisOption, pieceList) {
    var inverse = thisOption.inverse;
    if (thisOption.orient === "vertical" ? !inverse : inverse) {
      pieceList.reverse();
    }
  }
  var PiecewiseModel_default = PiecewiseModel;

  // node_modules/echarts/lib/component/visualMap/PiecewiseView.js
  var PiecewiseVisualMapView = function(_super) {
    __extends(PiecewiseVisualMapView2, _super);
    function PiecewiseVisualMapView2() {
      var _this = _super !== null && _super.apply(this, arguments) || this;
      _this.type = PiecewiseVisualMapView2.type;
      return _this;
    }
    PiecewiseVisualMapView2.prototype.doRender = function() {
      var thisGroup = this.group;
      thisGroup.removeAll();
      var visualMapModel = this.visualMapModel;
      var textGap = visualMapModel.get("textGap");
      var textStyleModel = visualMapModel.textStyleModel;
      var textFont = textStyleModel.getFont();
      var textFill = textStyleModel.getTextColor();
      var itemAlign = this._getItemAlign();
      var itemSize = visualMapModel.itemSize;
      var viewData = this._getViewData();
      var endsText = viewData.endsText;
      var showLabel = retrieve(visualMapModel.get("showLabel", true), !endsText);
      endsText && this._renderEndsText(thisGroup, endsText[0], itemSize, showLabel, itemAlign);
      each(viewData.viewPieceList, function(item) {
        var piece = item.piece;
        var itemGroup = new Group_default();
        itemGroup.onclick = bind(this._onItemClick, this, piece);
        this._enableHoverLink(itemGroup, item.indexInModelPieceList);
        var representValue = visualMapModel.getRepresentValue(piece);
        this._createItemSymbol(itemGroup, representValue, [0, 0, itemSize[0], itemSize[1]]);
        if (showLabel) {
          var visualState = this.visualMapModel.getValueState(representValue);
          itemGroup.add(new Text_default({
            style: {
              x: itemAlign === "right" ? -textGap : itemSize[0] + textGap,
              y: itemSize[1] / 2,
              text: piece.text,
              verticalAlign: "middle",
              align: itemAlign,
              font: textFont,
              fill: textFill,
              opacity: visualState === "outOfRange" ? 0.5 : 1
            }
          }));
        }
        thisGroup.add(itemGroup);
      }, this);
      endsText && this._renderEndsText(thisGroup, endsText[1], itemSize, showLabel, itemAlign);
      box(visualMapModel.get("orient"), thisGroup, visualMapModel.get("itemGap"));
      this.renderBackground(thisGroup);
      this.positionGroup(thisGroup);
    };
    PiecewiseVisualMapView2.prototype._enableHoverLink = function(itemGroup, pieceIndex) {
      var _this = this;
      itemGroup.on("mouseover", function() {
        return onHoverLink("highlight");
      }).on("mouseout", function() {
        return onHoverLink("downplay");
      });
      var onHoverLink = function(method) {
        var visualMapModel = _this.visualMapModel;
        visualMapModel.option.hoverLink && _this.api.dispatchAction({
          type: method,
          batch: makeHighDownBatch(visualMapModel.findTargetDataIndices(pieceIndex), visualMapModel)
        });
      };
    };
    PiecewiseVisualMapView2.prototype._getItemAlign = function() {
      var visualMapModel = this.visualMapModel;
      var modelOption = visualMapModel.option;
      if (modelOption.orient === "vertical") {
        return getItemAlign(visualMapModel, this.api, visualMapModel.itemSize);
      } else {
        var align = modelOption.align;
        if (!align || align === "auto") {
          align = "left";
        }
        return align;
      }
    };
    PiecewiseVisualMapView2.prototype._renderEndsText = function(group, text, itemSize, showLabel, itemAlign) {
      if (!text) {
        return;
      }
      var itemGroup = new Group_default();
      var textStyleModel = this.visualMapModel.textStyleModel;
      itemGroup.add(new Text_default({
        style: createTextStyle(textStyleModel, {
          x: showLabel ? itemAlign === "right" ? itemSize[0] : 0 : itemSize[0] / 2,
          y: itemSize[1] / 2,
          verticalAlign: "middle",
          align: showLabel ? itemAlign : "center",
          text
        })
      }));
      group.add(itemGroup);
    };
    PiecewiseVisualMapView2.prototype._getViewData = function() {
      var visualMapModel = this.visualMapModel;
      var viewPieceList = map(visualMapModel.getPieceList(), function(piece, index) {
        return {
          piece,
          indexInModelPieceList: index
        };
      });
      var endsText = visualMapModel.get("text");
      var orient = visualMapModel.get("orient");
      var inverse = visualMapModel.get("inverse");
      if (orient === "horizontal" ? inverse : !inverse) {
        viewPieceList.reverse();
      } else if (endsText) {
        endsText = endsText.slice().reverse();
      }
      return {
        viewPieceList,
        endsText
      };
    };
    PiecewiseVisualMapView2.prototype._createItemSymbol = function(group, representValue, shapeParam) {
      group.add(createSymbol(this.getControllerVisual(representValue, "symbol"), shapeParam[0], shapeParam[1], shapeParam[2], shapeParam[3], this.getControllerVisual(representValue, "color")));
    };
    PiecewiseVisualMapView2.prototype._onItemClick = function(piece) {
      var visualMapModel = this.visualMapModel;
      var option = visualMapModel.option;
      var selectedMode = option.selectedMode;
      if (!selectedMode) {
        return;
      }
      var selected = clone(option.selected);
      var newKey = visualMapModel.getSelectedMapKey(piece);
      if (selectedMode === "single" || selectedMode === true) {
        selected[newKey] = true;
        each(selected, function(o, key) {
          selected[key] = key === newKey;
        });
      } else {
        selected[newKey] = !selected[newKey];
      }
      this.api.dispatchAction({
        type: "selectDataRange",
        from: this.uid,
        visualMapId: this.visualMapModel.id,
        selected
      });
    };
    PiecewiseVisualMapView2.type = "visualMap.piecewise";
    return PiecewiseVisualMapView2;
  }(VisualMapView_default);
  var PiecewiseView_default = PiecewiseVisualMapView;

  // node_modules/echarts/lib/component/visualMap/installVisualMapPiecewise.js
  function install51(registers) {
    registers.registerComponentModel(PiecewiseModel_default);
    registers.registerComponentView(PiecewiseView_default);
    installCommon2(registers);
  }

  // node_modules/echarts/lib/component/visualMap/install.js
  function install52(registers) {
    use(install50);
    use(install51);
  }

  // node_modules/echarts/lib/visual/aria.js
  var DEFAULT_OPTION = {
    label: {
      enabled: true
    },
    decal: {
      show: false
    }
  };
  var inner22 = makeInner();
  var decalPaletteScope = {};
  function ariaVisual(ecModel, api) {
    var ariaModel = ecModel.getModel("aria");
    if (!ariaModel.get("enabled")) {
      return;
    }
    var defaultOption3 = clone(DEFAULT_OPTION);
    merge(defaultOption3.label, ecModel.getLocaleModel().get("aria"), false);
    merge(ariaModel.option, defaultOption3, false);
    setDecal();
    setLabel();
    function setDecal() {
      var decalModel = ariaModel.getModel("decal");
      var useDecal = decalModel.get("show");
      if (useDecal) {
        var paletteScopeGroupByType_1 = createHashMap();
        ecModel.eachSeries(function(seriesModel) {
          if (seriesModel.isColorBySeries()) {
            return;
          }
          var decalScope = paletteScopeGroupByType_1.get(seriesModel.type);
          if (!decalScope) {
            decalScope = {};
            paletteScopeGroupByType_1.set(seriesModel.type, decalScope);
          }
          inner22(seriesModel).scope = decalScope;
        });
        ecModel.eachRawSeries(function(seriesModel) {
          if (ecModel.isSeriesFiltered(seriesModel)) {
            return;
          }
          if (isFunction(seriesModel.enableAriaDecal)) {
            seriesModel.enableAriaDecal();
            return;
          }
          var data = seriesModel.getData();
          if (!seriesModel.isColorBySeries()) {
            var dataAll_1 = seriesModel.getRawData();
            var idxMap_1 = {};
            var decalScope_1 = inner22(seriesModel).scope;
            data.each(function(idx) {
              var rawIdx = data.getRawIndex(idx);
              idxMap_1[rawIdx] = idx;
            });
            var dataCount_1 = dataAll_1.count();
            dataAll_1.each(function(rawIdx) {
              var idx = idxMap_1[rawIdx];
              var name = dataAll_1.getName(rawIdx) || rawIdx + "";
              var paletteDecal2 = getDecalFromPalette(seriesModel.ecModel, name, decalScope_1, dataCount_1);
              var specifiedDecal2 = data.getItemVisual(idx, "decal");
              data.setItemVisual(idx, "decal", mergeDecal(specifiedDecal2, paletteDecal2));
            });
          } else {
            var paletteDecal = getDecalFromPalette(seriesModel.ecModel, seriesModel.name, decalPaletteScope, ecModel.getSeriesCount());
            var specifiedDecal = data.getVisual("decal");
            data.setVisual("decal", mergeDecal(specifiedDecal, paletteDecal));
          }
          function mergeDecal(specifiedDecal2, paletteDecal2) {
            var resultDecal = specifiedDecal2 ? extend(extend({}, paletteDecal2), specifiedDecal2) : paletteDecal2;
            resultDecal.dirty = true;
            return resultDecal;
          }
        });
      }
    }
    function setLabel() {
      var labelLocale = ecModel.getLocaleModel().get("aria");
      var labelModel = ariaModel.getModel("label");
      labelModel.option = defaults(labelModel.option, labelLocale);
      if (!labelModel.get("enabled")) {
        return;
      }
      var dom = api.getZr().dom;
      if (labelModel.get("description")) {
        dom.setAttribute("aria-label", labelModel.get("description"));
        return;
      }
      var seriesCnt = ecModel.getSeriesCount();
      var maxDataCnt = labelModel.get(["data", "maxCount"]) || 10;
      var maxSeriesCnt = labelModel.get(["series", "maxCount"]) || 10;
      var displaySeriesCnt = Math.min(seriesCnt, maxSeriesCnt);
      var ariaLabel;
      if (seriesCnt < 1) {
        return;
      } else {
        var title = getTitle();
        if (title) {
          var withTitle = labelModel.get(["general", "withTitle"]);
          ariaLabel = replace(withTitle, {
            title
          });
        } else {
          ariaLabel = labelModel.get(["general", "withoutTitle"]);
        }
        var seriesLabels_1 = [];
        var prefix = seriesCnt > 1 ? labelModel.get(["series", "multiple", "prefix"]) : labelModel.get(["series", "single", "prefix"]);
        ariaLabel += replace(prefix, {
          seriesCount: seriesCnt
        });
        ecModel.eachSeries(function(seriesModel, idx) {
          if (idx < displaySeriesCnt) {
            var seriesLabel = void 0;
            var seriesName = seriesModel.get("name");
            var withName = seriesName ? "withName" : "withoutName";
            seriesLabel = seriesCnt > 1 ? labelModel.get(["series", "multiple", withName]) : labelModel.get(["series", "single", withName]);
            seriesLabel = replace(seriesLabel, {
              seriesId: seriesModel.seriesIndex,
              seriesName: seriesModel.get("name"),
              seriesType: getSeriesTypeName(seriesModel.subType)
            });
            var data = seriesModel.getData();
            if (data.count() > maxDataCnt) {
              var partialLabel = labelModel.get(["data", "partialData"]);
              seriesLabel += replace(partialLabel, {
                displayCnt: maxDataCnt
              });
            } else {
              seriesLabel += labelModel.get(["data", "allData"]);
            }
            var middleSeparator_1 = labelModel.get(["data", "separator", "middle"]);
            var endSeparator_1 = labelModel.get(["data", "separator", "end"]);
            var dataLabels = [];
            for (var i = 0; i < data.count(); i++) {
              if (i < maxDataCnt) {
                var name_1 = data.getName(i);
                var value = data.getValues(i);
                var dataLabel = labelModel.get(["data", name_1 ? "withName" : "withoutName"]);
                dataLabels.push(replace(dataLabel, {
                  name: name_1,
                  value: value.join(middleSeparator_1)
                }));
              }
            }
            seriesLabel += dataLabels.join(middleSeparator_1) + endSeparator_1;
            seriesLabels_1.push(seriesLabel);
          }
        });
        var separatorModel = labelModel.getModel(["series", "multiple", "separator"]);
        var middleSeparator = separatorModel.get("middle");
        var endSeparator = separatorModel.get("end");
        ariaLabel += seriesLabels_1.join(middleSeparator) + endSeparator;
        dom.setAttribute("aria-label", ariaLabel);
      }
    }
    function replace(str, keyValues) {
      if (!isString(str)) {
        return str;
      }
      var result = str;
      each(keyValues, function(value, key) {
        result = result.replace(new RegExp("\\{\\s*" + key + "\\s*\\}", "g"), value);
      });
      return result;
    }
    function getTitle() {
      var title = ecModel.get("title");
      if (title && title.length) {
        title = title[0];
      }
      return title && title.text;
    }
    function getSeriesTypeName(type) {
      return ecModel.getLocaleModel().get(["series", "typeNames"])[type] || "自定义图";
    }
  }

  // node_modules/echarts/lib/component/aria/preprocessor.js
  function ariaPreprocessor(option) {
    if (!option || !option.aria) {
      return;
    }
    var aria = option.aria;
    if (aria.show != null) {
      aria.enabled = aria.show;
    }
    aria.label = aria.label || {};
    each(["description", "general", "series", "data"], function(name) {
      if (aria[name] != null) {
        aria.label[name] = aria[name];
      }
    });
  }

  // node_modules/echarts/lib/component/aria/install.js
  function install53(registers) {
    registers.registerPreprocessor(ariaPreprocessor);
    registers.registerVisual(registers.PRIORITY.VISUAL.ARIA, ariaVisual);
  }

  // node_modules/echarts/lib/util/conditionalExpression.js
  var RELATIONAL_EXPRESSION_OP_ALIAS_MAP = {
    value: "eq",
    "<": "lt",
    "<=": "lte",
    ">": "gt",
    ">=": "gte",
    "=": "eq",
    "!=": "ne",
    "<>": "ne"
  };
  var RegExpEvaluator = function() {
    function RegExpEvaluator2(rVal) {
      var condValue = this._condVal = isString(rVal) ? new RegExp(rVal) : isRegExp(rVal) ? rVal : null;
      if (condValue == null) {
        var errMsg = "";
        if (true) {
          errMsg = makePrintable("Illegal regexp", rVal, "in");
        }
        throwError(errMsg);
      }
    }
    RegExpEvaluator2.prototype.evaluate = function(lVal) {
      var type = typeof lVal;
      return isString(type) ? this._condVal.test(lVal) : isNumber(type) ? this._condVal.test(lVal + "") : false;
    };
    return RegExpEvaluator2;
  }();
  var ConstConditionInternal = function() {
    function ConstConditionInternal2() {
    }
    ConstConditionInternal2.prototype.evaluate = function() {
      return this.value;
    };
    return ConstConditionInternal2;
  }();
  var AndConditionInternal = function() {
    function AndConditionInternal2() {
    }
    AndConditionInternal2.prototype.evaluate = function() {
      var children = this.children;
      for (var i = 0; i < children.length; i++) {
        if (!children[i].evaluate()) {
          return false;
        }
      }
      return true;
    };
    return AndConditionInternal2;
  }();
  var OrConditionInternal = function() {
    function OrConditionInternal2() {
    }
    OrConditionInternal2.prototype.evaluate = function() {
      var children = this.children;
      for (var i = 0; i < children.length; i++) {
        if (children[i].evaluate()) {
          return true;
        }
      }
      return false;
    };
    return OrConditionInternal2;
  }();
  var NotConditionInternal = function() {
    function NotConditionInternal2() {
    }
    NotConditionInternal2.prototype.evaluate = function() {
      return !this.child.evaluate();
    };
    return NotConditionInternal2;
  }();
  var RelationalConditionInternal = function() {
    function RelationalConditionInternal2() {
    }
    RelationalConditionInternal2.prototype.evaluate = function() {
      var needParse = !!this.valueParser;
      var getValue = this.getValue;
      var tarValRaw = getValue(this.valueGetterParam);
      var tarValParsed = needParse ? this.valueParser(tarValRaw) : null;
      for (var i = 0; i < this.subCondList.length; i++) {
        if (!this.subCondList[i].evaluate(needParse ? tarValParsed : tarValRaw)) {
          return false;
        }
      }
      return true;
    };
    return RelationalConditionInternal2;
  }();
  function parseOption(exprOption, getters) {
    if (exprOption === true || exprOption === false) {
      var cond = new ConstConditionInternal();
      cond.value = exprOption;
      return cond;
    }
    var errMsg = "";
    if (!isObjectNotArray(exprOption)) {
      if (true) {
        errMsg = makePrintable("Illegal config. Expect a plain object but actually", exprOption);
      }
      throwError(errMsg);
    }
    if (exprOption.and) {
      return parseAndOrOption("and", exprOption, getters);
    } else if (exprOption.or) {
      return parseAndOrOption("or", exprOption, getters);
    } else if (exprOption.not) {
      return parseNotOption(exprOption, getters);
    }
    return parseRelationalOption(exprOption, getters);
  }
  function parseAndOrOption(op, exprOption, getters) {
    var subOptionArr = exprOption[op];
    var errMsg = "";
    if (true) {
      errMsg = makePrintable('"and"/"or" condition should only be `' + op + ": [...]` and must not be empty array.", "Illegal condition:", exprOption);
    }
    if (!isArray(subOptionArr)) {
      throwError(errMsg);
    }
    if (!subOptionArr.length) {
      throwError(errMsg);
    }
    var cond = op === "and" ? new AndConditionInternal() : new OrConditionInternal();
    cond.children = map(subOptionArr, function(subOption) {
      return parseOption(subOption, getters);
    });
    if (!cond.children.length) {
      throwError(errMsg);
    }
    return cond;
  }
  function parseNotOption(exprOption, getters) {
    var subOption = exprOption.not;
    var errMsg = "";
    if (true) {
      errMsg = makePrintable('"not" condition should only be `not: {}`.', "Illegal condition:", exprOption);
    }
    if (!isObjectNotArray(subOption)) {
      throwError(errMsg);
    }
    var cond = new NotConditionInternal();
    cond.child = parseOption(subOption, getters);
    if (!cond.child) {
      throwError(errMsg);
    }
    return cond;
  }
  function parseRelationalOption(exprOption, getters) {
    var errMsg = "";
    var valueGetterParam = getters.prepareGetValue(exprOption);
    var subCondList = [];
    var exprKeys = keys(exprOption);
    var parserName = exprOption.parser;
    var valueParser = parserName ? getRawValueParser(parserName) : null;
    for (var i = 0; i < exprKeys.length; i++) {
      var keyRaw = exprKeys[i];
      if (keyRaw === "parser" || getters.valueGetterAttrMap.get(keyRaw)) {
        continue;
      }
      var op = hasOwn(RELATIONAL_EXPRESSION_OP_ALIAS_MAP, keyRaw) ? RELATIONAL_EXPRESSION_OP_ALIAS_MAP[keyRaw] : keyRaw;
      var condValueRaw = exprOption[keyRaw];
      var condValueParsed = valueParser ? valueParser(condValueRaw) : condValueRaw;
      var evaluator = createFilterComparator(op, condValueParsed) || op === "reg" && new RegExpEvaluator(condValueParsed);
      if (!evaluator) {
        if (true) {
          errMsg = makePrintable('Illegal relational operation: "' + keyRaw + '" in condition:', exprOption);
        }
        throwError(errMsg);
      }
      subCondList.push(evaluator);
    }
    if (!subCondList.length) {
      if (true) {
        errMsg = makePrintable("Relational condition must have at least one operator.", "Illegal condition:", exprOption);
      }
      throwError(errMsg);
    }
    var cond = new RelationalConditionInternal();
    cond.valueGetterParam = valueGetterParam;
    cond.valueParser = valueParser;
    cond.getValue = getters.getValue;
    cond.subCondList = subCondList;
    return cond;
  }
  function isObjectNotArray(val) {
    return isObject(val) && !isArrayLike(val);
  }
  var ConditionalExpressionParsed = function() {
    function ConditionalExpressionParsed2(exprOption, getters) {
      this._cond = parseOption(exprOption, getters);
    }
    ConditionalExpressionParsed2.prototype.evaluate = function() {
      return this._cond.evaluate();
    };
    return ConditionalExpressionParsed2;
  }();
  function parseConditionalExpression(exprOption, getters) {
    return new ConditionalExpressionParsed(exprOption, getters);
  }

  // node_modules/echarts/lib/component/transform/filterTransform.js
  var filterTransform = {
    type: "echarts:filter",
    transform: function(params) {
      var upstream = params.upstream;
      var rawItem;
      var condition = parseConditionalExpression(params.config, {
        valueGetterAttrMap: createHashMap({
          dimension: true
        }),
        prepareGetValue: function(exprOption) {
          var errMsg = "";
          var dimLoose = exprOption.dimension;
          if (!hasOwn(exprOption, "dimension")) {
            if (true) {
              errMsg = makePrintable('Relation condition must has prop "dimension" specified.', "Illegal condition:", exprOption);
            }
            throwError(errMsg);
          }
          var dimInfo = upstream.getDimensionInfo(dimLoose);
          if (!dimInfo) {
            if (true) {
              errMsg = makePrintable("Can not find dimension info via: " + dimLoose + ".\n", "Existing dimensions: ", upstream.cloneAllDimensionInfo(), ".\n", "Illegal condition:", exprOption, ".\n");
            }
            throwError(errMsg);
          }
          return {
            dimIdx: dimInfo.index
          };
        },
        getValue: function(param) {
          return upstream.retrieveValueFromItem(rawItem, param.dimIdx);
        }
      });
      var resultData = [];
      for (var i = 0, len2 = upstream.count(); i < len2; i++) {
        rawItem = upstream.getRawDataItem(i);
        if (condition.evaluate()) {
          resultData.push(rawItem);
        }
      }
      return {
        data: resultData
      };
    }
  };

  // node_modules/echarts/lib/component/transform/sortTransform.js
  var sampleLog = "";
  if (true) {
    sampleLog = ["Valid config is like:", '{ dimension: "age", order: "asc" }', 'or [{ dimension: "age", order: "asc"], { dimension: "date", order: "desc" }]'].join(" ");
  }
  var sortTransform = {
    type: "echarts:sort",
    transform: function(params) {
      var upstream = params.upstream;
      var config = params.config;
      var errMsg = "";
      var orderExprList = normalizeToArray(config);
      if (!orderExprList.length) {
        if (true) {
          errMsg = "Empty `config` in sort transform.";
        }
        throwError(errMsg);
      }
      var orderDefList = [];
      each(orderExprList, function(orderExpr) {
        var dimLoose = orderExpr.dimension;
        var order = orderExpr.order;
        var parserName = orderExpr.parser;
        var incomparable = orderExpr.incomparable;
        if (dimLoose == null) {
          if (true) {
            errMsg = 'Sort transform config must has "dimension" specified.' + sampleLog;
          }
          throwError(errMsg);
        }
        if (order !== "asc" && order !== "desc") {
          if (true) {
            errMsg = 'Sort transform config must has "order" specified.' + sampleLog;
          }
          throwError(errMsg);
        }
        if (incomparable && incomparable !== "min" && incomparable !== "max") {
          var errMsg_1 = "";
          if (true) {
            errMsg_1 = 'incomparable must be "min" or "max" rather than "' + incomparable + '".';
          }
          throwError(errMsg_1);
        }
        if (order !== "asc" && order !== "desc") {
          var errMsg_2 = "";
          if (true) {
            errMsg_2 = 'order must be "asc" or "desc" rather than "' + order + '".';
          }
          throwError(errMsg_2);
        }
        var dimInfo = upstream.getDimensionInfo(dimLoose);
        if (!dimInfo) {
          if (true) {
            errMsg = makePrintable("Can not find dimension info via: " + dimLoose + ".\n", "Existing dimensions: ", upstream.cloneAllDimensionInfo(), ".\n", "Illegal config:", orderExpr, ".\n");
          }
          throwError(errMsg);
        }
        var parser = parserName ? getRawValueParser(parserName) : null;
        if (parserName && !parser) {
          if (true) {
            errMsg = makePrintable("Invalid parser name " + parserName + ".\n", "Illegal config:", orderExpr, ".\n");
          }
          throwError(errMsg);
        }
        orderDefList.push({
          dimIdx: dimInfo.index,
          parser,
          comparator: new SortOrderComparator(order, incomparable)
        });
      });
      var sourceFormat = upstream.sourceFormat;
      if (sourceFormat !== SOURCE_FORMAT_ARRAY_ROWS && sourceFormat !== SOURCE_FORMAT_OBJECT_ROWS) {
        if (true) {
          errMsg = 'sourceFormat "' + sourceFormat + '" is not supported yet';
        }
        throwError(errMsg);
      }
      var resultData = [];
      for (var i = 0, len2 = upstream.count(); i < len2; i++) {
        resultData.push(upstream.getRawDataItem(i));
      }
      resultData.sort(function(item0, item1) {
        for (var i2 = 0; i2 < orderDefList.length; i2++) {
          var orderDef = orderDefList[i2];
          var val0 = upstream.retrieveValueFromItem(item0, orderDef.dimIdx);
          var val1 = upstream.retrieveValueFromItem(item1, orderDef.dimIdx);
          if (orderDef.parser) {
            val0 = orderDef.parser(val0);
            val1 = orderDef.parser(val1);
          }
          var result = orderDef.comparator.evaluate(val0, val1);
          if (result !== 0) {
            return result;
          }
        }
        return 0;
      });
      return {
        data: resultData
      };
    }
  };

  // node_modules/echarts/lib/component/transform/install.js
  function install54(registers) {
    registers.registerTransform(filterTransform);
    registers.registerTransform(sortTransform);
  }

  // node_modules/echarts/lib/component/dataset/install.js
  var DatasetModel = function(_super) {
    __extends(DatasetModel2, _super);
    function DatasetModel2() {
      var _this = _super !== null && _super.apply(this, arguments) || this;
      _this.type = "dataset";
      return _this;
    }
    DatasetModel2.prototype.init = function(option, parentModel, ecModel) {
      _super.prototype.init.call(this, option, parentModel, ecModel);
      this._sourceManager = new SourceManager(this);
      disableTransformOptionMerge(this);
    };
    DatasetModel2.prototype.mergeOption = function(newOption, ecModel) {
      _super.prototype.mergeOption.call(this, newOption, ecModel);
      disableTransformOptionMerge(this);
    };
    DatasetModel2.prototype.optionUpdated = function() {
      this._sourceManager.dirty();
    };
    DatasetModel2.prototype.getSourceManager = function() {
      return this._sourceManager;
    };
    DatasetModel2.type = "dataset";
    DatasetModel2.defaultOption = {
      seriesLayoutBy: SERIES_LAYOUT_BY_COLUMN
    };
    return DatasetModel2;
  }(Component_default);
  var DatasetView = function(_super) {
    __extends(DatasetView2, _super);
    function DatasetView2() {
      var _this = _super !== null && _super.apply(this, arguments) || this;
      _this.type = "dataset";
      return _this;
    }
    DatasetView2.type = "dataset";
    return DatasetView2;
  }(Component_default2);
  function install55(registers) {
    registers.registerComponentModel(DatasetModel);
    registers.registerComponentView(DatasetView);
  }

  // node_modules/zrender/lib/tool/convertPath.js
  var CMD5 = PathProxy_default.CMD;
  function aroundEqual(a, b) {
    return Math.abs(a - b) < 1e-5;
  }
  function pathToBezierCurves(path) {
    var data = path.data;
    var len2 = path.len();
    var bezierArrayGroups = [];
    var currentSubpath;
    var xi = 0;
    var yi = 0;
    var x0 = 0;
    var y0 = 0;
    function createNewSubpath(x, y) {
      if (currentSubpath && currentSubpath.length > 2) {
        bezierArrayGroups.push(currentSubpath);
      }
      currentSubpath = [x, y];
    }
    function addLine(x02, y02, x12, y12) {
      if (!(aroundEqual(x02, x12) && aroundEqual(y02, y12))) {
        currentSubpath.push(x02, y02, x12, y12, x12, y12);
      }
    }
    function addArc(startAngle2, endAngle2, cx2, cy2, rx2, ry2) {
      var delta = Math.abs(endAngle2 - startAngle2);
      var len3 = Math.tan(delta / 4) * 4 / 3;
      var dir3 = endAngle2 < startAngle2 ? -1 : 1;
      var c1 = Math.cos(startAngle2);
      var s1 = Math.sin(startAngle2);
      var c2 = Math.cos(endAngle2);
      var s2 = Math.sin(endAngle2);
      var x12 = c1 * rx2 + cx2;
      var y12 = s1 * ry2 + cy2;
      var x4 = c2 * rx2 + cx2;
      var y4 = s2 * ry2 + cy2;
      var hx = rx2 * len3 * dir3;
      var hy = ry2 * len3 * dir3;
      currentSubpath.push(x12 - hx * s1, y12 + hy * c1, x4 + hx * s2, y4 - hy * c2, x4, y4);
    }
    var x1;
    var y1;
    var x2;
    var y2;
    for (var i = 0; i < len2; ) {
      var cmd = data[i++];
      var isFirst = i === 1;
      if (isFirst) {
        xi = data[i];
        yi = data[i + 1];
        x0 = xi;
        y0 = yi;
        if (cmd === CMD5.L || cmd === CMD5.C || cmd === CMD5.Q) {
          currentSubpath = [x0, y0];
        }
      }
      switch (cmd) {
        case CMD5.M:
          xi = x0 = data[i++];
          yi = y0 = data[i++];
          createNewSubpath(x0, y0);
          break;
        case CMD5.L:
          x1 = data[i++];
          y1 = data[i++];
          addLine(xi, yi, x1, y1);
          xi = x1;
          yi = y1;
          break;
        case CMD5.C:
          currentSubpath.push(data[i++], data[i++], data[i++], data[i++], xi = data[i++], yi = data[i++]);
          break;
        case CMD5.Q:
          x1 = data[i++];
          y1 = data[i++];
          x2 = data[i++];
          y2 = data[i++];
          currentSubpath.push(xi + 2 / 3 * (x1 - xi), yi + 2 / 3 * (y1 - yi), x2 + 2 / 3 * (x1 - x2), y2 + 2 / 3 * (y1 - y2), x2, y2);
          xi = x2;
          yi = y2;
          break;
        case CMD5.A:
          var cx = data[i++];
          var cy = data[i++];
          var rx = data[i++];
          var ry = data[i++];
          var startAngle = data[i++];
          var endAngle = data[i++] + startAngle;
          i += 1;
          var anticlockwise = !data[i++];
          x1 = Math.cos(startAngle) * rx + cx;
          y1 = Math.sin(startAngle) * ry + cy;
          if (isFirst) {
            x0 = x1;
            y0 = y1;
            createNewSubpath(x0, y0);
          } else {
            addLine(xi, yi, x1, y1);
          }
          xi = Math.cos(endAngle) * rx + cx;
          yi = Math.sin(endAngle) * ry + cy;
          var step = (anticlockwise ? -1 : 1) * Math.PI / 2;
          for (var angle = startAngle; anticlockwise ? angle > endAngle : angle < endAngle; angle += step) {
            var nextAngle = anticlockwise ? Math.max(angle + step, endAngle) : Math.min(angle + step, endAngle);
            addArc(angle, nextAngle, cx, cy, rx, ry);
          }
          break;
        case CMD5.R:
          x0 = xi = data[i++];
          y0 = yi = data[i++];
          x1 = x0 + data[i++];
          y1 = y0 + data[i++];
          createNewSubpath(x1, y0);
          addLine(x1, y0, x1, y1);
          addLine(x1, y1, x0, y1);
          addLine(x0, y1, x0, y0);
          addLine(x0, y0, x1, y0);
          break;
        case CMD5.Z:
          currentSubpath && addLine(xi, yi, x0, y0);
          xi = x0;
          yi = y0;
          break;
      }
    }
    if (currentSubpath && currentSubpath.length > 2) {
      bezierArrayGroups.push(currentSubpath);
    }
    return bezierArrayGroups;
  }
  function adpativeBezier(x0, y0, x1, y1, x2, y2, x3, y3, out2, scale4) {
    if (aroundEqual(x0, x1) && aroundEqual(y0, y1) && aroundEqual(x2, x3) && aroundEqual(y2, y3)) {
      out2.push(x3, y3);
      return;
    }
    var PIXEL_DISTANCE = 2 / scale4;
    var PIXEL_DISTANCE_SQR = PIXEL_DISTANCE * PIXEL_DISTANCE;
    var dx = x3 - x0;
    var dy = y3 - y0;
    var d = Math.sqrt(dx * dx + dy * dy);
    dx /= d;
    dy /= d;
    var dx1 = x1 - x0;
    var dy1 = y1 - y0;
    var dx2 = x2 - x3;
    var dy2 = y2 - y3;
    var cp1LenSqr = dx1 * dx1 + dy1 * dy1;
    var cp2LenSqr = dx2 * dx2 + dy2 * dy2;
    if (cp1LenSqr < PIXEL_DISTANCE_SQR && cp2LenSqr < PIXEL_DISTANCE_SQR) {
      out2.push(x3, y3);
      return;
    }
    var projLen1 = dx * dx1 + dy * dy1;
    var projLen2 = -dx * dx2 - dy * dy2;
    var d1Sqr = cp1LenSqr - projLen1 * projLen1;
    var d2Sqr = cp2LenSqr - projLen2 * projLen2;
    if (d1Sqr < PIXEL_DISTANCE_SQR && projLen1 >= 0 && d2Sqr < PIXEL_DISTANCE_SQR && projLen2 >= 0) {
      out2.push(x3, y3);
      return;
    }
    var tmpSegX = [];
    var tmpSegY = [];
    cubicSubdivide(x0, x1, x2, x3, 0.5, tmpSegX);
    cubicSubdivide(y0, y1, y2, y3, 0.5, tmpSegY);
    adpativeBezier(tmpSegX[0], tmpSegY[0], tmpSegX[1], tmpSegY[1], tmpSegX[2], tmpSegY[2], tmpSegX[3], tmpSegY[3], out2, scale4);
    adpativeBezier(tmpSegX[4], tmpSegY[4], tmpSegX[5], tmpSegY[5], tmpSegX[6], tmpSegY[6], tmpSegX[7], tmpSegY[7], out2, scale4);
  }
  function pathToPolygons(path, scale4) {
    var bezierArrayGroups = pathToBezierCurves(path);
    var polygons = [];
    scale4 = scale4 || 1;
    for (var i = 0; i < bezierArrayGroups.length; i++) {
      var beziers = bezierArrayGroups[i];
      var polygon = [];
      var x0 = beziers[0];
      var y0 = beziers[1];
      polygon.push(x0, y0);
      for (var k = 2; k < beziers.length; ) {
        var x1 = beziers[k++];
        var y1 = beziers[k++];
        var x2 = beziers[k++];
        var y2 = beziers[k++];
        var x3 = beziers[k++];
        var y3 = beziers[k++];
        adpativeBezier(x0, y0, x1, y1, x2, y2, x3, y3, polygon, scale4);
        x0 = x3;
        y0 = y3;
      }
      polygons.push(polygon);
    }
    return polygons;
  }

  // node_modules/zrender/lib/tool/dividePath.js
  function getDividingGrids(dimSize, rowDim, count2) {
    var rowSize = dimSize[rowDim];
    var columnSize = dimSize[1 - rowDim];
    var ratio = Math.abs(rowSize / columnSize);
    var rowCount = Math.ceil(Math.sqrt(ratio * count2));
    var columnCount = Math.floor(count2 / rowCount);
    if (columnCount === 0) {
      columnCount = 1;
      rowCount = count2;
    }
    var grids = [];
    for (var i = 0; i < rowCount; i++) {
      grids.push(columnCount);
    }
    var currentCount = rowCount * columnCount;
    var remained = count2 - currentCount;
    if (remained > 0) {
      for (var i = 0; i < remained; i++) {
        grids[i % rowCount] += 1;
      }
    }
    return grids;
  }
  function divideSector(sectorShape, count2, outShapes) {
    var r0 = sectorShape.r0;
    var r = sectorShape.r;
    var startAngle = sectorShape.startAngle;
    var endAngle = sectorShape.endAngle;
    var angle = Math.abs(endAngle - startAngle);
    var arcLen = angle * r;
    var deltaR = r - r0;
    var isAngleRow = arcLen > Math.abs(deltaR);
    var grids = getDividingGrids([arcLen, deltaR], isAngleRow ? 0 : 1, count2);
    var rowSize = (isAngleRow ? angle : deltaR) / grids.length;
    for (var row = 0; row < grids.length; row++) {
      var columnSize = (isAngleRow ? deltaR : angle) / grids[row];
      for (var column = 0; column < grids[row]; column++) {
        var newShape = {};
        if (isAngleRow) {
          newShape.startAngle = startAngle + rowSize * row;
          newShape.endAngle = startAngle + rowSize * (row + 1);
          newShape.r0 = r0 + columnSize * column;
          newShape.r = r0 + columnSize * (column + 1);
        } else {
          newShape.startAngle = startAngle + columnSize * column;
          newShape.endAngle = startAngle + columnSize * (column + 1);
          newShape.r0 = r0 + rowSize * row;
          newShape.r = r0 + rowSize * (row + 1);
        }
        newShape.clockwise = sectorShape.clockwise;
        newShape.cx = sectorShape.cx;
        newShape.cy = sectorShape.cy;
        outShapes.push(newShape);
      }
    }
  }
  function divideRect(rectShape, count2, outShapes) {
    var width = rectShape.width;
    var height = rectShape.height;
    var isHorizontalRow = width > height;
    var grids = getDividingGrids([width, height], isHorizontalRow ? 0 : 1, count2);
    var rowSizeDim = isHorizontalRow ? "width" : "height";
    var columnSizeDim = isHorizontalRow ? "height" : "width";
    var rowDim = isHorizontalRow ? "x" : "y";
    var columnDim = isHorizontalRow ? "y" : "x";
    var rowSize = rectShape[rowSizeDim] / grids.length;
    for (var row = 0; row < grids.length; row++) {
      var columnSize = rectShape[columnSizeDim] / grids[row];
      for (var column = 0; column < grids[row]; column++) {
        var newShape = {};
        newShape[rowDim] = row * rowSize;
        newShape[columnDim] = column * columnSize;
        newShape[rowSizeDim] = rowSize;
        newShape[columnSizeDim] = columnSize;
        newShape.x += rectShape.x;
        newShape.y += rectShape.y;
        outShapes.push(newShape);
      }
    }
  }
  function crossProduct2d2(x1, y1, x2, y2) {
    return x1 * y2 - x2 * y1;
  }
  function lineLineIntersect2(a1x, a1y, a2x, a2y, b1x, b1y, b2x, b2y) {
    var mx = a2x - a1x;
    var my = a2y - a1y;
    var nx = b2x - b1x;
    var ny = b2y - b1y;
    var nmCrossProduct = crossProduct2d2(nx, ny, mx, my);
    if (Math.abs(nmCrossProduct) < 1e-6) {
      return null;
    }
    var b1a1x = a1x - b1x;
    var b1a1y = a1y - b1y;
    var p = crossProduct2d2(b1a1x, b1a1y, nx, ny) / nmCrossProduct;
    if (p < 0 || p > 1) {
      return null;
    }
    return new Point_default(p * mx + a1x, p * my + a1y);
  }
  function projPtOnLine(pt, lineA, lineB) {
    var dir3 = new Point_default();
    Point_default.sub(dir3, lineB, lineA);
    dir3.normalize();
    var dir22 = new Point_default();
    Point_default.sub(dir22, pt, lineA);
    var len2 = dir22.dot(dir3);
    return len2;
  }
  function addToPoly(poly, pt) {
    var last = poly[poly.length - 1];
    if (last && last[0] === pt[0] && last[1] === pt[1]) {
      return;
    }
    poly.push(pt);
  }
  function splitPolygonByLine(points4, lineA, lineB) {
    var len2 = points4.length;
    var intersections = [];
    for (var i = 0; i < len2; i++) {
      var p0 = points4[i];
      var p1 = points4[(i + 1) % len2];
      var intersectionPt = lineLineIntersect2(p0[0], p0[1], p1[0], p1[1], lineA.x, lineA.y, lineB.x, lineB.y);
      if (intersectionPt) {
        intersections.push({
          projPt: projPtOnLine(intersectionPt, lineA, lineB),
          pt: intersectionPt,
          idx: i
        });
      }
    }
    if (intersections.length < 2) {
      return [{ points: points4 }, { points: points4 }];
    }
    intersections.sort(function(a, b) {
      return a.projPt - b.projPt;
    });
    var splitPt0 = intersections[0];
    var splitPt1 = intersections[intersections.length - 1];
    if (splitPt1.idx < splitPt0.idx) {
      var tmp = splitPt0;
      splitPt0 = splitPt1;
      splitPt1 = tmp;
    }
    var splitPt0Arr = [splitPt0.pt.x, splitPt0.pt.y];
    var splitPt1Arr = [splitPt1.pt.x, splitPt1.pt.y];
    var newPolyA = [splitPt0Arr];
    var newPolyB = [splitPt1Arr];
    for (var i = splitPt0.idx + 1; i <= splitPt1.idx; i++) {
      addToPoly(newPolyA, points4[i].slice());
    }
    addToPoly(newPolyA, splitPt1Arr);
    addToPoly(newPolyA, splitPt0Arr);
    for (var i = splitPt1.idx + 1; i <= splitPt0.idx + len2; i++) {
      addToPoly(newPolyB, points4[i % len2].slice());
    }
    addToPoly(newPolyB, splitPt0Arr);
    addToPoly(newPolyB, splitPt1Arr);
    return [{
      points: newPolyA
    }, {
      points: newPolyB
    }];
  }
  function binaryDividePolygon(polygonShape) {
    var points4 = polygonShape.points;
    var min3 = [];
    var max3 = [];
    fromPoints(points4, min3, max3);
    var boundingRect = new BoundingRect_default(min3[0], min3[1], max3[0] - min3[0], max3[1] - min3[1]);
    var width = boundingRect.width;
    var height = boundingRect.height;
    var x = boundingRect.x;
    var y = boundingRect.y;
    var pt02 = new Point_default();
    var pt12 = new Point_default();
    if (width > height) {
      pt02.x = pt12.x = x + width / 2;
      pt02.y = y;
      pt12.y = y + height;
    } else {
      pt02.y = pt12.y = y + height / 2;
      pt02.x = x;
      pt12.x = x + width;
    }
    return splitPolygonByLine(points4, pt02, pt12);
  }
  function binaryDivideRecursive(divider, shape, count2, out2) {
    if (count2 === 1) {
      out2.push(shape);
    } else {
      var mid = Math.floor(count2 / 2);
      var sub2 = divider(shape);
      binaryDivideRecursive(divider, sub2[0], mid, out2);
      binaryDivideRecursive(divider, sub2[1], count2 - mid, out2);
    }
    return out2;
  }
  function clone5(path, count2) {
    var paths = [];
    for (var i = 0; i < count2; i++) {
      paths.push(clonePath(path));
    }
    return paths;
  }
  function copyPathProps(source, target) {
    target.setStyle(source.style);
    target.z = source.z;
    target.z2 = source.z2;
    target.zlevel = source.zlevel;
  }
  function polygonConvert(points4) {
    var out2 = [];
    for (var i = 0; i < points4.length; ) {
      out2.push([points4[i++], points4[i++]]);
    }
    return out2;
  }
  function split(path, count2) {
    var outShapes = [];
    var shape = path.shape;
    var OutShapeCtor;
    switch (path.type) {
      case "rect":
        divideRect(shape, count2, outShapes);
        OutShapeCtor = Rect_default;
        break;
      case "sector":
        divideSector(shape, count2, outShapes);
        OutShapeCtor = Sector_default;
        break;
      case "circle":
        divideSector({
          r0: 0,
          r: shape.r,
          startAngle: 0,
          endAngle: Math.PI * 2,
          cx: shape.cx,
          cy: shape.cy
        }, count2, outShapes);
        OutShapeCtor = Sector_default;
        break;
      default:
        var m2 = path.getComputedTransform();
        var scale4 = m2 ? Math.sqrt(Math.max(m2[0] * m2[0] + m2[1] * m2[1], m2[2] * m2[2] + m2[3] * m2[3])) : 1;
        var polygons = map(pathToPolygons(path.getUpdatedPathProxy(), scale4), function(poly) {
          return polygonConvert(poly);
        });
        var polygonCount = polygons.length;
        if (polygonCount === 0) {
          binaryDivideRecursive(binaryDividePolygon, {
            points: polygons[0]
          }, count2, outShapes);
        } else if (polygonCount === count2) {
          for (var i = 0; i < polygonCount; i++) {
            outShapes.push({
              points: polygons[i]
            });
          }
        } else {
          var totalArea_1 = 0;
          var items = map(polygons, function(poly) {
            var min3 = [];
            var max3 = [];
            fromPoints(poly, min3, max3);
            var area = (max3[1] - min3[1]) * (max3[0] - min3[0]);
            totalArea_1 += area;
            return { poly, area };
          });
          items.sort(function(a, b) {
            return b.area - a.area;
          });
          var left = count2;
          for (var i = 0; i < polygonCount; i++) {
            var item = items[i];
            if (left <= 0) {
              break;
            }
            var selfCount = i === polygonCount - 1 ? left : Math.ceil(item.area / totalArea_1 * count2);
            if (selfCount < 0) {
              continue;
            }
            binaryDivideRecursive(binaryDividePolygon, {
              points: item.poly
            }, selfCount, outShapes);
            left -= selfCount;
          }
          ;
        }
        OutShapeCtor = Polygon_default;
        break;
    }
    if (!OutShapeCtor) {
      return clone5(path, count2);
    }
    var out2 = [];
    for (var i = 0; i < outShapes.length; i++) {
      var subPath = new OutShapeCtor();
      subPath.setShape(outShapes[i]);
      copyPathProps(path, subPath);
      out2.push(subPath);
    }
    return out2;
  }

  // node_modules/zrender/lib/tool/morphPath.js
  function alignSubpath(subpath1, subpath2) {
    var len1 = subpath1.length;
    var len2 = subpath2.length;
    if (len1 === len2) {
      return [subpath1, subpath2];
    }
    var tmpSegX = [];
    var tmpSegY = [];
    var shorterPath = len1 < len2 ? subpath1 : subpath2;
    var shorterLen = Math.min(len1, len2);
    var diff = Math.abs(len2 - len1) / 6;
    var shorterBezierCount = (shorterLen - 2) / 6;
    var eachCurveSubDivCount = Math.ceil(diff / shorterBezierCount) + 1;
    var newSubpath = [shorterPath[0], shorterPath[1]];
    var remained = diff;
    for (var i = 2; i < shorterLen; ) {
      var x0 = shorterPath[i - 2];
      var y0 = shorterPath[i - 1];
      var x1 = shorterPath[i++];
      var y1 = shorterPath[i++];
      var x2 = shorterPath[i++];
      var y2 = shorterPath[i++];
      var x3 = shorterPath[i++];
      var y3 = shorterPath[i++];
      if (remained <= 0) {
        newSubpath.push(x1, y1, x2, y2, x3, y3);
        continue;
      }
      var actualSubDivCount = Math.min(remained, eachCurveSubDivCount - 1) + 1;
      for (var k = 1; k <= actualSubDivCount; k++) {
        var p = k / actualSubDivCount;
        cubicSubdivide(x0, x1, x2, x3, p, tmpSegX);
        cubicSubdivide(y0, y1, y2, y3, p, tmpSegY);
        x0 = tmpSegX[3];
        y0 = tmpSegY[3];
        newSubpath.push(tmpSegX[1], tmpSegY[1], tmpSegX[2], tmpSegY[2], x0, y0);
        x1 = tmpSegX[5];
        y1 = tmpSegY[5];
        x2 = tmpSegX[6];
        y2 = tmpSegY[6];
      }
      remained -= actualSubDivCount - 1;
    }
    return shorterPath === subpath1 ? [newSubpath, subpath2] : [subpath1, newSubpath];
  }
  function createSubpath(lastSubpathSubpath, otherSubpath) {
    var len2 = lastSubpathSubpath.length;
    var lastX = lastSubpathSubpath[len2 - 2];
    var lastY = lastSubpathSubpath[len2 - 1];
    var newSubpath = [];
    for (var i = 0; i < otherSubpath.length; ) {
      newSubpath[i++] = lastX;
      newSubpath[i++] = lastY;
    }
    return newSubpath;
  }
  function alignBezierCurves(array1, array2) {
    var _a2;
    var lastSubpath1;
    var lastSubpath2;
    var newArray1 = [];
    var newArray2 = [];
    for (var i = 0; i < Math.max(array1.length, array2.length); i++) {
      var subpath1 = array1[i];
      var subpath2 = array2[i];
      var newSubpath1 = void 0;
      var newSubpath2 = void 0;
      if (!subpath1) {
        newSubpath1 = createSubpath(lastSubpath1 || subpath2, subpath2);
        newSubpath2 = subpath2;
      } else if (!subpath2) {
        newSubpath2 = createSubpath(lastSubpath2 || subpath1, subpath1);
        newSubpath1 = subpath1;
      } else {
        _a2 = alignSubpath(subpath1, subpath2), newSubpath1 = _a2[0], newSubpath2 = _a2[1];
        lastSubpath1 = newSubpath1;
        lastSubpath2 = newSubpath2;
      }
      newArray1.push(newSubpath1);
      newArray2.push(newSubpath2);
    }
    return [newArray1, newArray2];
  }
  function centroid2(array) {
    var signedArea = 0;
    var cx = 0;
    var cy = 0;
    var len2 = array.length;
    for (var i = 0, j = len2 - 2; i < len2; j = i, i += 2) {
      var x0 = array[j];
      var y0 = array[j + 1];
      var x1 = array[i];
      var y1 = array[i + 1];
      var a = x0 * y1 - x1 * y0;
      signedArea += a;
      cx += (x0 + x1) * a;
      cy += (y0 + y1) * a;
    }
    if (signedArea === 0) {
      return [array[0] || 0, array[1] || 0];
    }
    return [cx / signedArea / 3, cy / signedArea / 3, signedArea];
  }
  function findBestRingOffset(fromSubBeziers, toSubBeziers, fromCp, toCp) {
    var bezierCount = (fromSubBeziers.length - 2) / 6;
    var bestScore = Infinity;
    var bestOffset = 0;
    var len2 = fromSubBeziers.length;
    var len22 = len2 - 2;
    for (var offset = 0; offset < bezierCount; offset++) {
      var cursorOffset = offset * 6;
      var score = 0;
      for (var k = 0; k < len2; k += 2) {
        var idx = k === 0 ? cursorOffset : (cursorOffset + k - 2) % len22 + 2;
        var x0 = fromSubBeziers[idx] - fromCp[0];
        var y0 = fromSubBeziers[idx + 1] - fromCp[1];
        var x1 = toSubBeziers[k] - toCp[0];
        var y1 = toSubBeziers[k + 1] - toCp[1];
        var dx = x1 - x0;
        var dy = y1 - y0;
        score += dx * dx + dy * dy;
      }
      if (score < bestScore) {
        bestScore = score;
        bestOffset = offset;
      }
    }
    return bestOffset;
  }
  function reverse(array) {
    var newArr = [];
    var len2 = array.length;
    for (var i = 0; i < len2; i += 2) {
      newArr[i] = array[len2 - i - 2];
      newArr[i + 1] = array[len2 - i - 1];
    }
    return newArr;
  }
  function findBestMorphingRotation(fromArr, toArr2, searchAngleIteration, searchAngleRange) {
    var result = [];
    var fromNeedsReverse;
    for (var i = 0; i < fromArr.length; i++) {
      var fromSubpathBezier = fromArr[i];
      var toSubpathBezier = toArr2[i];
      var fromCp = centroid2(fromSubpathBezier);
      var toCp = centroid2(toSubpathBezier);
      if (fromNeedsReverse == null) {
        fromNeedsReverse = fromCp[2] < 0 !== toCp[2] < 0;
      }
      var newFromSubpathBezier = [];
      var newToSubpathBezier = [];
      var bestAngle = 0;
      var bestScore = Infinity;
      var tmpArr2 = [];
      var len2 = fromSubpathBezier.length;
      if (fromNeedsReverse) {
        fromSubpathBezier = reverse(fromSubpathBezier);
      }
      var offset = findBestRingOffset(fromSubpathBezier, toSubpathBezier, fromCp, toCp) * 6;
      var len22 = len2 - 2;
      for (var k = 0; k < len22; k += 2) {
        var idx = (offset + k) % len22 + 2;
        newFromSubpathBezier[k + 2] = fromSubpathBezier[idx] - fromCp[0];
        newFromSubpathBezier[k + 3] = fromSubpathBezier[idx + 1] - fromCp[1];
      }
      newFromSubpathBezier[0] = fromSubpathBezier[offset] - fromCp[0];
      newFromSubpathBezier[1] = fromSubpathBezier[offset + 1] - fromCp[1];
      if (searchAngleIteration > 0) {
        var step = searchAngleRange / searchAngleIteration;
        for (var angle = -searchAngleRange / 2; angle <= searchAngleRange / 2; angle += step) {
          var sa = Math.sin(angle);
          var ca = Math.cos(angle);
          var score = 0;
          for (var k = 0; k < fromSubpathBezier.length; k += 2) {
            var x0 = newFromSubpathBezier[k];
            var y0 = newFromSubpathBezier[k + 1];
            var x1 = toSubpathBezier[k] - toCp[0];
            var y1 = toSubpathBezier[k + 1] - toCp[1];
            var newX1 = x1 * ca - y1 * sa;
            var newY1 = x1 * sa + y1 * ca;
            tmpArr2[k] = newX1;
            tmpArr2[k + 1] = newY1;
            var dx = newX1 - x0;
            var dy = newY1 - y0;
            score += dx * dx + dy * dy;
          }
          if (score < bestScore) {
            bestScore = score;
            bestAngle = angle;
            for (var m2 = 0; m2 < tmpArr2.length; m2++) {
              newToSubpathBezier[m2] = tmpArr2[m2];
            }
          }
        }
      } else {
        for (var i_1 = 0; i_1 < len2; i_1 += 2) {
          newToSubpathBezier[i_1] = toSubpathBezier[i_1] - toCp[0];
          newToSubpathBezier[i_1 + 1] = toSubpathBezier[i_1 + 1] - toCp[1];
        }
      }
      result.push({
        from: newFromSubpathBezier,
        to: newToSubpathBezier,
        fromCp,
        toCp,
        rotation: -bestAngle
      });
    }
    return result;
  }
  function isCombineMorphing(path) {
    return path.__isCombineMorphing;
  }
  var SAVED_METHOD_PREFIX = "__mOriginal_";
  function saveAndModifyMethod(obj, methodName, modifiers) {
    var savedMethodName = SAVED_METHOD_PREFIX + methodName;
    var originalMethod = obj[savedMethodName] || obj[methodName];
    if (!obj[savedMethodName]) {
      obj[savedMethodName] = obj[methodName];
    }
    var replace = modifiers.replace;
    var after = modifiers.after;
    var before = modifiers.before;
    obj[methodName] = function() {
      var args = arguments;
      var res;
      before && before.apply(this, args);
      if (replace) {
        res = replace.apply(this, args);
      } else {
        res = originalMethod.apply(this, args);
      }
      after && after.apply(this, args);
      return res;
    };
  }
  function restoreMethod(obj, methodName) {
    var savedMethodName = SAVED_METHOD_PREFIX + methodName;
    if (obj[savedMethodName]) {
      obj[methodName] = obj[savedMethodName];
      obj[savedMethodName] = null;
    }
  }
  function applyTransformOnBeziers(bezierCurves, mm) {
    for (var i = 0; i < bezierCurves.length; i++) {
      var subBeziers = bezierCurves[i];
      for (var k = 0; k < subBeziers.length; ) {
        var x = subBeziers[k];
        var y = subBeziers[k + 1];
        subBeziers[k++] = mm[0] * x + mm[2] * y + mm[4];
        subBeziers[k++] = mm[1] * x + mm[3] * y + mm[5];
      }
    }
  }
  function prepareMorphPath(fromPath, toPath) {
    var fromPathProxy = fromPath.getUpdatedPathProxy();
    var toPathProxy = toPath.getUpdatedPathProxy();
    var _a2 = alignBezierCurves(pathToBezierCurves(fromPathProxy), pathToBezierCurves(toPathProxy)), fromBezierCurves = _a2[0], toBezierCurves = _a2[1];
    var fromPathTransform = fromPath.getComputedTransform();
    var toPathTransform = toPath.getComputedTransform();
    function updateIdentityTransform() {
      this.transform = null;
    }
    fromPathTransform && applyTransformOnBeziers(fromBezierCurves, fromPathTransform);
    toPathTransform && applyTransformOnBeziers(toBezierCurves, toPathTransform);
    saveAndModifyMethod(toPath, "updateTransform", { replace: updateIdentityTransform });
    toPath.transform = null;
    var morphingData = findBestMorphingRotation(fromBezierCurves, toBezierCurves, 10, Math.PI);
    var tmpArr2 = [];
    saveAndModifyMethod(toPath, "buildPath", { replace: function(path) {
      var t = toPath.__morphT;
      var onet = 1 - t;
      var newCp = [];
      for (var i = 0; i < morphingData.length; i++) {
        var item = morphingData[i];
        var from = item.from;
        var to = item.to;
        var angle = item.rotation * t;
        var fromCp = item.fromCp;
        var toCp = item.toCp;
        var sa = Math.sin(angle);
        var ca = Math.cos(angle);
        lerp(newCp, fromCp, toCp, t);
        for (var m2 = 0; m2 < from.length; m2 += 2) {
          var x0_1 = from[m2];
          var y0_1 = from[m2 + 1];
          var x1 = to[m2];
          var y1 = to[m2 + 1];
          var x = x0_1 * onet + x1 * t;
          var y = y0_1 * onet + y1 * t;
          tmpArr2[m2] = x * ca - y * sa + newCp[0];
          tmpArr2[m2 + 1] = x * sa + y * ca + newCp[1];
        }
        var x0 = tmpArr2[0];
        var y0 = tmpArr2[1];
        path.moveTo(x0, y0);
        for (var m2 = 2; m2 < from.length; ) {
          var x1 = tmpArr2[m2++];
          var y1 = tmpArr2[m2++];
          var x2 = tmpArr2[m2++];
          var y2 = tmpArr2[m2++];
          var x3 = tmpArr2[m2++];
          var y3 = tmpArr2[m2++];
          if (x0 === x1 && y0 === y1 && x2 === x3 && y2 === y3) {
            path.lineTo(x3, y3);
          } else {
            path.bezierCurveTo(x1, y1, x2, y2, x3, y3);
          }
          x0 = x3;
          y0 = y3;
        }
      }
    } });
  }
  function morphPath(fromPath, toPath, animationOpts) {
    if (!fromPath || !toPath) {
      return toPath;
    }
    var oldDone = animationOpts.done;
    var oldDuring = animationOpts.during;
    prepareMorphPath(fromPath, toPath);
    toPath.__morphT = 0;
    function restoreToPath() {
      restoreMethod(toPath, "buildPath");
      restoreMethod(toPath, "updateTransform");
      toPath.__morphT = -1;
      toPath.createPathProxy();
      toPath.dirtyShape();
    }
    toPath.animateTo({
      __morphT: 1
    }, defaults({
      during: function(p) {
        toPath.dirtyShape();
        oldDuring && oldDuring(p);
      },
      done: function() {
        restoreToPath();
        oldDone && oldDone();
      }
    }, animationOpts));
    return toPath;
  }
  function hilbert(x, y, minX, minY, maxX, maxY) {
    var bits = 16;
    x = maxX === minX ? 0 : Math.round(32767 * (x - minX) / (maxX - minX));
    y = maxY === minY ? 0 : Math.round(32767 * (y - minY) / (maxY - minY));
    var d = 0;
    var tmp;
    for (var s = (1 << bits) / 2; s > 0; s /= 2) {
      var rx = 0;
      var ry = 0;
      if ((x & s) > 0) {
        rx = 1;
      }
      if ((y & s) > 0) {
        ry = 1;
      }
      d += s * s * (3 * rx ^ ry);
      if (ry === 0) {
        if (rx === 1) {
          x = s - 1 - x;
          y = s - 1 - y;
        }
        tmp = x;
        x = y;
        y = tmp;
      }
    }
    return d;
  }
  function sortPaths(pathList) {
    var xMin = Infinity;
    var yMin = Infinity;
    var xMax = -Infinity;
    var yMax = -Infinity;
    var cps = map(pathList, function(path) {
      var rect = path.getBoundingRect();
      var m2 = path.getComputedTransform();
      var x = rect.x + rect.width / 2 + (m2 ? m2[4] : 0);
      var y = rect.y + rect.height / 2 + (m2 ? m2[5] : 0);
      xMin = Math.min(x, xMin);
      yMin = Math.min(y, yMin);
      xMax = Math.max(x, xMax);
      yMax = Math.max(y, yMax);
      return [x, y];
    });
    var items = map(cps, function(cp, idx) {
      return {
        cp,
        z: hilbert(cp[0], cp[1], xMin, yMin, xMax, yMax),
        path: pathList[idx]
      };
    });
    return items.sort(function(a, b) {
      return a.z - b.z;
    }).map(function(item) {
      return item.path;
    });
  }
  function defaultDividePath(param) {
    return split(param.path, param.count);
  }
  function createEmptyReturn() {
    return {
      fromIndividuals: [],
      toIndividuals: [],
      count: 0
    };
  }
  function combineMorph(fromList, toPath, animationOpts) {
    var fromPathList = [];
    function addFromPath(fromList2) {
      for (var i2 = 0; i2 < fromList2.length; i2++) {
        var from2 = fromList2[i2];
        if (isCombineMorphing(from2)) {
          addFromPath(from2.childrenRef());
        } else if (from2 instanceof Path_default) {
          fromPathList.push(from2);
        }
      }
    }
    addFromPath(fromList);
    var separateCount = fromPathList.length;
    if (!separateCount) {
      return createEmptyReturn();
    }
    var dividePath = animationOpts.dividePath || defaultDividePath;
    var toSubPathList = dividePath({
      path: toPath,
      count: separateCount
    });
    if (toSubPathList.length !== separateCount) {
      console.error("Invalid morphing: unmatched splitted path");
      return createEmptyReturn();
    }
    fromPathList = sortPaths(fromPathList);
    toSubPathList = sortPaths(toSubPathList);
    var oldDone = animationOpts.done;
    var oldDuring = animationOpts.during;
    var individualDelay = animationOpts.individualDelay;
    var identityTransform = new Transformable_default();
    for (var i = 0; i < separateCount; i++) {
      var from = fromPathList[i];
      var to = toSubPathList[i];
      to.parent = toPath;
      to.copyTransform(identityTransform);
      if (!individualDelay) {
        prepareMorphPath(from, to);
      }
    }
    toPath.__isCombineMorphing = true;
    toPath.childrenRef = function() {
      return toSubPathList;
    };
    function addToSubPathListToZr(zr) {
      for (var i2 = 0; i2 < toSubPathList.length; i2++) {
        toSubPathList[i2].addSelfToZr(zr);
      }
    }
    saveAndModifyMethod(toPath, "addSelfToZr", {
      after: function(zr) {
        addToSubPathListToZr(zr);
      }
    });
    saveAndModifyMethod(toPath, "removeSelfFromZr", {
      after: function(zr) {
        for (var i2 = 0; i2 < toSubPathList.length; i2++) {
          toSubPathList[i2].removeSelfFromZr(zr);
        }
      }
    });
    function restoreToPath() {
      toPath.__isCombineMorphing = false;
      toPath.__morphT = -1;
      toPath.childrenRef = null;
      restoreMethod(toPath, "addSelfToZr");
      restoreMethod(toPath, "removeSelfFromZr");
    }
    var toLen = toSubPathList.length;
    if (individualDelay) {
      var animating_1 = toLen;
      var eachDone = function() {
        animating_1--;
        if (animating_1 === 0) {
          restoreToPath();
          oldDone && oldDone();
        }
      };
      for (var i = 0; i < toLen; i++) {
        var indivdualAnimationOpts = individualDelay ? defaults({
          delay: (animationOpts.delay || 0) + individualDelay(i, toLen, fromPathList[i], toSubPathList[i]),
          done: eachDone
        }, animationOpts) : animationOpts;
        morphPath(fromPathList[i], toSubPathList[i], indivdualAnimationOpts);
      }
    } else {
      toPath.__morphT = 0;
      toPath.animateTo({
        __morphT: 1
      }, defaults({
        during: function(p) {
          for (var i2 = 0; i2 < toLen; i2++) {
            var child = toSubPathList[i2];
            child.__morphT = toPath.__morphT;
            child.dirtyShape();
          }
          oldDuring && oldDuring(p);
        },
        done: function() {
          restoreToPath();
          for (var i2 = 0; i2 < fromList.length; i2++) {
            restoreMethod(fromList[i2], "updateTransform");
          }
          oldDone && oldDone();
        }
      }, animationOpts));
    }
    if (toPath.__zr) {
      addToSubPathListToZr(toPath.__zr);
    }
    return {
      fromIndividuals: fromPathList,
      toIndividuals: toSubPathList,
      count: toLen
    };
  }
  function separateMorph(fromPath, toPathList, animationOpts) {
    var toLen = toPathList.length;
    var fromPathList = [];
    var dividePath = animationOpts.dividePath || defaultDividePath;
    function addFromPath(fromList) {
      for (var i2 = 0; i2 < fromList.length; i2++) {
        var from = fromList[i2];
        if (isCombineMorphing(from)) {
          addFromPath(from.childrenRef());
        } else if (from instanceof Path_default) {
          fromPathList.push(from);
        }
      }
    }
    if (isCombineMorphing(fromPath)) {
      addFromPath(fromPath.childrenRef());
      var fromLen = fromPathList.length;
      if (fromLen < toLen) {
        var k = 0;
        for (var i = fromLen; i < toLen; i++) {
          fromPathList.push(clonePath(fromPathList[k++ % fromLen]));
        }
      }
      fromPathList.length = toLen;
    } else {
      fromPathList = dividePath({ path: fromPath, count: toLen });
      var fromPathTransform = fromPath.getComputedTransform();
      for (var i = 0; i < fromPathList.length; i++) {
        fromPathList[i].setLocalTransform(fromPathTransform);
      }
      if (fromPathList.length !== toLen) {
        console.error("Invalid morphing: unmatched splitted path");
        return createEmptyReturn();
      }
    }
    fromPathList = sortPaths(fromPathList);
    toPathList = sortPaths(toPathList);
    var individualDelay = animationOpts.individualDelay;
    for (var i = 0; i < toLen; i++) {
      var indivdualAnimationOpts = individualDelay ? defaults({
        delay: (animationOpts.delay || 0) + individualDelay(i, toLen, fromPathList[i], toPathList[i])
      }, animationOpts) : animationOpts;
      morphPath(fromPathList[i], toPathList[i], indivdualAnimationOpts);
    }
    return {
      fromIndividuals: fromPathList,
      toIndividuals: toPathList,
      count: toPathList.length
    };
  }

  // node_modules/echarts/lib/animation/morphTransitionHelper.js
  function isMultiple(elements) {
    return isArray(elements[0]);
  }
  function prepareMorphBatches(one, many) {
    var batches = [];
    var batchCount = one.length;
    for (var i = 0; i < batchCount; i++) {
      batches.push({
        one: one[i],
        many: []
      });
    }
    for (var i = 0; i < many.length; i++) {
      var len2 = many[i].length;
      var k = void 0;
      for (k = 0; k < len2; k++) {
        batches[k % batchCount].many.push(many[i][k]);
      }
    }
    var off = 0;
    for (var i = batchCount - 1; i >= 0; i--) {
      if (!batches[i].many.length) {
        var moveFrom = batches[off].many;
        if (moveFrom.length <= 1) {
          if (off) {
            off = 0;
          } else {
            return batches;
          }
        }
        var len2 = moveFrom.length;
        var mid = Math.ceil(len2 / 2);
        batches[i].many = moveFrom.slice(mid, len2);
        batches[off].many = moveFrom.slice(0, mid);
        off++;
      }
    }
    return batches;
  }
  var pathDividers = {
    clone: function(params) {
      var ret = [];
      var approxOpacity = 1 - Math.pow(1 - params.path.style.opacity, 1 / params.count);
      for (var i = 0; i < params.count; i++) {
        var cloned = clonePath(params.path);
        cloned.setStyle("opacity", approxOpacity);
        ret.push(cloned);
      }
      return ret;
    },
    split: null
  };
  function applyMorphAnimation(from, to, divideShape, seriesModel, dataIndex, animateOtherProps) {
    if (!from.length || !to.length) {
      return;
    }
    var updateAnimationCfg = getAnimationConfig("update", seriesModel, dataIndex);
    if (!(updateAnimationCfg && updateAnimationCfg.duration > 0)) {
      return;
    }
    var animationDelay = seriesModel.getModel("universalTransition").get("delay");
    var animationCfg = Object.assign({
      setToFinal: true
    }, updateAnimationCfg);
    var many;
    var one;
    if (isMultiple(from)) {
      many = from;
      one = to;
    }
    if (isMultiple(to)) {
      many = to;
      one = from;
    }
    function morphOneBatch(batch, fromIsMany2, animateIndex2, animateCount2, forceManyOne) {
      var batchMany = batch.many;
      var batchOne = batch.one;
      if (batchMany.length === 1 && !forceManyOne) {
        var batchFrom = fromIsMany2 ? batchMany[0] : batchOne;
        var batchTo = fromIsMany2 ? batchOne : batchMany[0];
        if (isCombineMorphing(batchFrom)) {
          morphOneBatch({
            many: [batchFrom],
            one: batchTo
          }, true, animateIndex2, animateCount2, true);
        } else {
          var individualAnimationCfg = animationDelay ? defaults({
            delay: animationDelay(animateIndex2, animateCount2)
          }, animationCfg) : animationCfg;
          morphPath(batchFrom, batchTo, individualAnimationCfg);
          animateOtherProps(batchFrom, batchTo, batchFrom, batchTo, individualAnimationCfg);
        }
      } else {
        var separateAnimationCfg = defaults({
          dividePath: pathDividers[divideShape],
          individualDelay: animationDelay && function(idx, count3, fromPath, toPath) {
            return animationDelay(idx + animateIndex2, animateCount2);
          }
        }, animationCfg);
        var _a2 = fromIsMany2 ? combineMorph(batchMany, batchOne, separateAnimationCfg) : separateMorph(batchOne, batchMany, separateAnimationCfg), fromIndividuals = _a2.fromIndividuals, toIndividuals = _a2.toIndividuals;
        var count2 = fromIndividuals.length;
        for (var k = 0; k < count2; k++) {
          var individualAnimationCfg = animationDelay ? defaults({
            delay: animationDelay(k, count2)
          }, animationCfg) : animationCfg;
          animateOtherProps(fromIndividuals[k], toIndividuals[k], fromIsMany2 ? batchMany[k] : batch.one, fromIsMany2 ? batch.one : batchMany[k], individualAnimationCfg);
        }
      }
    }
    var fromIsMany = many ? many === from : from.length > to.length;
    var morphBatches = many ? prepareMorphBatches(one, many) : prepareMorphBatches(fromIsMany ? to : from, [fromIsMany ? from : to]);
    var animateCount = 0;
    for (var i = 0; i < morphBatches.length; i++) {
      animateCount += morphBatches[i].many.length;
    }
    var animateIndex = 0;
    for (var i = 0; i < morphBatches.length; i++) {
      morphOneBatch(morphBatches[i], fromIsMany, animateIndex, animateCount);
      animateIndex += morphBatches[i].many.length;
    }
  }
  function getPathList(elements) {
    if (!elements) {
      return [];
    }
    if (isArray(elements)) {
      var pathList_1 = [];
      for (var i = 0; i < elements.length; i++) {
        pathList_1.push(getPathList(elements[i]));
      }
      return pathList_1;
    }
    var pathList = [];
    elements.traverse(function(el) {
      if (el instanceof Path_default && !el.disableMorphing && !el.invisible && !el.ignore) {
        pathList.push(el);
      }
    });
    return pathList;
  }

  // node_modules/echarts/lib/animation/universalTransition.js
  var DATA_COUNT_THRESHOLD = 1e4;
  var getUniversalTransitionGlobalStore = makeInner();
  function getGroupIdDimension(data) {
    var dimensions = data.dimensions;
    for (var i = 0; i < dimensions.length; i++) {
      var dimInfo = data.getDimensionInfo(dimensions[i]);
      if (dimInfo && dimInfo.otherDims.itemGroupId === 0) {
        return dimensions[i];
      }
    }
  }
  function flattenDataDiffItems(list) {
    var items = [];
    each(list, function(seriesInfo) {
      var data = seriesInfo.data;
      if (data.count() > DATA_COUNT_THRESHOLD) {
        if (true) {
          warn("Universal transition is disabled on large data > 10k.");
        }
        return;
      }
      var indices = data.getIndices();
      var groupDim = getGroupIdDimension(data);
      for (var dataIndex = 0; dataIndex < indices.length; dataIndex++) {
        items.push({
          data,
          dim: seriesInfo.dim || groupDim,
          divide: seriesInfo.divide,
          dataIndex
        });
      }
    });
    return items;
  }
  function fadeInElement(newEl2, newSeries, newIndex) {
    newEl2.traverse(function(el) {
      if (el instanceof Path_default) {
        initProps(el, {
          style: {
            opacity: 0
          }
        }, newSeries, {
          dataIndex: newIndex,
          isFrom: true
        });
      }
    });
  }
  function removeEl2(el) {
    if (el.parent) {
      var computedTransform = el.getComputedTransform();
      el.setLocalTransform(computedTransform);
      el.parent.remove(el);
    }
  }
  function stopAnimation(el) {
    el.stopAnimation();
    if (el.isGroup) {
      el.traverse(function(child) {
        child.stopAnimation();
      });
    }
  }
  function animateElementStyles(el, dataIndex, seriesModel) {
    var animationConfig = getAnimationConfig("update", seriesModel, dataIndex);
    animationConfig && el.traverse(function(child) {
      if (child instanceof Displayable_default) {
        var oldStyle = getOldStyle(child);
        if (oldStyle) {
          child.animateFrom({
            style: oldStyle
          }, animationConfig);
        }
      }
    });
  }
  function isAllIdSame(oldDiffItems, newDiffItems) {
    var len2 = oldDiffItems.length;
    if (len2 !== newDiffItems.length) {
      return false;
    }
    for (var i = 0; i < len2; i++) {
      var oldItem = oldDiffItems[i];
      var newItem = newDiffItems[i];
      if (oldItem.data.getId(oldItem.dataIndex) !== newItem.data.getId(newItem.dataIndex)) {
        return false;
      }
    }
    return true;
  }
  function transitionBetween(oldList, newList, api) {
    var oldDiffItems = flattenDataDiffItems(oldList);
    var newDiffItems = flattenDataDiffItems(newList);
    function updateMorphingPathProps(from, to, rawFrom, rawTo, animationCfg) {
      if (rawFrom || from) {
        to.animateFrom({
          style: rawFrom && rawFrom !== from ? extend(extend({}, rawFrom.style), from.style) : from.style
        }, animationCfg);
      }
    }
    function findKeyDim(items) {
      for (var i2 = 0; i2 < items.length; i2++) {
        if (items[i2].dim) {
          return items[i2].dim;
        }
      }
    }
    var oldKeyDim = findKeyDim(oldDiffItems);
    var newKeyDim = findKeyDim(newDiffItems);
    var hasMorphAnimation = false;
    function createKeyGetter(isOld, onlyGetId) {
      return function(diffItem) {
        var data = diffItem.data;
        var dataIndex = diffItem.dataIndex;
        if (onlyGetId) {
          return data.getId(dataIndex);
        }
        var dataGroupId = data.hostModel && data.hostModel.get("dataGroupId");
        var keyDim = isOld ? oldKeyDim || newKeyDim : newKeyDim || oldKeyDim;
        var dimInfo = keyDim && data.getDimensionInfo(keyDim);
        var dimOrdinalMeta = dimInfo && dimInfo.ordinalMeta;
        if (dimInfo) {
          var key = data.get(dimInfo.name, dataIndex);
          if (dimOrdinalMeta) {
            return dimOrdinalMeta.categories[key] || key + "";
          }
          return key + "";
        }
        var itemVal = data.getRawDataItem(dataIndex);
        if (itemVal && itemVal.groupId) {
          return itemVal.groupId + "";
        }
        return dataGroupId || data.getId(dataIndex);
      };
    }
    var useId = isAllIdSame(oldDiffItems, newDiffItems);
    var isElementStillInChart = {};
    if (!useId) {
      for (var i = 0; i < newDiffItems.length; i++) {
        var newItem = newDiffItems[i];
        var el = newItem.data.getItemGraphicEl(newItem.dataIndex);
        if (el) {
          isElementStillInChart[el.id] = true;
        }
      }
    }
    function updateOneToOne(newIndex, oldIndex) {
      var oldItem = oldDiffItems[oldIndex];
      var newItem2 = newDiffItems[newIndex];
      var newSeries = newItem2.data.hostModel;
      var oldEl = oldItem.data.getItemGraphicEl(oldItem.dataIndex);
      var newEl2 = newItem2.data.getItemGraphicEl(newItem2.dataIndex);
      if (oldEl === newEl2) {
        newEl2 && animateElementStyles(newEl2, newItem2.dataIndex, newSeries);
        return;
      }
      if (oldEl && isElementStillInChart[oldEl.id]) {
        return;
      }
      if (newEl2) {
        stopAnimation(newEl2);
        if (oldEl) {
          stopAnimation(oldEl);
          removeEl2(oldEl);
          hasMorphAnimation = true;
          applyMorphAnimation(getPathList(oldEl), getPathList(newEl2), newItem2.divide, newSeries, newIndex, updateMorphingPathProps);
        } else {
          fadeInElement(newEl2, newSeries, newIndex);
        }
      }
    }
    new DataDiffer_default(oldDiffItems, newDiffItems, createKeyGetter(true, useId), createKeyGetter(false, useId), null, "multiple").update(updateOneToOne).updateManyToOne(function(newIndex, oldIndices) {
      var newItem2 = newDiffItems[newIndex];
      var newData = newItem2.data;
      var newSeries = newData.hostModel;
      var newEl2 = newData.getItemGraphicEl(newItem2.dataIndex);
      var oldElsList = filter(map(oldIndices, function(idx) {
        return oldDiffItems[idx].data.getItemGraphicEl(oldDiffItems[idx].dataIndex);
      }), function(oldEl) {
        return oldEl && oldEl !== newEl2 && !isElementStillInChart[oldEl.id];
      });
      if (newEl2) {
        stopAnimation(newEl2);
        if (oldElsList.length) {
          each(oldElsList, function(oldEl) {
            stopAnimation(oldEl);
            removeEl2(oldEl);
          });
          hasMorphAnimation = true;
          applyMorphAnimation(getPathList(oldElsList), getPathList(newEl2), newItem2.divide, newSeries, newIndex, updateMorphingPathProps);
        } else {
          fadeInElement(newEl2, newSeries, newItem2.dataIndex);
        }
      }
    }).updateOneToMany(function(newIndices, oldIndex) {
      var oldItem = oldDiffItems[oldIndex];
      var oldEl = oldItem.data.getItemGraphicEl(oldItem.dataIndex);
      if (oldEl && isElementStillInChart[oldEl.id]) {
        return;
      }
      var newElsList = filter(map(newIndices, function(idx) {
        return newDiffItems[idx].data.getItemGraphicEl(newDiffItems[idx].dataIndex);
      }), function(el2) {
        return el2 && el2 !== oldEl;
      });
      var newSeris = newDiffItems[newIndices[0]].data.hostModel;
      if (newElsList.length) {
        each(newElsList, function(newEl2) {
          return stopAnimation(newEl2);
        });
        if (oldEl) {
          stopAnimation(oldEl);
          removeEl2(oldEl);
          hasMorphAnimation = true;
          applyMorphAnimation(getPathList(oldEl), getPathList(newElsList), oldItem.divide, newSeris, newIndices[0], updateMorphingPathProps);
        } else {
          each(newElsList, function(newEl2) {
            return fadeInElement(newEl2, newSeris, newIndices[0]);
          });
        }
      }
    }).updateManyToMany(function(newIndices, oldIndices) {
      new DataDiffer_default(oldIndices, newIndices, function(rawIdx) {
        return oldDiffItems[rawIdx].data.getId(oldDiffItems[rawIdx].dataIndex);
      }, function(rawIdx) {
        return newDiffItems[rawIdx].data.getId(newDiffItems[rawIdx].dataIndex);
      }).update(function(newIndex, oldIndex) {
        updateOneToOne(newIndices[newIndex], oldIndices[oldIndex]);
      }).execute();
    }).execute();
    if (hasMorphAnimation) {
      each(newList, function(_a2) {
        var data = _a2.data;
        var seriesModel = data.hostModel;
        var view = seriesModel && api.getViewOfSeriesModel(seriesModel);
        var animationCfg = getAnimationConfig("update", seriesModel, 0);
        if (view && seriesModel.isAnimationEnabled() && animationCfg && animationCfg.duration > 0) {
          view.group.traverse(function(el2) {
            if (el2 instanceof Path_default && !el2.animators.length) {
              el2.animateFrom({
                style: {
                  opacity: 0
                }
              }, animationCfg);
            }
          });
        }
      });
    }
  }
  function getSeriesTransitionKey(series) {
    var seriesKey = series.getModel("universalTransition").get("seriesKey");
    if (!seriesKey) {
      return series.id;
    }
    return seriesKey;
  }
  function convertArraySeriesKeyToString(seriesKey) {
    if (isArray(seriesKey)) {
      return seriesKey.sort().join(",");
    }
    return seriesKey;
  }
  function getDivideShapeFromData(data) {
    if (data.hostModel) {
      return data.hostModel.getModel("universalTransition").get("divideShape");
    }
  }
  function findTransitionSeriesBatches(globalStore, params) {
    var updateBatches = createHashMap();
    var oldDataMap = createHashMap();
    var oldDataMapForSplit = createHashMap();
    each(globalStore.oldSeries, function(series, idx) {
      var oldData = globalStore.oldData[idx];
      var transitionKey = getSeriesTransitionKey(series);
      var transitionKeyStr = convertArraySeriesKeyToString(transitionKey);
      oldDataMap.set(transitionKeyStr, oldData);
      if (isArray(transitionKey)) {
        each(transitionKey, function(key) {
          oldDataMapForSplit.set(key, {
            data: oldData,
            key: transitionKeyStr
          });
        });
      }
    });
    function checkTransitionSeriesKeyDuplicated(transitionKeyStr) {
      if (updateBatches.get(transitionKeyStr)) {
        warn("Duplicated seriesKey in universalTransition " + transitionKeyStr);
      }
    }
    each(params.updatedSeries, function(series) {
      if (series.isUniversalTransitionEnabled() && series.isAnimationEnabled()) {
        var newData = series.getData();
        var transitionKey = getSeriesTransitionKey(series);
        var transitionKeyStr = convertArraySeriesKeyToString(transitionKey);
        var oldData = oldDataMap.get(transitionKeyStr);
        if (oldData) {
          if (true) {
            checkTransitionSeriesKeyDuplicated(transitionKeyStr);
          }
          updateBatches.set(transitionKeyStr, {
            oldSeries: [{
              divide: getDivideShapeFromData(oldData),
              data: oldData
            }],
            newSeries: [{
              divide: getDivideShapeFromData(newData),
              data: newData
            }]
          });
        } else {
          if (isArray(transitionKey)) {
            if (true) {
              checkTransitionSeriesKeyDuplicated(transitionKeyStr);
            }
            var oldSeries_1 = [];
            each(transitionKey, function(key) {
              var oldData2 = oldDataMap.get(key);
              if (oldData2) {
                oldSeries_1.push({
                  divide: getDivideShapeFromData(oldData2),
                  data: oldData2
                });
              }
            });
            if (oldSeries_1.length) {
              updateBatches.set(transitionKeyStr, {
                oldSeries: oldSeries_1,
                newSeries: [{
                  data: newData,
                  divide: getDivideShapeFromData(newData)
                }]
              });
            }
          } else {
            var oldData_1 = oldDataMapForSplit.get(transitionKey);
            if (oldData_1) {
              var batch = updateBatches.get(oldData_1.key);
              if (!batch) {
                batch = {
                  oldSeries: [{
                    data: oldData_1.data,
                    divide: getDivideShapeFromData(oldData_1.data)
                  }],
                  newSeries: []
                };
                updateBatches.set(oldData_1.key, batch);
              }
              batch.newSeries.push({
                data: newData,
                divide: getDivideShapeFromData(newData)
              });
            }
          }
        }
      }
    });
    return updateBatches;
  }
  function querySeries(series, finder) {
    for (var i = 0; i < series.length; i++) {
      var found = finder.seriesIndex != null && finder.seriesIndex === series[i].seriesIndex || finder.seriesId != null && finder.seriesId === series[i].id;
      if (found) {
        return i;
      }
    }
  }
  function transitionSeriesFromOpt(transitionOpt, globalStore, params, api) {
    var from = [];
    var to = [];
    each(normalizeToArray(transitionOpt.from), function(finder) {
      var idx = querySeries(globalStore.oldSeries, finder);
      if (idx >= 0) {
        from.push({
          data: globalStore.oldData[idx],
          divide: getDivideShapeFromData(globalStore.oldData[idx]),
          dim: finder.dimension
        });
      }
    });
    each(normalizeToArray(transitionOpt.to), function(finder) {
      var idx = querySeries(params.updatedSeries, finder);
      if (idx >= 0) {
        var data = params.updatedSeries[idx].getData();
        to.push({
          data,
          divide: getDivideShapeFromData(data),
          dim: finder.dimension
        });
      }
    });
    if (from.length > 0 && to.length > 0) {
      transitionBetween(from, to, api);
    }
  }
  function installUniversalTransition(registers) {
    registers.registerUpdateLifecycle("series:beforeupdate", function(ecMOdel, api, params) {
      each(normalizeToArray(params.seriesTransition), function(transOpt) {
        each(normalizeToArray(transOpt.to), function(finder) {
          var series = params.updatedSeries;
          for (var i = 0; i < series.length; i++) {
            if (finder.seriesIndex != null && finder.seriesIndex === series[i].seriesIndex || finder.seriesId != null && finder.seriesId === series[i].id) {
              series[i][SERIES_UNIVERSAL_TRANSITION_PROP] = true;
            }
          }
        });
      });
    });
    registers.registerUpdateLifecycle("series:transition", function(ecModel, api, params) {
      var globalStore = getUniversalTransitionGlobalStore(api);
      if (globalStore.oldSeries && params.updatedSeries && params.optionChanged) {
        var transitionOpt = params.seriesTransition;
        if (transitionOpt) {
          each(normalizeToArray(transitionOpt), function(opt) {
            transitionSeriesFromOpt(opt, globalStore, params, api);
          });
        } else {
          var updateBatches_1 = findTransitionSeriesBatches(globalStore, params);
          each(updateBatches_1.keys(), function(key) {
            var batch = updateBatches_1.get(key);
            transitionBetween(batch.oldSeries, batch.newSeries, api);
          });
        }
        each(params.updatedSeries, function(series) {
          if (series[SERIES_UNIVERSAL_TRANSITION_PROP]) {
            series[SERIES_UNIVERSAL_TRANSITION_PROP] = false;
          }
        });
      }
      var allSeries = ecModel.getSeries();
      var savedSeries = globalStore.oldSeries = [];
      var savedData = globalStore.oldData = [];
      for (var i = 0; i < allSeries.length; i++) {
        var data = allSeries[i].getData();
        if (data.count() < DATA_COUNT_THRESHOLD) {
          savedSeries.push(allSeries[i]);
          savedData.push(data);
        }
      }
    });
  }

  // node_modules/echarts/index.js
  use([install2]);
  use([install]);
  use([install3, install4, install5, install7, install9, install11, install12, install13, install14, install15, install16, install18, install19, install20, install21, install22, install23, install24, install25, install26, install27, install28]);
  use(install30);
  use(install31);
  use(install10);
  use(install32);
  use(install17);
  use(install33);
  use(install34);
  use(install36);
  use(install37);
  use(install29);
  use(install38);
  use(install39);
  use(install40);
  use(install41);
  use(install42);
  use(install43);
  use(install46);
  use(install49);
  use(install47);
  use(install48);
  use(install52);
  use(install50);
  use(install51);
  use(install53);
  use(install54);
  use(install55);
  use(installUniversalTransition);
  use(installLabelLayout);

  // src/components/BarChart.vue
  var import_plugin_vue2_normalizer = __toESM(__require("lib/vue2/normalizer.js"));
  console.log(echarts_exports2);
  var _sfc_main = {
    data() {
      return {
        barChart: null
      };
    },
    methods: {
      initBar() {
        this.barChart = init2(this.$refs.bar);
        let option = {
          title: {
            text: "ECharts 入门示例"
          },
          tooltip: {},
          legend: {
            data: ["销量"]
          },
          xAxis: {
            data: ["衬衫", "羊毛衫", "雪纺衫", "裤子", "高跟鞋", "袜子"]
          },
          yAxis: {},
          series: [
            {
              name: "销量",
              type: "bar",
              data: [5, 20, 36, 10, 10, 20]
            }
          ]
        };
        this.barChart.setOption(option);
      }
    },
    mounted() {
      this.initBar();
      window.addEventListener("resize", () => {
      });
    }
  };
  var _sfc_render = function render2() {
    var _vm = this, _c2 = _vm._self._c;
    return _c2("div", [_c2("div", { ref: "bar", staticClass: "bar", attrs: { "id": "bar" } })]);
  };
  var _sfc_staticRenderFns = [];
  var __component__ = /* @__PURE__ */ (0, import_plugin_vue2_normalizer.default)(_sfc_main, _sfc_render, _sfc_staticRenderFns, false, null, "f419ad45", null, null);
  var BarChart = __component__.exports;

  // src/components/TinymceEditor.vue
  var import_tinymce = __require("utils/tinymce.js");

  // node_modules/tinymce/themes/silver/theme.min.js
  !function() {
    "use strict";
    function t(o2) {
      return function(t2) {
        return e3 = typeof (n2 = t2), (null === n2 ? "null" : "object" == e3 && (Array.prototype.isPrototypeOf(n2) || n2.constructor && "Array" === n2.constructor.name) ? "array" : "object" == e3 && (String.prototype.isPrototypeOf(n2) || n2.constructor && "String" === n2.constructor.name) ? "string" : e3) === o2;
        var n2, e3;
      };
    }
    function n(n2) {
      return function(t2) {
        return typeof t2 === n2;
      };
    }
    function e2(n2) {
      return function(t2) {
        return n2 === t2;
      };
    }
    function g(t2) {
      return null == t2;
    }
    function f(t2, n2) {
      if (c(t2)) {
        for (var e3 = 0, o2 = t2.length; e3 < o2; ++e3)
          if (!n2(t2[e3]))
            return;
        return 1;
      }
    }
    function st() {
    }
    function r(e3, o2) {
      return function() {
        for (var t2 = [], n2 = 0; n2 < arguments.length; n2++)
          t2[n2] = arguments[n2];
        return e3(o2.apply(null, t2));
      };
    }
    function rt2(t2) {
      return function() {
        return t2;
      };
    }
    function h(t2) {
      return t2;
    }
    function v(t2, n2) {
      return t2 === n2;
    }
    var y = t("string"), x = t("object"), c = t("array"), b = e2(null), w = n("boolean"), E = e2(void 0), k = function(t2) {
      return !g(t2);
    }, S = n("function"), u = n("number");
    function C(o2) {
      for (var r2 = [], t2 = 1; t2 < arguments.length; t2++)
        r2[t2 - 1] = arguments[t2];
      return function() {
        for (var t3 = [], n2 = 0; n2 < arguments.length; n2++)
          t3[n2] = arguments[n2];
        var e3 = r2.concat(t3);
        return o2.apply(null, e3);
      };
    }
    function O(n2) {
      return function(t2) {
        return !n2(t2);
      };
    }
    function _(t2) {
      return function() {
        throw new Error(t2);
      };
    }
    var T = rt2(false), D = rt2(true), o = tinymce.util.Tools.resolve("tinymce.ThemeManager"), lt2 = function() {
      return (lt2 = Object.assign || function(t2) {
        for (var n2, e3 = 1, o2 = arguments.length; e3 < o2; e3++)
          for (var r2 in n2 = arguments[e3])
            Object.prototype.hasOwnProperty.call(n2, r2) && (t2[r2] = n2[r2]);
        return t2;
      }).apply(this, arguments);
    };
    function B(t2, n2) {
      var e3 = {};
      for (r2 in t2)
        Object.prototype.hasOwnProperty.call(t2, r2) && n2.indexOf(r2) < 0 && (e3[r2] = t2[r2]);
      if (null != t2 && "function" == typeof Object.getOwnPropertySymbols)
        for (var o2 = 0, r2 = Object.getOwnPropertySymbols(t2); o2 < r2.length; o2++)
          n2.indexOf(r2[o2]) < 0 && Object.prototype.propertyIsEnumerable.call(t2, r2[o2]) && (e3[r2[o2]] = t2[r2[o2]]);
      return e3;
    }
    function H(t2, n2, e3) {
      if (e3 || 2 === arguments.length)
        for (var o2, r2 = 0, i2 = n2.length; r2 < i2; r2++)
          !o2 && r2 in n2 || ((o2 = o2 || Array.prototype.slice.call(n2, 0, r2))[r2] = n2[r2]);
      return t2.concat(o2 || Array.prototype.slice.call(n2));
    }
    function i() {
      return a;
    }
    var a = { fold: function(t2, n2) {
      return t2();
    }, isSome: T, isNone: D, getOr: h, getOrThunk: s, getOrDie: function(t2) {
      throw new Error(t2 || "error: getOrDie called on none.");
    }, getOrNull: rt2(null), getOrUndefined: rt2(void 0), or: h, orThunk: s, map: i, each: st, bind: i, exists: T, forall: D, filter: function() {
      return a;
    }, toArray: function() {
      return [];
    }, toString: rt2("none()") };
    function s(t2) {
      return t2();
    }
    function l(t2, n2) {
      return yt.call(t2, n2);
    }
    function d(t2, n2) {
      for (var e3 = 0, o2 = t2.length; e3 < o2; e3++)
        if (n2(t2[e3], e3))
          return true;
      return false;
    }
    function m2(t2, n2) {
      for (var e3 = [], o2 = 0; o2 < t2; o2++)
        e3.push(n2(o2));
      return e3;
    }
    function p(t2, n2) {
      for (var e3 = [], o2 = 0; o2 < t2.length; o2 += n2) {
        var r2 = bt.call(t2, o2, o2 + n2);
        e3.push(r2);
      }
      return e3;
    }
    function M(t2, n2) {
      for (var e3 = t2.length, o2 = new Array(e3), r2 = 0; r2 < e3; r2++) {
        var i2 = t2[r2];
        o2[r2] = n2(i2, r2);
      }
      return o2;
    }
    function A(t2, n2) {
      for (var e3 = [], o2 = [], r2 = 0, i2 = t2.length; r2 < i2; r2++) {
        var u2 = t2[r2];
        (n2(u2, r2) ? e3 : o2).push(u2);
      }
      return { pass: e3, fail: o2 };
    }
    function F(t2, n2) {
      for (var e3 = [], o2 = 0, r2 = t2.length; o2 < r2; o2++) {
        var i2 = t2[o2];
        n2(i2, o2) && e3.push(i2);
      }
      return e3;
    }
    function I(t2, o2, r2) {
      return function(t3) {
        for (var n2, e3 = t3.length - 1; 0 <= e3; e3--)
          n2 = t3[e3], r2 = o2(r2, n2, e3);
      }(t2), r2;
    }
    function R(t2, e3, o2) {
      return St(t2, function(t3, n2) {
        o2 = e3(o2, t3, n2);
      }), o2;
    }
    function V(t2, n2) {
      return function(t3, n3, e3) {
        for (var o2 = 0, r2 = t3.length; o2 < r2; o2++) {
          var i2 = t3[o2];
          if (n3(i2, o2))
            return vt.some(i2);
          if (e3(i2, o2))
            break;
        }
        return vt.none();
      }(t2, n2, T);
    }
    function P(t2, n2) {
      for (var e3 = 0, o2 = t2.length; e3 < o2; e3++)
        if (n2(t2[e3], e3))
          return vt.some(e3);
      return vt.none();
    }
    function ft(t2) {
      for (var n2 = [], e3 = 0, o2 = t2.length; e3 < o2; ++e3) {
        if (!c(t2[e3]))
          throw new Error("Arr.flatten item " + e3 + " was not an array, input: " + t2);
        xt.apply(n2, t2[e3]);
      }
      return n2;
    }
    function z(t2, n2) {
      return ft(M(t2, n2));
    }
    function N(t2, n2) {
      for (var e3 = 0, o2 = t2.length; e3 < o2; ++e3)
        if (true !== n2(t2[e3], e3))
          return false;
      return true;
    }
    function L(t2) {
      var n2 = bt.call(t2, 0);
      return n2.reverse(), n2;
    }
    function W(t2, n2) {
      return F(t2, function(t3) {
        return !wt(n2, t3);
      });
    }
    function U(t2, n2) {
      for (var e3 = {}, o2 = 0, r2 = t2.length; o2 < r2; o2++) {
        var i2 = t2[o2];
        e3[String(i2)] = n2(i2, o2);
      }
      return e3;
    }
    function j(t2) {
      return [t2];
    }
    function G(t2, n2) {
      var e3 = bt.call(t2, 0);
      return e3.sort(n2), e3;
    }
    function X(t2, n2) {
      return 0 <= n2 && n2 < t2.length ? vt.some(t2[n2]) : vt.none();
    }
    function Y(t2) {
      return X(t2, 0);
    }
    function q(t2) {
      return X(t2, t2.length - 1);
    }
    function K(t2, n2) {
      for (var e3 = 0; e3 < t2.length; e3++) {
        var o2 = n2(t2[e3], e3);
        if (o2.isSome())
          return o2;
      }
      return vt.none();
    }
    function J(t2, n2) {
      for (var e3 = Ct(t2), o2 = 0, r2 = e3.length; o2 < r2; o2++) {
        var i2 = e3[o2];
        n2(t2[i2], i2);
      }
    }
    function dt(t2, e3) {
      return _t(t2, function(t3, n2) {
        return { k: n2, v: e3(t3, n2) };
      });
    }
    function $(t2, e3) {
      var o2 = [];
      return J(t2, function(t3, n2) {
        o2.push(e3(t3, n2));
      }), o2;
    }
    function Q(t2, n2) {
      for (var e3 = Ct(t2), o2 = 0, r2 = e3.length; o2 < r2; o2++) {
        var i2 = e3[o2], u2 = t2[i2];
        if (n2(u2, i2, t2))
          return vt.some(u2);
      }
      return vt.none();
    }
    function Z(t2) {
      return $(t2, h);
    }
    function tt(t2, n2) {
      return Tt(t2, n2) ? vt.from(t2[n2]) : vt.none();
    }
    function nt(t2, n2) {
      return Tt(t2, n2) && void 0 !== t2[n2] && null !== t2[n2];
    }
    function mt(t2, n2, e3) {
      return void 0 === e3 && (e3 = v), t2.exists(function(t3) {
        return e3(t3, n2);
      });
    }
    function et(t2) {
      for (var n2 = [], e3 = function(t3) {
        n2.push(t3);
      }, o2 = 0; o2 < t2.length; o2++)
        t2[o2].each(e3);
      return n2;
    }
    function ot(t2, n2) {
      return t2 ? vt.some(n2) : vt.none();
    }
    function it(t2, n2, e3) {
      return "" === n2 || t2.length >= n2.length && t2.substr(e3, e3 + n2.length) === n2;
    }
    function ut(t2, n2) {
      return -1 !== t2.indexOf(n2);
    }
    function at(t2) {
      return 0 < t2.length;
    }
    function ct(t2) {
      return void 0 !== t2.style && S(t2.style.getPropertyValue);
    }
    function gt(t2) {
      if (null == t2)
        throw new Error("Node cannot be null or undefined");
      return { dom: t2 };
    }
    var pt, ht = function(e3) {
      function t2() {
        return r2;
      }
      function n2(t3) {
        return t3(e3);
      }
      var o2 = rt2(e3), r2 = { fold: function(t3, n3) {
        return n3(e3);
      }, isSome: D, isNone: T, getOr: o2, getOrThunk: o2, getOrDie: o2, getOrNull: o2, getOrUndefined: o2, or: t2, orThunk: t2, map: function(t3) {
        return ht(t3(e3));
      }, each: function(t3) {
        t3(e3);
      }, bind: n2, exists: n2, forall: n2, filter: function(t3) {
        return t3(e3) ? r2 : a;
      }, toArray: function() {
        return [e3];
      }, toString: function() {
        return "some(" + e3 + ")";
      } };
      return r2;
    }, vt = { some: ht, none: i, from: function(t2) {
      return null == t2 ? a : ht(t2);
    } }, bt = Array.prototype.slice, yt = Array.prototype.indexOf, xt = Array.prototype.push, wt = function(t2, n2) {
      return -1 < l(t2, n2);
    }, St = function(t2, n2) {
      for (var e3 = 0, o2 = t2.length; e3 < o2; e3++)
        n2(t2[e3], e3);
    }, kt = S(Array.from) ? Array.from : function(t2) {
      return bt.call(t2);
    }, Ct = Object.keys, Ot = Object.hasOwnProperty, _t = function(t2, o2) {
      var r2 = {};
      return J(t2, function(t3, n2) {
        var e3 = o2(t3, n2);
        r2[e3.k] = e3.v;
      }), r2;
    }, Tt = function(t2, n2) {
      return Ot.call(t2, n2);
    }, Et = function(t2, n2, e3) {
      return t2.isSome() && n2.isSome() ? vt.some(e3(t2.getOrDie(), n2.getOrDie())) : vt.none();
    }, Dt = function(t2, n2) {
      return it(t2, n2, 0);
    }, Bt = function(t2, n2) {
      return it(t2, n2, t2.length - n2.length);
    }, Mt = (pt = /^\s+|\s+$/g, function(t2) {
      return t2.replace(pt, "");
    }), At = { fromHtml: function(t2, n2) {
      var e3 = (n2 || document).createElement("div");
      if (e3.innerHTML = t2, !e3.hasChildNodes() || 1 < e3.childNodes.length)
        throw console.error("HTML does not have a single root node", t2), new Error("HTML must have a single root node");
      return gt(e3.childNodes[0]);
    }, fromTag: function(t2, n2) {
      var e3 = (n2 || document).createElement(t2);
      return gt(e3);
    }, fromText: function(t2, n2) {
      var e3 = (n2 || document).createTextNode(t2);
      return gt(e3);
    }, fromDom: gt, fromPoint: function(t2, n2, e3) {
      return vt.from(t2.dom.elementFromPoint(n2, e3)).map(gt);
    } };
    function Ft(t2) {
      return t2.dom.nodeName.toLowerCase();
    }
    function It(n2) {
      return function(t2) {
        return t2.dom.nodeType === n2;
      };
    }
    function Rt(e3) {
      var o2, r2 = false;
      return function() {
        for (var t2 = [], n2 = 0; n2 < arguments.length; n2++)
          t2[n2] = arguments[n2];
        return r2 || (r2 = true, o2 = e3.apply(null, t2)), o2;
      };
    }
    function Vt(t2, n2) {
      var e3 = String(n2).toLowerCase();
      return V(t2, function(t3) {
        return t3.search(e3);
      });
    }
    function Pt(n2) {
      return function(t2) {
        return ut(t2, n2);
      };
    }
    function Ht(t2) {
      return window.matchMedia(t2).matches;
    }
    function zt(t2, n2) {
      var e3 = t2.dom;
      if (1 !== e3.nodeType)
        return false;
      var o2 = e3;
      if (void 0 !== o2.matches)
        return o2.matches(n2);
      if (void 0 !== o2.msMatchesSelector)
        return o2.msMatchesSelector(n2);
      if (void 0 !== o2.webkitMatchesSelector)
        return o2.webkitMatchesSelector(n2);
      if (void 0 !== o2.mozMatchesSelector)
        return o2.mozMatchesSelector(n2);
      throw new Error("Browser lacks native selectors");
    }
    function Nt(t2) {
      return 1 !== t2.nodeType && 9 !== t2.nodeType && 11 !== t2.nodeType || 0 === t2.childElementCount;
    }
    function Lt(t2, n2) {
      return t2.dom === n2.dom;
    }
    function Wt(t2, n2) {
      return le().browser.isIE() ? (e3 = t2.dom, o2 = n2.dom, r2 = Node.DOCUMENT_POSITION_CONTAINED_BY, 0 != (e3.compareDocumentPosition(o2) & r2)) : (i2 = t2.dom) !== (u2 = n2.dom) && i2.contains(u2);
      var e3, o2, r2, i2, u2;
    }
    function Ut(t2) {
      return At.fromDom(t2.dom.ownerDocument);
    }
    function jt(t2) {
      return qn(t2) ? t2 : Ut(t2);
    }
    function Gt(t2) {
      return At.fromDom(jt(t2).dom.documentElement);
    }
    function Xt(t2) {
      return At.fromDom(jt(t2).dom.defaultView);
    }
    function Yt(t2) {
      return vt.from(t2.dom.parentNode).map(At.fromDom);
    }
    function qt(t2) {
      return vt.from(t2.dom.offsetParent).map(At.fromDom);
    }
    function Kt(t2) {
      return M(t2.dom.childNodes, At.fromDom);
    }
    function Jt(t2, n2) {
      var e3 = t2.dom.childNodes;
      return vt.from(e3[n2]).map(At.fromDom);
    }
    function $t(t2, n2) {
      return { element: t2, offset: n2 };
    }
    function Qt(t2, n2) {
      var e3 = Kt(t2);
      return 0 < e3.length && n2 < e3.length ? $t(e3[n2], 0) : $t(t2, n2);
    }
    function Zt(t2) {
      return Kn(t2) && k(t2.dom.host);
    }
    function tn(t2) {
      return Zt(t2) ? t2 : At.fromDom(jt(t2).dom.body);
    }
    function nn(t2) {
      return At.fromDom(t2.dom.host);
    }
    function en(t2, n2, e3) {
      if (!(y(e3) || w(e3) || u(e3)))
        throw console.error("Invalid call to Attribute.set. Key ", n2, ":: Value ", e3, ":: Element ", t2), new Error("Attribute value was not simple");
      t2.setAttribute(n2, e3 + "");
    }
    function on(t2, n2, e3) {
      en(t2.dom, n2, e3);
    }
    function rn(t2, n2) {
      var e3 = t2.dom;
      J(n2, function(t3, n3) {
        en(e3, n3, t3);
      });
    }
    function un(t2, n2) {
      var e3 = t2.dom.getAttribute(n2);
      return null === e3 ? void 0 : e3;
    }
    function an(t2, n2) {
      return vt.from(un(t2, n2));
    }
    function cn(t2, n2) {
      var e3 = t2.dom;
      return !(!e3 || !e3.hasAttribute) && e3.hasAttribute(n2);
    }
    function sn(t2, n2) {
      t2.dom.removeAttribute(n2);
    }
    function ln(t2, n2, e3) {
      if (!y(e3))
        throw console.error("Invalid call to CSS.set. Property ", n2, ":: Value ", e3, ":: Element ", t2), new Error("CSS value must be a string: " + e3);
      ct(t2) && t2.style.setProperty(n2, e3);
    }
    function fn(t2, n2) {
      ct(t2) && t2.style.removeProperty(n2);
    }
    function dn(t2, n2, e3) {
      ln(t2.dom, n2, e3);
    }
    function mn(t2, n2) {
      var e3 = t2.dom;
      J(n2, function(t3, n3) {
        ln(e3, n3, t3);
      });
    }
    function gn(t2, n2) {
      var e3 = t2.dom;
      J(n2, function(t3, n3) {
        t3.fold(function() {
          fn(e3, n3);
        }, function(t4) {
          ln(e3, n3, t4);
        });
      });
    }
    function pn(t2, n2) {
      var e3 = t2.dom, o2 = window.getComputedStyle(e3).getPropertyValue(n2);
      return "" !== o2 || ve(t2) ? o2 : xe(e3, n2);
    }
    function hn(t2, n2) {
      var e3 = t2.dom, o2 = xe(e3, n2);
      return vt.from(o2).filter(function(t3) {
        return 0 < t3.length;
      });
    }
    function vn(t2, n2, e3) {
      var o2 = At.fromTag(t2);
      return dn(o2, n2, e3), hn(o2, n2).isSome();
    }
    function bn(t2, n2) {
      fn(t2.dom, n2), mt(an(t2, "style").map(Mt), "") && sn(t2, "style");
    }
    function yn(t2) {
      return t2.dom.offsetWidth;
    }
    function xn(o2, r2) {
      function t2(t3) {
        var n2 = r2(t3);
        if (n2 <= 0 || null === n2) {
          var e3 = pn(t3, o2);
          return parseFloat(e3) || 0;
        }
        return n2;
      }
      function i2(r3, t3) {
        return R(t3, function(t4, n2) {
          var e3 = pn(r3, n2), o3 = void 0 === e3 ? 0 : parseInt(e3, 10);
          return isNaN(o3) ? t4 : t4 + o3;
        }, 0);
      }
      return { set: function(t3, n2) {
        if (!u(n2) && !n2.match(/^[0-9]+$/))
          throw new Error(o2 + ".set accepts only positive integer values. Value was " + n2);
        var e3 = t3.dom;
        ct(e3) && (e3.style[o2] = n2 + "px");
      }, get: t2, getOuter: t2, aggregate: i2, max: function(t3, n2, e3) {
        var o3 = i2(t3, e3);
        return o3 < n2 ? n2 - o3 : 0;
      } };
    }
    function wn(t2) {
      return we.get(t2);
    }
    function Sn(t2) {
      return we.getOuter(t2);
    }
    function kn(t2, n2) {
      return void 0 !== t2 ? t2 : void 0 !== n2 ? n2 : 0;
    }
    function Cn(t2) {
      var n2 = t2.dom.ownerDocument, e3 = n2.body, o2 = n2.defaultView, r2 = n2.documentElement;
      if (e3 === t2.dom)
        return ke(e3.offsetLeft, e3.offsetTop);
      var i2 = kn(null == o2 ? void 0 : o2.pageYOffset, r2.scrollTop), u2 = kn(null == o2 ? void 0 : o2.pageXOffset, r2.scrollLeft), a2 = kn(r2.clientTop, e3.clientTop), c2 = kn(r2.clientLeft, e3.clientLeft);
      return Ce(t2).translate(u2 - c2, i2 - a2);
    }
    function On(t2) {
      return Oe.get(t2);
    }
    function _n(t2) {
      return Oe.getOuter(t2);
    }
    function Tn(t2) {
      function n2() {
        return t2.stopPropagation();
      }
      function e3() {
        return t2.preventDefault();
      }
      var o2 = r(e3, n2);
      return { target: At.fromDom(function(t3) {
        if (me() && k(t3.target)) {
          var n3 = At.fromDom(t3.target);
          if (Xn(n3) && he(n3) && t3.composed && t3.composedPath) {
            var e4 = t3.composedPath();
            if (e4)
              return Y(e4);
          }
        }
        return vt.from(t3.target);
      }(t2).getOr(t2.target)), x: t2.clientX, y: t2.clientY, stop: n2, prevent: e3, kill: o2, raw: t2 };
    }
    function En(t2, n2, e3, o2, r2) {
      var i2, u2, a2 = (i2 = e3, u2 = o2, function(t3) {
        i2(t3) && u2(Tn(t3));
      });
      return t2.dom.addEventListener(n2, a2, r2), { unbind: C(_e, t2, n2, a2, r2) };
    }
    function Dn(n2, e3) {
      Yt(n2).each(function(t2) {
        t2.dom.insertBefore(e3.dom, n2.dom);
      });
    }
    function Bn(t2, n2) {
      vt.from(t2.dom.nextSibling).map(At.fromDom).fold(function() {
        Yt(t2).each(function(t3) {
          Te(t3, n2);
        });
      }, function(t3) {
        Dn(t3, n2);
      });
    }
    function Mn(n2, e3) {
      Jt(n2, 0).fold(function() {
        Te(n2, e3);
      }, function(t2) {
        n2.dom.insertBefore(e3.dom, t2.dom);
      });
    }
    function An(n2, t2) {
      St(t2, function(t3) {
        Te(n2, t3);
      });
    }
    function Fn(t2) {
      t2.dom.textContent = "", St(Kt(t2), function(t3) {
        Ee(t3);
      });
    }
    function In(t2) {
      var n2, e3 = Kt(t2);
      0 < e3.length && (n2 = t2, St(e3, function(t3) {
        Dn(n2, t3);
      })), Ee(t2);
    }
    function Rn(t2) {
      var n2 = void 0 !== t2 ? t2.dom : document, e3 = n2.body.scrollLeft || n2.documentElement.scrollLeft, o2 = n2.body.scrollTop || n2.documentElement.scrollTop;
      return ke(e3, o2);
    }
    function Vn(t2, n2, e3) {
      var o2 = (void 0 !== e3 ? e3.dom : document).defaultView;
      o2 && o2.scrollTo(t2, n2);
    }
    function Pn(t2, n2, e3, o2) {
      return { x: t2, y: n2, width: e3, height: o2, right: t2 + e3, bottom: n2 + o2 };
    }
    function Hn(t2) {
      var o2 = void 0 === t2 ? window : t2, n2 = o2.document, r2 = Rn(At.fromDom(n2)), e3 = void 0 === o2 ? window : o2;
      return (le().browser.isFirefox() ? vt.none() : vt.from(e3.visualViewport)).fold(function() {
        var t3 = o2.document.documentElement, n3 = t3.clientWidth, e4 = t3.clientHeight;
        return Pn(r2.left, r2.top, n3, e4);
      }, function(t3) {
        return Pn(Math.max(t3.pageLeft, r2.left), Math.max(t3.pageTop, r2.top), t3.width, t3.height);
      });
    }
    function zn(o2) {
      var t2, r2 = Rn(At.fromDom(document)), n2 = (t2 = Be).owner(o2), e3 = De(t2, n2);
      return vt.some(e3).fold(C(Cn, o2), function(t3) {
        var n3 = Ce(o2), e4 = I(t3, function(t4, n4) {
          var e5 = Ce(n4);
          return { left: t4.left + e5.left, top: t4.top + e5.top };
        }, { left: 0, top: 0 });
        return ke(e4.left + n3.left + r2.left, e4.top + n3.top + r2.top);
      });
    }
    function Nn(t2) {
      var n2 = zn(t2), e3 = _n(t2), o2 = Sn(t2);
      return Me(n2.left, n2.top, e3, o2);
    }
    "undefined" != typeof window || Function("return this;")();
    function Ln() {
      return Jn(0, 0);
    }
    function Wn(t2) {
      function n2(t3) {
        return function() {
          return e3 === t3;
        };
      }
      var e3 = t2.current, o2 = t2.version;
      return { current: e3, version: o2, isEdge: n2("Edge"), isChrome: n2("Chrome"), isIE: n2("IE"), isOpera: n2("Opera"), isFirefox: n2(te), isSafari: n2("Safari") };
    }
    function Un(t2) {
      function n2(t3) {
        return function() {
          return e3 === t3;
        };
      }
      var e3 = t2.current, o2 = t2.version;
      return { current: e3, version: o2, isWindows: n2(oe), isiOS: n2("iOS"), isAndroid: n2(re), isOSX: n2("OSX"), isLinux: n2("Linux"), isSolaris: n2(ie), isFreeBSD: n2(ue), isChromeOS: n2(ae) };
    }
    var jn, Gn, Xn = It(1), Yn = It(3), qn = It(9), Kn = It(11), Jn = function(t2, n2) {
      return { major: t2, minor: n2 };
    }, $n = { nu: Jn, detect: function(t2, n2) {
      var e3, o2, r2 = String(n2).toLowerCase();
      return 0 === t2.length ? Ln() : (o2 = function(t3, n3) {
        for (var e4 = 0; e4 < t3.length; e4++) {
          var o3 = t3[e4];
          if (o3.test(n3))
            return o3;
        }
      }(t2, e3 = r2)) ? Jn(i2(1), i2(2)) : { major: 0, minor: 0 };
      function i2(t3) {
        return Number(e3.replace(o2, "$" + t3));
      }
    }, unknown: Ln }, Qn = /.*?version\/\ ?([0-9]+)\.([0-9]+).*/, Zn = { browsers: rt2([{ name: "Edge", versionRegexes: [/.*?edge\/ ?([0-9]+)\.([0-9]+)$/], search: function(t2) {
      return ut(t2, "edge/") && ut(t2, "chrome") && ut(t2, "safari") && ut(t2, "applewebkit");
    } }, { name: "Chrome", brand: "Chromium", versionRegexes: [/.*?chrome\/([0-9]+)\.([0-9]+).*/, Qn], search: function(t2) {
      return ut(t2, "chrome") && !ut(t2, "chromeframe");
    } }, { name: "IE", versionRegexes: [/.*?msie\ ?([0-9]+)\.([0-9]+).*/, /.*?rv:([0-9]+)\.([0-9]+).*/], search: function(t2) {
      return ut(t2, "msie") || ut(t2, "trident");
    } }, { name: "Opera", versionRegexes: [Qn, /.*?opera\/([0-9]+)\.([0-9]+).*/], search: Pt("opera") }, { name: "Firefox", versionRegexes: [/.*?firefox\/\ ?([0-9]+)\.([0-9]+).*/], search: Pt("firefox") }, { name: "Safari", versionRegexes: [Qn, /.*?cpu os ([0-9]+)_([0-9]+).*/], search: function(t2) {
      return (ut(t2, "safari") || ut(t2, "mobile/")) && ut(t2, "applewebkit");
    } }]), oses: rt2([{ name: "Windows", search: Pt("win"), versionRegexes: [/.*?windows\ nt\ ?([0-9]+)\.([0-9]+).*/] }, { name: "iOS", search: function(t2) {
      return ut(t2, "iphone") || ut(t2, "ipad");
    }, versionRegexes: [/.*?version\/\ ?([0-9]+)\.([0-9]+).*/, /.*cpu os ([0-9]+)_([0-9]+).*/, /.*cpu iphone os ([0-9]+)_([0-9]+).*/] }, { name: "Android", search: Pt("android"), versionRegexes: [/.*?android\ ?([0-9]+)\.([0-9]+).*/] }, { name: "OSX", search: Pt("mac os x"), versionRegexes: [/.*?mac\ os\ x\ ?([0-9]+)_([0-9]+).*/] }, { name: "Linux", search: Pt("linux"), versionRegexes: [] }, { name: "Solaris", search: Pt("sunos"), versionRegexes: [] }, { name: "FreeBSD", search: Pt("freebsd"), versionRegexes: [] }, { name: "ChromeOS", search: Pt("cros"), versionRegexes: [/.*?chrome\/([0-9]+)\.([0-9]+).*/] }]) }, te = "Firefox", ne = function() {
      return Wn({ current: void 0, version: $n.unknown() });
    }, ee = Wn, oe = (rt2("Edge"), rt2("Chrome"), rt2("IE"), rt2("Opera"), rt2(te), rt2("Safari"), "Windows"), re = "Android", ie = "Solaris", ue = "FreeBSD", ae = "ChromeOS", ce = function() {
      return Un({ current: void 0, version: $n.unknown() });
    }, se = Un, le = (rt2(oe), rt2("iOS"), rt2(re), rt2("Linux"), rt2("OSX"), rt2(ie), rt2(ue), rt2(ae), Rt(function() {
      return t2 = navigator.userAgent, n2 = vt.from(navigator.userAgentData), e3 = Ht, p2 = Zn.browsers(), h2 = Zn.oses(), v4 = n2.bind(function(t3) {
        return o3 = p2, K(t3.brands, function(n3) {
          var e4 = n3.brand.toLowerCase();
          return V(o3, function(t4) {
            var n4;
            return e4 === (null === (n4 = t4.brand) || void 0 === n4 ? void 0 : n4.toLowerCase());
          }).map(function(t4) {
            return { current: t4.name, version: $n.nu(parseInt(n3.version, 10), 0) };
          });
        });
        var o3;
      }).orThunk(function() {
        return Vt(p2, e4 = t2).map(function(t3) {
          var n3 = $n.detect(t3.versionRegexes, e4);
          return { current: t3.name, version: n3 };
        });
        var e4;
      }).fold(ne, ee), b2 = Vt(h2, o2 = t2).map(function(t3) {
        var n3 = $n.detect(t3.versionRegexes, o2);
        return { current: t3.name, version: n3 };
      }).fold(ce, se), { browser: v4, os: b2, deviceType: (i2 = v4, u2 = t2, a2 = e3, c2 = (r2 = b2).isiOS() && true === /ipad/i.test(u2), s2 = r2.isiOS() && !c2, f2 = (l2 = r2.isiOS() || r2.isAndroid()) || a2("(pointer:coarse)"), d2 = c2 || !s2 && l2 && a2("(min-device-width:768px)"), m3 = s2 || l2 && !d2, g2 = i2.isSafari() && r2.isiOS() && false === /safari/i.test(u2), { isiPad: rt2(c2), isiPhone: rt2(s2), isTablet: rt2(d2), isPhone: rt2(m3), isTouch: rt2(f2), isAndroid: r2.isAndroid, isiOS: r2.isiOS, isWebView: rt2(g2), isDesktop: rt2(!m3 && !d2 && !g2) }) };
      var t2, n2, e3, o2, r2, i2, u2, a2, c2, s2, l2, f2, d2, m3, g2, p2, h2, v4, b2;
    })), fe = Yt, de = S(Element.prototype.attachShadow) && S(Node.prototype.getRootNode), me = rt2(de), ge = de ? function(t2) {
      return At.fromDom(t2.dom.getRootNode());
    } : jt, pe = function(t2) {
      var n2 = ge(t2);
      return Zt(n2) ? vt.some(n2) : vt.none();
    }, he = function(t2) {
      return k(t2.dom.shadowRoot);
    }, ve = function(t2) {
      var n2 = Yn(t2) ? t2.dom.parentNode : t2.dom;
      if (null == n2 || null === n2.ownerDocument)
        return false;
      var e3, o2, r2 = n2.ownerDocument;
      return pe(At.fromDom(n2)).fold(function() {
        return r2.body.contains(n2);
      }, (e3 = ve, o2 = nn, function(t3) {
        return e3(o2(t3));
      }));
    }, be = function() {
      return ye(At.fromDom(document));
    }, ye = function(t2) {
      var n2 = t2.dom.body;
      if (null == n2)
        throw new Error("Body is not available yet");
      return At.fromDom(n2);
    }, xe = function(t2, n2) {
      return ct(t2) ? t2.style.getPropertyValue(n2) : "";
    }, we = xn("height", function(t2) {
      var n2 = t2.dom;
      return ve(t2) ? n2.getBoundingClientRect().height : n2.offsetHeight;
    }), Se = function(e3, o2) {
      return { left: e3, top: o2, translate: function(t2, n2) {
        return Se(e3 + t2, o2 + n2);
      } };
    }, ke = Se, Ce = function(t2) {
      var n2, e3 = t2.dom, o2 = e3.ownerDocument.body;
      return o2 === e3 ? ke(o2.offsetLeft, o2.offsetTop) : ve(t2) ? (n2 = e3.getBoundingClientRect(), ke(n2.left, n2.top)) : ke(0, 0);
    }, Oe = xn("width", function(t2) {
      return t2.dom.offsetWidth;
    }), _e = function(t2, n2, e3, o2) {
      t2.dom.removeEventListener(n2, e3, o2);
    }, Te = function(t2, n2) {
      t2.dom.appendChild(n2.dom);
    }, Ee = function(t2) {
      var n2 = t2.dom;
      null !== n2.parentNode && n2.parentNode.removeChild(n2);
    }, De = function(o2, t2) {
      return o2.view(t2).fold(rt2([]), function(t3) {
        var n2 = o2.owner(t3), e3 = De(o2, n2);
        return [t3].concat(e3);
      });
    }, Be = Object.freeze({ __proto__: null, view: function(t2) {
      var n2;
      return (t2.dom === document ? vt.none() : vt.from(null === (n2 = t2.dom.defaultView) || void 0 === n2 ? void 0 : n2.frameElement)).map(At.fromDom);
    }, owner: Ut }), Me = function(t2, n2, e3, o2) {
      return { x: t2, y: n2, width: e3, height: o2, right: t2 + e3, bottom: n2 + o2 };
    }, Ae = function(t2) {
      var n2 = Cn(t2), e3 = _n(t2), o2 = Sn(t2);
      return Me(n2.left, n2.top, e3, o2);
    }, Fe = function() {
      return Hn(window);
    }, Ie = function(e3) {
      return { isValue: D, isError: T, getOr: rt2(e3), getOrThunk: rt2(e3), getOrDie: rt2(e3), or: function(t2) {
        return Ie(e3);
      }, orThunk: function(t2) {
        return Ie(e3);
      }, fold: function(t2, n2) {
        return n2(e3);
      }, map: function(t2) {
        return Ie(t2(e3));
      }, mapError: function(t2) {
        return Ie(e3);
      }, each: function(t2) {
        t2(e3);
      }, bind: function(t2) {
        return t2(e3);
      }, exists: function(t2) {
        return t2(e3);
      }, forall: function(t2) {
        return t2(e3);
      }, toOptional: function() {
        return vt.some(e3);
      } };
    }, Re = function(e3) {
      return { isValue: T, isError: D, getOr: h, getOrThunk: function(t2) {
        return t2();
      }, getOrDie: function() {
        return _(String(e3))();
      }, or: h, orThunk: function(t2) {
        return t2();
      }, fold: function(t2, n2) {
        return t2(e3);
      }, map: function(t2) {
        return Re(e3);
      }, mapError: function(t2) {
        return Re(t2(e3));
      }, each: st, bind: function(t2) {
        return Re(e3);
      }, exists: T, forall: D, toOptional: vt.none };
    }, Ve = { value: Ie, error: Re, fromOption: function(t2, n2) {
      return t2.fold(function() {
        return Re(n2);
      }, Ie);
    } };
    function Pe(t2, n2, e3) {
      return t2.stype === jn.Error ? n2(t2.serror) : e3(t2.svalue);
    }
    function He(t2) {
      return { stype: jn.Value, svalue: t2 };
    }
    function ze(t2) {
      return { stype: jn.Error, serror: t2 };
    }
    function Ne(t2, n2, e3, o2) {
      return { tag: "field", key: t2, newKey: n2, presence: e3, prop: o2 };
    }
    function Le(t2, n2, e3) {
      switch (t2.tag) {
        case "field":
          return n2(t2.key, t2.newKey, t2.presence, t2.prop);
        case "custom":
          return e3(t2.newKey, t2.instantiator);
      }
    }
    function We(u2) {
      return function() {
        for (var t2 = [], n2 = 0; n2 < arguments.length; n2++)
          t2[n2] = arguments[n2];
        if (0 === t2.length)
          throw new Error("Can't merge zero objects");
        for (var e3 = {}, o2 = 0; o2 < t2.length; o2++) {
          var r2, i2 = t2[o2];
          for (r2 in i2)
            Tt(i2, r2) && (e3[r2] = u2(e3[r2], i2[r2]));
        }
        return e3;
      };
    }
    function Ue() {
      return { tag: "required", process: {} };
    }
    function je(t2) {
      return { tag: "defaultedThunk", process: t2 };
    }
    function Ge(t2) {
      return je(rt2(t2));
    }
    function Xe() {
      return { tag: "option", process: {} };
    }
    function Ye(t2) {
      return { tag: "mergeWithThunk", process: t2 };
    }
    function qe(t2) {
      return x(t2) && 100 < Ct(t2).length ? " removed due to size" : JSON.stringify(t2, null, 2);
    }
    function Ke(t2, n2) {
      return Lo([{ path: t2, getErrorInfo: n2 }]);
    }
    function Je(e3) {
      return { extract: function(n2, t2) {
        return Uo(e3(t2), function(t3) {
          return Ke(n2, rt2(t3));
        });
      }, toString: rt2("val") };
    }
    function $e(t2, n2, e3, o2) {
      return o2(tt(t2, n2).getOrThunk(function() {
        return e3(t2);
      }));
    }
    function Qe(n2, e3, o2, r2, i2) {
      function u2(t3) {
        return i2.extract(e3.concat([r2]), t3);
      }
      function t2(t3) {
        return t3.fold(function() {
          return No(vt.none());
        }, function(t4) {
          var n3 = i2.extract(e3.concat([r2]), t4);
          return jo(n3, vt.some);
        });
      }
      var a2, c2, s2, l2, f2, d2;
      switch (n2.tag) {
        case "required":
          return s2 = e3, d2 = u2, tt(l2 = o2, f2 = r2).fold(function() {
            return t3 = f2, n3 = l2, Ke(s2, function() {
              return 'Could not find valid *required* value for "' + t3 + '" in ' + qe(n3);
            });
            var t3, n3;
          }, d2);
        case "defaultedThunk":
          return $e(o2, r2, n2.process, u2);
        case "option":
          return t2(tt(o2, r2));
        case "defaultedOptionThunk":
          return c2 = n2.process, t2(tt(a2 = o2, r2).map(function(t3) {
            return true === t3 ? c2(a2) : t3;
          }));
        case "mergeWithThunk":
          return $e(o2, r2, rt2({}), function(t3) {
            return u2(Yo(n2.process(o2), t3));
          });
      }
    }
    function Ze(e3) {
      return { extract: function(t2, n2) {
        return e3().extract(t2, n2);
      }, toString: function() {
        return e3().toString();
      } };
    }
    function to(t2) {
      var s2 = $o(t2), l2 = I(t2, function(e3, t3) {
        return Le(t3, function(t4) {
          var n2;
          return Yo(e3, ((n2 = {})[t4] = true, n2));
        }, rt2(e3));
      }, {});
      return { extract: function(t3, n2) {
        var e3, o2, r2, i2, u2, a2, c2 = F(w(n2) ? [] : Ct((r2 = k, i2 = o2 = {}, u2 = function(t4, n3) {
          i2[n3] = t4;
        }, a2 = st, J(n2, function(t4, n3) {
          (r2(t4, n3) ? u2 : a2)(t4, n3);
        }), o2)), function(t4) {
          return !nt(l2, t4);
        });
        return 0 === c2.length ? s2.extract(t3, n2) : (e3 = c2, Ke(t3, function() {
          return "There are unsupported fields: [" + e3.join(", ") + "] specified";
        }));
      }, toString: s2.toString };
    }
    function no(o2) {
      return { extract: function(e3, t2) {
        var n2 = M(t2, function(t3, n3) {
          return o2.extract(e3.concat(["[" + n3 + "]"]), t3);
        });
        return Ko(n2);
      }, toString: function() {
        return "array(" + o2.toString() + ")";
      } };
    }
    function eo(u2) {
      return { extract: function(t2, n2) {
        for (var e3 = [], o2 = 0, r2 = u2; o2 < r2.length; o2++) {
          var i2 = r2[o2].extract(t2, n2);
          if (i2.stype === jn.Value)
            return i2;
          e3.push(i2);
        }
        return Ko(e3);
      }, toString: function() {
        return "oneOf(" + M(u2, function(t2) {
          return t2.toString();
        }).join(", ") + ")";
      } };
    }
    function oo(e3, o2) {
      return Je(function(t2) {
        var n2 = typeof t2;
        return e3(t2) ? No(t2) : Lo("Expected type: " + o2 + " but got: " + n2);
      });
    }
    function ro(n2, a2) {
      return { extract: function(i2, u2) {
        return tt(u2, n2).fold(function() {
          return t2 = n2, Ke(i2, function() {
            return 'Choice schema did not contain choice key: "' + t2 + '"';
          });
          var t2;
        }, function(t2) {
          return e3 = i2, n3 = u2, tt(o2 = a2, r2 = t2).fold(function() {
            return t3 = o2, n4 = r2, Ke(e3, function() {
              return 'The chosen schema: "' + n4 + '" did not exist in branches: ' + qe(t3);
            });
            var t3, n4;
          }, function(t3) {
            return t3.extract(e3.concat(["branch: " + r2]), n3);
          });
          var e3, n3, o2, r2;
        });
      }, toString: function() {
        return "chooseOn(" + n2 + "). Possible values: " + Ct(a2);
      } };
    }
    function io(n2) {
      return Je(function(t2) {
        return n2(t2).fold(Lo, No);
      });
    }
    function uo(n2, t2) {
      return r2 = function(t3) {
        return n2(t3).fold(ze, He);
      }, i2 = t2, { extract: function(e3, o2) {
        var t3 = Ct(o2), n3 = no(Je(r2)).extract(e3, t3);
        return Wo(n3, function(t4) {
          var n4 = M(t4, function(t5) {
            return Ne(t5, t5, Ue(), i2);
          });
          return $o(n4).extract(e3, o2);
        });
      }, toString: function() {
        return "setOf(" + i2.toString() + ")";
      } };
      var r2, i2;
    }
    function ao(t2, n2, e3) {
      return zo((r2 = n2.extract([t2], o2 = e3), Go(r2, function(t3) {
        return { input: o2, errors: t3 };
      })));
      var o2, r2;
    }
    function co(t2) {
      return t2.fold(function(t3) {
        throw new Error(ur(t3));
      }, h);
    }
    function so(t2, n2, e3) {
      return co(ao(t2, n2, e3));
    }
    function lo(t2, n2) {
      return ro(t2, dt(n2, $o));
    }
    function fo(n2) {
      return io(function(t2) {
        return wt(n2, t2) ? Ve.value(t2) : Ve.error('Unsupported value: "' + t2 + '", choose one of "' + n2.join(", ") + '".');
      });
    }
    function mo(t2) {
      return ar(t2, t2, Ue(), Zo());
    }
    function go(t2, n2) {
      return ar(t2, t2, Ue(), n2);
    }
    function po(t2) {
      return go(t2, nr);
    }
    function ho(t2, n2) {
      return ar(t2, t2, Ue(), fo(n2));
    }
    function vo(t2) {
      return go(t2, or);
    }
    function bo(t2, n2) {
      return ar(t2, t2, Ue(), $o(n2));
    }
    function yo(t2, n2) {
      return ar(t2, t2, Ue(), Qo(n2));
    }
    function xo(t2, n2) {
      return ar(t2, t2, Ue(), no(n2));
    }
    function wo(t2) {
      return ar(t2, t2, Xe(), Zo());
    }
    function So(t2, n2) {
      return ar(t2, t2, Xe(), n2);
    }
    function ko(t2) {
      return So(t2, tr);
    }
    function Co(t2) {
      return So(t2, nr);
    }
    function Oo(t2) {
      return So(t2, or);
    }
    function _o(t2, n2) {
      return So(t2, no(n2));
    }
    function To(t2, n2) {
      return So(t2, $o(n2));
    }
    function Eo(t2, n2) {
      return ar(t2, t2, Ge(n2), Zo());
    }
    function Do(t2, n2, e3) {
      return ar(t2, t2, Ge(n2), e3);
    }
    function Bo(t2, n2) {
      return Do(t2, n2, tr);
    }
    function Mo(t2, n2) {
      return Do(t2, n2, nr);
    }
    function Ao(t2, n2, e3) {
      return Do(t2, n2, fo(e3));
    }
    function Fo(t2, n2) {
      return Do(t2, n2, er);
    }
    function Io(t2, n2) {
      return Do(t2, n2, or);
    }
    function Ro(t2, n2, e3) {
      return Do(t2, n2, no(e3));
    }
    function Vo(t2, n2, e3) {
      return Do(t2, n2, $o(e3));
    }
    function Po(t2) {
      var n2 = t2;
      return { get: function() {
        return n2;
      }, set: function(t3) {
        n2 = t3;
      } };
    }
    (Gn = jn = {})[Gn.Error = 0] = "Error", Gn[Gn.Value = 1] = "Value";
    function Ho(u2) {
      if (!c(u2))
        throw new Error("cases must be an array");
      if (0 === u2.length)
        throw new Error("there must be at least one case");
      var a2 = [], e3 = {};
      return St(u2, function(t2, o2) {
        var n2 = Ct(t2);
        if (1 !== n2.length)
          throw new Error("one and only one name per case");
        var r2 = n2[0], i2 = t2[r2];
        if (void 0 !== e3[r2])
          throw new Error("duplicate key detected:" + r2);
        if ("cata" === r2)
          throw new Error("cannot have a case named cata (sorry)");
        if (!c(i2))
          throw new Error("case arguments must be an array");
        a2.push(r2), e3[r2] = function() {
          for (var e4 = [], t3 = 0; t3 < arguments.length; t3++)
            e4[t3] = arguments[t3];
          var n3 = e4.length;
          if (n3 !== i2.length)
            throw new Error("Wrong number of arguments to case " + r2 + ". Expected " + i2.length + " (" + i2 + "), got " + n3);
          return { fold: function() {
            for (var t4 = [], n4 = 0; n4 < arguments.length; n4++)
              t4[n4] = arguments[n4];
            if (t4.length !== u2.length)
              throw new Error("Wrong number of arguments to fold. Expected " + u2.length + ", got " + t4.length);
            return t4[o2].apply(null, e4);
          }, match: function(t4) {
            var n4 = Ct(t4);
            if (a2.length !== n4.length)
              throw new Error("Wrong number of arguments to match. Expected: " + a2.join(",") + "\nActual: " + n4.join(","));
            if (!N(a2, function(t5) {
              return wt(n4, t5);
            }))
              throw new Error("Not all branches were specified when using match. Specified: " + n4.join(", ") + "\nRequired: " + a2.join(", "));
            return t4[r2].apply(null, e4);
          }, log: function(t4) {
            console.log(t4, { constructors: a2, constructor: r2, params: e4 });
          } };
        };
      }), e3;
    }
    var zo = function(t2) {
      return Pe(t2, Ve.error, Ve.value);
    }, No = He, Lo = ze, Wo = function(t2, n2) {
      return t2.stype === jn.Value ? n2(t2.svalue) : t2;
    }, Uo = function(t2, n2) {
      return t2.stype === jn.Error ? n2(t2.serror) : t2;
    }, jo = function(t2, n2) {
      return t2.stype === jn.Value ? { stype: jn.Value, svalue: n2(t2.svalue) } : t2;
    }, Go = function(t2, n2) {
      return t2.stype === jn.Error ? { stype: jn.Error, serror: n2(t2.serror) } : t2;
    }, Xo = Pe, Yo = We(function(t2, n2) {
      return x(t2) && x(n2) ? Yo(t2, n2) : n2;
    }), qo = We(function(t2, n2) {
      return n2;
    }), Ko = function(t2) {
      var n2, e3, o2 = (n2 = [], e3 = [], St(t2, function(t3) {
        Pe(t3, function(t4) {
          return e3.push(t4);
        }, function(t4) {
          return n2.push(t4);
        });
      }), { values: n2, errors: e3 });
      return 0 < o2.errors.length ? r(Lo, ft)(o2.errors) : No(o2.values);
    }, Jo = Je(No), $o = function(e3) {
      return { extract: function(i2, u2) {
        for (var a2 = {}, c2 = [], t2 = 0, n2 = e3; t2 < n2.length; t2++)
          Le(n2[t2], function(t3, n3, e4, o2) {
            var r2 = Qe(e4, i2, u2, t3, o2);
            Xo(r2, function(t4) {
              c2.push.apply(c2, t4);
            }, function(t4) {
              a2[n3] = t4;
            });
          }, function(t3, n3) {
            a2[t3] = n3(u2);
          });
        return 0 < c2.length ? Lo(c2) : No(a2);
      }, toString: function() {
        return "obj{\n" + M(e3, function(t2) {
          return Le(t2, function(t3, n2, e4, o2) {
            return t3 + " -> " + o2.toString();
          }, function(t3, n2) {
            return "state(" + t3 + ")";
          });
        }).join("\n") + "}";
      } };
    }, Qo = r(no, $o), Zo = rt2(Jo), tr = oo(u, "number"), nr = oo(y, "string"), er = oo(w, "boolean"), or = oo(S, "function"), rr = function(n2) {
      if (Object(n2) !== n2)
        return true;
      switch ({}.toString.call(n2).slice(8, -1)) {
        case "Boolean":
        case "Number":
        case "String":
        case "Date":
        case "RegExp":
        case "Blob":
        case "FileList":
        case "ImageData":
        case "ImageBitmap":
        case "ArrayBuffer":
          return true;
        case "Array":
        case "Object":
          return Object.keys(n2).every(function(t2) {
            return rr(n2[t2]);
          });
        default:
          return false;
      }
    }, ir = Je(function(t2) {
      return rr(t2) ? No(t2) : Lo("Expected value to be acceptable for sending via postMessage");
    }), ur = function(t2) {
      return "Errors: \n" + M(10 < (n2 = t2.errors).length ? n2.slice(0, 10).concat([{ path: [], getErrorInfo: rt2("... (only showing first ten failures)") }]) : n2, function(t3) {
        return "Failed path: (" + t3.path.join(" > ") + ")\n" + t3.getErrorInfo();
      }).join("\n") + "\n\nInput object: " + qe(t2.input);
      var n2;
    }, ar = Ne, cr = function(t2, n2) {
      return { tag: "custom", newKey: t2, instantiator: n2 };
    };
    function sr(t2, n2) {
      return (e3 = {})[t2] = n2, e3;
      var e3;
    }
    function lr(t2) {
      return n2 = {}, St(t2, function(t3) {
        n2[t3.key] = t3.value;
      }), n2;
      var n2;
    }
    function fr(t2) {
      return S(t2) ? t2 : T;
    }
    function dr(t2, n2, e3) {
      for (var o2 = t2.dom, r2 = fr(e3); o2.parentNode; ) {
        var o2 = o2.parentNode, i2 = At.fromDom(o2), u2 = n2(i2);
        if (u2.isSome())
          return u2;
        if (r2(i2))
          break;
      }
      return vt.none();
    }
    function mr(t2, n2, e3) {
      var o2 = n2(t2), r2 = fr(e3);
      return o2.orThunk(function() {
        return r2(t2) ? vt.none() : dr(t2, n2, r2);
      });
    }
    function gr(t2, n2) {
      return Lt(t2.element, n2.event.target);
    }
    function pr(t2) {
      if (!nt(t2, "can") && !nt(t2, "abort") && !nt(t2, "run"))
        throw new Error("EventHandler defined by: " + JSON.stringify(t2, null, 2) + " does not have can, abort, or run!");
      return lt2(lt2({}, ai), t2);
    }
    function hr(t2) {
      return rt2("alloy." + t2);
    }
    function vr(t2, n2) {
      nu(t2, t2.element, n2, {});
    }
    function br(t2, n2, e3) {
      nu(t2, t2.element, n2, e3);
    }
    function yr(t2) {
      vr(t2, Ii());
    }
    function xr(t2, n2, e3) {
      nu(t2, n2, e3, {});
    }
    function wr(t2, n2, e3, o2) {
      t2.getSystem().triggerEvent(e3, n2, o2.event);
    }
    function Sr(t2, n2) {
      return { key: t2, value: pr({ abort: n2 }) };
    }
    function kr(t2) {
      return { key: t2, value: pr({ run: function(t3, n2) {
        n2.event.prevent();
      } }) };
    }
    function Cr(t2, n2) {
      return { key: t2, value: pr({ run: n2 }) };
    }
    function Or(t2, e3, o2) {
      return { key: t2, value: pr({ run: function(t3, n2) {
        e3.apply(void 0, [t3, n2].concat(o2));
      } }) };
    }
    function _r(t2) {
      return function(e3) {
        return { key: t2, value: pr({ run: function(t3, n2) {
          gr(t3, n2) && e3(t3, n2);
        } }) };
      };
    }
    function Tr(t2, n2, e3) {
      var o2, r2 = n2.partUids[e3];
      return Cr(o2 = t2, function(t3, n3) {
        t3.getSystem().getByUid(r2).each(function(t4) {
          wr(t4, t4.element, o2, n3);
        });
      });
    }
    function Er(t2, r2) {
      return Cr(t2, function(n2, t3) {
        var e3 = t3.event, o2 = n2.getSystem().getByDom(e3.target).getOrThunk(function() {
          return mr(e3.target, function(t4) {
            return n2.getSystem().getByDom(t4).toOptional();
          }, T).getOr(n2);
        });
        r2(n2, o2, t3);
      });
    }
    function Dr(t2) {
      return Cr(t2, function(t3, n2) {
        n2.cut();
      });
    }
    function Br(t2, n2) {
      return _r(t2)(n2);
    }
    function Mr(t2) {
      return t2.dom.innerHTML;
    }
    function Ar(t2, n2) {
      var e3, o2, r2 = Ut(t2).dom, i2 = At.fromDom(r2.createDocumentFragment());
      An(i2, (e3 = n2, (o2 = (r2 || document).createElement("div")).innerHTML = e3, Kt(At.fromDom(o2)))), Fn(t2), Te(t2, i2);
    }
    function Fr(t2) {
      if (Zt(t2))
        return "#shadow-root";
      var n2 = At.fromDom(t2.dom.cloneNode(false)), e3 = At.fromTag("div"), o2 = At.fromDom(n2.dom.cloneNode(true));
      return Te(e3, o2), Mr(e3);
    }
    function Ir(t2) {
      var n2 = new Date().getTime();
      return t2 + "_" + Math.floor(1e9 * Math.random()) + ++su + String(n2);
    }
    function Rr(t2) {
      var n2 = Xn(t2) ? t2.dom[mu] : null;
      return vt.from(n2);
    }
    function Vr(n2) {
      function e3(t3) {
        return "The component must be in a context to execute: " + t3 + (n2 ? "\n" + Fr(n2().element) + " is not in context." : "");
      }
      function t2(t3) {
        return function() {
          throw new Error(e3(t3));
        };
      }
      function o2(t3) {
        return function() {
          console.warn(e3(t3));
        };
      }
      return { debugInfo: rt2("fake"), triggerEvent: o2("triggerEvent"), triggerFocus: o2("triggerFocus"), triggerEscape: o2("triggerEscape"), broadcast: o2("broadcast"), broadcastOn: o2("broadcastOn"), broadcastEvent: o2("broadcastEvent"), build: t2("build"), addToWorld: t2("addToWorld"), removeFromWorld: t2("removeFromWorld"), addToGui: t2("addToGui"), removeFromGui: t2("removeFromGui"), getByUid: t2("getByUid"), getByDom: t2("getByDom"), isConnected: T };
    }
    function Pr(t2, n2) {
      var e3 = t2.toString(), o2 = e3.indexOf(")") + 1, r2 = e3.indexOf("("), i2 = e3.substring(r2 + 1, o2 - 1).split(/,\s*/);
      return t2.toFunctionAnnotation = function() {
        return { name: n2, parameters: bu(i2) };
      }, t2;
    }
    function Hr(t2) {
      return sr(yu, t2);
    }
    function zr(o2) {
      return t2 = function(t3) {
        for (var n3 = [], e4 = 1; e4 < arguments.length; e4++)
          n3[e4 - 1] = arguments[e4];
        return o2.apply(void 0, H([t3.getApis(), t3], n3, false));
      }, e3 = (n2 = o2.toString()).indexOf(")") + 1, r2 = n2.indexOf("("), i2 = n2.substring(r2 + 1, e3 - 1).split(/,\s*/), t2.toFunctionAnnotation = function() {
        return { name: "OVERRIDE", parameters: bu(i2.slice(1)) };
      }, t2;
      var t2, n2, e3, r2, i2;
    }
    function Nr(t2, r2) {
      var i2 = {};
      return J(t2, function(t3, o2) {
        J(t3, function(t4, n2) {
          var e3 = tt(i2, n2).getOr([]);
          i2[n2] = e3.concat([r2(o2, t4)]);
        });
      }), i2;
    }
    function Lr(t2) {
      return { classes: E(t2.classes) ? [] : t2.classes, attributes: E(t2.attributes) ? {} : t2.attributes, styles: E(t2.styles) ? {} : t2.styles };
    }
    function Wr(t2) {
      return t2.cHandler;
    }
    function Ur(t2, n2) {
      return { name: t2, handler: n2 };
    }
    function jr(t2, n2, e3) {
      var o2 = n2[e3];
      return o2 ? function(u2, t3, a2) {
        try {
          var n3 = G(t3, function(t4, n4) {
            var e4 = t4.name, o3 = n4.name, r2 = a2.indexOf(e4), i2 = a2.indexOf(o3);
            if (-1 === r2)
              throw new Error("The ordering for " + u2 + " does not have an entry for " + e4 + ".\nOrder specified: " + JSON.stringify(a2, null, 2));
            if (-1 === i2)
              throw new Error("The ordering for " + u2 + " does not have an entry for " + o3 + ".\nOrder specified: " + JSON.stringify(a2, null, 2));
            return r2 < i2 ? -1 : i2 < r2 ? 1 : 0;
          });
          return Ve.value(n3);
        } catch (t4) {
          return Ve.error([t4]);
        }
      }("Event: " + e3, t2, o2).map(function(t3) {
        var e4, n3, o3, r2, i2 = M(t3, function(t4) {
          return t4.handler;
        });
        return { can: function() {
          for (var e5 = [], t4 = 0; t4 < arguments.length; t4++)
            e5[t4] = arguments[t4];
          return R(n3, function(t5, n4) {
            return t5 && n4.can.apply(void 0, e5);
          }, true);
        }, abort: (o3 = n3 = e4 = i2, r2 = function(t4) {
          return t4.abort;
        }, function() {
          for (var e5 = [], t4 = 0; t4 < arguments.length; t4++)
            e5[t4] = arguments[t4];
          return R(o3, function(t5, n4) {
            return t5 || r2(n4).apply(void 0, e5);
          }, false);
        }), run: function() {
          for (var n4 = [], t4 = 0; t4 < arguments.length; t4++)
            n4[t4] = arguments[t4];
          St(e4, function(t5) {
            t5.run.apply(void 0, n4);
          });
        } };
      }) : Ve.error(["The event (" + e3 + ') has more than one behaviour that listens to it.\nWhen this occurs, you must specify an event ordering for the behaviours in your spec (e.g. [ "listing", "toggling" ]).\nThe behaviours that can trigger it are: ' + JSON.stringify(M(t2, function(t3) {
        return t3.name;
      }), null, 2)]);
    }
    function Gr(t2, n2) {
      var e3 = un(t2, n2);
      return void 0 === e3 || "" === e3 ? [] : e3.split(" ");
    }
    function Xr(t2) {
      return void 0 !== t2.dom.classList;
    }
    function Yr(t2, n2) {
      var e3, o2, r2;
      Xr(t2) ? t2.dom.classList.add(n2) : (o2 = n2, r2 = Gr(e3 = t2, "class").concat([o2]), on(e3, "class", r2.join(" ")));
    }
    function qr(t2, n2) {
      var e3, o2, r2, i2;
      Xr(t2) ? t2.dom.classList.remove(n2) : (r2 = n2, 0 < (i2 = F(Gr(o2 = t2, "class"), function(t3) {
        return t3 !== r2;
      })).length ? on(o2, "class", i2.join(" ")) : sn(o2, "class")), 0 === (Xr(e3 = t2) ? e3.dom.classList : Gr(e3, "class")).length && sn(e3, "class");
    }
    function Kr(t2, n2) {
      return Xr(t2) && t2.dom.classList.contains(n2);
    }
    function Jr(n2, t2) {
      St(t2, function(t3) {
        Yr(n2, t3);
      });
    }
    function $r(n2, t2) {
      St(t2, function(t3) {
        qr(n2, t3);
      });
    }
    function Qr(t2) {
      return t2.dom.value;
    }
    function Zr(t2, n2) {
      if (void 0 === n2)
        throw new Error("Value.set was undefined");
      t2.dom.value = n2;
    }
    function ti(t2) {
      var e3, n2, o2, r2, i2 = (e3 = tt(t2, "behaviours").getOr({}), z(Ct(e3), function(t3) {
        var n3 = e3[t3];
        return k(n3) ? [n3.me] : [];
      }));
      return n2 = t2, r2 = M(o2 = i2, function(t3) {
        return To(t3.name(), [mo("config"), Eo("state", xu)]);
      }), { list: o2, data: dt(ao("component.behaviours", $o(r2), n2.behaviours).fold(function(t3) {
        throw new Error(ur(t3) + "\nComplete spec:\n" + JSON.stringify(n2, null, 2));
      }, h), function(t3) {
        return rt2(t3.map(function(t4) {
          return { config: t4.config, state: t4.state.init(t4.config) };
        }));
      }) };
    }
    function ni(t2, n2, e3) {
      var o2, r2, i2 = lt2(lt2({}, (o2 = t2).dom), { uid: o2.uid, domChildren: M(o2.components, function(t3) {
        return t3.element;
      }) }), u2 = t2.domModification.fold(function() {
        return Lr({});
      }, Lr), a2 = 0 < n2.length ? function(n3, t3, e4, o3) {
        var r3 = lt2({}, t3);
        function i3(t4) {
          return I(t4, function(t5, n4) {
            return lt2(lt2({}, n4.modification), t5);
          }, {});
        }
        St(e4, function(t4) {
          r3[t4.name()] = t4.exhibit(n3, o3);
        });
        var u3 = Nr(r3, function(t4, n4) {
          return { name: t4, modification: n4 };
        });
        return Lr({ classes: I(u3.classes, function(t4, n4) {
          return n4.modification.concat(t4);
        }, []), attributes: i3(u3.attributes), styles: i3(u3.styles) });
      }(e3, { "alloy.base.modification": u2 }, n2, i2) : u2;
      return lt2(lt2({}, r2 = i2), { attributes: lt2(lt2({}, r2.attributes), a2.attributes), styles: lt2(lt2({}, r2.styles), a2.styles), classes: r2.classes.concat(a2.classes) });
    }
    function ei(t2, n2, e3) {
      var o2, r2, i2, u2, a2, c2 = { "alloy.base.behaviour": t2.events }, s2 = t2.eventOrder;
      return r2 = e3, i2 = n2, o2 = Nr(lt2(lt2({}, c2), (u2 = r2, a2 = {}, St(i2, function(t3) {
        a2[t3.name()] = t3.handlers(u2);
      }), a2)), Ur), Su(o2, s2).getOrDie();
    }
    function oi(t2) {
      var e3, n2, o2, r2, i2, u2, a2, c2, s2, l2, f2 = hu(t2), d2 = f2.events, m3 = B(f2, ["events"]), g2 = M(tt(m3, "components").getOr([]), Tu), p2 = lt2(lt2({}, m3), { events: lt2(lt2({}, cu), d2), components: g2 });
      return Ve.value((n2 = Po(vu), o2 = co(ao("custom.definition", Cu, e3 = p2)), r2 = ti(e3), i2 = r2.list, u2 = r2.data, a2 = function(t3) {
        var n3 = At.fromTag(t3.tag);
        rn(n3, t3.attributes), Jr(n3, t3.classes), mn(n3, t3.styles), t3.innerHtml.each(function(t4) {
          return Ar(n3, t4);
        });
        var e4 = t3.domChildren;
        return An(n3, e4), t3.value.each(function(t4) {
          Zr(n3, t4);
        }), t3.uid, gu(n3, t3.uid), n3;
      }(ni(o2, i2, u2)), c2 = ei(o2, i2, u2), s2 = Po(o2.components), l2 = { uid: e3.uid, getSystem: n2.get, config: function(t3) {
        var n3 = u2;
        return (S(n3[t3.name()]) ? n3[t3.name()] : function() {
          throw new Error("Could not find " + t3.name() + " in " + JSON.stringify(e3, null, 2));
        })();
      }, hasConfigured: function(t3) {
        return S(u2[t3.name()]);
      }, spec: e3, readState: function(t3) {
        return u2[t3]().map(function(t4) {
          return t4.state.readState();
        }).getOr("not enabled");
      }, getApis: function() {
        return o2.apis;
      }, connect: function(t3) {
        n2.set(t3);
      }, disconnect: function() {
        n2.set(Vr(h2));
      }, element: a2, syncComponents: function() {
        var t3 = z(Kt(a2), function(t4) {
          return n2.get().getByDom(t4).fold(function() {
            return [];
          }, j);
        });
        s2.set(t3);
      }, components: s2.get, events: c2 }));
      function h2() {
        return l2;
      }
    }
    function ri(t2) {
      var n2 = At.fromText(t2);
      return Ou({ element: n2 });
    }
    Ho([{ bothErrors: ["error1", "error2"] }, { firstError: ["error1", "value2"] }, { secondError: ["value1", "error2"] }, { bothValues: ["value1", "value2"] }]);
    var ii, ui, ai = { can: D, abort: T, run: st }, ci = rt2, si = ci("touchstart"), li = ci("touchmove"), fi = ci("touchend"), di = ci("touchcancel"), mi = ci("mousedown"), gi = ci("mousemove"), pi = ci("mouseout"), hi = ci("mouseup"), vi = ci("mouseover"), bi = ci("focusin"), yi = ci("focusout"), xi = ci("keydown"), wi = ci("keyup"), Si = ci("input"), ki = ci("change"), Ci = ci("click"), Oi = ci("transitioncancel"), _i = ci("transitionend"), Ti = ci("transitionstart"), Ei = ci("selectstart"), Di = { tap: hr("tap") }, Bi = hr("focus"), Mi = hr("blur.post"), Ai = hr("paste.post"), Fi = hr("receive"), Ii = hr("execute"), Ri = hr("focus.item"), Vi = Di.tap, Pi = hr("longpress"), Hi = hr("sandbox.close"), zi = hr("typeahead.cancel"), Ni = hr("system.init"), Li = hr("system.touchmove"), Wi = hr("system.touchend"), Ui = hr("system.scroll"), ji = hr("system.resize"), Gi = hr("system.attached"), Xi = hr("system.detached"), Yi = hr("system.dismissRequested"), qi = hr("system.repositionRequested"), Ki = hr("focusmanager.shifted"), Ji = hr("slotcontainer.visibility"), $i = hr("change.tab"), Qi = hr("dismiss.tab"), Zi = hr("highlight"), tu = hr("dehighlight"), nu = function(t2, n2, e3, o2) {
      var r2 = lt2({ target: n2 }, o2);
      t2.getSystem().triggerEvent(e3, n2, r2);
    }, eu = lr, ou = _r(Gi()), ru = _r(Xi()), iu = _r(Ni()), uu = (ii = Ii(), function(t2) {
      return Cr(ii, t2);
    }), au = eu([{ key: Bi(), value: pr({ can: function(t2, n2) {
      var e3, o2 = n2.event, r2 = o2.originator, i2 = o2.target;
      return !(Lt(e3 = r2, t2.element) && !Lt(e3, i2) && (console.warn(Bi() + " did not get interpreted by the desired target. \nOriginator: " + Fr(r2) + "\nTarget: " + Fr(i2) + "\nCheck the " + Bi() + " event handlers"), 1));
    } }) }]), cu = Object.freeze({ __proto__: null, events: au }), su = 0, lu = rt2("alloy-id-"), fu = rt2("data-alloy-id"), du = lu(), mu = fu(), gu = function(t2, n2) {
      Object.defineProperty(t2.dom, mu, { value: n2, writable: true });
    }, pu = Ir, hu = h, vu = Vr(), bu = function(t2) {
      return M(t2, function(t3) {
        return Bt(t3, "/*") ? t3.substring(0, t3.length - "/*".length) : t3;
      });
    }, yu = Ir("alloy-premade"), xu = { init: function() {
      return wu({ readState: rt2("No State required") });
    } }, wu = function(t2) {
      return t2;
    }, Su = function(t2, a2) {
      var n2, e3, o2, r2, i2, u2, c2 = $(t2, function(r3, u3) {
        return (1 === r3.length ? Ve.value(r3[0].handler) : jr(r3, a2, u3)).map(function(t3) {
          var n3, i3, e4 = (i3 = S(n3 = t3) ? { can: D, abort: T, run: n3 } : n3, function(t4, n4) {
            for (var e5 = [], o4 = 2; o4 < arguments.length; o4++)
              e5[o4 - 2] = arguments[o4];
            var r4 = [t4, n4].concat(e5);
            i3.abort.apply(void 0, r4) ? n4.stop() : i3.can.apply(void 0, r4) && i3.run.apply(void 0, r4);
          }), o3 = 1 < r3.length ? F(a2[u3], function(n4) {
            return d(r3, function(t4) {
              return t4.name === n4;
            });
          }).join(" > ") : r3[0].name;
          return sr(u3, { handler: e4, purpose: o3 });
        });
      });
      return n2 = {}, e3 = [], o2 = [], St(c2, function(t3) {
        t3.fold(function(t4) {
          e3.push(t4);
        }, function(t4) {
          o2.push(t4);
        });
      }), 0 < (u2 = { errors: e3, values: o2 }).errors.length ? Ve.error(ft(u2.errors)) : (i2 = n2, 0 === (r2 = u2.values).length ? Ve.value(i2) : Ve.value(Yo(i2, qo.apply(void 0, r2))));
    }, ku = "alloy.base.behaviour", Cu = $o([ar("dom", "dom", Ue(), $o([mo("tag"), Eo("styles", {}), Eo("classes", []), Eo("attributes", {}), wo("value"), wo("innerHtml")])), mo("components"), mo("uid"), Eo("events", {}), Eo("apis", {}), ar("eventOrder", "eventOrder", ((ui = {})[Ii()] = ["disabling", ku, "toggling", "typeaheadevents"], ui[Bi()] = [ku, "focusing", "keying"], ui[Ni()] = [ku, "disabling", "toggling", "representing"], ui[Si()] = [ku, "representing", "streaming", "invalidating"], ui[Xi()] = [ku, "representing", "item-events", "tooltipping"], ui[mi()] = ["focusing", ku, "item-type-events"], ui[si()] = ["focusing", ku, "item-type-events"], ui[vi()] = ["item-type-events", "tooltipping"], ui[Fi()] = ["receiving", "reflecting", "tooltipping"], Ye(rt2(ui))), Zo()), wo("domModification")]), Ou = function(t2) {
      var n2 = so("external.component", to([mo("element"), wo("uid")]), t2), e3 = Po(Vr()), o2 = n2.uid.getOrThunk(function() {
        return pu("external");
      });
      gu(n2.element, o2);
      var r2 = { uid: o2, getSystem: e3.get, config: vt.none, hasConfigured: T, connect: function(t3) {
        e3.set(t3);
      }, disconnect: function() {
        e3.set(Vr(function() {
          return r2;
        }));
      }, getApis: function() {
        return {};
      }, element: n2.element, spec: t2, readState: rt2("No state"), syncComponents: st, components: rt2([]), events: {} };
      return Hr(r2);
    }, _u = pu, Tu = function(t2) {
      return tt(t2, yu).getOrThunk(function() {
        return oi(Tt(t2, "uid") ? t2 : lt2({ uid: _u("") }, t2)).getOrDie();
      });
    }, Eu = Hr;
    function Du(t2, n2, e3, o2, r2) {
      return t2(e3, o2) ? vt.some(e3) : S(r2) && r2(e3) ? vt.none() : n2(e3, o2, r2);
    }
    function Bu(t2, n2, e3) {
      for (var o2 = t2.dom, r2 = S(e3) ? e3 : T; o2.parentNode; ) {
        var o2 = o2.parentNode, i2 = At.fromDom(o2);
        if (n2(i2))
          return vt.some(i2);
        if (r2(i2))
          break;
      }
      return vt.none();
    }
    function Mu(t2, n2, e3) {
      return Du(function(t3, n3) {
        return n3(t3);
      }, Bu, t2, n2, e3);
    }
    function Au(t2, n2, e3) {
      return Mu(t2, n2, e3).isSome();
    }
    function Fu(t2, n2, e3) {
      return Bu(t2, function(t3) {
        return zt(t3, n2);
      }, e3);
    }
    function Iu(t2, n2) {
      return e3 = n2, Nt(o2 = void 0 === t2 ? document : t2.dom) ? vt.none() : vt.from(o2.querySelector(e3)).map(At.fromDom);
      var e3, o2;
    }
    function Ru(t2, n2, e3) {
      return Du(zt, Fu, t2, n2, e3);
    }
    function Vu() {
      var n2 = Ir("aria-owns");
      return { id: n2, link: function(t2) {
        on(t2, "aria-owns", n2);
      }, unlink: function(t2) {
        sn(t2, "aria-owns");
      } };
    }
    var Pu, Hu, zu = function(n2, t2) {
      return Au(t2, function(t3) {
        return Lt(t3, n2.element);
      }, T) || (e3 = n2, Mu(t2, function(t3) {
        if (!Xn(t3))
          return false;
        var n3 = un(t3, "id");
        return void 0 !== n3 && -1 < n3.indexOf("aria-owns");
      }).bind(function(t3) {
        var n3 = un(t3, "id");
        return Iu(ge(t3), '[aria-owns="' + n3 + '"]');
      }).exists(function(t3) {
        return zu(e3, t3);
      }));
      var e3;
    }, Nu = "unknown";
    function Lu(n2, t2, e3) {
      var o2, r2, i2, u2;
      switch (tt(Wu.get(), n2).orThunk(function() {
        return K(Ct(Wu.get()), function(t3) {
          return -1 < n2.indexOf(t3) ? vt.some(Wu.get()[t3]) : vt.none();
        });
      }).getOr(Pu.NORMAL)) {
        case Pu.NORMAL:
          return e3(ju());
        case Pu.LOGGING:
          var a2 = (o2 = n2, r2 = t2, i2 = [], u2 = new Date().getTime(), { logEventCut: function(t3, n3, e4) {
            i2.push({ outcome: "cut", target: n3, purpose: e4 });
          }, logEventStopped: function(t3, n3, e4) {
            i2.push({ outcome: "stopped", target: n3, purpose: e4 });
          }, logNoParent: function(t3, n3, e4) {
            i2.push({ outcome: "no-parent", target: n3, purpose: e4 });
          }, logEventNoHandlers: function(t3, n3) {
            i2.push({ outcome: "no-handlers-left", target: n3 });
          }, logEventResponse: function(t3, n3, e4) {
            i2.push({ outcome: "response", purpose: e4, target: n3 });
          }, write: function() {
            var t3 = new Date().getTime();
            wt(["mousemove", "mouseover", "mouseout", Ni()], o2) || console.log(o2, { event: o2, time: t3 - u2, target: r2.dom, sequence: M(i2, function(t4) {
              return wt(["cut", "stopped", "response"], t4.outcome) ? "{" + t4.purpose + "} " + t4.outcome + " at (" + Fr(t4.target) + ")" : t4.outcome;
            }) });
          } }), c2 = e3(a2);
          return a2.write(), c2;
        case Pu.STOP:
          return true;
      }
    }
    (Hu = Pu = Pu || {})[Hu.STOP = 0] = "STOP", Hu[Hu.NORMAL = 1] = "NORMAL", Hu[Hu.LOGGING = 2] = "LOGGING";
    var Wu = Po({}), Uu = ["alloy/data/Fields", "alloy/debugging/Debugging"], ju = rt2({ logEventCut: st, logEventStopped: st, logNoParent: st, logEventNoHandlers: st, logEventResponse: st, write: st }), Gu = rt2([mo("menu"), mo("selectedMenu")]), Xu = rt2([mo("item"), mo("selectedItem")]);
    function Yu() {
      return bo("markers", [mo("backgroundMenu")].concat(Gu()).concat(Xu()));
    }
    function qu(t2) {
      return bo("markers", M(t2, mo));
    }
    function Ku(t2, n2, e3) {
      return void 0 !== (o2 = new Error()).stack && V(o2.stack.split("\n"), function(n3) {
        return 0 < n3.indexOf("alloy") && !d(Uu, function(t3) {
          return -1 < n3.indexOf(t3);
        });
      }).getOr(Nu), ar(n2, n2, e3, io(function(e4) {
        return Ve.value(function() {
          for (var t3 = [], n3 = 0; n3 < arguments.length; n3++)
            t3[n3] = arguments[n3];
          return e4.apply(void 0, t3);
        });
      }));
      var o2;
    }
    function Ju(t2) {
      return Ku(0, t2, Ge(st));
    }
    function $u(t2) {
      return Ku(0, t2, Ge(vt.none));
    }
    function Qu(t2) {
      return Ku(0, t2, Ue());
    }
    function Zu(t2) {
      return Ku(0, t2, Ue());
    }
    function ta(t2, n2) {
      return cr(t2, rt2(n2));
    }
    function na(t2) {
      return cr(t2, h);
    }
    function ea(t2, n2, e3, o2, r2, i2, u2, a2) {
      return { x: t2, y: n2, bubble: e3, direction: o2, placement: r2, restriction: i2, label: u2 + "-" + r2, alwaysFit: a2 = void 0 !== a2 && a2 };
    }
    function oa(t2, n2, e3, o2) {
      var r2 = t2 + n2;
      return o2 < r2 ? e3 : r2 < e3 ? o2 : r2;
    }
    function ra(e3, n2) {
      return U(["left", "right", "top", "bottom"], function(t2) {
        return tt(n2, t2).map(function(n3) {
          return function(t3) {
            switch (n3) {
              case 1:
                return t3.x;
              case 0:
                return t3.x + t3.width;
              case 2:
                return t3.y;
              case 3:
                return t3.y + t3.height;
            }
          }(e3);
        });
      });
    }
    function ia(t2, n2) {
      return t2.x + t2.width / 2 - n2.width / 2;
    }
    function ua(t2, n2) {
      return t2.x + t2.width - n2.width;
    }
    function aa(t2, n2) {
      return t2.y - n2.height;
    }
    function ca(t2) {
      return t2.y + t2.height;
    }
    function sa(t2, n2) {
      return t2.y + t2.height / 2 - n2.height / 2;
    }
    function la(t2, n2, e3) {
      return ea(t2.x + t2.width, sa(t2, n2), e3.east(), Wa(), "east", ra(t2, { left: 0 }), Ga);
    }
    function fa(t2, n2, e3) {
      return ea(t2.x - n2.width, sa(t2, n2), e3.west(), Ua(), "west", ra(t2, { right: 1 }), Ga);
    }
    function da() {
      return [Xa, Ya, qa, Ka, $a, Ja, la, fa];
    }
    function ma() {
      return [Ya, Xa, Ka, qa, $a, Ja, la, fa];
    }
    function ga() {
      return [qa, Ka, Xa, Ya, Ja, $a];
    }
    function pa() {
      return [Ka, qa, Ya, Xa, Ja, $a];
    }
    function ha() {
      return [Xa, Ya, qa, Ka, $a, Ja];
    }
    function va() {
      return [Ya, Xa, Ka, qa, $a, Ja];
    }
    function ba(e3, o2, r2) {
      return iu(function(t2, n2) {
        r2(t2, e3, o2);
      });
    }
    function ya(t2) {
      return { key: t2, value: void 0 };
    }
    function xa(t2) {
      var n2, e3, o2, r2, i2, u2, a2, c2, s2 = so("Creating behaviour: " + t2.name, ec, t2);
      return n2 = s2.fields, e3 = s2.name, o2 = s2.active, r2 = s2.apis, i2 = s2.extra, u2 = s2.state, a2 = to(n2), c2 = To(e3, [So("config", to(n2))]), tc(a2, c2, e3, o2, r2, i2, u2);
    }
    function wa(t2) {
      var n2, e3 = so("Creating behaviour: " + t2.name, oc, t2), o2 = lo(e3.branchKey, e3.branches), r2 = e3.name, i2 = e3.active, u2 = e3.apis, a2 = e3.extra, c2 = e3.state, s2 = To(r2, [So("config", n2 = o2)]);
      return tc(n2, s2, r2, i2, u2, a2, c2);
    }
    function Sa() {
      return At.fromDom(document);
    }
    function ka(t2) {
      return t2.dom.focus();
    }
    function Ca(t2) {
      var n2 = ge(t2).dom;
      return t2.dom === n2.activeElement;
    }
    function Oa(t2) {
      return void 0 === t2 && (t2 = Sa()), vt.from(t2.dom.activeElement).map(At.fromDom);
    }
    function _a2(n2) {
      return Oa(ge(n2)).filter(function(t2) {
        return n2.dom.contains(t2.dom);
      });
    }
    function Ta(t2, e3) {
      var o2 = ge(e3), n2 = Oa(o2).bind(function(n3) {
        function t3(t4) {
          return Lt(n3, t4);
        }
        var r3, i2;
        return t3(e3) ? vt.some(e3) : (r3 = t3, (i2 = function(t4) {
          for (var n4 = 0; n4 < t4.childNodes.length; n4++) {
            var e4 = At.fromDom(t4.childNodes[n4]);
            if (r3(e4))
              return vt.some(e4);
            var o3 = i2(t4.childNodes[n4]);
            if (o3.isSome())
              return o3;
          }
          return vt.none();
        })(e3.dom));
      }), r2 = t2(e3);
      return n2.each(function(n3) {
        Oa(o2).filter(function(t3) {
          return Lt(t3, n3);
        }).fold(function() {
          ka(n3);
        }, st);
      }), r2;
    }
    function Ea(t2, n2, e3, o2, r2) {
      function i2(t3) {
        return t3 + "px";
      }
      return { position: t2, left: n2.map(i2), top: e3.map(i2), right: o2.map(i2), bottom: r2.map(i2) };
    }
    function Da(t2, n2) {
      var e3;
      gn(t2, lt2(lt2({}, e3 = n2), { position: vt.some(e3.position) }));
    }
    function Ba(t2, n2, e3, o2, r2, i2) {
      var u2 = n2.rect, a2 = u2.x - e3, c2 = u2.y - o2, s2 = r2 - (a2 + u2.width), l2 = i2 - (c2 + u2.height), f2 = vt.some(a2), d2 = vt.some(c2), m3 = vt.some(s2), g2 = vt.some(l2), p2 = vt.none();
      return n2.direction.fold(function() {
        return Ea(t2, f2, d2, p2, p2);
      }, function() {
        return Ea(t2, p2, d2, m3, p2);
      }, function() {
        return Ea(t2, f2, p2, p2, g2);
      }, function() {
        return Ea(t2, p2, p2, m3, g2);
      }, function() {
        return Ea(t2, f2, d2, p2, p2);
      }, function() {
        return Ea(t2, f2, p2, p2, g2);
      }, function() {
        return Ea(t2, f2, d2, p2, p2);
      }, function() {
        return Ea(t2, p2, d2, m3, p2);
      });
    }
    function Ma(t2, r2) {
      return t2.fold(function() {
        var t3 = r2.rect;
        return Ea("absolute", vt.some(t3.x), vt.some(t3.y), vt.none(), vt.none());
      }, function(t3, n2, e3, o2) {
        return Ba("absolute", r2, t3, n2, e3, o2);
      }, function(t3, n2, e3, o2) {
        return Ba("fixed", r2, t3, n2, e3, o2);
      });
    }
    function Aa(t2, n2) {
      var e3 = C(zn, n2), o2 = t2.fold(e3, e3, function() {
        var t3 = Rn();
        return zn(n2).translate(-t3.left, -t3.top);
      }), r2 = _n(n2), i2 = Sn(n2);
      return Me(o2.left, o2.top, r2, i2);
    }
    rt2($o(Xu().concat(Gu())));
    var Fa = rt2($o(Xu())), Ia = rt2(bo("initSize", [mo("numColumns"), mo("numRows")])), Ra = Ho([{ southeast: [] }, { southwest: [] }, { northeast: [] }, { northwest: [] }, { south: [] }, { north: [] }, { east: [] }, { west: [] }]), Va = Ra.southeast, Pa = Ra.southwest, Ha = Ra.northeast, za = Ra.northwest, Na = Ra.south, La = Ra.north, Wa = Ra.east, Ua = Ra.west, ja = function(t2, n2, e3) {
      return Math.min(Math.max(t2, n2), e3);
    }, Ga = "layout", Xa = function(t2, n2, e3) {
      return ea(t2.x, ca(t2), e3.southeast(), Va(), "southeast", ra(t2, { left: 1, top: 3 }), Ga);
    }, Ya = function(t2, n2, e3) {
      return ea(ua(t2, n2), ca(t2), e3.southwest(), Pa(), "southwest", ra(t2, { right: 0, top: 3 }), Ga);
    }, qa = function(t2, n2, e3) {
      return ea(t2.x, aa(t2, n2), e3.northeast(), Ha(), "northeast", ra(t2, { left: 1, bottom: 2 }), Ga);
    }, Ka = function(t2, n2, e3) {
      return ea(ua(t2, n2), aa(t2, n2), e3.northwest(), za(), "northwest", ra(t2, { right: 0, bottom: 2 }), Ga);
    }, Ja = function(t2, n2, e3) {
      return ea(ia(t2, n2), aa(t2, n2), e3.north(), La(), "north", ra(t2, { bottom: 2 }), Ga);
    }, $a = function(t2, n2, e3) {
      return ea(ia(t2, n2), ca(t2), e3.south(), Na(), "south", ra(t2, { top: 3 }), Ga);
    }, Qa = Object.freeze({ __proto__: null, events: function(a2) {
      return eu([Cr(Fi(), function(r2, t2) {
        var n2, i2 = a2.channels, e3 = Ct(i2), u2 = t2, o2 = (n2 = u2).universal ? e3 : F(e3, function(t3) {
          return wt(n2.channels, t3);
        });
        St(o2, function(t3) {
          var n3 = i2[t3], e4 = n3.schema, o3 = so("channel[" + t3 + "] data\nReceiver: " + Fr(r2.element), e4, u2.data);
          n3.onReceive(r2, o3);
        });
      })]);
    } }), Za = [go("channels", uo(Ve.value, to([Qu("onReceive"), Eo("schema", Zo())])))], tc = function(e3, t2, f2, n2, o2, r2, i2) {
      function u2(t3) {
        return nt(t3, f2) ? t3[f2]() : vt.none();
      }
      var a2 = dt(o2, function(t3, n3) {
        return r3 = f2, e4 = function(e5) {
          for (var t4 = [], n4 = 1; n4 < arguments.length; n4++)
            t4[n4 - 1] = arguments[n4];
          var o4 = [e5].concat(t4);
          return e5.config({ name: rt2(r3) }).fold(function() {
            throw new Error("We could not find any behaviour configuration for: " + r3 + ". Using API: " + u3);
          }, function(t5) {
            var n5 = Array.prototype.slice.call(o4, 1);
            return i3.apply(void 0, [e5, t5.config, t5.state].concat(n5));
          });
        }, o3 = u3 = n3, a3 = (i3 = t3).toString(), c3 = a3.indexOf(")") + 1, s3 = a3.indexOf("("), l2 = a3.substring(s3 + 1, c3 - 1).split(/,\s*/), e4.toFunctionAnnotation = function() {
          return { name: o3, parameters: bu(l2.slice(0, 1).concat(l2.slice(3))) };
        }, e4;
        var r3, i3, u3, e4, o3, a3, c3, s3, l2;
      }), c2 = dt(r2, Pr), s2 = lt2(lt2(lt2({}, c2), a2), { revoke: C(ya, f2), config: function(t3) {
        var n3 = so(f2 + "-config", e3, t3);
        return { key: f2, value: { config: n3, me: s2, configAsRaw: Rt(function() {
          return so(f2 + "-config", e3, t3);
        }), initialConfig: t3, state: i2 } };
      }, schema: rt2(t2), exhibit: function(t3, e4) {
        return Et(u2(t3), tt(n2, "exhibit"), function(t4, n3) {
          return n3(e4, t4.config, t4.state);
        }).getOrThunk(function() {
          return Lr({});
        });
      }, name: rt2(f2), handlers: function(t3) {
        return u2(t3).map(function(t4) {
          return tt(n2, "events").getOr(function() {
            return {};
          })(t4.config, t4.state);
        }).getOr({});
      } });
      return s2;
    }, nc = lr, ec = to([mo("fields"), mo("name"), Eo("active", {}), Eo("apis", {}), Eo("state", xu), Eo("extra", {})]), oc = to([mo("branchKey"), mo("branches"), mo("name"), Eo("active", {}), Eo("apis", {}), Eo("state", xu), Eo("extra", {})]), rc = rt2(void 0), ic = xa({ fields: Za, name: "receiving", active: Qa }), uc = Object.freeze({ __proto__: null, exhibit: function(t2, n2) {
      return Lr({ classes: [], styles: n2.useFixed() ? {} : { position: "relative" } });
    } }), ac = Ho([{ none: [] }, { relative: ["x", "y", "width", "height"] }, { fixed: ["x", "y", "width", "height"] }]), cc = function(t2, n2, e3) {
      var o2 = ke(n2, e3);
      return t2.fold(rt2(o2), rt2(o2), function() {
        var t3 = Rn();
        return o2.translate(-t3.left, -t3.top);
      });
    };
    function sc(t2) {
      return an(t2, Dc);
    }
    function lc(t2, n2, e3, o2) {
      var r2, i2, u2, a2, c2, s2, l2, f2, d2, m3, g2, p2, h2, v4, b2, y2, x2, w2, S2, k2, C2, O2, _2, T2, E2, D2, B2, M2, A2, F2, I2, R2, V2, P2, H2, z2, N2, L2, W2, U2 = t2.bubble, j2 = U2.offset, G2 = (V2 = o2, P2 = t2.restriction, H2 = j2, z2 = ot2("left", V2.x), N2 = ot2("top", V2.y), L2 = ot2("right", V2.right), W2 = ot2("bottom", V2.bottom), Me(z2, N2, L2 - z2, W2 - N2)), X2 = t2.x + j2.left, Y2 = t2.y + j2.top, q2 = Me(X2, Y2, n2, e3), K2 = (r2 = G2.x, i2 = G2.y, u2 = G2.right, a2 = G2.bottom, c2 = q2.x, s2 = q2.y, l2 = q2.right, f2 = q2.bottom, d2 = q2.width, m3 = q2.height, { originInBounds: r2 <= c2 && c2 <= u2 && i2 <= s2 && s2 <= a2, sizeInBounds: l2 <= u2 && r2 <= l2 && f2 <= a2 && i2 <= f2, visibleW: Math.min(d2, r2 <= c2 ? u2 - c2 : l2 - r2), visibleH: Math.min(m3, i2 <= s2 ? a2 - s2 : f2 - i2) }), J2 = K2.visibleW, $2 = K2.visibleH, Q2 = K2.originInBounds && K2.sizeInBounds, Z2 = Q2 ? q2 : (g2 = G2.x, p2 = G2.y, h2 = G2.right, v4 = G2.bottom, b2 = q2.x, y2 = q2.y, x2 = q2.width, w2 = q2.height, S2 = Math.max(g2, h2 - x2), k2 = Math.max(p2, v4 - w2), C2 = ja(b2, g2, S2), O2 = ja(y2, p2, k2), _2 = Math.min(C2 + x2, h2) - C2, T2 = Math.min(O2 + w2, v4) - O2, Me(C2, O2, _2, T2)), tt2 = 0 < Z2.width && 0 < Z2.height, nt2 = (E2 = t2.direction, M2 = rt2((D2 = Z2).bottom - (B2 = o2).y), A2 = rt2(B2.bottom - D2.y), F2 = E2.fold(A2, A2, M2, M2, A2, M2, A2, A2), I2 = rt2(D2.right - B2.x), R2 = rt2(B2.right - D2.x), { maxWidth: E2.fold(R2, I2, R2, I2, R2, R2, R2, I2), maxHeight: F2 }), et2 = { rect: Z2, maxHeight: nt2.maxHeight, maxWidth: nt2.maxWidth, direction: t2.direction, placement: t2.placement, classes: { on: U2.classesOn, off: U2.classesOff }, layout: t2.label, testY: Y2 };
      function ot2(r3, i3) {
        return P2[r3].map(function(t3) {
          var n3 = "top" === r3 || "bottom" === r3, e4 = n3 ? H2.top : H2.left, o3 = ("left" === r3 || "top" === r3 ? Math.max : Math.min)(t3, i3) + e4;
          return n3 ? ja(o3, V2.y, V2.bottom) : ja(o3, V2.x, V2.right);
        }).getOr(i3);
      }
      return Q2 || t2.alwaysFit ? Bc.fit(et2) : Bc.nofit(et2, J2, $2, tt2);
    }
    function fc(t2) {
      function n2() {
        return e3.get().each(t2);
      }
      var e3 = Po(vt.none());
      return { clear: function() {
        n2(), e3.set(vt.none());
      }, isSet: function() {
        return e3.get().isSome();
      }, get: function() {
        return e3.get();
      }, set: function(t3) {
        n2(), e3.set(vt.some(t3));
      } };
    }
    function dc() {
      return fc(function(t2) {
        return t2.destroy();
      });
    }
    function mc() {
      return fc(function(t2) {
        return t2.unbind();
      });
    }
    function gc() {
      var n2 = fc(st);
      return lt2(lt2({}, n2), { on: function(t2) {
        return n2.get().each(t2);
      } });
    }
    function pc(t2, n2, e3) {
      return En(t2, n2, Mc, e3, false);
    }
    function hc(t2, n2, e3) {
      return En(t2, n2, Mc, e3, true);
    }
    function vc(o2, e3) {
      function r2(t3) {
        var n3, e4 = null !== (n3 = t3.raw.pseudoElement) && void 0 !== n3 ? n3 : "";
        return Lt(t3.target, o2) && !at(e4) && wt(Fc, t3.raw.propertyName);
      }
      function t2(t3) {
        var n3;
        (g(t3) || r2(t3)) && (a2.clear(), c2.clear(), !g(n3 = null == t3 ? void 0 : t3.raw.type) && n3 !== _i() || (clearTimeout(i2), sn(o2, Ic), $r(o2, e3.classes)));
      }
      function n2() {
        a2.set(pc(o2, _i(), t2)), c2.set(pc(o2, Oi(), t2));
      }
      var i2, u2, a2 = mc(), c2 = mc();
      "ontransitionstart" in o2.dom ? u2 = pc(o2, Ti(), function(t3) {
        r2(t3) && (u2.unbind(), n2());
      }) : n2();
      var s2, l2, f2 = (s2 = o2, l2 = d2("transition-delay"), R(d2("transition-duration"), function(t3, n3, e4) {
        var o3 = m3(l2[e4]) + m3(n3);
        return Math.max(t3, o3);
      }, 0));
      function d2(t3) {
        var n3 = pn(s2, t3);
        return F(y(n3) ? n3.split(/\s*,\s*/) : [], at);
      }
      function m3(t3) {
        if (y(t3) && /^[\d.]+/.test(t3)) {
          var n3 = parseFloat(t3);
          return Bt(t3, "ms") ? n3 : 1e3 * n3;
        }
        return 0;
      }
      requestAnimationFrame(function() {
        i2 = setTimeout(t2, f2 + 17), on(o2, Ic, i2);
      });
    }
    function bc(t2, n2, e3, o2, r2, i2) {
      var u2, a2, c2, s2, l2, f2, d2, m3, g2, p2 = (u2 = o2, a2 = r2, i2.exists(function(t3) {
        var n3 = u2.mode;
        return "all" === n3 || t3[n3] !== a2[n3];
      }));
      function h2(t3) {
        return parseFloat(t3).toFixed(3);
      }
      p2 || (g2 = t2, N(o2.classes, function(t3) {
        return Kr(g2, t3);
      })) ? (dn(t2, "position", e3.position), c2 = Aa(n2, t2), s2 = Ma(n2, lt2(lt2({}, r2), { rect: c2 })), l2 = U(Fc, function(t3) {
        return s2[t3];
      }), m3 = e3, Q(l2, function(t3, n3) {
        var e4, o3, r3, i3 = m3[n3].map(h2), u3 = t3.map(h2);
        return !Et(e4 = i3, o3 = u3, r3 = void 0 === r3 ? v : r3).getOr(e4.isNone() && o3.isNone());
      }).isSome() && (gn(t2, l2), p2 && (Jr(f2 = t2, (d2 = o2).classes), an(f2, Ic).each(function(t3) {
        clearTimeout(parseInt(t3, 10)), sn(f2, Ic);
      }), vc(f2, d2)), yn(t2))) : $r(t2, o2.classes);
    }
    function yc(t2, n2, e3, o2) {
      bn(n2, "max-height"), bn(n2, "max-width");
      var r2, s2, i2, l2, f2, d2, m3, g2, p2, u2 = { width: _n(r2 = n2), height: Sn(r2) };
      return s2 = n2, i2 = o2.preference, l2 = t2, f2 = u2, d2 = e3, m3 = o2.bounds, g2 = f2.width, p2 = f2.height, R(i2, function(t3, n3) {
        var e4 = C(a2, n3);
        return t3.fold(rt2(t3), e4);
      }, Bc.nofit({ rect: l2, maxHeight: f2.height, maxWidth: f2.width, direction: Va(), placement: "southeast", classes: { on: [], off: [] }, layout: "none", testY: l2.y }, -1, -1, false)).fold(h, h);
      function a2(t3, r3, i3, u3, a3) {
        var c2 = lc(t3(l2, f2, d2, s2, m3), g2, p2, m3);
        return c2.fold(rt2(c2), function(t4, n3, e4, o3) {
          return (a3 === o3 ? u3 < e4 || i3 < n3 : !a3 && o3) ? c2 : Bc.nofit(r3, i3, u3, a3);
        });
      }
    }
    function xc(t2, n2) {
      var e3 = t2, o2 = Math.floor(n2);
      dn(e3, "max-height", we.max(e3, o2, ["margin-top", "border-top-width", "padding-top", "padding-bottom", "border-bottom-width", "margin-bottom"]) + "px");
    }
    function wc(t2, n2, e3) {
      return void 0 === t2[n2] ? e3 : t2[n2];
    }
    function Sc(t2, n2, e3, o2) {
      function r2(t3) {
        return tt(e3, t3).getOr([]);
      }
      function i2(t3, n3, e4) {
        var o3 = W(Hc, e4);
        return { offset: ke(t3, n3), classesOn: z(e4, r2), classesOff: z(o3, r2) };
      }
      var u2 = t2 * (o2 = void 0 === o2 ? 1 : o2), a2 = n2 * o2;
      return { southeast: function() {
        return i2(-t2, n2, ["top", "alignLeft"]);
      }, southwest: function() {
        return i2(t2, n2, ["top", "alignRight"]);
      }, south: function() {
        return i2(-t2 / 2, n2, ["top", "alignCentre"]);
      }, northeast: function() {
        return i2(-t2, -n2, ["bottom", "alignLeft"]);
      }, northwest: function() {
        return i2(t2, -n2, ["bottom", "alignRight"]);
      }, north: function() {
        return i2(-t2 / 2, -n2, ["bottom", "alignCentre"]);
      }, east: function() {
        return i2(t2, -n2 / 2, ["valignCentre", "left"]);
      }, west: function() {
        return i2(-t2, -n2 / 2, ["valignCentre", "right"]);
      }, insetNortheast: function() {
        return i2(u2, a2, ["top", "alignLeft", "inset"]);
      }, insetNorthwest: function() {
        return i2(-u2, a2, ["top", "alignRight", "inset"]);
      }, insetNorth: function() {
        return i2(-u2 / 2, a2, ["top", "alignCentre", "inset"]);
      }, insetSoutheast: function() {
        return i2(u2, -a2, ["bottom", "alignLeft", "inset"]);
      }, insetSouthwest: function() {
        return i2(-u2, -a2, ["bottom", "alignRight", "inset"]);
      }, insetSouth: function() {
        return i2(-u2 / 2, -a2, ["bottom", "alignCentre", "inset"]);
      }, insetEast: function() {
        return i2(-u2, -a2 / 2, ["valignCentre", "right", "inset"]);
      }, insetWest: function() {
        return i2(u2, -a2 / 2, ["valignCentre", "left", "inset"]);
      } };
    }
    function kc() {
      return Sc(0, 0, {});
    }
    function Cc(n2, e3) {
      return function(t2) {
        return "rtl" === Nc(t2) ? e3 : n2;
      };
    }
    ac.none;
    var Oc, _c2, Tc = ac.relative, Ec = ac.fixed, Dc = "data-alloy-placement", Bc = Ho([{ fit: ["reposition"] }, { nofit: ["reposition", "visibleW", "visibleH", "isVisible"] }]), Mc = D, Ac = Tn, Fc = ["top", "bottom", "right", "left"], Ic = "data-alloy-transition-timer", Rc = rt2(function(t2, n2) {
      xc(t2, n2), mn(t2, { "overflow-x": "hidden", "overflow-y": "auto" });
    }), Vc = rt2(function(t2, n2) {
      xc(t2, n2);
    }), Pc = function(t2, n2, e3, o2) {
      var r2, i2, u2, a2, c2 = yc(t2, n2, e3, o2), s2 = n2, l2 = c2, f2 = Ma((r2 = o2).origin, l2);
      return r2.transition.each(function(t3) {
        bc(s2, r2.origin, f2, t3, l2, r2.lastPlacement);
      }), Da(s2, f2), a2 = c2.placement, on(n2, Dc, a2), $r(i2 = n2, (u2 = c2.classes).off), Jr(i2, u2.on), (0, o2.maxHeightFunction)(n2, c2.maxHeight), (0, o2.maxWidthFunction)(n2, c2.maxWidth), { layout: c2.layout, placement: c2.placement };
    }, Hc = ["valignCentre", "alignLeft", "alignRight", "alignCentre", "top", "bottom", "left", "right", "inset"], zc = h, Nc = function(t2) {
      return "rtl" === pn(t2, "direction") ? "rtl" : "ltr";
    };
    function Lc(t2) {
      return Au(t2, function(t3) {
        return Xn(t3) && un(t3, "data-alloy-vertical-dir") === Oc.BottomToTop;
      });
    }
    function Wc() {
      return To("layouts", [mo("onLtr"), mo("onRtl"), wo("onBottomLtr"), wo("onBottomRtl")]);
    }
    function Uc(n2, t2, e3, o2, r2, i2, u2) {
      var a2 = u2.map(Lc).getOr(false), c2 = t2.layouts.map(function(t3) {
        return t3.onLtr(n2);
      }), s2 = t2.layouts.map(function(t3) {
        return t3.onRtl(n2);
      });
      return Cc(a2 ? t2.layouts.bind(function(t3) {
        return t3.onBottomLtr.map(function(t4) {
          return t4(n2);
        });
      }).or(c2).getOr(r2) : c2.getOr(e3), a2 ? t2.layouts.bind(function(t3) {
        return t3.onBottomRtl.map(function(t4) {
          return t4(n2);
        });
      }).or(s2).getOr(i2) : s2.getOr(o2))(n2);
    }
    function jc(t2) {
      return t2.fold(h, function(t3, n2, e3) {
        return t3.translate(-n2, -e3);
      });
    }
    function Gc(t2) {
      return t2.fold(h, h);
    }
    function Xc(t2) {
      return R(t2, function(t3, n2) {
        return t3.translate(n2.left, n2.top);
      }, ke(0, 0));
    }
    function Yc(t2) {
      return Xc(M(t2, Gc));
    }
    function qc(t2, n2, e3) {
      var o2, r2, i2 = Rn(Ut(t2.element)), u2 = (o2 = t2, r2 = Xt(e3.root).dom, vt.from(r2.frameElement).map(At.fromDom).filter(function(t3) {
        return Lt(Ut(t3), Ut(o2.element));
      }).map(Cn).getOr(i2));
      return as(u2, i2.left, i2.top);
    }
    function Kc(t2, n2, e3, o2) {
      var r2 = us(ke(t2, n2));
      return vt.some({ point: r2, width: e3, height: o2 });
    }
    function Jc(t2, a2, c2, s2, l2) {
      return t2.map(function(t3) {
        var n2 = [a2, t3.point], e3 = s2.fold(function() {
          return Yc(n2);
        }, function() {
          return Yc(n2);
        }, function() {
          return Xc(M(n2, jc));
        }), o2 = { x: e3.left, y: e3.top, width: t3.width, height: t3.height }, r2 = (c2.showAbove ? ga : ha)(), i2 = (c2.showAbove ? pa : va)(), u2 = Uc(l2, c2, r2, i2, r2, i2, vt.none());
        return zc({ anchorBox: o2, bubble: c2.bubble.getOr(kc()), overrides: c2.overrides, layouts: u2, placer: vt.none() });
      });
    }
    function $c(t2, n2, e3) {
      var o2, r2 = t2.document.createRange(), i2 = r2;
      return n2.fold(function(t3) {
        i2.setStartBefore(t3.dom);
      }, function(t3, n3) {
        i2.setStart(t3.dom, n3);
      }, function(t3) {
        i2.setStartAfter(t3.dom);
      }), o2 = r2, e3.fold(function(t3) {
        o2.setEndBefore(t3.dom);
      }, function(t3, n3) {
        o2.setEnd(t3.dom, n3);
      }, function(t3) {
        o2.setEndAfter(t3.dom);
      }), r2;
    }
    function Qc(t2, n2, e3, o2, r2) {
      var i2 = t2.document.createRange();
      return i2.setStart(n2.dom, e3), i2.setEnd(o2.dom, r2), i2;
    }
    function Zc(t2) {
      return { left: t2.left, top: t2.top, right: t2.right, bottom: t2.bottom, width: t2.width, height: t2.height };
    }
    function ts(t2, n2, e3) {
      return n2(At.fromDom(e3.startContainer), e3.startOffset, At.fromDom(e3.endContainer), e3.endOffset);
    }
    function ns(i2, t2) {
      return r2 = i2, o2 = t2.match({ domRange: function(t3) {
        return { ltr: rt2(t3), rtl: vt.none };
      }, relative: function(t3, n3) {
        return { ltr: Rt(function() {
          return $c(r2, t3, n3);
        }), rtl: Rt(function() {
          return vt.some($c(r2, n3, t3));
        }) };
      }, exact: function(t3, n3, e4, o3) {
        return { ltr: Rt(function() {
          return Qc(r2, t3, n3, e4, o3);
        }), rtl: Rt(function() {
          return vt.some(Qc(r2, e4, o3, t3, n3));
        }) };
      } }), ((e3 = (n2 = o2).ltr()).collapsed ? n2.rtl().filter(function(t3) {
        return false === t3.collapsed;
      }).map(function(t3) {
        return gs.rtl(At.fromDom(t3.endContainer), t3.endOffset, At.fromDom(t3.startContainer), t3.startOffset);
      }).getOrThunk(function() {
        return ts(0, gs.ltr, e3);
      }) : ts(0, gs.ltr, e3)).match({ ltr: function(t3, n3, e4, o3) {
        var r3 = i2.document.createRange();
        return r3.setStart(t3.dom, n3), r3.setEnd(e4.dom, o3), r3;
      }, rtl: function(t3, n3, e4, o3) {
        var r3 = i2.document.createRange();
        return r3.setStart(e4.dom, o3), r3.setEnd(t3.dom, n3), r3;
      } });
      var r2, n2, e3, o2;
    }
    (Oc = Oc || {}).TopToBottom = "toptobottom", Oc.BottomToTop = "bottomtotop";
    var es = "data-alloy-vertical-dir", os = [mo("hotspot"), wo("bubble"), Eo("overrides", {}), Wc(), ta("placement", function(t2, n2, e3) {
      var o2 = Aa(e3, n2.hotspot.element), r2 = Uc(t2.element, n2, ha(), va(), ga(), pa(), vt.some(n2.hotspot.element));
      return vt.some(zc({ anchorBox: o2, bubble: n2.bubble.getOr(kc()), overrides: n2.overrides, layouts: r2, placer: vt.none() }));
    })], rs = [mo("x"), mo("y"), Eo("height", 0), Eo("width", 0), Eo("bubble", kc()), Eo("overrides", {}), Wc(), ta("placement", function(t2, n2, e3) {
      var o2 = cc(e3, n2.x, n2.y), r2 = Me(o2.left, o2.top, n2.width, n2.height), i2 = Uc(t2.element, n2, da(), ma(), da(), ma(), vt.none());
      return vt.some(zc({ anchorBox: r2, bubble: n2.bubble, overrides: n2.overrides, layouts: i2, placer: vt.none() }));
    })], is = Ho([{ screen: ["point"] }, { absolute: ["point", "scrollLeft", "scrollTop"] }]), us = is.screen, as = is.absolute, cs = [mo("node"), mo("root"), wo("bubble"), Wc(), Eo("overrides", {}), Eo("showAbove", false), ta("placement", function(r2, i2, u2) {
      var a2 = qc(r2, 0, i2);
      return i2.node.filter(ve).bind(function(t2) {
        var n2 = t2.dom.getBoundingClientRect(), e3 = Kc(n2.left, n2.top, n2.width, n2.height), o2 = i2.node.getOr(r2.element);
        return Jc(e3, a2, i2, u2, o2);
      });
    })], ss = function(t2, n2, e3, o2) {
      return { start: t2, soffset: n2, finish: e3, foffset: o2 };
    }, ls = Ho([{ before: ["element"] }, { on: ["element", "offset"] }, { after: ["element"] }]), fs = (ls.before, ls.on, ls.after, function(t2) {
      return t2.fold(h, h, h);
    }), ds = Ho([{ domRange: ["rng"] }, { relative: ["startSitu", "finishSitu"] }, { exact: ["start", "soffset", "finish", "foffset"] }]), ms = { domRange: ds.domRange, relative: ds.relative, exact: ds.exact, exactFromRange: function(t2) {
      return ds.exact(t2.start, t2.soffset, t2.finish, t2.foffset);
    }, getWin: function(t2) {
      return Xt(t2.match({ domRange: function(t3) {
        return At.fromDom(t3.startContainer);
      }, relative: function(t3, n2) {
        return fs(t3);
      }, exact: function(t3, n2, e3, o2) {
        return t3;
      } }));
    }, range: ss }, gs = Ho([{ ltr: ["start", "soffset", "finish", "foffset"] }, { rtl: ["start", "soffset", "finish", "foffset"] }]);
    function ps(t2) {
      return nf.getOption(t2);
    }
    function hs(t2) {
      return ps(t2).filter(function(t3) {
        return 0 !== t3.trim().length || -1 < t3.indexOf(" ");
      }).isSome() || wt(ef, Ft(t2));
    }
    function vs(t2, n2) {
      return Nt(e3 = void 0 === t2 ? document : t2.dom) ? [] : M(e3.querySelectorAll(n2), At.fromDom);
      var e3;
    }
    function bs(t2) {
      if (0 < t2.rangeCount) {
        var n2 = t2.getRangeAt(0), e3 = t2.getRangeAt(t2.rangeCount - 1);
        return vt.some(ss(At.fromDom(n2.startContainer), n2.startOffset, At.fromDom(e3.endContainer), e3.endOffset));
      }
      return vt.none();
    }
    function ys(t2) {
      if (null === t2.anchorNode || null === t2.focusNode)
        return bs(t2);
      var n2, e3, o2, r2, i2, u2, a2, c2, s2, l2, f2, d2 = At.fromDom(t2.anchorNode), m3 = At.fromDom(t2.focusNode);
      return n2 = d2, e3 = t2.anchorOffset, o2 = m3, r2 = t2.focusOffset, u2 = e3, a2 = o2, c2 = r2, (s2 = Ut(i2 = n2).dom.createRange()).setStart(i2.dom, u2), s2.setEnd(a2.dom, c2), l2 = s2, f2 = Lt(n2, o2) && e3 === r2, l2.collapsed && !f2 ? vt.some(ss(d2, t2.anchorOffset, m3, t2.focusOffset)) : bs(t2);
    }
    function xs(t2, n2) {
      var e3, o2, r2 = (e3 = ns(t2, n2)).getClientRects();
      return 0 < (o2 = 0 < r2.length ? r2[0] : e3.getBoundingClientRect()).width || 0 < o2.height ? vt.some(o2).map(Zc) : vt.none();
    }
    function ws(t2, n2) {
      return { element: t2, offset: n2 };
    }
    function Ss(t2, n2) {
      return (Yn(t2) ? ws : function(t3, n3) {
        var e3 = Kt(t3);
        if (0 === e3.length)
          return ws(t3, n3);
        if (n3 < e3.length)
          return ws(e3[n3], 0);
        var o2 = e3[e3.length - 1];
        return ws(o2, (Yn(o2) ? nf.get(o2) : Kt(o2)).length);
      })(t2, n2);
    }
    function ks(t2, n2) {
      return n2.getSelection.getOrThunk(function() {
        return function() {
          return vt.from(t2.getSelection()).filter(function(t3) {
            return 0 < t3.rangeCount;
          }).bind(ys);
        };
      })().map(function(t3) {
        var n3 = Ss(t3.start, t3.soffset), e3 = Ss(t3.finish, t3.foffset);
        return ms.range(n3.element, n3.offset, e3.element, e3.offset);
      });
    }
    function Cs(t2) {
      return t2.x + t2.width;
    }
    function Os(t2, n2) {
      return t2.x - n2.width;
    }
    function _s(t2, n2) {
      return t2.y - n2.height + t2.height;
    }
    function Ts(t2, n2, e3) {
      return ea(Cs(t2), t2.y, e3.southeast(), Va(), "southeast", ra(t2, { left: 0, top: 2 }), rf);
    }
    function Es(t2, n2, e3) {
      return ea(Os(t2, n2), t2.y, e3.southwest(), Pa(), "southwest", ra(t2, { right: 1, top: 2 }), rf);
    }
    function Ds(t2, n2, e3) {
      return ea(Cs(t2), _s(t2, n2), e3.northeast(), Ha(), "northeast", ra(t2, { left: 0, bottom: 3 }), rf);
    }
    function Bs(t2, n2, e3) {
      return ea(Os(t2, n2), _s(t2, n2), e3.northwest(), za(), "northwest", ra(t2, { right: 1, bottom: 3 }), rf);
    }
    function Ms() {
      return [Ts, Es, Ds, Bs];
    }
    function As() {
      return [Es, Ts, Bs, Ds];
    }
    function Fs(t2, n2, e3, o2, r2, i2, u2) {
      var a2, c2, s2, l2, f2, d2, m3, g2, p2, h2, v4, b2, y2, x2, w2 = { anchorBox: e3.anchorBox, origin: n2 };
      return a2 = w2, c2 = r2.element, s2 = e3.bubble, l2 = e3.layouts, f2 = i2, d2 = o2, m3 = e3.overrides, g2 = u2, h2 = wc(m3, "maxHeightFunction", Rc()), v4 = wc(m3, "maxWidthFunction", st), b2 = a2.anchorBox, y2 = a2.origin, x2 = { bounds: (p2 = y2, d2.fold(function() {
        return p2.fold(Fe, Fe, Me);
      }, function(e4) {
        return p2.fold(e4, e4, function() {
          var t3 = e4(), n3 = cc(p2, t3.x, t3.y);
          return Me(n3.left, n3.top, t3.width, t3.height);
        });
      })), origin: y2, preference: l2, maxHeightFunction: h2, maxWidthFunction: v4, lastPlacement: f2, transition: g2 }, Pc(b2, c2, s2, x2);
    }
    function Is(t2, n2) {
      Te(t2.element, n2.element);
    }
    function Rs(n2, t2) {
      var e3, o2 = n2.components();
      St((e3 = n2).components(), function(t3) {
        return Ee(t3.element);
      }), Fn(e3.element), e3.syncComponents();
      var r2 = W(o2, t2);
      St(r2, function(t3) {
        df(t3), n2.getSystem().removeFromWorld(t3);
      }), St(t2, function(t3) {
        t3.getSystem().isConnected() ? Is(n2, t3) : (n2.getSystem().addToWorld(t3), Is(n2, t3), ve(n2.element) && mf(t3)), n2.syncComponents();
      });
    }
    function Vs(t2, n2) {
      gf(t2, n2, Te);
    }
    function Ps(t2) {
      df(t2), Ee(t2.element), t2.getSystem().removeFromWorld(t2);
    }
    function Hs(n2) {
      var t2 = Yt(n2.element).bind(function(t3) {
        return n2.getSystem().getByDom(t3).toOptional();
      });
      Ps(n2), t2.each(function(t3) {
        t3.syncComponents();
      });
    }
    function zs(t2) {
      var n2 = t2.components();
      St(n2, Ps), Fn(t2.element), t2.syncComponents();
    }
    function Ns(t2, n2) {
      pf(t2, n2, Te);
    }
    function Ls(n2) {
      var t2 = Kt(n2.element);
      St(t2, function(t3) {
        n2.getByDom(t3).each(df);
      }), Ee(n2.element);
    }
    function Ws(n2, t2, e3, o2) {
      e3.get().each(function(t3) {
        zs(n2);
      }), Vs(t2.getAttachPoint(n2), n2);
      var r2 = n2.getSystem().build(o2);
      return Vs(n2, r2), e3.set(r2), r2;
    }
    function Us(t2, n2, e3, o2) {
      var r2 = Ws(t2, n2, e3, o2);
      return n2.onOpen(t2, r2), r2;
    }
    function js(n2, e3, o2) {
      o2.get().each(function(t2) {
        zs(n2), Hs(n2), e3.onClose(n2, t2), o2.clear();
      });
    }
    function Gs(t2, n2, e3) {
      return e3.isOpen();
    }
    function Xs(t2) {
      var e3 = so("Dismissal", Sf, t2), n2 = {};
      return n2[yf()] = { schema: to([mo("target")]), onReceive: function(n3, t3) {
        bf.isOpen(n3) && (bf.isPartOf(n3, t3.target) || e3.isExtraPart(n3, t3.target) || e3.fireEventInstead.fold(function() {
          return bf.close(n3);
        }, function(t4) {
          return vr(n3, t4.event);
        }));
      } }, n2;
    }
    function Ys(t2) {
      var e3 = so("Reposition", kf, t2), n2 = {};
      return n2[xf()] = { onReceive: function(n3) {
        bf.isOpen(n3) && e3.fireEventInstead.fold(function() {
          return e3.doReposition(n3);
        }, function(t3) {
          return vr(n3, t3.event);
        });
      } }, n2;
    }
    function qs(t2, n2, e3) {
      n2.store.manager.onLoad(t2, n2, e3);
    }
    function Ks(t2, n2, e3) {
      n2.store.manager.onUnload(t2, n2, e3);
    }
    function Js() {
      var t2 = Po(null);
      return wu({ set: t2.set, get: t2.get, isNotSet: function() {
        return null === t2.get();
      }, clear: function() {
        t2.set(null);
      }, readState: function() {
        return { mode: "memory", value: t2.get() };
      } });
    }
    function $s() {
      var i2 = Po({}), u2 = Po({});
      return wu({ readState: function() {
        return { mode: "dataset", dataByValue: i2.get(), dataByText: u2.get() };
      }, lookup: function(t2) {
        return tt(i2.get(), t2).orThunk(function() {
          return tt(u2.get(), t2);
        });
      }, update: function(t2) {
        var n2 = i2.get(), e3 = u2.get(), o2 = {}, r2 = {};
        St(t2, function(n3) {
          tt(o2[n3.value] = n3, "meta").each(function(t3) {
            tt(t3, "text").each(function(t4) {
              r2[t4] = n3;
            });
          });
        }), i2.set(lt2(lt2({}, n2), o2)), u2.set(lt2(lt2({}, e3), r2));
      }, clear: function() {
        i2.set({}), u2.set({});
      } });
    }
    function Qs(t2, n2, e3, o2) {
      var r2 = n2.store;
      e3.update([o2]), r2.setValue(t2, o2), n2.onSetValue(t2, o2);
    }
    function Zs(o2, t2) {
      return Vo(o2, {}, M(t2, function(t3) {
        return n2 = t3.name(), e3 = "Cannot configure " + t3.name() + " for " + o2, ar(n2, n2, Xe(), Je(function(t4) {
          return Lo("The field: " + n2 + " is forbidden. " + e3);
        }));
        var n2, e3;
      }).concat([cr("dump", h)]));
    }
    function tl(t2) {
      return t2.dump;
    }
    function nl(t2, n2) {
      return lt2(lt2({}, nc(n2)), t2.dump);
    }
    function el(t2) {
      return Tt(t2, "uiType");
    }
    function ol(t2) {
      return t2.fold(vt.some, vt.none, vt.some, vt.some);
    }
    function rl(t2) {
      function n2(t3) {
        return t3.name;
      }
      return t2.fold(n2, n2, n2, n2);
    }
    function il(e3, o2) {
      return function(t2) {
        var n2 = so("Converting part type", o2, t2);
        return e3(n2);
      };
    }
    function ul(t2, n2, e3, o2) {
      return Yo(n2.defaults(t2, e3, o2), e3, { uid: t2.partUids[n2.name] }, n2.overrides(t2, e3, o2));
    }
    function al(r2, t2) {
      var n2 = {};
      return St(t2, function(t3) {
        ol(t3).each(function(e3) {
          var o2 = ed(r2, e3.pname);
          n2[e3.name] = function(t4) {
            var n3 = so("Part: " + e3.name + " in " + r2, $o(e3.schema), t4);
            return lt2(lt2({}, o2), { config: t4, validated: n3 });
          };
        });
      }), n2;
    }
    function cl(t2, n2, e3) {
      return { uiType: Pf(), owner: t2, name: n2, config: e3, validated: {} };
    }
    function sl(t2) {
      return z(t2, function(t3) {
        return t3.fold(vt.none, vt.some, vt.none, vt.none).map(function(t4) {
          return bo(t4.name, t4.schema.concat([na(td())]));
        }).toArray();
      });
    }
    function ll(t2) {
      return M(t2, rl);
    }
    function fl(t2, n2, e3) {
      return o2 = n2, r2 = {}, i2 = {}, St(e3, function(t3) {
        t3.fold(function(o3) {
          r2[o3.pname] = Rf(true, function(t4, n3, e4) {
            return o3.factory.sketch(ul(t4, o3, n3, e4));
          });
        }, function(t4) {
          var n3 = o2.parts[t4.name];
          i2[t4.name] = rt2(t4.factory.sketch(ul(o2, t4, n3[td()]), n3));
        }, function(o3) {
          r2[o3.pname] = Rf(false, function(t4, n3, e4) {
            return o3.factory.sketch(ul(t4, o3, n3, e4));
          });
        }, function(o3) {
          r2[o3.pname] = Vf(true, function(n3, t4, e4) {
            return M(n3[o3.name], function(t5) {
              return o3.factory.sketch(Yo(o3.defaults(n3, t5, e4), t5, o3.overrides(n3, t5)));
            });
          });
        });
      }), { internals: rt2(r2), externals: rt2(i2) };
      var o2, r2, i2;
    }
    function dl(t2, n2, e3) {
      return o2 = vt.some(t2), i2 = (r2 = n2).components, s2 = dt(e3, function(t3, n3) {
        return o3 = t3, r3 = false, { name: rt2(e4 = n3), required: function() {
          return o3.fold(function(t4, n4) {
            return t4;
          }, function(t4, n4) {
            return t4;
          });
        }, used: function() {
          return r3;
        }, replace: function() {
          if (r3)
            throw new Error("Trying to use the same placeholder more than once: " + e4);
          return r3 = true, o3;
        } };
        var e4, o3, r3;
      }), u2 = o2, a2 = r2, c2 = s2, l2 = z(i2, function(t3) {
        return If(u2, a2, t3, c2);
      }), J(s2, function(t3) {
        if (false === t3.used() && t3.required())
          throw new Error("Placeholder: " + t3.name() + " was not found in components list\nNamespace: " + o2.getOr("none") + "\nComponents: " + JSON.stringify(r2.components, null, 2));
      }), l2;
      var o2, r2, i2, u2, a2, c2, s2, l2;
    }
    function ml(t2, n2, e3) {
      var o2 = n2.partUids[e3];
      return t2.getSystem().getByUid(o2).toOptional();
    }
    function gl(t2, n2, e3) {
      return ml(t2, n2, e3).getOrDie("Could not find part: " + e3);
    }
    function pl(t2, n2, e3) {
      var o2 = {}, r2 = n2.partUids, i2 = t2.getSystem();
      return St(e3, function(t3) {
        o2[t3] = rt2(i2.getByUid(r2[t3]));
      }), o2;
    }
    function hl(t2, n2) {
      var e3 = t2.getSystem();
      return dt(n2.partUids, function(t3, n3) {
        return rt2(e3.getByUid(t3));
      });
    }
    function vl(t2) {
      return Ct(t2.partUids);
    }
    function bl(t2, n2, e3) {
      var o2 = {}, r2 = n2.partUids, i2 = t2.getSystem();
      return St(e3, function(t3) {
        o2[t3] = rt2(i2.getByUid(r2[t3]).getOrDie());
      }), o2;
    }
    function yl(n2, t2) {
      return lr(M(ll(t2), function(t3) {
        return { key: t3, value: n2 + "-" + t3 };
      }));
    }
    function xl(n2) {
      return ar("partUids", "partUids", Ye(function(t2) {
        return yl(t2.uid, n2);
      }), Zo());
    }
    function wl(t2, n2, e3, o2, r2) {
      var i2;
      return so(t2 + " [SpecSchema]", to((i2 = r2, (0 < o2.length ? [bo("parts", o2)] : []).concat([mo("uid"), Eo("dom", {}), Eo("components", []), na("originalSpec"), Eo("debug.sketcher", {})]).concat(i2)).concat(n2)), e3);
    }
    function Sl(t2, n2, e3, o2, r2) {
      var i2 = rd(r2), u2 = wl(t2, n2, i2, sl(e3), [xl(e3)]), a2 = fl(0, u2, e3);
      return o2(u2, dl(t2, u2, a2.internals()), i2, a2.externals());
    }
    function kl(t2) {
      var r2 = so("Sketcher for " + t2.name, id, t2), n2 = dt(r2.apis, zr), e3 = dt(r2.extraApis, Pr);
      return lt2(lt2({ name: r2.name, configFields: r2.configFields, sketch: function(t3) {
        return n3 = r2.name, e4 = r2.configFields, (0, r2.factory)(wl(n3, e4, o2 = rd(t3), [], []), o2);
        var n3, e4, o2;
      } }, n2), e3);
    }
    function Cl(t2) {
      var n2 = so("Sketcher for " + t2.name, ud, t2), e3 = al(n2.name, n2.partFields), o2 = dt(n2.apis, zr), r2 = dt(n2.extraApis, Pr);
      return lt2(lt2({ name: n2.name, partFields: n2.partFields, configFields: n2.configFields, sketch: function(t3) {
        return Sl(n2.name, n2.configFields, n2.partFields, n2.factory, t3);
      }, parts: e3 }, o2), r2);
    }
    function Ol(t2) {
      return "input" === Ft(t2) && "radio" !== un(t2, "type") || "textarea" === Ft(t2);
    }
    function _l(t2, n2, e3) {
      (n2.disabled() ? ld : fd)(t2, n2);
    }
    function Tl(t2, n2) {
      return true === n2.useNative && wt(sd, Ft(t2.element));
    }
    function El(t2, n2) {
      return Tl(t2, n2) ? cn(t2.element, "disabled") : "true" === un(t2.element, "aria-disabled");
    }
    function Dl(e3, o2, t2, r2) {
      var n2 = vs(e3.element, "." + o2.highlightClass);
      St(n2, function(n3) {
        d(r2, function(t3) {
          return t3.element === n3;
        }) || (qr(n3, o2.highlightClass), e3.getSystem().getByDom(n3).each(function(t3) {
          o2.onDehighlight(e3, t3), vr(t3, tu());
        }));
      });
    }
    function Bl(t2, n2, e3, o2) {
      Dl(t2, n2, 0, [o2]), Yl(0, n2, 0, o2) || (Yr(o2.element, n2.highlightClass), n2.onHighlight(t2, o2), vr(o2, Zi()));
    }
    function Ml(e3, n2, t2, o2) {
      var r2 = vs(e3.element, "." + n2.itemClass);
      return P(r2, function(t3) {
        return Kr(t3, n2.highlightClass);
      }).bind(function(t3) {
        var n3 = oa(t3, o2, 0, r2.length - 1);
        return e3.getSystem().getByDom(r2[n3]).toOptional();
      });
    }
    function Al(t2, n2, e3) {
      var o2 = L(t2.slice(0, n2)), r2 = L(t2.slice(n2 + 1));
      return V(o2.concat(r2), e3);
    }
    function Fl(t2, n2, e3) {
      return V(L(t2.slice(0, n2)), e3);
    }
    function Il(t2, n2, e3) {
      var o2 = t2.slice(0, n2);
      return V(t2.slice(n2 + 1).concat(o2), e3);
    }
    function Rl(t2, n2, e3) {
      return V(t2.slice(n2 + 1), e3);
    }
    function Vl(e3) {
      return function(t2) {
        var n2 = t2.raw;
        return wt(e3, n2.which);
      };
    }
    function Pl(t2) {
      return function(n2) {
        return N(t2, function(t3) {
          return t3(n2);
        });
      };
    }
    function Hl(t2) {
      return true === t2.raw.shiftKey;
    }
    function zl(t2) {
      return true === t2.raw.ctrlKey;
    }
    function Nl(t2, n2) {
      return { matches: t2, classification: n2 };
    }
    function Ll(t2, n2, e3) {
      n2.exists(function(n3) {
        return e3.exists(function(t3) {
          return Lt(t3, n3);
        });
      }) || br(t2, Ki(), { prevFocus: n2, newFocus: e3 });
    }
    function Wl() {
      function o2(t2) {
        return _a2(t2.element);
      }
      return { get: o2, set: function(t2, n2) {
        var e3 = o2(t2);
        t2.getSystem().triggerFocus(n2, t2.element), Ll(t2, e3, o2(t2));
      } };
    }
    function Ul() {
      function r2(t2) {
        return hd.getHighlighted(t2).map(function(t3) {
          return t3.element;
        });
      }
      return { get: r2, set: function(n2, t2) {
        var e3 = r2(n2);
        n2.getSystem().getByDom(t2).fold(st, function(t3) {
          hd.highlight(n2, t3);
        });
        var o2 = r2(n2);
        Ll(n2, e3, o2);
      } };
    }
    gs.ltr, gs.rtl;
    function jl(t2, n2, e3, o2, r2, i2) {
      var u2 = i2.map(Ae);
      return lf(t2, n2, e3, o2, r2, u2);
    }
    function Gl(t2, n2, e3) {
      var o2, r2, i2, u2 = n2.getAttachPoint(t2);
      dn(t2.element, "position", ff.getMode(u2)), i2 = n2.cloakVisibilityAttr, hn((o2 = t2).element, r2 = "visibility").fold(function() {
        sn(o2.element, i2);
      }, function(t3) {
        on(o2.element, i2, t3);
      }), dn(o2.element, r2, "hidden");
    }
    function Xl(t2, n2, e3) {
      var o2, r2, i2, u2 = t2.element;
      d(["top", "left", "right", "bottom"], function(t3) {
        return hn(u2, t3).isSome();
      }) || bn(t2.element, "position"), r2 = "visibility", i2 = n2.cloakVisibilityAttr, an((o2 = t2).element, i2).fold(function() {
        return bn(o2.element, r2);
      }, function(t3) {
        return dn(o2.element, r2, t3);
      });
    }
    function Yl(t2, n2, e3, o2) {
      return Kr(o2.element, n2.highlightClass);
    }
    function ql(n2, t2, e3) {
      return Iu(n2.element, "." + t2.itemClass).bind(function(t3) {
        return n2.getSystem().getByDom(t3).toOptional();
      });
    }
    function Kl(n2, t2, e3) {
      var o2 = vs(n2.element, "." + t2.itemClass);
      return (0 < o2.length ? vt.some(o2[o2.length - 1]) : vt.none()).bind(function(t3) {
        return n2.getSystem().getByDom(t3).toOptional();
      });
    }
    function Jl(n2, t2, e3) {
      return et(M(vs(n2.element, "." + t2.itemClass), function(t3) {
        return n2.getSystem().getByDom(t3).toOptional();
      }));
    }
    var $l, Ql, Zl, tf, nf = ($l = Yn, { get: function(t2) {
      if (!$l(t2))
        throw new Error("Can only get text value of a text node");
      return Ql(t2).getOr("");
    }, getOption: Ql = function(t2) {
      return $l(t2) ? vt.from(t2.dom.nodeValue) : vt.none();
    }, set: function(t2, n2) {
      if (!$l(t2))
        throw new Error("Can only set raw text value of a text node");
      t2.dom.nodeValue = n2;
    } }), ef = ["img", "br"], of = [wo("getSelection"), mo("root"), wo("bubble"), Wc(), Eo("overrides", {}), Eo("showAbove", false), ta("placement", function(t2, n2, e3) {
      var r2 = Xt(n2.root).dom, o2 = qc(t2, 0, n2);
      return Jc(ks(r2, n2).bind(function(e4) {
        return t3 = r2, n3 = ms.exactFromRange(e4), (0 < (o3 = ns(t3, n3).getBoundingClientRect()).width || 0 < o3.height ? vt.some(o3).map(Zc) : vt.none()).orThunk(function() {
          var t4 = At.fromText("\uFEFF");
          Dn(e4.start, t4);
          var n4 = xs(r2, ms.exact(t4, 0, t4, 1));
          return Ee(t4), n4;
        }).bind(function(t4) {
          return Kc(t4.left, t4.top, t4.width, t4.height);
        });
        var t3, n3, o3;
      }), o2, n2, e3, ks(r2, n2).bind(function(t3) {
        return Xn(t3.start) ? vt.some(t3.start) : fe(t3.start);
      }).getOr(t2.element));
    })], rf = "link-layout", uf = lo("type", { selection: of, node: cs, hotspot: os, submenu: [mo("item"), Wc(), Eo("overrides", {}), ta("placement", function(t2, n2, e3) {
      var o2 = Aa(e3, n2.item.element), r2 = Uc(t2.element, n2, Ms(), As(), Ms(), As(), vt.none());
      return vt.some(zc({ anchorBox: o2, bubble: kc(), overrides: n2.overrides, layouts: r2, placer: vt.none() }));
    })], makeshift: rs }), af = [xo("classes", nr), Ao("mode", "all", ["all", "layout", "placement"])], cf = [Eo("useFixed", T), wo("getBounds")], sf = [go("anchor", uf), To("transition", af)], lf = function(c2, s2, l2, f2, t2, d2) {
      var m3 = so("placement.info", $o(sf), t2), g2 = m3.anchor, p2 = f2.element, h2 = l2.get(f2.uid);
      Ta(function() {
        dn(p2, "position", "fixed");
        var t3 = hn(p2, "visibility");
        dn(p2, "visibility", "hidden");
        var n2, e3, o2, r2, i2 = s2.useFixed() ? (r2 = document.documentElement, Ec(0, 0, r2.clientWidth, r2.clientHeight)) : (e3 = Cn((n2 = c2).element), o2 = n2.element.dom.getBoundingClientRect(), Tc(e3.left, e3.top, o2.width, o2.height)), u2 = g2.placement, a2 = d2.map(rt2).or(s2.getBounds);
        u2(c2, g2, i2).each(function(t4) {
          var n3 = t4.placer.getOr(Fs)(c2, i2, t4, a2, f2, h2, m3.transition);
          l2.set(f2.uid, n3);
        }), t3.fold(function() {
          bn(p2, "visibility");
        }, function(t4) {
          dn(p2, "visibility", t4);
        }), hn(p2, "left").isNone() && hn(p2, "top").isNone() && hn(p2, "right").isNone() && hn(p2, "bottom").isNone() && mt(hn(p2, "position"), "fixed") && bn(p2, "position");
      }, p2);
    }, ff = xa({ fields: cf, name: "positioning", active: uc, apis: Object.freeze({ __proto__: null, position: function(t2, n2, e3, o2, r2) {
      jl(t2, n2, e3, o2, r2, vt.none());
    }, positionWithin: jl, positionWithinBounds: lf, getMode: function(t2, n2, e3) {
      return n2.useFixed() ? "fixed" : "absolute";
    }, reset: function(t2, n2, e3, o2) {
      var r2 = o2.element;
      St(["position", "left", "right", "top", "bottom"], function(t3) {
        return bn(r2, t3);
      }), sn(r2, Dc), e3.clear(o2.uid);
    } }), state: Object.freeze({ __proto__: null, init: function() {
      var e3 = {};
      return wu({ readState: function() {
        return e3;
      }, clear: function(t2) {
        k(t2) ? delete e3[t2] : e3 = {};
      }, set: function(t2, n2) {
        e3[t2] = n2;
      }, get: function(t2) {
        return tt(e3, t2);
      } });
    } }) }), df = function(t2) {
      vr(t2, Xi());
      var n2 = t2.components();
      St(n2, df);
    }, mf = function(t2) {
      var n2 = t2.components();
      St(n2, mf), vr(t2, Gi());
    }, gf = function(t2, n2, e3) {
      t2.getSystem().addToWorld(n2), e3(t2.element, n2.element), ve(t2.element) && mf(n2), t2.syncComponents();
    }, pf = function(t2, n2, e3) {
      e3(t2, n2.element);
      var o2 = Kt(n2.element);
      St(o2, function(t3) {
        n2.getByDom(t3).each(mf);
      });
    }, hf = Object.freeze({ __proto__: null, cloak: Gl, decloak: Xl, open: Us, openWhileCloaked: function(t2, n2, e3, o2, r2) {
      Gl(t2, n2), Us(t2, n2, e3, o2), r2(), Xl(t2, n2);
    }, close: js, isOpen: Gs, isPartOf: function(n2, e3, t2, o2) {
      return Gs(0, 0, t2) && t2.get().exists(function(t3) {
        return e3.isPartOf(n2, t3, o2);
      });
    }, getState: function(t2, n2, e3) {
      return e3.get();
    }, setContent: function(t2, n2, e3, o2) {
      return e3.get().map(function() {
        return Ws(t2, n2, e3, o2);
      });
    } }), vf = Object.freeze({ __proto__: null, events: function(e3, o2) {
      return eu([Cr(Hi(), function(t2, n2) {
        js(t2, e3, o2);
      })]);
    } }), bf = xa({ fields: [Ju("onOpen"), Ju("onClose"), mo("isPartOf"), mo("getAttachPoint"), Eo("cloakVisibilityAttr", "data-precloak-visibility")], name: "sandboxing", active: vf, apis: hf, state: Object.freeze({ __proto__: null, init: function() {
      var t2 = gc(), n2 = rt2("not-implemented");
      return wu({ readState: n2, isOpen: t2.isSet, clear: t2.clear, set: t2.set, get: t2.get });
    } }) }), yf = rt2("dismiss.popups"), xf = rt2("reposition.popups"), wf = rt2("mouse.released"), Sf = to([Eo("isExtraPart", T), To("fireEventInstead", [Eo("event", Yi())])]), kf = to([To("fireEventInstead", [Eo("event", qi())]), vo("doReposition")]), Cf = Object.freeze({ __proto__: null, onLoad: qs, onUnload: Ks, setValue: function(t2, n2, e3, o2) {
      n2.store.manager.setValue(t2, n2, e3, o2);
    }, getValue: function(t2, n2, e3) {
      return n2.store.manager.getValue(t2, n2, e3);
    }, getState: function(t2, n2, e3) {
      return e3;
    } }), Of = Object.freeze({ __proto__: null, events: function(e3, o2) {
      var t2 = e3.resetOnDom ? [ou(function(t3, n2) {
        qs(t3, e3, o2);
      }), ru(function(t3, n2) {
        Ks(t3, e3, o2);
      })] : [ba(e3, o2, qs)];
      return eu(t2);
    } }), _f = Object.freeze({ __proto__: null, memory: Js, dataset: $s, manual: function() {
      return wu({ readState: st });
    }, init: function(t2) {
      return t2.store.manager.state(t2);
    } }), Tf = [wo("initialValue"), mo("getFallbackEntry"), mo("getDataKey"), mo("setValue"), ta("manager", { setValue: Qs, getValue: function(t2, n2, e3) {
      var o2 = n2.store, r2 = o2.getDataKey(t2);
      return e3.lookup(r2).getOrThunk(function() {
        return o2.getFallbackEntry(r2);
      });
    }, onLoad: function(n2, e3, o2) {
      e3.store.initialValue.each(function(t2) {
        Qs(n2, e3, o2, t2);
      });
    }, onUnload: function(t2, n2, e3) {
      e3.clear();
    }, state: $s })], Ef = [mo("getValue"), Eo("setValue", st), wo("initialValue"), ta("manager", { setValue: function(t2, n2, e3, o2) {
      n2.store.setValue(t2, o2), n2.onSetValue(t2, o2);
    }, getValue: function(t2, n2, e3) {
      return n2.store.getValue(t2);
    }, onLoad: function(n2, e3, t2) {
      e3.store.initialValue.each(function(t3) {
        e3.store.setValue(n2, t3);
      });
    }, onUnload: st, state: xu.init })], Df = xa({ fields: [Do("store", { mode: "memory" }, lo("mode", { memory: [wo("initialValue"), ta("manager", { setValue: function(t2, n2, e3, o2) {
      e3.set(o2), n2.onSetValue(t2, o2);
    }, getValue: function(t2, n2, e3) {
      return e3.get();
    }, onLoad: function(t2, n2, e3) {
      n2.store.initialValue.each(function(t3) {
        e3.isNotSet() && e3.set(t3);
      });
    }, onUnload: function(t2, n2, e3) {
      e3.clear();
    }, state: Js })], manual: Ef, dataset: Tf })), Ju("onSetValue"), Eo("resetOnDom", false)], name: "representing", active: Of, apis: Cf, extra: { setValueFrom: function(t2, n2) {
      var e3 = Df.getValue(n2);
      Df.setValue(t2, e3);
    } }, state: _f }), Bf = Zs, Mf = nl, Af = "placeholder", Ff = Ho([{ single: ["required", "valueThunk"] }, { multiple: ["required", "valueThunks"] }]), If = function(r2, i2, u2, a2) {
      return t2 = r2, e3 = a2, (el(n2 = u2) && n2.uiType === Af ? (c2 = n2, s2 = e3, (o2 = t2).exists(function(t3) {
        return t3 !== c2.owner;
      }) ? Ff.single(true, rt2(c2)) : tt(s2, c2.name).fold(function() {
        throw new Error("Unknown placeholder component: " + c2.name + "\nKnown: [" + Ct(s2) + "]\nNamespace: " + o2.getOr("none") + "\nSpec: " + JSON.stringify(c2, null, 2));
      }, function(t3) {
        return t3.replace();
      })) : Ff.single(false, rt2(n2))).fold(function(t3, n3) {
        var e4 = el(u2) ? n3(i2, u2.config, u2.validated) : n3(i2), o3 = z(tt(e4, "components").getOr([]), function(t4) {
          return If(r2, i2, t4, a2);
        });
        return [lt2(lt2({}, e4), { components: o3 })];
      }, function(t3, n3) {
        if (el(u2)) {
          var e4 = n3(i2, u2.config, u2.validated);
          return u2.validated.preprocess.getOr(h)(e4);
        }
        return n3(i2);
      });
      var t2, n2, e3, o2, c2, s2;
    }, Rf = Ff.single, Vf = Ff.multiple, Pf = rt2(Af), Hf = Ho([{ required: ["data"] }, { external: ["data"] }, { optional: ["data"] }, { group: ["data"] }]), zf = Eo("factory", { sketch: h }), Nf = Eo("schema", []), Lf = mo("name"), Wf = ar("pname", "pname", je(function(t2) {
      return "<alloy." + Ir(t2.name) + ">";
    }), Zo()), Uf = cr("schema", function() {
      return [wo("preprocess")];
    }), jf = Eo("defaults", rt2({})), Gf = Eo("overrides", rt2({})), Xf = $o([zf, Nf, Lf, Wf, jf, Gf]), Yf = $o([zf, Nf, Lf, jf, Gf]), qf = $o([zf, Nf, Lf, Wf, jf, Gf]), Kf = $o([zf, Uf, Lf, mo("unit"), Wf, jf, Gf]), Jf = il(Hf.required, Xf), $f = il(Hf.external, Yf), Qf = il(Hf.optional, qf), Zf = il(Hf.group, Kf), td = rt2("entirety"), nd = Object.freeze({ __proto__: null, required: Jf, external: $f, optional: Qf, group: Zf, asNamedPart: ol, name: rl, asCommon: function(t2) {
      return t2.fold(h, h, h, h);
    }, original: td }), ed = function(t2, n2) {
      return { uiType: Pf(), owner: t2, name: n2 };
    }, od = Object.freeze({ __proto__: null, generate: al, generateOne: cl, schemas: sl, names: ll, substitutes: fl, components: dl, defaultUids: yl, defaultUidsSchema: xl, getAllParts: hl, getAllPartNames: vl, getPart: ml, getPartOrDie: gl, getParts: pl, getPartsOrDie: bl }), rd = function(t2) {
      return Tt(t2, "uid") ? t2 : lt2(lt2({}, t2), { uid: pu("uid") });
    }, id = to([mo("name"), mo("factory"), mo("configFields"), Eo("apis", {}), Eo("extraApis", {})]), ud = to([mo("name"), mo("factory"), mo("configFields"), mo("partFields"), Eo("apis", {}), Eo("extraApis", {})]), ad = Object.freeze({ __proto__: null, getCurrent: function(t2, n2, e3) {
      return n2.find(t2);
    } }), cd = xa({ fields: [mo("find")], name: "composing", apis: ad }), sd = ["input", "button", "textarea", "select"], ld = function(n2, t2, e3) {
      t2.disableClass.each(function(t3) {
        Yr(n2.element, t3);
      }), (Tl(n2, t2) ? function(t3) {
        on(t3.element, "disabled", "disabled");
      } : function(t3) {
        on(t3.element, "aria-disabled", "true");
      })(n2), t2.onDisabled(n2);
    }, fd = function(n2, t2, e3) {
      t2.disableClass.each(function(t3) {
        qr(n2.element, t3);
      }), (Tl(n2, t2) ? function(t3) {
        sn(t3.element, "disabled");
      } : function(t3) {
        on(t3.element, "aria-disabled", "false");
      })(n2), t2.onEnabled(n2);
    }, dd = Object.freeze({ __proto__: null, enable: fd, disable: ld, isDisabled: El, onLoad: _l, set: function(t2, n2, e3, o2) {
      (o2 ? ld : fd)(t2, n2);
    } }), md = Object.freeze({ __proto__: null, exhibit: function(t2, n2) {
      return Lr({ classes: n2.disabled() ? n2.disableClass.toArray() : [] });
    }, events: function(e3, t2) {
      return eu([Sr(Ii(), function(t3, n2) {
        return El(t3, e3);
      }), ba(e3, t2, _l)]);
    } }), gd = xa({ fields: [Io("disabled", T), Eo("useNative", true), wo("disableClass"), Ju("onDisabled"), Ju("onEnabled")], name: "disabling", active: md, apis: dd }), pd = Object.freeze({ __proto__: null, dehighlightAll: function(t2, n2, e3) {
      return Dl(t2, n2, 0, []);
    }, dehighlight: function(t2, n2, e3, o2) {
      Yl(0, n2, 0, o2) && (qr(o2.element, n2.highlightClass), n2.onDehighlight(t2, o2), vr(o2, tu()));
    }, highlight: Bl, highlightFirst: function(n2, e3, t2) {
      ql(n2, e3).each(function(t3) {
        Bl(n2, e3, 0, t3);
      });
    }, highlightLast: function(n2, e3, t2) {
      Kl(n2, e3).each(function(t3) {
        Bl(n2, e3, 0, t3);
      });
    }, highlightAt: function(n2, e3, t2, o2) {
      var r2, i2, u2;
      i2 = o2, u2 = vs((r2 = n2).element, "." + e3.itemClass), vt.from(u2[i2]).fold(function() {
        return Ve.error(new Error("No element found with index " + i2));
      }, r2.getSystem().getByDom).fold(function(t3) {
        throw t3;
      }, function(t3) {
        Bl(n2, e3, 0, t3);
      });
    }, highlightBy: function(n2, e3, t2, o2) {
      V(Jl(n2, e3), o2).each(function(t3) {
        Bl(n2, e3, 0, t3);
      });
    }, isHighlighted: Yl, getHighlighted: function(n2, t2, e3) {
      return Iu(n2.element, "." + t2.highlightClass).bind(function(t3) {
        return n2.getSystem().getByDom(t3).toOptional();
      });
    }, getFirst: ql, getLast: Kl, getPrevious: function(t2, n2, e3) {
      return Ml(t2, n2, 0, -1);
    }, getNext: function(t2, n2, e3) {
      return Ml(t2, n2, 0, 1);
    }, getCandidates: Jl }), hd = xa({ fields: [mo("highlightClass"), mo("itemClass"), Ju("onHighlight"), Ju("onDehighlight")], name: "highlighting", apis: pd }), vd = [8], bd = [9], yd = [13], xd = [27], wd = [32], Sd = [37], kd = [38], Cd = [39], Od = [40], _d = O(Hl);
    function Td(t2, n2, e3, o2, a2) {
      function c2(n3, e4, t3, o3, r3) {
        var i2 = t3(n3, e4, o3, r3), u2 = e4.event;
        return V(i2, function(t4) {
          return t4.matches(u2);
        }).map(function(t4) {
          return t4.classification;
        }).bind(function(t4) {
          return t4(n3, e4, o3, r3);
        });
      }
      var r2 = { schema: function() {
        return t2.concat([Eo("focusManager", Wl()), Do("focusInside", "onFocus", io(function(t3) {
          return wt(["onFocus", "onEnterOrSpace", "onApi"], t3) ? Ve.value(t3) : Ve.error("Invalid value for focusInside");
        })), ta("handler", r2), ta("state", n2), ta("sendFocusIn", a2)]);
      }, processKey: c2, toEvents: function(i2, u2) {
        var t3 = i2.focusInside !== Zl.OnFocusMode ? vt.none() : a2(i2).map(function(e4) {
          return Cr(Bi(), function(t4, n4) {
            e4(t4, i2, u2), n4.stop();
          });
        }), n3 = [Cr(xi(), function(o3, r3) {
          c2(o3, r3, e3, i2, u2).fold(function() {
            var n4 = o3, e4 = r3, t4 = Vl(wd.concat(yd))(e4.event);
            i2.focusInside === Zl.OnEnterOrSpaceMode && t4 && gr(n4, e4) && a2(i2).each(function(t5) {
              t5(n4, i2, u2), e4.stop();
            });
          }, function(t4) {
            r3.stop();
          });
        }), Cr(wi(), function(t4, n4) {
          c2(t4, n4, o2, i2, u2).each(function(t5) {
            n4.stop();
          });
        })];
        return eu(t3.toArray().concat(n3));
      } };
      return r2;
    }
    function Ed(t2) {
      function a2(t3, n3) {
        return 0 < wn(t3.visibilitySelector.bind(function(t4) {
          return Ru(n3, t4);
        }).getOr(n3));
      }
      function n2(n3, e4, t3) {
        var o3 = e4, r3 = F(vs(n3.element, o3.selector), function(t4) {
          return a2(o3, t4);
        });
        vt.from(r3[o3.firstTabstop]).each(function(t4) {
          e4.focusManager.set(n3, t4);
        });
      }
      function o2(e4, t3, r3, i3) {
        var n3, u2 = vs(e4.element, r3.selector);
        return (n3 = r3).focusManager.get(e4).bind(function(t4) {
          return Ru(t4, n3.selector);
        }).bind(function(t4) {
          return P(u2, C(Lt, t4)).bind(function(t5) {
            return n4 = e4, o3 = r3, i3(u2, t5, function(t6) {
              return a2(n5 = o3, e5 = t6) && n5.useTabstopAt(e5);
              var n5, e5;
            }).fold(function() {
              return o3.cyclic ? vt.some(true) : vt.none();
            }, function(t6) {
              return o3.focusManager.set(n4, t6), vt.some(true);
            });
            var n4, o3;
          });
        });
      }
      var e3 = [wo("onEscape"), wo("onEnter"), Eo("selector", '[data-alloy-tabstop="true"]:not(:disabled)'), Eo("firstTabstop", 0), Eo("useTabstopAt", D), wo("visibilitySelector")].concat([t2]), r2 = rt2([Nl(Pl([Hl, Vl(bd)]), function(t3, n3, e4) {
        return o2(t3, 0, e4, e4.cyclic ? Al : Fl);
      }), Nl(Vl(bd), function(t3, n3, e4) {
        return o2(t3, 0, e4, e4.cyclic ? Il : Rl);
      }), Nl(Vl(xd), function(n3, e4, t3) {
        return t3.onEscape.bind(function(t4) {
          return t4(n3, e4);
        });
      }), Nl(Pl([_d, Vl(yd)]), function(n3, e4, t3) {
        return t3.onEnter.bind(function(t4) {
          return t4(n3, e4);
        });
      })]), i2 = rt2([]);
      return Td(e3, xu.init, r2, i2, function() {
        return vt.some(n2);
      });
    }
    function Dd(t2, n2, e3) {
      return Ol(e3) && Vl(wd)(n2.event) ? vt.none() : (xr(t2, e3, Ii()), vt.some(true));
    }
    function Bd(t2, n2) {
      return vt.some(true);
    }
    function Md(t2, n2, e3) {
      return e3.execute(t2, n2, t2.element);
    }
    function Ad() {
      var e3 = gc();
      return wu({ readState: function() {
        return e3.get().map(function(t2) {
          return { numRows: String(t2.numRows), numColumns: String(t2.numColumns) };
        }).getOr({ numRows: "?", numColumns: "?" });
      }, setGridSize: function(t2, n2) {
        e3.set({ numRows: t2, numColumns: n2 });
      }, getNumRows: function() {
        return e3.get().map(function(t2) {
          return t2.numRows;
        });
      }, getNumColumns: function() {
        return e3.get().map(function(t2) {
          return t2.numColumns;
        });
      } });
    }
    function Fd(i2) {
      return function(t2, n2, e3, o2) {
        var r2 = i2(t2.element);
        return tg(r2, t2, n2, e3, o2);
      };
    }
    function Id(t2, n2) {
      return Fd(Cc(t2, n2));
    }
    function Rd(t2, n2) {
      return Fd(Cc(n2, t2));
    }
    function Vd(r2) {
      return function(t2, n2, e3, o2) {
        return tg(r2, t2, n2, e3, o2);
      };
    }
    function Pd(t2) {
      return !((n2 = t2.dom).offsetWidth <= 0 && n2.offsetHeight <= 0);
      var n2;
    }
    function Hd(t2, n2, e3) {
      var o2, r2 = F(vs(t2, e3), Pd);
      return P(o2 = r2, function(t3) {
        return Lt(t3, n2);
      }).map(function(t3) {
        return { index: t3, candidates: o2 };
      });
    }
    function zd(t2, n2) {
      return P(t2, function(t3) {
        return Lt(n2, t3);
      });
    }
    function Nd(e3, t2, o2, n2) {
      return n2(Math.floor(t2 / o2), t2 % o2).bind(function(t3) {
        var n3 = t3.row * o2 + t3.column;
        return 0 <= n3 && n3 < e3.length ? vt.some(e3[n3]) : vt.none();
      });
    }
    function Ld(r2, t2, i2, u2, a2) {
      return Nd(r2, t2, u2, function(t3, n2) {
        var e3 = t3 === i2 - 1 ? r2.length - t3 * u2 : u2, o2 = oa(n2, a2, 0, e3 - 1);
        return vt.some({ row: t3, column: o2 });
      });
    }
    function Wd(i2, t2, u2, a2, c2) {
      return Nd(i2, t2, a2, function(t3, n2) {
        var e3 = oa(t3, c2, 0, u2 - 1), o2 = e3 === u2 - 1 ? i2.length - e3 * a2 : a2, r2 = ja(n2, 0, o2 - 1);
        return vt.some({ row: e3, column: r2 });
      });
    }
    function Ud(n2, e3, t2) {
      Iu(n2.element, e3.selector).each(function(t3) {
        e3.focusManager.set(n2, t3);
      });
    }
    function jd(r2) {
      return function(t2, n2, e3, o2) {
        return Hd(t2, n2, e3.selector).bind(function(t3) {
          return r2(t3.candidates, t3.index, o2.getNumRows().getOr(e3.initSize.numRows), o2.getNumColumns().getOr(e3.initSize.numColumns));
        });
      };
    }
    function Gd(t2, n2, e3) {
      return e3.captureTab ? vt.some(true) : vt.none();
    }
    function Xd(t2, n2, e3, i2) {
      var u2 = function(t3, n3, e4) {
        var o2, r2 = oa(n3, i2, 0, e4.length - 1);
        return r2 === t3 ? vt.none() : "button" === Ft(o2 = e4[r2]) && "disabled" === un(o2, "disabled") ? u2(t3, r2, e4) : vt.from(e4[r2]);
      };
      return Hd(t2, e3, n2).bind(function(t3) {
        var n3 = t3.index, e4 = t3.candidates;
        return u2(n3, n3, e4);
      });
    }
    function Yd(n2, e3, o2) {
      return (r2 = o2).focusManager.get(n2).bind(function(t2) {
        return Ru(t2, r2.selector);
      }).bind(function(t2) {
        return o2.execute(n2, e3, t2);
      });
      var r2;
    }
    function qd(n2, e3, t2) {
      e3.getInitial(n2).orThunk(function() {
        return Iu(n2.element, e3.selector);
      }).each(function(t3) {
        e3.focusManager.set(n2, t3);
      });
    }
    function Kd(t2, n2, e3) {
      return Xd(t2, e3.selector, n2, -1);
    }
    function Jd(t2, n2, e3) {
      return Xd(t2, e3.selector, n2, 1);
    }
    function $d(r2) {
      return function(t2, n2, e3, o2) {
        return r2(t2, n2, e3, o2).bind(function() {
          return e3.executeOnMove ? Yd(t2, n2, e3) : vt.some(true);
        });
      };
    }
    function Qd(t2, n2, e3) {
      return e3.onEscape(t2, n2);
    }
    function Zd(t2, n2, e3) {
      return vt.from(t2[n2]).bind(function(t3) {
        return vt.from(t3[e3]).map(function(t4) {
          return { rowIndex: n2, columnIndex: e3, cell: t4 };
        });
      });
    }
    function tm(t2, n2, e3, o2) {
      return Zd(t2, n2, oa(e3, o2, 0, t2[n2].length - 1));
    }
    function nm(t2, n2, e3, o2) {
      var r2 = oa(e3, o2, 0, t2.length - 1), i2 = t2[r2].length;
      return Zd(t2, r2, ja(n2, 0, i2 - 1));
    }
    function em(t2, n2, e3, o2) {
      var r2 = t2[n2].length;
      return Zd(t2, n2, ja(e3 + o2, 0, r2 - 1));
    }
    function om(t2, n2, e3, o2) {
      var r2 = ja(e3 + o2, 0, t2.length - 1), i2 = t2[r2].length;
      return Zd(t2, r2, ja(n2, 0, i2 - 1));
    }
    function rm(n2, e3, t2) {
      e3.previousSelector(n2).orThunk(function() {
        var t3 = e3.selectors;
        return Iu(n2.element, t3.cell);
      }).each(function(t3) {
        e3.focusManager.set(n2, t3);
      });
    }
    function im(t2, o2) {
      return function(n2, e3, i2) {
        var u2 = i2.cycles ? t2 : o2;
        return Ru(e3, i2.selectors.row).bind(function(t3) {
          return zd(vs(t3, i2.selectors.cell), e3).bind(function(o3) {
            var r2 = vs(n2, i2.selectors.row);
            return zd(r2, t3).bind(function(t4) {
              var n3, e4 = (n3 = i2, M(r2, function(t5) {
                return vs(t5, n3.selectors.cell);
              }));
              return u2(e4, t4, o3).map(function(t5) {
                return t5.cell;
              });
            });
          });
        });
      };
    }
    function um(n2, e3, o2) {
      return o2.focusManager.get(n2).bind(function(t2) {
        return o2.execute(n2, e3, t2);
      });
    }
    function am(n2, e3, t2) {
      Iu(n2.element, e3.selector).each(function(t3) {
        e3.focusManager.set(n2, t3);
      });
    }
    function cm(t2, n2, e3) {
      return Xd(t2, e3.selector, n2, -1);
    }
    function sm(t2, n2, e3) {
      return Xd(t2, e3.selector, n2, 1);
    }
    function lm(t2, n2, e3, o2) {
      var r2 = t2.getSystem().build(o2);
      gf(t2, r2, e3);
    }
    function fm(t2, n2, e3, o2) {
      V(Ig(t2), function(t3) {
        return Lt(o2.element, t3.element);
      }).each(Hs);
    }
    function dm(n2, t2, e3, r2, o2) {
      var i2 = Ig(n2);
      return vt.from(i2[r2]).map(function(t3) {
        return fm(n2, 0, 0, t3), o2.each(function(t4) {
          lm(n2, 0, function(t5, n3) {
            var e4, o3 = n3;
            Jt(e4 = t5, r2).fold(function() {
              Te(e4, o3);
            }, function(t6) {
              Dn(t6, o3);
            });
          }, t4);
        }), t3;
      });
    }
    function mm(t2, n2) {
      var e3, o2;
      return { key: t2, value: { config: {}, me: (e3 = t2, o2 = eu(n2), xa({ fields: [mo("enabled")], name: e3, active: { events: rt2(o2) } })), configAsRaw: rt2({}), initialConfig: {}, state: xu } };
    }
    function gm(t2, n2) {
      n2.ignore || (ka(t2.element), n2.onFocus(t2));
    }
    function pm(t2, n2, e3) {
      var o2 = n2.aria;
      o2.update(t2, o2, e3.get());
    }
    function hm(n2, t2, e3) {
      t2.toggleClass.each(function(t3) {
        (e3.get() ? Yr : qr)(n2.element, t3);
      });
    }
    function vm(t2, n2, e3) {
      Ym(t2, n2, e3, !e3.get());
    }
    function bm(t2, n2, e3) {
      e3.set(true), hm(t2, n2, e3), pm(t2, n2, e3);
    }
    function ym(t2, n2, e3) {
      e3.set(false), hm(t2, n2, e3), pm(t2, n2, e3);
    }
    function xm(t2, n2, e3) {
      Ym(t2, n2, e3, n2.selected);
    }
    function wm() {
      function t2(t3, n2) {
        n2.stop(), yr(t3);
      }
      return [Cr(Ci(), t2), Cr(Vi(), t2), Dr(si()), Dr(mi())];
    }
    function Sm(t2) {
      return eu(ft([t2.map(function(e3) {
        return uu(function(t3, n2) {
          e3(t3), n2.stop();
        });
      }).toArray(), wm()]));
    }
    function km(t2) {
      (_a2(t2.element).isNone() || Hg.isFocused(t2)) && (Hg.isFocused(t2) || Hg.focus(t2), br(t2, Wg, { item: t2 }));
    }
    function Cm(t2) {
      br(t2, Ug, { item: t2 });
    }
    function Om(t2, n2) {
      return t2.x + t2.width / 2 - n2.width / 2;
    }
    function _m(t2, n2) {
      return t2.x + t2.width - n2.width;
    }
    function Tm(t2, n2) {
      return t2.y + t2.height - n2.height;
    }
    function Em(t2, n2) {
      return t2.y + t2.height / 2 - n2.height / 2;
    }
    function Dm(t2, n2, e3) {
      return ea(_m(t2, n2), Tm(t2, n2), e3.insetSouthwest(), za(), "southwest", ra(t2, { right: 0, bottom: 3 }), ap);
    }
    function Bm(t2, n2, e3) {
      return ea(t2.x, Tm(t2, n2), e3.insetSoutheast(), Ha(), "southeast", ra(t2, { left: 1, bottom: 3 }), ap);
    }
    function Mm(t2, n2, e3) {
      return ea(_m(t2, n2), t2.y, e3.insetNorthwest(), Pa(), "northwest", ra(t2, { right: 0, top: 2 }), ap);
    }
    function Am(t2, n2, e3) {
      return ea(t2.x, t2.y, e3.insetNortheast(), Va(), "northeast", ra(t2, { left: 1, top: 2 }), ap);
    }
    function Fm(t2, n2, e3) {
      return ea(_m(t2, n2), Em(t2, n2), e3.insetEast(), Ua(), "east", ra(t2, { right: 0 }), ap);
    }
    function Im(t2, n2, e3) {
      return ea(t2.x, Em(t2, n2), e3.insetWest(), Wa(), "west", ra(t2, { left: 1 }), ap);
    }
    function Rm(t2) {
      switch (t2) {
        case "north":
          return cp;
        case "northeast":
          return Am;
        case "northwest":
          return Mm;
        case "south":
          return sp;
        case "southeast":
          return Bm;
        case "southwest":
          return Dm;
        case "east":
          return Fm;
        case "west":
          return Im;
      }
    }
    function Vm(t2, n2, e3, o2, r2) {
      return sc(o2).map(Rm).getOr(cp)(t2, n2, e3, o2, r2);
    }
    function Pm(t2) {
      switch (t2) {
        case "north":
          return sp;
        case "northeast":
          return Bm;
        case "northwest":
          return Dm;
        case "south":
          return cp;
        case "southeast":
          return Am;
        case "southwest":
          return Mm;
        case "east":
          return Im;
        case "west":
          return Fm;
      }
    }
    function Hm(t2, n2, e3, o2, r2) {
      return sc(o2).map(Pm).getOr(cp)(t2, n2, e3, o2, r2);
    }
    function zm(t2) {
      var n2 = void 0 !== t2.uid && nt(t2, "uid") ? t2.uid : pu("memento");
      return { get: function(t3) {
        return t3.getSystem().getByUid(n2).getOrDie();
      }, getOpt: function(t3) {
        return t3.getSystem().getByUid(n2).toOptional();
      }, asSpec: function() {
        return lt2(lt2({}, t2), { uid: n2 });
      } };
    }
    function Nm(t2) {
      return function() {
        return tt(t2, gp).getOr("!not found!");
      };
    }
    function Lm(t2, n2) {
      var e3, o2 = t2.toLowerCase();
      if (dp.isRtl()) {
        var r2 = Bt(e3 = o2, "-rtl") ? e3 : e3 + "-rtl";
        return Tt(n2, r2) ? r2 : o2;
      }
      return o2;
    }
    function Wm(t2, n2) {
      return tt(n2, Lm(t2, n2));
    }
    function Um(t2, n2) {
      var e3 = n2();
      return Wm(t2, e3).getOrThunk(Nm(e3));
    }
    function jm() {
      return mm("add-focusable", [ou(function(t2) {
        var n2, e3, o2;
        n2 = t2.element, e3 = "svg", o2 = function(t3) {
          return zt(t3, e3);
        }, V(n2.dom.childNodes, function(t3) {
          return o2(At.fromDom(t3));
        }).map(At.fromDom).each(function(t3) {
          return on(t3, "focusable", "false");
        });
      })]);
    }
    function Gm(t2, n2, e3, o2) {
      var r2, i2, u2, a2 = (u2 = n2, dp.isRtl() && Tt(mp, u2) ? ["tox-icon--flip"] : []), c2 = tt(e3, Lm(n2, e3)).or(o2).getOrThunk(Nm(e3));
      return { dom: { tag: t2.tag, attributes: null !== (r2 = t2.attributes) && void 0 !== r2 ? r2 : {}, classes: t2.classes.concat(a2), innerHtml: c2 }, behaviours: nc(H(H([], null !== (i2 = t2.behaviours) && void 0 !== i2 ? i2 : [], true), [jm()], false)) };
    }
    function Xm(t2, n2, e3, o2) {
      return void 0 === o2 && (o2 = vt.none()), Gm(n2, t2, e3(), o2);
    }
    (tf = Zl = Zl || {}).OnFocusMode = "onFocus", tf.OnEnterOrSpaceMode = "onEnterOrSpace", tf.OnApiMode = "onApi";
    function Ym(t2, n2, e3, o2) {
      (o2 ? bm : ym)(t2, n2, e3);
    }
    function qm(t2, n2, e3) {
      on(t2.element, "aria-expanded", e3);
    }
    function Km(t2) {
      return "prepared" === t2.type ? vt.some(t2.menu) : vt.none();
    }
    var Jm = Ed(cr("cyclic", T)), $m = Ed(cr("cyclic", D)), Qm = Td([Eo("execute", Dd), Eo("useSpace", false), Eo("useEnter", true), Eo("useControlEnter", false), Eo("useDown", false)], xu.init, function(t2, n2, e3, o2) {
      var r2 = e3.useSpace && !Ol(t2.element) ? wd : [], i2 = e3.useEnter ? yd : [], u2 = e3.useDown ? Od : [];
      return [Nl(Vl(r2.concat(i2).concat(u2)), Md)].concat(e3.useControlEnter ? [Nl(Pl([zl, Vl(yd)]), Md)] : []);
    }, function(t2, n2, e3, o2) {
      return e3.useSpace && !Ol(t2.element) ? [Nl(Vl(wd), Bd)] : [];
    }, function() {
      return vt.none();
    }), Zm = Object.freeze({ __proto__: null, flatgrid: Ad, init: function(t2) {
      return t2.state(t2);
    } }), tg = function(n2, e3, t2, o2, r2) {
      return o2.focusManager.get(e3).bind(function(t3) {
        return n2(e3.element, t3, o2, r2);
      }).map(function(t3) {
        return o2.focusManager.set(e3, t3), true;
      });
    }, ng = Vd, eg = Vd, og = Vd, rg = jd(function(t2, n2, e3, o2) {
      return Ld(t2, n2, e3, o2, -1);
    }), ig = jd(function(t2, n2, e3, o2) {
      return Ld(t2, n2, e3, o2, 1);
    }), ug = jd(function(t2, n2, e3, o2) {
      return Wd(t2, n2, e3, o2, -1);
    }), ag = jd(function(t2, n2, e3, o2) {
      return Wd(t2, n2, e3, o2, 1);
    }), cg = Td([mo("selector"), Eo("execute", Dd), $u("onEscape"), Eo("captureTab", false), Ia()], Ad, rt2([Nl(Vl(Sd), Id(rg, ig)), Nl(Vl(Cd), Rd(rg, ig)), Nl(Vl(kd), ng(ug)), Nl(Vl(Od), eg(ag)), Nl(Pl([Hl, Vl(bd)]), Gd), Nl(Pl([_d, Vl(bd)]), Gd), Nl(Vl(xd), function(t2, n2, e3) {
      return e3.onEscape(t2, n2);
    }), Nl(Vl(wd.concat(yd)), function(n2, e3, o2, t2) {
      return (r2 = o2).focusManager.get(n2).bind(function(t3) {
        return Ru(t3, r2.selector);
      }).bind(function(t3) {
        return o2.execute(n2, e3, t3);
      });
      var r2;
    })]), rt2([Nl(Vl(wd), Bd)]), function() {
      return vt.some(Ud);
    }), sg = [mo("selector"), Eo("getInitial", vt.none), Eo("execute", Dd), $u("onEscape"), Eo("executeOnMove", false), Eo("allowVertical", true)], lg = rt2([Nl(Vl(wd), Bd)]), fg = Td(sg, xu.init, function(t2, n2, e3, o2) {
      var r2 = Sd.concat(e3.allowVertical ? kd : []), i2 = Cd.concat(e3.allowVertical ? Od : []);
      return [Nl(Vl(r2), $d(Id(Kd, Jd))), Nl(Vl(i2), $d(Rd(Kd, Jd))), Nl(Vl(yd), Yd), Nl(Vl(wd), Yd), Nl(Vl(xd), Qd)];
    }, lg, function() {
      return vt.some(qd);
    }), dg = [bo("selectors", [mo("row"), mo("cell")]), Eo("cycles", true), Eo("previousSelector", vt.none), Eo("execute", Dd)], mg = im(function(t2, n2, e3) {
      return tm(t2, n2, e3, -1);
    }, function(t2, n2, e3) {
      return em(t2, n2, e3, -1);
    }), gg = im(function(t2, n2, e3) {
      return tm(t2, n2, e3, 1);
    }, function(t2, n2, e3) {
      return em(t2, n2, e3, 1);
    }), pg = im(function(t2, n2, e3) {
      return nm(t2, e3, n2, -1);
    }, function(t2, n2, e3) {
      return om(t2, e3, n2, -1);
    }), hg = im(function(t2, n2, e3) {
      return nm(t2, e3, n2, 1);
    }, function(t2, n2, e3) {
      return om(t2, e3, n2, 1);
    }), vg = rt2([Nl(Vl(Sd), Id(mg, gg)), Nl(Vl(Cd), Rd(mg, gg)), Nl(Vl(kd), ng(pg)), Nl(Vl(Od), eg(hg)), Nl(Vl(wd.concat(yd)), function(n2, e3, o2) {
      return _a2(n2.element).bind(function(t2) {
        return o2.execute(n2, e3, t2);
      });
    })]), bg = rt2([Nl(Vl(wd), Bd)]), yg = Td(dg, xu.init, vg, bg, function() {
      return vt.some(rm);
    }), xg = [mo("selector"), Eo("execute", Dd), Eo("moveOnTab", false)], wg = rt2([Nl(Vl(kd), og(cm)), Nl(Vl(Od), og(sm)), Nl(Pl([Hl, Vl(bd)]), function(t2, n2, e3, o2) {
      return e3.moveOnTab ? og(cm)(t2, n2, e3, o2) : vt.none();
    }), Nl(Pl([_d, Vl(bd)]), function(t2, n2, e3, o2) {
      return e3.moveOnTab ? og(sm)(t2, n2, e3, o2) : vt.none();
    }), Nl(Vl(yd), um), Nl(Vl(wd), um)]), Sg = rt2([Nl(Vl(wd), Bd)]), kg = Td(xg, xu.init, wg, Sg, function() {
      return vt.some(am);
    }), Cg = Td([$u("onSpace"), $u("onEnter"), $u("onShiftEnter"), $u("onLeft"), $u("onRight"), $u("onTab"), $u("onShiftTab"), $u("onUp"), $u("onDown"), $u("onEscape"), Eo("stopSpaceKeyup", false), wo("focusIn")], xu.init, function(t2, n2, e3) {
      return [Nl(Vl(wd), e3.onSpace), Nl(Pl([_d, Vl(yd)]), e3.onEnter), Nl(Pl([Hl, Vl(yd)]), e3.onShiftEnter), Nl(Pl([Hl, Vl(bd)]), e3.onShiftTab), Nl(Pl([_d, Vl(bd)]), e3.onTab), Nl(Vl(kd), e3.onUp), Nl(Vl(Od), e3.onDown), Nl(Vl(Sd), e3.onLeft), Nl(Vl(Cd), e3.onRight), Nl(Vl(wd), e3.onSpace), Nl(Vl(xd), e3.onEscape)];
    }, function(t2, n2, e3) {
      return e3.stopSpaceKeyup ? [Nl(Vl(wd), Bd)] : [];
    }, function(t2) {
      return t2.focusIn;
    }), Og = Jm.schema(), _g = $m.schema(), Tg = fg.schema(), Eg = cg.schema(), Dg = yg.schema(), Bg = Qm.schema(), Mg = kg.schema(), Ag = Cg.schema(), Fg = wa({ branchKey: "mode", branches: Object.freeze({ __proto__: null, acyclic: Og, cyclic: _g, flow: Tg, flatgrid: Eg, matrix: Dg, execution: Bg, menu: Mg, special: Ag }), name: "keying", active: { events: function(t2, n2) {
      return t2.handler.toEvents(t2, n2);
    } }, apis: { focusIn: function(n2, e3, o2) {
      e3.sendFocusIn(e3).fold(function() {
        n2.getSystem().triggerFocus(n2.element, n2.element);
      }, function(t2) {
        t2(n2, e3, o2);
      });
    }, setGridSize: function(t2, n2, e3, o2, r2) {
      nt(e3, "setGridSize") ? e3.setGridSize(o2, r2) : console.error("Layout does not support setGridSize");
    } }, state: Zm }), Ig = function(t2, n2) {
      return t2.components();
    }, Rg = xa({ fields: [], name: "replacing", apis: Object.freeze({ __proto__: null, append: function(t2, n2, e3, o2) {
      lm(t2, 0, Te, o2);
    }, prepend: function(t2, n2, e3, o2) {
      lm(t2, 0, Mn, o2);
    }, remove: fm, replaceAt: dm, replaceBy: function(n2, t2, e3, o2, r2) {
      return P(Ig(n2), o2).bind(function(t3) {
        return dm(n2, 0, 0, t3, r2);
      });
    }, set: function(n2, t2, e3, o2) {
      Ta(function() {
        var t3 = M(o2, n2.getSystem().build);
        Rs(n2, t3);
      }, n2.element);
    }, contents: Ig }) }), Vg = Object.freeze({ __proto__: null, focus: gm, blur: function(t2, n2) {
      n2.ignore || t2.element.dom.blur();
    }, isFocused: function(t2) {
      return Ca(t2.element);
    } }), Pg = Object.freeze({ __proto__: null, exhibit: function(t2, n2) {
      return Lr(n2.ignore ? {} : { attributes: { tabindex: "-1" } });
    }, events: function(e3) {
      return eu([Cr(Bi(), function(t2, n2) {
        gm(t2, e3), n2.stop();
      })].concat(e3.stopMousedown ? [Cr(mi(), function(t2, n2) {
        n2.event.prevent();
      })] : []));
    } }), Hg = xa({ fields: [Ju("onFocus"), Eo("stopMousedown", false), Eo("ignore", false)], name: "focusing", active: Pg, apis: Vg }), zg = Object.freeze({ __proto__: null, onLoad: xm, toggle: vm, isOn: function(t2, n2, e3) {
      return e3.get();
    }, on: bm, off: ym, set: Ym }), Ng = Object.freeze({ __proto__: null, exhibit: function() {
      return Lr({});
    }, events: function(t2, n2) {
      var e3, o2, r2, i2 = (e3 = t2, o2 = n2, r2 = vm, uu(function(t3) {
        r2(t3, e3, o2);
      })), u2 = ba(t2, n2, xm);
      return eu(ft([t2.toggleOnExecute ? [i2] : [], [u2]]));
    } }), Lg = xa({ fields: [Eo("selected", false), wo("toggleClass"), Eo("toggleOnExecute", true), Do("aria", { mode: "none" }, lo("mode", { pressed: [Eo("syncWithExpanded", false), ta("update", function(t2, n2, e3) {
      on(t2.element, "aria-pressed", e3), n2.syncWithExpanded && qm(t2, 0, e3);
    })], checked: [ta("update", function(t2, n2, e3) {
      on(t2.element, "aria-checked", e3);
    })], expanded: [ta("update", qm)], selected: [ta("update", function(t2, n2, e3) {
      on(t2.element, "aria-selected", e3);
    })], none: [ta("update", st)] }))], name: "toggling", active: Ng, apis: zg, state: { init: function() {
      var n2 = Po(false);
      return { get: function() {
        return n2.get();
      }, set: function(t2) {
        return n2.set(t2);
      }, clear: function() {
        return n2.set(false);
      }, readState: function() {
        return n2.get();
      } };
    } } }), Wg = "alloy.item-hover", Ug = "alloy.item-focus", jg = rt2(Wg), Gg = rt2(Ug), Xg = [mo("data"), mo("components"), mo("dom"), Eo("hasSubmenu", false), wo("toggling"), Bf("itemBehaviours", [Lg, Hg, Fg, Df]), Eo("ignoreFocus", false), Eo("domModification", {}), ta("builder", function(t2) {
      return { dom: t2.dom, domModification: lt2(lt2({}, t2.domModification), { attributes: lt2(lt2(lt2({ role: t2.toggling.isSome() ? "menuitemcheckbox" : "menuitem" }, t2.domModification.attributes), { "aria-haspopup": t2.hasSubmenu }), t2.hasSubmenu ? { "aria-expanded": false } : {}) }), behaviours: Mf(t2.itemBehaviours, [t2.toggling.fold(Lg.revoke, function(t3) {
        return Lg.config(lt2({ aria: { mode: "checked" } }, t3));
      }), Hg.config({ ignore: t2.ignoreFocus, stopMousedown: t2.ignoreFocus, onFocus: function(t3) {
        Cm(t3);
      } }), Fg.config({ mode: "execution" }), Df.config({ store: { mode: "memory", initialValue: t2.data } }), mm("item-type-events", H(H([], wm(), true), [Cr(vi(), km), Cr(Ri(), Hg.focus)], false))]), components: t2.components, eventOrder: t2.eventOrder };
    }), Eo("eventOrder", {})], Yg = [mo("dom"), mo("components"), ta("builder", function(t2) {
      return { dom: t2.dom, components: t2.components, events: eu([Cr(Ri(), function(t3, n2) {
        n2.stop();
      })]) };
    })], qg = rt2("item-widget"), Kg = rt2([Jf({ name: "widget", overrides: function(n2) {
      return { behaviours: nc([Df.config({ store: { mode: "manual", getValue: function(t2) {
        return n2.data;
      }, setValue: st } })]) };
    } })]), Jg = lo("type", { widget: [mo("uid"), mo("data"), mo("components"), mo("dom"), Eo("autofocus", false), Eo("ignoreFocus", false), Bf("widgetBehaviours", [Df, Hg, Fg]), Eo("domModification", {}), xl(Kg()), ta("builder", function(e3) {
      function o2(t3) {
        return ml(t3, e3, "widget").map(function(t4) {
          return Fg.focusIn(t4), t4;
        });
      }
      function t2(t3, n3) {
        return Ol(n3.event.target) || e3.autofocus && n3.setSource(t3.element), vt.none();
      }
      var n2 = fl(qg(), e3, Kg()), r2 = dl(qg(), e3, n2.internals());
      return { dom: e3.dom, components: r2, domModification: e3.domModification, events: eu([uu(function(t3, n3) {
        o2(t3).each(function(t4) {
          n3.stop();
        });
      }), Cr(vi(), km), Cr(Ri(), function(t3, n3) {
        e3.autofocus ? o2(t3) : Hg.focus(t3);
      })]), behaviours: Mf(e3.widgetBehaviours, [Df.config({ store: { mode: "memory", initialValue: e3.data } }), Hg.config({ ignore: e3.ignoreFocus, onFocus: function(t3) {
        Cm(t3);
      } }), Fg.config({ mode: "special", focusIn: e3.autofocus ? function(t3) {
        o2(t3);
      } : rc(), onLeft: t2, onRight: t2, onEscape: function(t3, n3) {
        return Hg.isFocused(t3) || e3.autofocus ? (e3.autofocus && n3.setSource(t3.element), vt.none()) : (Hg.focus(t3), vt.some(true));
      } })]) };
    })], item: Xg, separator: Yg }), $g = rt2([Zf({ factory: { sketch: function(t2) {
      var n2 = so("menu.spec item", Jg, t2);
      return n2.builder(n2);
    } }, name: "items", unit: "item", defaults: function(t2, n2) {
      return Tt(n2, "uid") ? n2 : lt2(lt2({}, n2), { uid: pu("item") });
    }, overrides: function(t2, n2) {
      return { type: n2.type, ignoreFocus: t2.fakeFocus, domModification: { classes: [t2.markers.item] } };
    } })]), Qg = rt2([mo("value"), mo("items"), mo("dom"), mo("components"), Eo("eventOrder", {}), Zs("menuBehaviours", [hd, Df, cd, Fg]), Do("movement", { mode: "menu", moveOnTab: true }, lo("mode", { grid: [Ia(), ta("config", function(t2, n2) {
      return { mode: "flatgrid", selector: "." + t2.markers.item, initSize: { numColumns: n2.initSize.numColumns, numRows: n2.initSize.numRows }, focusManager: t2.focusManager };
    })], matrix: [ta("config", function(t2, n2) {
      return { mode: "matrix", selectors: { row: n2.rowSelector, cell: "." + t2.markers.item }, focusManager: t2.focusManager };
    }), mo("rowSelector")], menu: [Eo("moveOnTab", true), ta("config", function(t2, n2) {
      return { mode: "menu", selector: "." + t2.markers.item, moveOnTab: n2.moveOnTab, focusManager: t2.focusManager };
    })] })), go("markers", Fa()), Eo("fakeFocus", false), Eo("focusManager", Wl()), Ju("onHighlight")]), Zg = rt2("alloy.menu-focus"), tp = Cl({ name: "Menu", configFields: Qg(), partFields: $g(), factory: function(t2, n2, e3, o2) {
      return { uid: t2.uid, dom: t2.dom, markers: t2.markers, behaviours: nl(t2.menuBehaviours, [hd.config({ highlightClass: t2.markers.selectedItem, itemClass: t2.markers.item, onHighlight: t2.onHighlight }), Df.config({ store: { mode: "memory", initialValue: t2.value } }), cd.config({ find: vt.some }), Fg.config(t2.movement.config(t2, t2.movement))]), events: eu([Cr(Gg(), function(n3, e4) {
        var t3 = e4.event;
        n3.getSystem().getByDom(t3.target).each(function(t4) {
          hd.highlight(n3, t4), e4.stop(), br(n3, Zg(), { menu: n3, item: t4 });
        });
      }), Cr(jg(), function(t3, n3) {
        var e4 = n3.event.item;
        hd.highlight(t3, e4);
      })]), components: n2, eventOrder: t2.eventOrder, domModification: { attributes: { role: "menu" } } };
    } }), np = function(e3, o2, r2, t2) {
      return tt(r2, t2).bind(function(t3) {
        return tt(e3, t3).bind(function(t4) {
          var n2 = np(e3, o2, r2, t4);
          return vt.some([t4].concat(n2));
        });
      }).getOr([]);
    }, ep = function() {
      function a2(t2) {
        return n2(t2).bind(Km);
      }
      function e3(t2) {
        return tt(c2.get(), t2);
      }
      var c2 = Po({}), i2 = Po({}), s2 = Po({}), l2 = gc(), u2 = Po({}), n2 = function(t2) {
        return tt(i2.get(), t2);
      };
      return { setMenuBuilt: function(t2, n3) {
        var e4;
        i2.set(lt2(lt2({}, i2.get()), ((e4 = {})[t2] = { type: "prepared", menu: n3 }, e4)));
      }, setContents: function(t2, n3, e4, o2) {
        l2.set(t2), c2.set(e4), i2.set(n3), u2.set(o2);
        var r2 = function(t3, n4) {
          var e5 = {};
          J(t3, function(t4, n5) {
            St(t4, function(t5) {
              e5[t5] = n5;
            });
          });
          var o3 = n4, r3 = _t(n4, function(t4, n5) {
            return { k: t4, v: n5 };
          }), i3 = dt(r3, function(t4, n5) {
            return [n5].concat(np(e5, o3, r3, n5));
          });
          return dt(e5, function(t4) {
            return tt(i3, t4).getOr([t4]);
          });
        }(o2, e4);
        s2.set(r2);
      }, expand: function(e4) {
        return tt(c2.get(), e4).map(function(t2) {
          var n3 = tt(s2.get(), e4).getOr([]);
          return [t2].concat(n3);
        });
      }, refresh: function(t2) {
        return tt(s2.get(), t2);
      }, collapse: function(t2) {
        return tt(s2.get(), t2).bind(function(t3) {
          return 1 < t3.length ? vt.some(t3.slice(1)) : vt.none();
        });
      }, lookupMenu: n2, lookupItem: e3, otherMenus: function(t2) {
        var n3 = u2.get();
        return W(Ct(n3), t2);
      }, getPrimary: function() {
        return l2.get().bind(a2);
      }, getMenus: function() {
        return i2.get();
      }, clear: function() {
        c2.set({}), i2.set({}), s2.set({}), l2.clear();
      }, isClear: function() {
        return l2.get().isNone();
      }, getTriggeringPath: function(t2, u3) {
        var n3 = F(e3(t2).toArray(), function(t3) {
          return a2(t3).isSome();
        });
        return tt(s2.get(), t2).bind(function(t3) {
          var e4 = L(n3.concat(t3));
          return function(t4) {
            for (var n4 = [], e5 = 0; e5 < t4.length; e5++) {
              var o2 = t4[e5];
              if (!o2.isSome())
                return vt.none();
              n4.push(o2.getOrDie());
            }
            return vt.some(n4);
          }(z(e4, function(t4, n4) {
            return o2 = t4, r2 = u3, i3 = e4.slice(0, n4 + 1), a2(o2).bind(function(n5) {
              return e5 = o2, Q(c2.get(), function(t5, n6) {
                return t5 === e5;
              }).bind(function(t5) {
                return r2(t5).map(function(t6) {
                  return { triggeredMenu: n5, triggeringItem: t6, triggeringPath: i3 };
                });
              });
              var e5;
            }).fold(function() {
              return mt(l2.get(), t4) ? [] : [vt.none()];
            }, function(t5) {
              return [vt.some(t5)];
            });
            var o2, r2, i3;
          }));
        });
      } };
    }, op = Km, rp = rt2("collapse-item"), ip = kl({ name: "TieredMenu", configFields: [Zu("onExecute"), Zu("onEscape"), Qu("onOpenMenu"), Qu("onOpenSubmenu"), Ju("onRepositionMenu"), Ju("onCollapseMenu"), Eo("highlightImmediately", true), bo("data", [mo("primary"), mo("menus"), mo("expansions")]), Eo("fakeFocus", false), Ju("onHighlight"), Ju("onHover"), Yu(), mo("dom"), Eo("navigateOnHover", true), Eo("stayInDom", false), Zs("tmenuBehaviours", [Fg, hd, cd, Rg]), Eo("eventOrder", {})], apis: { collapseMenu: function(t2, n2) {
      t2.collapseMenu(n2);
    }, highlightPrimary: function(t2, n2) {
      t2.highlightPrimary(n2);
    }, repositionMenus: function(t2, n2) {
      t2.repositionMenus(n2);
    } }, factory: function(a2, t2) {
      function e3(t3) {
        var o3, r3, n3 = (o3 = t3, r3 = a2.data.primary, dt(a2.data.menus, function(t4, n4) {
          function e5() {
            return tp.sketch(lt2(lt2({}, t4), { value: n4, markers: a2.markers, fakeFocus: a2.fakeFocus, onHighlight: a2.onHighlight, focusManager: (a2.fakeFocus ? Ul : Wl)() }));
          }
          return n4 === r3 ? { type: "prepared", menu: o3.getSystem().build(e5()) } : { type: "notbuilt", nbMenu: e5 };
        })), e4 = dt(a2.data.menus, function(t4, n4) {
          return z(t4.items, function(t5) {
            return "separator" === t5.type ? [] : [t5.data.value];
          });
        });
        return g2.setContents(a2.data.primary, n3, a2.data.expansions, e4), g2.getPrimary();
      }
      function c2(t3) {
        return Df.getValue(t3).value;
      }
      function u2(n3, t3) {
        hd.highlight(n3, t3), hd.getHighlighted(t3).orThunk(function() {
          return hd.getFirst(t3);
        }).each(function(t4) {
          xr(n3, t4.element, Ri());
        });
      }
      function s2(n3, t3) {
        return et(M(t3, function(t4) {
          return n3.lookupMenu(t4).bind(function(t5) {
            return "prepared" === t5.type ? vt.some(t5.menu) : vt.none();
          });
        }));
      }
      function l2(n3, t3, e4) {
        var o3 = s2(t3, t3.otherMenus(e4));
        St(o3, function(t4) {
          $r(t4.element, [a2.markers.backgroundMenu]), a2.stayInDom || Rg.remove(n3, t4);
        });
      }
      function f2(t3, o3) {
        var n3;
        J((n3 = t3, r2.get().getOrThunk(function() {
          var e4 = {}, t4 = F(vs(n3.element, "." + a2.markers.item), function(t5) {
            return "true" === un(t5, "aria-haspopup");
          });
          return St(t4, function(t5) {
            n3.getSystem().getByDom(t5).each(function(t6) {
              var n4 = c2(t6);
              e4[n4] = t6;
            });
          }), r2.set(e4), e4;
        })), function(t4, n4) {
          var e4 = wt(o3, n4);
          on(t4.element, "aria-expanded", e4);
        });
      }
      function d2(o3, r3, i3) {
        return vt.from(i3[0]).bind(function(t3) {
          return r3.lookupMenu(t3).bind(function(t4) {
            if ("notbuilt" === t4.type)
              return vt.none();
            var n3 = t4.menu, e4 = s2(r3, i3.slice(1));
            return St(e4, function(t5) {
              Yr(t5.element, a2.markers.backgroundMenu);
            }), ve(n3.element) || Rg.append(o3, Eu(n3)), $r(n3.element, [a2.markers.backgroundMenu]), u2(o3, n3), l2(o3, r3, i3), vt.some(n3);
          });
        });
      }
      var m3, n2, r2 = gc(), g2 = ep();
      function i2(r3, i3, u3) {
        if (void 0 === u3 && (u3 = m3.HighlightSubmenu), i3.hasConfigured(gd) && gd.isDisabled(i3))
          return vt.some(i3);
        var t3 = c2(i3);
        return g2.expand(t3).bind(function(o3) {
          return f2(r3, o3), vt.from(o3[0]).bind(function(e4) {
            return g2.lookupMenu(e4).bind(function(t4) {
              var n3 = function(t5, n4, e5) {
                if ("notbuilt" !== e5.type)
                  return e5.menu;
                var o4 = t5.getSystem().build(e5.nbMenu());
                return g2.setMenuBuilt(n4, o4), o4;
              }(r3, e4, t4);
              return ve(n3.element) || Rg.append(r3, Eu(n3)), a2.onOpenSubmenu(r3, i3, n3, L(o3)), u3 === m3.HighlightSubmenu ? (hd.highlightFirst(n3), d2(r3, g2, o3)) : (hd.dehighlightAll(n3), vt.some(i3));
            });
          });
        });
      }
      function o2(n3, e4) {
        var t3 = c2(e4);
        return g2.collapse(t3).bind(function(t4) {
          return f2(n3, t4), d2(n3, g2, t4).map(function(t5) {
            return a2.onCollapseMenu(n3, e4, t5), t5;
          });
        });
      }
      function p2(e4) {
        return function(n3, t3) {
          return Ru(t3.getSource(), "." + a2.markers.item).bind(function(t4) {
            return n3.getSystem().getByDom(t4).toOptional().bind(function(t5) {
              return e4(n3, t5).map(D);
            });
          });
        };
      }
      function h2(t3) {
        return hd.getHighlighted(t3).bind(hd.getHighlighted);
      }
      (n2 = m3 = {})[n2.HighlightSubmenu = 0] = "HighlightSubmenu", n2[n2.HighlightParent = 1] = "HighlightParent";
      var v4 = eu([Cr(Zg(), function(e4, o3) {
        var t3 = o3.event.item;
        g2.lookupItem(c2(t3)).each(function() {
          var t4 = o3.event.menu;
          hd.highlight(e4, t4);
          var n3 = c2(o3.event.item);
          g2.refresh(n3).each(function(t5) {
            return l2(e4, g2, t5);
          });
        });
      }), uu(function(n3, t3) {
        var e4 = t3.event.target;
        n3.getSystem().getByDom(e4).each(function(t4) {
          0 === c2(t4).indexOf("collapse-item") && o2(n3, t4), i2(n3, t4, m3.HighlightSubmenu).fold(function() {
            a2.onExecute(n3, t4);
          }, st);
        });
      }), ou(function(n3, t3) {
        e3(n3).each(function(t4) {
          Rg.append(n3, Eu(t4)), a2.onOpenMenu(n3, t4), a2.highlightImmediately && u2(n3, t4);
        });
      })].concat(a2.navigateOnHover ? [Cr(jg(), function(t3, n3) {
        var e4 = n3.event.item, o3 = t3, r3 = c2(e4);
        g2.refresh(r3).bind(function(t4) {
          return f2(o3, t4), d2(o3, g2, t4);
        }), i2(t3, e4, m3.HighlightParent), a2.onHover(t3, e4);
      })] : [])), b2 = { collapseMenu: function(n3) {
        h2(n3).each(function(t3) {
          o2(n3, t3);
        });
      }, highlightPrimary: function(n3) {
        g2.getPrimary().each(function(t3) {
          u2(n3, t3);
        });
      }, repositionMenus: function(o3) {
        g2.getPrimary().bind(function(n3) {
          return h2(o3).bind(function(t3) {
            var n4 = c2(t3), e4 = et(M(Z(g2.getMenus()), op));
            return g2.getTriggeringPath(n4, function(t4) {
              return n5 = t4, K(e4, function(t5) {
                return t5.getSystem().isConnected() ? V(hd.getCandidates(t5), function(t6) {
                  return c2(t6) === n5;
                }) : vt.none();
              });
              var n5;
            });
          }).map(function(t3) {
            return { primary: n3, triggeringPath: t3 };
          });
        }).fold(function() {
          vt.from(o3.components()[0]).filter(function(t3) {
            return "menu" === un(t3.element, "role");
          }).each(function(t3) {
            a2.onRepositionMenu(o3, t3, []);
          });
        }, function(t3) {
          var n3 = t3.primary, e4 = t3.triggeringPath;
          a2.onRepositionMenu(o3, n3, e4);
        });
      } };
      return { uid: a2.uid, dom: a2.dom, markers: a2.markers, behaviours: nl(a2.tmenuBehaviours, [Fg.config({ mode: "special", onRight: p2(function(t3, n3) {
        return Ol(n3.element) ? vt.none() : i2(t3, n3, m3.HighlightSubmenu);
      }), onLeft: p2(function(t3, n3) {
        return Ol(n3.element) ? vt.none() : o2(t3, n3);
      }), onEscape: p2(function(t3, n3) {
        return o2(t3, n3).orThunk(function() {
          return a2.onEscape(t3, n3).map(function() {
            return t3;
          });
        });
      }), focusIn: function(n3, t3) {
        g2.getPrimary().each(function(t4) {
          xr(n3, t4.element, Ri());
        });
      } }), hd.config({ highlightClass: a2.markers.selectedMenu, itemClass: a2.markers.menu }), cd.config({ find: function(t3) {
        return hd.getHighlighted(t3);
      } }), Rg.config({})]), eventOrder: a2.eventOrder, apis: b2, events: v4 };
    }, extraApis: { tieredData: function(t2, n2, e3) {
      return { primary: t2, menus: n2, expansions: e3 };
    }, singleData: function(t2, n2) {
      return { primary: t2, menus: sr(t2, n2), expansions: {} };
    }, collapseItem: function(t2) {
      return { value: Ir(rp()), meta: { text: t2 } };
    } } }), up = kl({ name: "InlineView", configFields: [mo("lazySink"), Ju("onShow"), Ju("onHide"), Oo("onEscape"), Zs("inlineBehaviours", [bf, Df, ic]), To("fireDismissalEventInstead", [Eo("event", Yi())]), To("fireRepositionEventInstead", [Eo("event", qi())]), Eo("getRelated", vt.none), Eo("isExtraPart", T), Eo("eventOrder", vt.none)], factory: function(d2, t2) {
      function n2(e4) {
        bf.isOpen(e4) && Df.getValue(e4).each(function(t3) {
          switch (t3.mode) {
            case "menu":
              bf.getState(e4).each(ip.repositionMenus);
              break;
            case "position":
              var n3 = d2.lazySink(e4).getOrDie();
              ff.positionWithinBounds(n3, e4, t3.config, t3.getBounds());
          }
        });
      }
      function o2(t3, n3, e4, o3) {
        i2(t3, n3, e4, function() {
          return o3.map(function(t4) {
            return Ae(t4);
          });
        });
      }
      function r2(t3, n3, e4, o3) {
        var r3, i3, u2, a2, c2, s2 = (r3 = d2, i3 = t3, u2 = n3, a2 = o3, c2 = "horizontal" === e4.type ? { layouts: { onLtr: ha, onRtl: va } } : {}, ip.sketch({ dom: { tag: "div" }, data: e4.data, markers: e4.menu.markers, highlightImmediately: e4.menu.highlightImmediately, onEscape: function() {
          return bf.close(i3), r3.onEscape.map(function(t4) {
            return t4(i3);
          }), vt.some(true);
        }, onExecute: function() {
          return vt.some(true);
        }, onOpenMenu: function(t4, n4) {
          ff.positionWithinBounds(l2().getOrDie(), n4, u2, a2());
        }, onOpenSubmenu: function(t4, n4, e5, o4) {
          var r4 = l2().getOrDie();
          ff.position(r4, e5, { anchor: lt2({ type: "submenu", item: n4 }, f2(o4)) });
        }, onRepositionMenu: function(t4, n4, e5) {
          var o4 = l2().getOrDie();
          ff.positionWithinBounds(o4, n4, u2, a2()), St(e5, function(t5) {
            var n5 = f2(t5.triggeringPath);
            ff.position(o4, t5.triggeredMenu, { anchor: lt2({ type: "submenu", item: t5.triggeringItem }, n5) });
          });
        } }));
        function l2() {
          return r3.lazySink(i3);
        }
        function f2(t4) {
          return 2 === t4.length ? c2 : {};
        }
        bf.open(t3, s2), Df.setValue(t3, vt.some({ mode: "menu", menu: s2 }));
      }
      var i2 = function(t3, n3, e4, o3) {
        var r3 = d2.lazySink(t3).getOrDie();
        bf.openWhileCloaked(t3, n3, function() {
          return ff.positionWithinBounds(r3, t3, e4, o3());
        }), Df.setValue(t3, vt.some({ mode: "position", config: e4, getBounds: o3 }));
      }, e3 = { setContent: function(t3, n3) {
        bf.setContent(t3, n3);
      }, showAt: function(t3, n3, e4) {
        o2(t3, n3, e4, vt.none());
      }, showWithin: o2, showWithinBounds: i2, showMenuAt: function(t3, n3, e4) {
        r2(t3, n3, e4, vt.none);
      }, showMenuWithinBounds: r2, hide: function(t3) {
        bf.isOpen(t3) && (Df.setValue(t3, vt.none()), bf.close(t3));
      }, getContent: function(t3) {
        return bf.getState(t3);
      }, reposition: n2, isOpen: bf.isOpen };
      return { uid: d2.uid, dom: d2.dom, behaviours: nl(d2.inlineBehaviours, [bf.config({ isPartOf: function(t3, n3, e4) {
        return zu(n3, e4) || (o3 = e4, d2.getRelated(t3).exists(function(t4) {
          return zu(t4, o3);
        }));
        var o3;
      }, getAttachPoint: function(t3) {
        return d2.lazySink(t3).getOrDie();
      }, onOpen: function(t3) {
        d2.onShow(t3);
      }, onClose: function(t3) {
        d2.onHide(t3);
      } }), Df.config({ store: { mode: "memory", initialValue: vt.none() } }), ic.config({ channels: lt2(lt2({}, Xs(lt2({ isExtraPart: t2.isExtraPart }, d2.fireDismissalEventInstead.map(function(t3) {
        return { fireEventInstead: { event: t3.event } };
      }).getOr({})))), Ys(lt2(lt2({}, d2.fireRepositionEventInstead.map(function(t3) {
        return { fireEventInstead: { event: t3.event } };
      }).getOr({})), { doReposition: n2 }))) })]), eventOrder: d2.eventOrder, apis: e3 };
    }, apis: { showAt: function(t2, n2, e3, o2) {
      t2.showAt(n2, e3, o2);
    }, showWithin: function(t2, n2, e3, o2, r2) {
      t2.showWithin(n2, e3, o2, r2);
    }, showWithinBounds: function(t2, n2, e3, o2, r2) {
      t2.showWithinBounds(n2, e3, o2, r2);
    }, showMenuAt: function(t2, n2, e3, o2) {
      t2.showMenuAt(n2, e3, o2);
    }, showMenuWithinBounds: function(t2, n2, e3, o2, r2) {
      t2.showMenuWithinBounds(n2, e3, o2, r2);
    }, hide: function(t2, n2) {
      t2.hide(n2);
    }, isOpen: function(t2, n2) {
      return t2.isOpen(n2);
    }, getContent: function(t2, n2) {
      return t2.getContent(n2);
    }, setContent: function(t2, n2, e3) {
      t2.setContent(n2, e3);
    }, reposition: function(t2, n2) {
      t2.reposition(n2);
    } } }), ap = "layout-inset", cp = function(t2, n2, e3) {
      return ea(Om(t2, n2), t2.y, e3.insetNorth(), Na(), "north", ra(t2, { top: 2 }), ap);
    }, sp = function(t2, n2, e3) {
      return ea(Om(t2, n2), Tm(t2, n2), e3.insetSouth(), La(), "south", ra(t2, { bottom: 3 }), ap);
    }, lp = tinymce.util.Tools.resolve("tinymce.util.Delay"), fp = kl({ name: "Button", factory: function(t2) {
      function e3(n3) {
        return tt(t2.dom, "attributes").bind(function(t3) {
          return tt(t3, n3);
        });
      }
      var n2 = Sm(t2.action), o2 = t2.dom.tag;
      return { uid: t2.uid, dom: t2.dom, components: t2.components, events: n2, behaviours: Mf(t2.buttonBehaviours, [Hg.config({}), Fg.config({ mode: "execution", useSpace: true, useEnter: true })]), domModification: { attributes: function() {
        if ("button" !== o2)
          return { role: e3("role").getOr("button") };
        var t3 = e3("type").getOr("button"), n3 = e3("role").map(function(t4) {
          return { role: t4 };
        }).getOr({});
        return lt2({ type: t3 }, n3);
      }() }, eventOrder: t2.eventOrder };
    }, configFields: [Eo("uid", void 0), mo("dom"), Eo("components", []), Bf("buttonBehaviours", [Hg, Fg]), wo("action"), wo("role"), Eo("eventOrder", {})] }), dp = tinymce.util.Tools.resolve("tinymce.util.I18n"), mp = { indent: true, outdent: true, "table-insert-column-after": true, "table-insert-column-before": true, "paste-column-after": true, "paste-column-before": true, "unordered-list": true, "list-bull-circle": true, "list-bull-default": true, "list-bull-square": true }, gp = "temporary-placeholder", pp = { success: "checkmark", error: "warning", err: "error", warning: "warning", warn: "warning", info: "info" }, hp = kl({ name: "Notification", factory: function(n2) {
      function e3(t3) {
        return { dom: { tag: "div", classes: ["tox-bar"], attributes: { style: "width: " + t3 + "%" } } };
      }
      function o2(t3) {
        return { dom: { tag: "div", classes: ["tox-text"], innerHtml: t3 + "%" } };
      }
      var t2, r2, i2, u2, a2 = zm({ dom: { tag: "p", innerHtml: n2.translationProvider(n2.text) }, behaviours: nc([Rg.config({})]) }), c2 = zm({ dom: { tag: "div", classes: n2.progress ? ["tox-progress-bar", "tox-progress-indicator"] : ["tox-progress-bar"] }, components: [{ dom: { tag: "div", classes: ["tox-bar-container"] }, components: [e3(0)] }, o2(0)], behaviours: nc([Rg.config({})]) }), s2 = { updateProgress: function(t3, n3) {
        t3.getSystem().isConnected() && c2.getOpt(t3).each(function(t4) {
          Rg.set(t4, [{ dom: { tag: "div", classes: ["tox-bar-container"] }, components: [e3(n3)] }, o2(n3)]);
        });
      }, updateText: function(t3, n3) {
        var e4;
        t3.getSystem().isConnected() && (e4 = a2.get(t3), Rg.set(e4, [ri(n3)]));
      } }, l2 = ft([n2.icon.toArray(), n2.level.toArray(), n2.level.bind(function(t3) {
        return vt.from(pp[t3]);
      }).toArray()]), f2 = zm(fp.sketch({ dom: { tag: "button", classes: ["tox-notification__dismiss", "tox-button", "tox-button--naked", "tox-button--icon"] }, components: [Xm("close", { tag: "div", classes: ["tox-icon"], attributes: { "aria-label": n2.translationProvider("Close") } }, n2.iconProvider)], action: function(t3) {
        n2.onAction(t3);
      } })), d2 = [(t2 = l2, r2 = { tag: "div", classes: ["tox-notification__icon"] }, i2 = n2.iconProvider, u2 = i2(), Gm(r2, V(t2, function(t3) {
        return Tt(u2, Lm(t3, u2));
      }).getOr(gp), u2, vt.none())), { dom: { tag: "div", classes: ["tox-notification__body"] }, components: [a2.asSpec()], behaviours: nc([Rg.config({})]) }];
      return { uid: n2.uid, dom: { tag: "div", attributes: { role: "alert" }, classes: n2.level.map(function(t3) {
        return ["tox-notification", "tox-notification--in", "tox-notification--" + t3];
      }).getOr(["tox-notification", "tox-notification--in"]) }, behaviours: nc([Hg.config({}), mm("notification-events", [Cr(bi(), function(t3) {
        f2.getOpt(t3).each(Hg.focus);
      })])]), components: d2.concat(n2.progress ? [c2.asSpec()] : []).concat(n2.closeButton ? [f2.asSpec()] : []), apis: s2 };
    }, configFields: [wo("level"), mo("progress"), mo("icon"), mo("onAction"), mo("text"), mo("iconProvider"), mo("translationProvider"), Fo("closeButton", true)], apis: { updateProgress: function(t2, n2, e3) {
      t2.updateProgress(n2, e3);
    }, updateText: function(t2, n2, e3) {
      t2.updateText(n2, e3);
    } } });
    function vp(e3, o2) {
      function r2() {
        b(i2) || (clearTimeout(i2), i2 = null);
      }
      var i2 = null;
      return { cancel: r2, throttle: function() {
        for (var t2 = [], n2 = 0; n2 < arguments.length; n2++)
          t2[n2] = arguments[n2];
        r2(), i2 = setTimeout(function() {
          i2 = null, e3.apply(null, t2);
        }, o2);
      } };
    }
    function bp(o2, t2, n2, e3, r2) {
      var i2 = Bp(o2, function(t3) {
        return (n3 = o2).isBlock(e4 = t3) || wt(["BR", "IMG", "HR", "INPUT"], e4.nodeName) || "false" === n3.getContentEditable(e4);
        var n3, e4;
      });
      return vt.from(i2.backwards(t2, n2, e3, r2));
    }
    function yp(e3, n2) {
      return Mp(At.fromDom(e3.selection.getNode())).getOrThunk(function() {
        var i2, u2, t2 = At.fromHtml('<span data-mce-autocompleter="1" data-mce-bogus="1"></span>', e3.getDoc());
        return Te(t2, At.fromDom(n2.extractContents())), n2.insertNode(t2.dom), Yt(t2).each(function(t3) {
          return t3.dom.normalize();
        }), i2 = hs, (u2 = function(t3) {
          for (var n3 = Kt(t3), e4 = n3.length - 1; 0 <= e4; e4--) {
            var o2 = n3[e4];
            if (i2(o2))
              return vt.some(o2);
            var r2 = u2(o2);
            if (r2.isSome())
              return r2;
          }
          return vt.none();
        })(t2).map(function(t3) {
          var n3;
          e3.selection.setCursorLocation(t3.dom, "img" === Ft(n3 = t3) ? 1 : ps(n3).fold(function() {
            return Kt(n3).length;
          }, function(t4) {
            return t4.length;
          }));
        }), t2;
      });
    }
    function xp(t2) {
      return t2.toString().replace(/\u00A0/g, " ").replace(/\uFEFF/g, "");
    }
    function wp(t2) {
      return "" !== t2 && -1 !== "  \f\n\r	\v".indexOf(t2);
    }
    function Sp(t2, n2) {
      return t2.substring(n2.length);
    }
    function kp(o2, t2, r2, n2) {
      return void 0 === n2 && (n2 = 0), Mp(At.fromDom(t2.startContainer)).fold(function() {
        return function(t3, o3, i2, r3) {
          if (void 0 === r3 && (r3 = 0), !o3.collapsed || 3 !== o3.startContainer.nodeType)
            return vt.none();
          var n3 = t3.getParent(o3.startContainer, t3.isBlock) || t3.getRoot();
          return bp(t3, o3.startContainer, o3.startOffset, function(t4, r4, n4) {
            return function(t5, n5) {
              for (var e3 = r4 - 1; 0 <= e3; e3--) {
                var o4 = t5.charAt(e3);
                if (wp(o4))
                  return vt.none();
                if (o4 === n5)
                  break;
              }
              return vt.some(e3);
            }(n4, i2).getOr(r4);
          }, n3).bind(function(t4) {
            var n4 = o3.cloneRange();
            if (n4.setStart(t4.container, t4.offset), n4.setEnd(o3.endContainer, o3.endOffset), n4.collapsed)
              return vt.none();
            var e3 = xp(n4);
            return 0 !== e3.lastIndexOf(i2) || Sp(e3, i2).length < r3 ? vt.none() : vt.some({ text: Sp(e3, i2), range: n4, triggerChar: i2 });
          });
        }(o2, t2, r2, n2);
      }, function(t3) {
        var n3 = o2.createRng();
        n3.selectNode(t3.dom);
        var e3 = xp(n3);
        return vt.some({ range: n3, text: Sp(e3, r2), triggerChar: r2 });
      });
    }
    function Cp(t2, n2) {
      return { container: t2, offset: n2 };
    }
    function Op(t2) {
      return ao("toolbarbutton", zp, t2);
    }
    function _p(t2) {
      return ao("ToggleButton", Lp, t2);
    }
    function Tp(n2, t2, e3, o2) {
      void 0 === o2 && (o2 = {});
      var r2 = t2(), i2 = n2.selection.getRng().startContainer.nodeValue, u2 = F(r2.lookupByChar(e3.triggerChar), function(t3) {
        return e3.text.length >= t3.minChars && t3.matches.getOrThunk(function() {
          return e4 = n2.dom, function(t4) {
            var n3 = Ip(t4.startContainer, t4.startOffset);
            return !bp(e4, n3.container, n3.offset, function(t5, n4) {
              return 0 === n4 ? -1 : n4;
            }, e4.getRoot()).filter(function(t5) {
              return !wp(t5.container.data.charAt(t5.offset - 1));
            }).isSome();
          };
          var e4;
        })(e3.range, i2, e3.text);
      });
      if (0 === u2.length)
        return vt.none();
      var a2 = Ap.all(M(u2, function(n3) {
        return n3.fetch(e3.text, n3.maxResults, o2).then(function(t3) {
          return { matchText: e3.text, items: t3, columns: n3.columns, onAction: n3.onAction, highlightOn: n3.highlightOn };
        });
      }));
      return vt.some({ lookupData: a2, context: e3 });
    }
    var Ep, Dp, Bp = tinymce.util.Tools.resolve("tinymce.dom.TextSeeker"), Mp = function(t2) {
      return Ru(t2, "[data-mce-autocompleter]");
    }, Ap = tinymce.util.Tools.resolve("tinymce.util.Promise"), Fp = function(t2) {
      if (3 === t2.nodeType)
        return Cp(t2, t2.data.length);
      var n2 = t2.childNodes;
      return 0 < n2.length ? Fp(n2[n2.length - 1]) : Cp(t2, n2.length);
    }, Ip = function(t2, n2) {
      var e3 = t2.childNodes;
      return 0 < e3.length && n2 < e3.length ? Ip(e3[n2], 0) : 0 < e3.length && 1 === t2.nodeType && e3.length === n2 ? Fp(e3[e3.length - 1]) : Cp(t2, n2);
    }, Rp = $o([po("type"), Co("text")]), Vp = $o([Eo("type", "autocompleteitem"), Eo("active", false), Eo("disabled", false), Eo("meta", {}), po("value"), Co("text"), Co("icon")]), Pp = $o([po("type"), po("ch"), Bo("minChars", 1), Eo("columns", 1), Bo("maxResults", 10), Oo("matches"), vo("fetch"), vo("onAction"), Ro("highlightOn", [], nr)]), Hp = [Fo("disabled", false), Co("tooltip"), Co("icon"), Co("text"), Io("onSetup", function() {
      return st;
    })], zp = $o([po("type"), vo("onAction")].concat(Hp)), Np = [Fo("active", false)].concat(Hp), Lp = $o(Np.concat([po("type"), vo("onAction")])), Wp = [Io("predicate", T), Ao("scope", "node", ["node", "editor"]), Ao("position", "selection", ["node", "selection", "line"])], Up = Hp.concat([Eo("type", "contextformbutton"), Eo("primary", false), vo("onAction"), cr("original", h)]), jp = Np.concat([Eo("type", "contextformbutton"), Eo("primary", false), vo("onAction"), cr("original", h)]), Gp = Hp.concat([Eo("type", "contextformbutton")]), Xp = Np.concat([Eo("type", "contextformtogglebutton")]), Yp = lo("type", { contextformbutton: Up, contextformtogglebutton: jp }), qp = $o([Eo("type", "contextform"), Io("initValue", rt2("")), Co("label"), xo("commands", Yp), So("launch", lo("type", { contextformbutton: Gp, contextformtogglebutton: Xp }))].concat(Wp)), Kp = $o([Eo("type", "contexttoolbar"), po("items")].concat(Wp));
    function Jp(t2) {
      return tt(_h, t2).getOr(kh);
    }
    function $p(t2) {
      return { backgroundMenu: "tox-background-menu", selectedMenu: "tox-selected-menu", selectedItem: "tox-collection__item--active", hasIcons: "tox-menu--has-icons", menu: "color" === t2 ? "tox-swatches" : "tox-menu", tieredMenu: "tox-tiered-menu" };
    }
    function Qp(t2) {
      var n2 = $p(t2);
      return { backgroundMenu: n2.backgroundMenu, selectedMenu: n2.selectedMenu, menu: n2.menu, selectedItem: n2.selectedItem, item: Jp(t2) };
    }
    function Zp(t2, n2, e3) {
      return { dom: { tag: "div", classes: ft([[$p(e3).tieredMenu]]) }, markers: Qp(e3) };
    }
    function th(n2, e3) {
      return function(t2) {
        return M(p(t2, e3), function(t3) {
          return { dom: n2, components: t3 };
        });
      };
    }
    function nh(t2, e3) {
      var o2 = [], r2 = [];
      return St(t2, function(t3, n2) {
        e3(t3, n2) ? (0 < r2.length && o2.push(r2), r2 = [], Tt(t3.dom, "innerHtml") && r2.push(t3)) : r2.push(t3);
      }), 0 < r2.length && o2.push(r2), M(o2, function(t3) {
        return { dom: { tag: "div", classes: ["tox-collection__group"] }, components: t3 };
      });
    }
    function eh(n2, e3) {
      return { dom: { tag: "div", classes: ["tox-menu", "tox-collection"].concat(1 === n2 ? ["tox-collection--list"] : ["tox-collection--grid"]) }, components: [tp.parts.items({ preprocess: function(t2) {
        return "auto" !== n2 && 1 < n2 ? th({ tag: "div", classes: ["tox-collection__group"] }, n2)(t2) : nh(t2, function(t3, n3) {
          return "separator" === e3[n3].type;
        });
      } })] };
    }
    function oh(t2) {
      return d(t2, function(t3) {
        return "icon" in t3 && void 0 !== t3.icon;
      });
    }
    function rh(t2) {
      return console.error(ur(t2)), console.log(t2), vt.none();
    }
    function ih(t2, n2, e3, o2, r2) {
      var i2, u2 = (i2 = e3, { dom: { tag: "div", classes: ["tox-collection", "tox-collection--horizontal"] }, components: [tp.parts.items({ preprocess: function(t3) {
        return nh(t3, function(t4, n3) {
          return "separator" === i2[n3].type;
        });
      } })] });
      return { value: t2, dom: u2.dom, components: u2.components, items: e3 };
    }
    function uh(t2, n2, e3, o2, r2) {
      var i2, u2;
      return "color" === r2 ? { value: t2, dom: (i2 = { dom: { tag: "div", classes: ["tox-menu", "tox-swatches-menu"] }, components: [{ dom: { tag: "div", classes: ["tox-swatches"] }, components: [tp.parts.items({ preprocess: "auto" !== o2 ? th({ tag: "div", classes: ["tox-swatches__row"] }, o2) : h })] }] }).dom, components: i2.components, items: e3 } : "normal" === r2 && "auto" === o2 ? { value: t2, dom: (i2 = eh(o2, e3)).dom, components: i2.components, items: e3 } : "normal" === r2 && 1 === o2 ? { value: t2, dom: (i2 = eh(1, e3)).dom, components: i2.components, items: e3 } : "normal" === r2 ? { value: t2, dom: (i2 = eh(o2, e3)).dom, components: i2.components, items: e3 } : "listpreview" !== r2 || "auto" === o2 ? { value: t2, dom: { tag: "div", classes: ft([[(u2 = $p(r2)).menu, "tox-menu-" + o2 + "-column"], n2 ? [u2.hasIcons] : []]) }, components: Ih, items: e3 } : { value: t2, dom: (i2 = { dom: { tag: "div", classes: ["tox-menu", "tox-collection", "tox-collection--toolbar", "tox-collection--toolbar-lg"] }, components: [tp.parts.items({ preprocess: th({ tag: "div", classes: ["tox-collection__group"] }, o2) })] }).dom, components: i2.components, items: e3 };
    }
    function ah(t2, o2, n2) {
      var r2 = vs(t2.element, "." + n2);
      if (0 < r2.length) {
        var e3 = P(r2, function(t3) {
          var n3 = t3.dom.getBoundingClientRect().top, e4 = r2[0].dom.getBoundingClientRect().top;
          return Math.abs(n3 - e4) > o2;
        }).getOr(r2.length);
        return vt.some({ numColumns: e3, numRows: Math.ceil(r2.length / e3) });
      }
      return vt.none();
    }
    function ch(t2, n2, e3) {
      t2.getSystem().broadcastOn([Jh], {});
    }
    function sh(t2) {
      return t2.getParam("height", Math.max(t2.getElement().offsetHeight, 200));
    }
    function lh(t2) {
      return t2.getParam("width", ev.DOM.getStyle(t2.getElement(), "width"));
    }
    function fh(t2) {
      return vt.from(t2.getParam("min_width")).filter(u);
    }
    function dh(t2) {
      return vt.from(t2.getParam("min_height")).filter(u);
    }
    function mh(t2) {
      return vt.from(t2.getParam("max_width")).filter(u);
    }
    function gh(t2) {
      return vt.from(t2.getParam("max_height")).filter(u);
    }
    function ph(t2) {
      return false !== t2.getParam("menubar", true, "boolean");
    }
    function hh(t2) {
      var n2 = t2.getParam("toolbar", true), e3 = true === n2, o2 = y(n2), r2 = c(n2) && 0 < n2.length;
      return !rv(t2) && (r2 || o2 || e3);
    }
    function vh(n2) {
      var t2 = F(m2(9, function(t3) {
        return n2.getParam("toolbar" + (t3 + 1), false, "string");
      }), function(t3) {
        return "string" == typeof t3;
      });
      return 0 < t2.length ? vt.some(t2) : vt.none();
    }
    (Dp = Ep = {})[Dp.CLOSE_ON_EXECUTE = 0] = "CLOSE_ON_EXECUTE", Dp[Dp.BUBBLE_TO_SANDBOX = 1] = "BUBBLE_TO_SANDBOX";
    var bh, yh, xh, wh, Sh = Ep, kh = "tox-menu-nav__js", Ch = "tox-collection__item", Oh = "tox-swatch", _h = { normal: kh, color: Oh }, Th = "tox-collection__item--enabled", Eh = "tox-collection__item-icon", Dh = "tox-collection__item-label", Bh = "tox-collection__item-caret", Mh = "tox-collection__item--active", Ah = "tox-collection__item-container", Fh = "tox-collection__item-container--row", Ih = [tp.parts.items({})], Rh = [po("type"), po("src"), Co("alt"), Ro("classes", [], nr)], Vh = $o(Rh), Ph = [po("type"), po("text"), Co("name"), Ro("classes", ["tox-collection__item-label"], nr)], Hh = $o(Ph), zh = Ze(function() {
      return ro("type", { cardimage: Vh, cardtext: Hh, cardcontainer: Nh });
    }), Nh = $o([po("type"), Mo("direction", "horizontal"), Mo("align", "left"), Mo("valign", "middle"), xo("items", zh)]), Lh = [Fo("disabled", false), Co("text"), Co("shortcut"), ar("value", "value", je(function() {
      return Ir("menuitem-value");
    }), Zo()), Eo("meta", {})], Wh = $o([po("type"), Co("label"), xo("items", zh), Io("onSetup", function() {
      return st;
    }), Io("onAction", st)].concat(Lh)), Uh = $o([po("type"), Fo("active", false), Co("icon")].concat(Lh)), jh = [po("type"), po("fancytype"), Io("onAction", st)], Gh = lo("fancytype", { inserttable: [Eo("initData", {})].concat(jh), colorswatch: [Vo("initData", {}, [Fo("allowCustomColors", true), _o("colors", Zo())])].concat(jh) }), Xh = $o([po("type"), Io("onSetup", function() {
      return st;
    }), Io("onAction", st), Co("icon")].concat(Lh)), Yh = $o([po("type"), vo("getSubmenuItems"), Io("onSetup", function() {
      return st;
    }), Co("icon")].concat(Lh)), qh = $o([po("type"), Co("icon"), Fo("active", false), Io("onSetup", function() {
      return st;
    }), vo("onAction")].concat(Lh)), Kh = function(t2) {
      return n2 = Ir("unnamed-events"), nc([mm(n2, t2)]);
      var n2;
    }, Jh = Ir("tooltip.exclusive"), $h = Ir("tooltip.show"), Qh = Ir("tooltip.hide"), Zh = Object.freeze({ __proto__: null, hideAllExclusive: ch, setComponents: function(t2, n2, e3, o2) {
      e3.getTooltip().each(function(t3) {
        t3.getSystem().isConnected() && Rg.set(t3, o2);
      });
    } }), tv = Object.freeze({ __proto__: null, events: function(r2, i2) {
      function e3(n2) {
        i2.getTooltip().each(function(t2) {
          Hs(t2), r2.onHide(n2, t2), i2.clearTooltip();
        }), i2.clearTimer();
      }
      return eu(ft([[Cr($h, function(o2) {
        i2.resetTimer(function() {
          var t2, n2, e4 = o2;
          i2.isShowing() || (ch(e4), t2 = r2.lazySink(e4).getOrDie(), n2 = e4.getSystem().build({ dom: r2.tooltipDom, components: r2.tooltipComponents, events: eu("normal" === r2.mode ? [Cr(vi(), function(t3) {
            vr(e4, $h);
          }), Cr(pi(), function(t3) {
            vr(e4, Qh);
          })] : []), behaviours: nc([Rg.config({})]) }), i2.setTooltip(n2), Vs(t2, n2), r2.onShow(e4, n2), ff.position(t2, n2, { anchor: r2.anchor(e4) }));
        }, r2.delay);
      }), Cr(Qh, function(t2) {
        i2.resetTimer(function() {
          e3(t2);
        }, r2.delay);
      }), Cr(Fi(), function(t2, n2) {
        n2.universal || wt(n2.channels, Jh) && e3(t2);
      }), ru(function(t2) {
        e3(t2);
      })], "normal" === r2.mode ? [Cr(bi(), function(t2) {
        vr(t2, $h);
      }), Cr(Mi(), function(t2) {
        vr(t2, Qh);
      }), Cr(vi(), function(t2) {
        vr(t2, $h);
      }), Cr(pi(), function(t2) {
        vr(t2, Qh);
      })] : [Cr(Zi(), function(t2, n2) {
        vr(t2, $h);
      }), Cr(tu(), function(t2) {
        vr(t2, Qh);
      })]]));
    } }), nv = xa({ fields: [mo("lazySink"), mo("tooltipDom"), Eo("exclusive", true), Eo("tooltipComponents", []), Eo("delay", 300), Ao("mode", "normal", ["normal", "follow-highlight"]), Eo("anchor", function(t2) {
      return { type: "hotspot", hotspot: t2, layouts: { onLtr: rt2([$a, Ja, Xa, qa, Ya, Ka]), onRtl: rt2([$a, Ja, Xa, qa, Ya, Ka]) } };
    }), Ju("onHide"), Ju("onShow")], name: "tooltipping", active: tv, state: Object.freeze({ __proto__: null, init: function() {
      function e3() {
        o2.on(clearTimeout);
      }
      var o2 = gc(), t2 = gc(), n2 = rt2("not-implemented");
      return wu({ getTooltip: t2.get, isShowing: t2.isSet, setTooltip: t2.set, clearTooltip: t2.clear, clearTimer: e3, resetTimer: function(t3, n3) {
        e3(), o2.set(setTimeout(t3, n3));
      }, readState: n2 });
    } }), apis: Zh }), ev = tinymce.util.Tools.resolve("tinymce.dom.DOMUtils"), ov = tinymce.util.Tools.resolve("tinymce.EditorManager"), rv = function(t2) {
      return vh(t2).fold(function() {
        return 0 < t2.getParam("toolbar", [], "string[]").length;
      }, D);
    };
    function iv(t2) {
      return t2.getParam("toolbar_mode", "", "string");
    }
    function uv(t2) {
      return t2.getParam("toolbar_location", xh.auto, "string");
    }
    function av(t2) {
      return uv(t2) === xh.bottom;
    }
    function cv(t2) {
      if (!t2.inline)
        return vt.none();
      var n2 = t2.getParam("fixed_toolbar_container", "", "string");
      if (0 < n2.length)
        return Iu(be(), n2);
      var e3 = t2.getParam("fixed_toolbar_container_target");
      return k(e3) ? vt.some(At.fromDom(e3)) : vt.none();
    }
    function sv(t2) {
      return t2.inline && cv(t2).isSome();
    }
    function lv(t2) {
      return cv(t2).getOrThunk(function() {
        return tn(ge(At.fromDom(t2.getElement())));
      });
    }
    function fv(t2) {
      return t2.inline && !ph(t2) && !hh(t2) && !rv(t2);
    }
    function dv(t2) {
      return (t2.getParam("toolbar_sticky", false, "boolean") || t2.inline) && !sv(t2) && !fv(t2);
    }
    function mv(t2, n2) {
      var e3 = t2.outerContainer.element;
      n2 && (t2.mothership.broadcastOn([yf()], { target: e3 }), t2.uiMothership.broadcastOn([yf()], { target: e3 })), t2.mothership.broadcastOn([Kv], { readonly: n2 }), t2.uiMothership.broadcastOn([Kv], { readonly: n2 });
    }
    function gv(t2, n2) {
      t2.on("init", function() {
        t2.mode.isReadOnly() && mv(n2, true);
      }), t2.on("SwitchMode", function() {
        return mv(n2, t2.mode.isReadOnly());
      }), t2.getParam("readonly", false, "boolean") && t2.setMode("readonly");
    }
    function pv() {
      var t2;
      return ic.config({ channels: ((t2 = {})[Kv] = { schema: Jv, onReceive: function(t3, n2) {
        gd.set(t3, n2.readonly);
      } }, t2) });
    }
    function hv(t2, n2) {
      var e3 = t2.getApi(n2);
      return function(t3) {
        t3(e3);
      };
    }
    function vv(e3, o2) {
      return ou(function(t2) {
        hv(e3, t2)(function(t3) {
          var n2 = e3.onSetup(t3);
          S(n2) && o2.set(n2);
        });
      });
    }
    function bv(n2, e3) {
      return ru(function(t2) {
        return hv(n2, t2)(e3.get());
      });
    }
    function yv(t2, n2, e3, o2) {
      var r2, i2, u2 = Po(st);
      return { type: "item", dom: n2.dom, components: tb(n2.optComponents), data: t2.data, eventOrder: Zv, hasSubmenu: t2.triggersSubmenu, itemBehaviours: nc([mm("item-events", [(r2 = t2, i2 = e3, uu(function(t3, n3) {
        hv(r2, t3)(r2.onAction), r2.triggersSubmenu || i2 !== Sh.CLOSE_ON_EXECUTE || (vr(t3, Hi()), n3.stop());
      })), vv(t2, u2), bv(t2, u2)]), gd.config({ disabled: function() {
        return t2.disabled || o2.isDisabled();
      }, disableClass: "tox-collection__item--state-disabled" }), pv(), Rg.config({})].concat(t2.itemBehaviours)) };
    }
    function xv(t2) {
      return { value: t2.value, meta: lt2({ text: t2.text.getOr("") }, t2.meta) };
    }
    function wv(t2, n2, e3) {
      return Xm(t2, { tag: "div", classes: e3 = void 0 === e3 ? [Eh] : e3 }, n2);
    }
    function Sv(t2) {
      return { dom: { tag: "div", classes: [Dh] }, components: [ri(dp.translate(t2))] };
    }
    function kv(t2, n2) {
      return { dom: { tag: "div", classes: n2, innerHtml: t2 } };
    }
    function Cv(t2, n2) {
      return { dom: { tag: "div", classes: [Dh] }, components: [{ dom: { tag: t2.tag, styles: t2.styles }, components: [ri(dp.translate(n2))] }] };
    }
    function Ov(t2) {
      return { dom: { tag: "div", classes: ["tox-collection__item-accessory"], innerHtml: (e3 = nb.mac ? { alt: "&#x2325;", ctrl: "&#x2303;", shift: "&#x21E7;", meta: "&#x2318;", access: "&#x2303;&#x2325;" } : { meta: "Ctrl", access: "Shift+Alt" }, n2 = M(t2.split("+"), function(t3) {
        var n3 = t3.toLowerCase().trim();
        return Tt(e3, n3) ? e3[n3] : t3;
      }), nb.mac ? n2.join("") : n2.join("+")) } };
      var e3, n2;
    }
    function _v(t2) {
      return wv("checkmark", t2, ["tox-collection__item-checkmark"]);
    }
    function Tv(t2) {
      var n2 = t2.map(function(t3) {
        return { attributes: { title: dp.translate(t3) } };
      }).getOr({});
      return lt2({ tag: "div", classes: [kh, Ch] }, n2);
    }
    function Ev(t2, n2, e3, o2) {
      return void 0 === o2 && (o2 = vt.none()), "color" === t2.presets ? (r2 = n2, i2 = o2, c2 = t2.ariaLabel, s2 = t2.value, { dom: (u2 = t2.iconContent.map(function(t3) {
        return n3 = r2.icons, e4 = i2, Wm(t3, o3 = n3()).or(e4).getOrThunk(Nm(o3));
        var n3, e4, o3;
      }).getOr(""), a2 = { tag: "div", attributes: c2.map(function(t3) {
        return { title: r2.translate(t3) };
      }).getOr({}), classes: ["tox-swatch"] }, lt2(lt2({}, a2), "custom" === s2 ? { tag: "button", classes: H(H([], a2.classes, true), ["tox-swatches__picker-btn"], false), innerHtml: u2 } : "remove" === s2 ? { classes: H(H([], a2.classes, true), ["tox-swatch--remove"], false), innerHtml: u2 } : { attributes: lt2(lt2({}, a2.attributes), { "data-mce-color": s2 }), styles: { "background-color": s2 } })), optComponents: [] }) : (l2 = t2, f2 = n2, d2 = o2, m3 = { tag: "div", classes: [Eh] }, g2 = e3 ? l2.iconContent.map(function(t3) {
        return Xm(t3, m3, f2.icons, d2);
      }).orThunk(function() {
        return vt.some({ dom: m3 });
      }) : vt.none(), p2 = l2.checkMark, h2 = vt.from(l2.meta).fold(function() {
        return Sv;
      }, function(t3) {
        return Tt(t3, "style") ? C(Cv, t3.style) : Sv;
      }), v4 = l2.htmlContent.fold(function() {
        return l2.textContent.map(h2);
      }, function(t3) {
        return vt.some(kv(t3, [Dh]));
      }), { dom: Tv(l2.ariaLabel), optComponents: [g2, v4, l2.shortcutContent.map(Ov), p2, l2.caret] });
      var r2, i2, u2, a2, c2, s2, l2, f2, d2, m3, g2, p2, h2, v4;
    }
    function Dv(t2, n2) {
      return tt(t2, "tooltipWorker").map(function(e3) {
        return [nv.config({ lazySink: n2.getSink, tooltipDom: { tag: "div", classes: ["tox-tooltip-worker-container"] }, tooltipComponents: [], anchor: function(t3) {
          return { type: "submenu", item: t3, overrides: { maxHeightFunction: Vc } };
        }, mode: "follow-highlight", onShow: function(n3, t3) {
          e3(function(t4) {
            nv.setComponents(n3, [Ou({ element: At.fromDom(t4) })]);
          });
        } })];
      }).getOr([]);
    }
    function Bv(t2, n2) {
      var e3 = dp.translate(t2), o2 = ev.DOM.encode(e3);
      if (0 < n2.length) {
        var r2 = new RegExp(n2.replace(/[.*+?^${}()|[\]\\]/g, "\\$&"), "gi");
        return o2.replace(r2, function(t3) {
          return '<span class="tox-autocompleter-highlight">' + t3 + "</span>";
        });
      }
      return o2;
    }
    function Mv(t2) {
      return { value: t2 };
    }
    function Av(t2) {
      return rb2.test(t2) || ib.test(t2);
    }
    function Fv(t2) {
      var n2 = t2.toString(16);
      return (1 === n2.length ? "0" + n2 : n2).toUpperCase();
    }
    function Iv(t2) {
      return Mv(Fv(t2.red) + Fv(t2.green) + Fv(t2.blue));
    }
    function Rv(t2, n2, e3, o2) {
      return { red: t2, green: n2, blue: e3, alpha: o2 };
    }
    function Vv(t2) {
      var n2 = parseInt(t2, 10);
      return n2.toString() === t2 && 0 <= n2 && n2 <= 255;
    }
    function Pv(t2) {
      var n2, e3, o2, r2 = (t2.hue || 0) % 360, i2 = t2.saturation / 100, u2 = t2.value / 100, i2 = ab(0, ub(i2, 1)), u2 = ab(0, ub(u2, 1));
      if (0 === i2)
        return Rv(n2 = e3 = o2 = cb(255 * u2), e3, o2, 1);
      var a2 = r2 / 60, c2 = u2 * i2, s2 = c2 * (1 - Math.abs(a2 % 2 - 1)), l2 = u2 - c2;
      switch (Math.floor(a2)) {
        case 0:
          n2 = c2, e3 = s2, o2 = 0;
          break;
        case 1:
          n2 = s2, e3 = c2, o2 = 0;
          break;
        case 2:
          n2 = 0, e3 = c2, o2 = s2;
          break;
        case 3:
          n2 = 0, e3 = s2, o2 = c2;
          break;
        case 4:
          n2 = s2, e3 = 0, o2 = c2;
          break;
        case 5:
          n2 = c2, e3 = 0, o2 = s2;
          break;
        default:
          n2 = e3 = o2 = 0;
      }
      return Rv(n2 = cb(255 * (n2 + l2)), e3 = cb(255 * (e3 + l2)), o2 = cb(255 * (o2 + l2)), 1);
    }
    function Hv(t2) {
      var n2, e3, o2 = (n2 = { value: t2.value.replace(rb2, function(t3, n3, e4, o3) {
        return n3 + n3 + e4 + e4 + o3 + o3;
      }) }, null === (e3 = ib.exec(n2.value)) ? ["FFFFFF", "FF", "FF", "FF"] : e3);
      return Rv(parseInt(o2[1], 16), parseInt(o2[2], 16), parseInt(o2[3], 16), 1);
    }
    function zv(t2, n2, e3, o2) {
      return Rv(parseInt(t2, 10), parseInt(n2, 10), parseInt(e3, 10), parseFloat(o2));
    }
    function Nv(t2) {
      if ("transparent" === t2)
        return vt.some(Rv(0, 0, 0, 0));
      var n2 = sb.exec(t2);
      if (null !== n2)
        return vt.some(zv(n2[1], n2[2], n2[3], "1"));
      var e3 = lb2.exec(t2);
      return null !== e3 ? vt.some(zv(e3[1], e3[2], e3[3], e3[4])) : vt.none();
    }
    function Lv(t2) {
      return "rgba(" + t2.red + "," + t2.green + "," + t2.blue + "," + t2.alpha + ")";
    }
    function Wv(t2, n2) {
      return t2.fire("ResizeContent", n2);
    }
    function Uv(t2, n2, e3) {
      return { hue: t2, saturation: n2, value: e3 };
    }
    function jv(t2) {
      var n2, e3, o2 = 0, r2 = t2.red / 255, i2 = t2.green / 255, u2 = t2.blue / 255, a2 = Math.min(r2, Math.min(i2, u2)), c2 = Math.max(r2, Math.max(i2, u2));
      return a2 === c2 ? Uv(0, 0, 100 * (o2 = a2)) : (e3 = 60 * ((r2 === a2 ? 3 : u2 === a2 ? 1 : 5) - (r2 === a2 ? i2 - u2 : u2 === a2 ? r2 - i2 : u2 - r2) / (c2 - a2)), n2 = (c2 - a2) / c2, o2 = c2, Uv(Math.round(e3), Math.round(100 * n2), Math.round(100 * o2)));
    }
    function Gv(t2) {
      return Iv(Pv(t2));
    }
    function Xv(o2) {
      return (Av(n2 = o2) ? vt.some({ value: (Dt(t2 = n2, "#") ? t2.substring("#".length) : t2).toUpperCase() }) : vt.none()).orThunk(function() {
        return Nv(o2).map(Iv);
      }).getOrThunk(function() {
        var t3 = document.createElement("canvas");
        t3.height = 1, t3.width = 1;
        var n3 = t3.getContext("2d");
        n3.clearRect(0, 0, t3.width, t3.height), n3.fillStyle = "#FFFFFF", n3.fillStyle = o2, n3.fillRect(0, 0, 1, 1);
        var e3 = n3.getImageData(0, 0, 1, 1).data;
        return Iv(Rv(e3[0], e3[1], e3[2], e3[3]));
      });
      var t2, n2;
    }
    (yh = bh = bh || {}).default = "wrap", yh.floating = "floating", yh.sliding = "sliding", yh.scrolling = "scrolling", (wh = xh = xh || {}).auto = "auto", wh.top = "top", wh.bottom = "bottom";
    function Yv(t2) {
      return gd.config({ disabled: t2, disableClass: "tox-tbtn--disabled" });
    }
    var qv, Kv = "silver.readonly", Jv = $o([go("readonly", er)]), $v = function(t2) {
      return gd.config({ disabled: t2 });
    }, Qv = function(t2) {
      return gd.config({ disabled: t2, disableClass: "tox-tbtn--disabled", useNative: false });
    }, Zv = ((qv = {})[Ii()] = ["disabling", "alloy.base.behaviour", "toggling", "item-events"], qv), tb = et, nb = tinymce.util.Tools.resolve("tinymce.Env"), eb = function(t2, a2) {
      return M(t2, function(t3) {
        switch (t3.type) {
          case "cardcontainer":
            return r2 = eb((o2 = t3).items, a2), i2 = "vertical" === o2.direction ? "tox-collection__item-container--column" : Fh, u2 = "left" === o2.align ? "tox-collection__item-container--align-left" : "tox-collection__item-container--align-right", { dom: { tag: "div", classes: [Ah, i2, u2, function() {
              switch (o2.valign) {
                case "top":
                  return "tox-collection__item-container--valign-top";
                case "middle":
                  return "tox-collection__item-container--valign-middle";
                case "bottom":
                  return "tox-collection__item-container--valign-bottom";
              }
            }()] }, components: r2 };
          case "cardimage":
            return e3 = t3.src, { dom: { tag: "img", classes: t3.classes, attributes: { src: e3, alt: t3.alt.getOr("") } } };
          case "cardtext":
            var n2 = t3.name.exists(function(t4) {
              return wt(a2.cardText.highlightOn, t4);
            }) ? vt.from(a2.cardText.matchText).getOr("") : "";
            return kv(Bv(t3.text, n2), t3.classes);
        }
        var e3, o2, r2, i2, u2;
      });
    }, ob = al(qg(), Kg()), rb2 = /^#?([a-f\d])([a-f\d])([a-f\d])$/i, ib = /^#?([a-f\d]{2})([a-f\d]{2})([a-f\d]{2})$/i, ub = Math.min, ab = Math.max, cb = Math.round, sb = /^rgb\((\d+),\s*(\d+),\s*(\d+)\)/, lb2 = /^rgba\((\d+),\s*(\d+),\s*(\d+),\s*(\d?(?:\.\d+)?)\)/, fb = Rv(255, 0, 0, 1), db = tinymce.util.Tools.resolve("tinymce.util.LocalStorage"), mb = "tinymce-custom-colors";
    function gb(t2) {
      return false !== t2.getParam("custom_colors");
    }
    function pb(t2) {
      var n2 = t2.getParam("color_map");
      return void 0 !== n2 ? function(t3) {
        for (var n3 = [], e3 = 0; e3 < t3.length; e3 += 2)
          n3.push({ text: t3[e3 + 1], value: "#" + Xv(t3[e3]).value, type: "choiceitem" });
        return n3;
      }(n2) : Mb;
    }
    function hb(t2) {
      Ab.add(t2);
    }
    function vb(t2) {
      var n2, e3 = (n2 = pb(t2).length, Math.max(5, Math.ceil(Math.sqrt(n2))));
      return t2.getParam("color_cols", e3, "number");
    }
    function bb(t2) {
      var n2 = "choiceitem", e3 = { type: n2, text: "Remove color", icon: "color-swatch-remove-color", value: "remove" };
      return t2 ? [e3, { type: n2, text: "Custom color", icon: "color-picker", value: "custom" }] : [e3];
    }
    function yb(n2, e3, t2, o2) {
      "custom" === t2 ? Ib(n2)(function(t3) {
        t3.each(function(t4) {
          hb(t4), n2.execCommand("mceApplyTextcolor", e3, t4), o2(t4);
        });
      }, Fb) : "remove" === t2 ? (o2(""), n2.execCommand("mceRemoveTextcolor", e3)) : (o2(t2), n2.execCommand("mceApplyTextcolor", e3, t2));
    }
    function xb(t2, n2) {
      return t2.concat(M(Ab.state(), function(t3) {
        return { type: Bb, text: t3, value: t3 };
      }).concat(bb(n2)));
    }
    function wb(n2, e3) {
      return function(t2) {
        t2(xb(n2, e3));
      };
    }
    function Sb(t2, n2, e3) {
      t2.setIconFill("forecolor" === n2 ? "tox-icon-text-color__color" : "tox-icon-highlight-bg-color__color", e3);
    }
    function kb(i2, e3, u2, t2, o2) {
      i2.ui.registry.addSplitButton(e3, { tooltip: t2, presets: "color", icon: "forecolor" === e3 ? "text-color" : "highlight-bg-color", select: function(e4) {
        var o3, r2 = u2;
        return i2.dom.getParents(i2.selection.getStart(), function(t3) {
          var n2;
          (n2 = t3.style["forecolor" === r2 ? "color" : "background-color"]) && (o3 = o3 || n2);
        }), vt.from(o3).bind(function(t3) {
          return Nv(t3).map(function(t4) {
            var n2 = Iv(t4).value;
            return ut(e4.toLowerCase(), n2);
          });
        }).getOr(false);
      }, columns: vb(i2), fetch: wb(pb(i2), gb(i2)), onAction: function(t3) {
        yb(i2, u2, o2.get(), st);
      }, onItemAction: function(t3, n2) {
        yb(i2, u2, n2, function(t4) {
          o2.set(t4), i2.fire("TextColorChange", { name: e3, color: t4 });
        });
      }, onSetup: function(n2) {
        function t3(t4) {
          t4.name === e3 && Sb(n2, t4.name, t4.color);
        }
        return Sb(n2, e3, o2.get()), i2.on("TextColorChange", t3), function() {
          i2.off("TextColorChange", t3);
        };
      } });
    }
    function Cb(n2, t2, e3, o2) {
      n2.ui.registry.addNestedMenuItem(t2, { text: o2, icon: "forecolor" === t2 ? "text-color" : "highlight-bg-color", getSubmenuItems: function() {
        return [{ type: "fancymenuitem", fancytype: "colorswatch", onAction: function(t3) {
          yb(n2, e3, t3.value, st);
        } }];
      } });
    }
    function Ob(t2, n2, e3, o2, r2, i2, u2, a2) {
      return uh(t2, oh(n2), Rb(n2, e3, o2, "color" !== r2 ? "normal" : "color", i2, u2, a2), o2, r2);
    }
    function _b2(t2, n2) {
      var e3 = Qp(n2);
      return 1 === t2 ? { mode: "menu", moveOnTab: true } : "auto" === t2 ? { mode: "grid", selector: "." + e3.item, initSize: { numColumns: 1, numRows: 1 } } : { mode: "matrix", rowSelector: "." + ("color" === n2 ? "tox-swatches__row" : "tox-collection__group") };
    }
    function Tb(t2, n2) {
      return ri(n2 + "x" + t2);
    }
    var Eb, Db, Bb = "choiceitem", Mb = [{ type: Bb, text: "Light Green", value: "#BFEDD2" }, { type: Bb, text: "Light Yellow", value: "#FBEEB8" }, { type: Bb, text: "Light Red", value: "#F8CAC6" }, { type: Bb, text: "Light Purple", value: "#ECCAFA" }, { type: Bb, text: "Light Blue", value: "#C2E0F4" }, { type: Bb, text: "Green", value: "#2DC26B" }, { type: Bb, text: "Yellow", value: "#F1C40F" }, { type: Bb, text: "Red", value: "#E03E2D" }, { type: Bb, text: "Purple", value: "#B96AD9" }, { type: Bb, text: "Blue", value: "#3598DB" }, { type: Bb, text: "Dark Turquoise", value: "#169179" }, { type: Bb, text: "Orange", value: "#E67E23" }, { type: Bb, text: "Dark Red", value: "#BA372A" }, { type: Bb, text: "Dark Purple", value: "#843FA1" }, { type: Bb, text: "Dark Blue", value: "#236FA1" }, { type: Bb, text: "Light Gray", value: "#ECF0F1" }, { type: Bb, text: "Medium Gray", value: "#CED4D9" }, { type: Bb, text: "Gray", value: "#95A5A6" }, { type: Bb, text: "Dark Gray", value: "#7E8C8D" }, { type: Bb, text: "Navy Blue", value: "#34495E" }, { type: Bb, text: "Black", value: "#000000" }, { type: Bb, text: "White", value: "#ffffff" }], Ab = function(e3) {
      void 0 === e3 && (e3 = 10);
      function o2(t3) {
        i2.splice(t3, 1);
      }
      var t2, n2 = db.getItem(mb), r2 = y(n2) ? JSON.parse(n2) : [], i2 = e3 - (t2 = r2).length < 0 ? t2.slice(0, e3) : t2;
      return { add: function(t3) {
        var n3;
        (-1 === (n3 = l(i2, t3)) ? vt.none() : vt.some(n3)).each(o2), i2.unshift(t3), i2.length > e3 && i2.pop(), db.setItem(mb, JSON.stringify(i2));
      }, state: function() {
        return i2.slice(0);
      } };
    }(10), Fb = "#000000", Ib = function(r2) {
      return function(e3, t2) {
        var o2 = false;
        r2.windowManager.open({ title: "Color Picker", size: "normal", body: { type: "panel", items: [{ type: "colorpicker", name: "colorpicker", label: "Color" }] }, buttons: [{ type: "cancel", name: "cancel", text: "Cancel" }, { type: "submit", name: "save", text: "Save", primary: true }], initialData: { colorpicker: t2 }, onAction: function(t3, n2) {
          "hex-valid" === n2.name && (o2 = n2.value);
        }, onSubmit: function(t3) {
          var n2 = t3.getData().colorpicker;
          o2 ? (e3(vt.from(n2)), t3.close()) : r2.windowManager.alert(r2.translate(["Invalid hex color code: {0}", n2]));
        }, onClose: st, onCancel: function() {
          e3(vt.none());
        } });
      };
    }, Rb = function(e3, o2, r2, i2, u2, a2, c2) {
      return et(M(e3, function(n2) {
        return "choiceitem" === n2.type ? ao("choicemenuitem", Uh, n2).fold(rh, function(t2) {
          return vt.some(function(n3, t3, e4, o3, r3, i3, u3, a3) {
            void 0 === a3 && (a3 = true);
            var c3 = Ev({ presets: e4, textContent: t3 ? n3.text : vt.none(), htmlContent: vt.none(), ariaLabel: n3.text, iconContent: n3.icon, shortcutContent: t3 ? n3.shortcut : vt.none(), checkMark: t3 ? vt.some(_v(u3.icons)) : vt.none(), caret: vt.none(), value: n3.value }, u3, a3);
            return Yo(yv({ data: xv(n3), disabled: n3.disabled, getApi: function(n4) {
              return { setActive: function(t4) {
                Lg.set(n4, t4);
              }, isActive: function() {
                return Lg.isOn(n4);
              }, isDisabled: function() {
                return gd.isDisabled(n4);
              }, setDisabled: function(t4) {
                return gd.set(n4, t4);
              } };
            }, onAction: function(t4) {
              return o3(n3.value);
            }, onSetup: function(t4) {
              return t4.setActive(r3), st;
            }, triggersSubmenu: false, itemBehaviours: [] }, c3, i3, u3), { toggling: { toggleClass: Th, toggleOnExecute: false, selected: n3.active } });
          }(t2, 1 === r2, i2, o2, a2(n2.value), u2, c2, oh(e3)));
        }) : vt.none();
      }));
    }, Vb = Ir("cell-over"), Pb = Ir("cell-execute"), Hb = { inserttable: function(u2) {
      var t2 = Ir("size-label"), a2 = function(t3) {
        for (var n3 = [], e3 = 0; e3 < 10; e3++) {
          for (var o2 = [], r2 = 0; r2 < 10; r2++)
            o2.push(function(n4, e4, t4) {
              function o3(t5) {
                return br(t5, Pb, { row: n4, col: e4 });
              }
              function r3(t5, n5) {
                n5.stop(), o3(t5);
              }
              var i2;
              return Tu({ dom: { tag: "div", attributes: ((i2 = { role: "button" })["aria-labelledby"] = t4, i2) }, behaviours: nc([mm("insert-table-picker-cell", [Cr(vi(), Hg.focus), Cr(Ii(), o3), Cr(Ci(), r3), Cr(Vi(), r3)]), Lg.config({ toggleClass: "tox-insert-table-picker__selected", toggleOnExecute: false }), Hg.config({ onFocus: function(t5) {
                return br(t5, Vb, { row: n4, col: e4 });
              } })]) });
            }(e3, r2, t3));
          n3.push(o2);
        }
        return n3;
      }(t2), n2 = Tb(0, 0), c2 = zm({ dom: { tag: "span", classes: ["tox-insert-table-picker__label"], attributes: { id: t2 } }, components: [n2], behaviours: nc([Rg.config({})]) });
      return { type: "widget", data: { value: Ir("widget-id") }, dom: { tag: "div", classes: ["tox-fancymenuitem"] }, autofocus: true, components: [ob.widget({ dom: { tag: "div", classes: ["tox-insert-table-picker"] }, components: z(a2, function(t3) {
        return M(t3, Eu);
      }).concat(c2.asSpec()), behaviours: nc([mm("insert-table-picker", [ou(function(t3) {
        Rg.set(c2.get(t3), [n2]);
      }), Er(Vb, function(t3, n3, e3) {
        var o2 = e3.event, r2 = o2.row, i2 = o2.col;
        !function(t4, n4, e4) {
          for (var o3 = 0; o3 < 10; o3++)
            for (var r3 = 0; r3 < 10; r3++)
              Lg.set(t4[o3][r3], o3 <= n4 && r3 <= e4);
        }(a2, r2, i2), Rg.set(c2.get(t3), [Tb(r2 + 1, i2 + 1)]);
      }), Er(Pb, function(t3, n3, e3) {
        var o2 = e3.event, r2 = o2.row, i2 = o2.col;
        u2.onAction({ numRows: r2 + 1, numColumns: i2 + 1 }), vr(t3, Hi());
      })]), Fg.config({ initSize: { numRows: 10, numColumns: 10 }, mode: "flatgrid", selector: '[role="button"]' })]) })] };
    }, colorswatch: function(n2, t2) {
      var e3, o2, r2, i2 = (o2 = t2, r2 = (e3 = n2).initData.allowCustomColors && o2.colorinput.hasCustomColors(), e3.initData.colors.fold(function() {
        return xb(o2.colorinput.getColors(), r2);
      }, function(t3) {
        return t3.concat(bb(r2));
      })), u2 = t2.colorinput.getColorCols(), a2 = Ob(Ir("menu-value"), i2, function(t3) {
        n2.onAction({ value: t3 });
      }, u2, "color", Sh.CLOSE_ON_EXECUTE, T, t2.shared.providers), c2 = lt2(lt2({}, a2), { markers: Qp("color"), movement: _b2(u2, "color") });
      return { type: "widget", data: { value: Ir("widget-id") }, dom: { tag: "div", classes: ["tox-fancymenuitem"] }, autofocus: true, components: [ob.widget(tp.sketch(c2))] };
    } }, zb = function(t2) {
      var n2 = t2.text.fold(function() {
        return {};
      }, function(t3) {
        return { innerHtml: t3 };
      });
      return { type: "separator", dom: lt2({ tag: "div", classes: [Ch, "tox-collection__group-heading"] }, n2), components: [] };
    }, Nb = function(t2, n2, e3, o2) {
      void 0 === o2 && (o2 = true);
      var r2 = Ev({ presets: "normal", iconContent: t2.icon, textContent: t2.text, htmlContent: vt.none(), ariaLabel: t2.text, caret: vt.none(), checkMark: vt.none(), shortcutContent: t2.shortcut }, e3, o2);
      return yv({ data: xv(t2), getApi: function(n3) {
        return { isDisabled: function() {
          return gd.isDisabled(n3);
        }, setDisabled: function(t3) {
          return gd.set(n3, t3);
        } };
      }, disabled: t2.disabled, onAction: t2.onAction, onSetup: t2.onSetup, triggersSubmenu: false, itemBehaviours: [] }, r2, n2, e3);
    }, Lb = function(t2, n2, e3, o2, r2) {
      void 0 === o2 && (o2 = true);
      var i2 = (r2 = void 0 !== r2 && r2) ? wv("chevron-down", e3.icons, [Bh]) : wv("chevron-right", e3.icons, [Bh]), u2 = Ev({ presets: "normal", iconContent: t2.icon, textContent: t2.text, htmlContent: vt.none(), ariaLabel: t2.text, caret: vt.some(i2), checkMark: vt.none(), shortcutContent: t2.shortcut }, e3, o2);
      return yv({ data: xv(t2), getApi: function(n3) {
        return { isDisabled: function() {
          return gd.isDisabled(n3);
        }, setDisabled: function(t3) {
          return gd.set(n3, t3);
        } };
      }, disabled: t2.disabled, onAction: st, onSetup: t2.onSetup, triggersSubmenu: true, itemBehaviours: [] }, u2, n2, e3);
    }, Wb = function(t2, n2, e3, o2) {
      void 0 === o2 && (o2 = true);
      var r2 = Ev({ iconContent: t2.icon, textContent: t2.text, htmlContent: vt.none(), ariaLabel: t2.text, checkMark: vt.some(_v(e3.icons)), caret: vt.none(), shortcutContent: t2.shortcut, presets: "normal", meta: t2.meta }, e3, o2);
      return Yo(yv({ data: xv(t2), disabled: t2.disabled, getApi: function(n3) {
        return { setActive: function(t3) {
          Lg.set(n3, t3);
        }, isActive: function() {
          return Lg.isOn(n3);
        }, isDisabled: function() {
          return gd.isDisabled(n3);
        }, setDisabled: function(t3) {
          return gd.set(n3, t3);
        } };
      }, onAction: t2.onAction, onSetup: t2.onSetup, triggersSubmenu: false, itemBehaviours: [] }, r2, n2, e3), { toggling: { toggleClass: Th, toggleOnExecute: false, selected: t2.active } });
    }, Ub = function(n2, e3) {
      return tt(Hb, n2.fancytype).map(function(t2) {
        return t2(n2, e3);
      });
    };
    function jb(t2, u2, a2, n2, c2, s2, l2) {
      var e3 = 1 === n2, o2 = !e3 || oh(t2);
      return et(M(t2, function(t3) {
        switch (t3.type) {
          case "separator":
            return ao("Autocompleter.Separator", Rp, t3).fold(rh, function(t4) {
              return vt.some(zb(t4));
            });
          case "cardmenuitem":
            return ao("cardmenuitem", Wh, t3).fold(rh, function(n3) {
              return vt.some((t4 = lt2(lt2({}, n3), { onAction: function(t5) {
                n3.onAction(t5), a2(n3.value, n3.meta);
              } }), e4 = c2, o3 = s2, r2 = { itemBehaviours: Dv(n3.meta, s2), cardText: { matchText: u2, highlightOn: l2 } }, i2 = { dom: Tv(t4.label), optComponents: [vt.some({ dom: { tag: "div", classes: [Ah, Fh] }, components: eb(t4.items, r2) })] }, yv({ data: xv(lt2({ text: vt.none() }, t4)), disabled: t4.disabled, getApi: function(e5) {
                return { isDisabled: function() {
                  return gd.isDisabled(e5);
                }, setDisabled: function(n4) {
                  gd.set(e5, n4), St(vs(e5.element, "*"), function(t5) {
                    e5.getSystem().getByDom(t5).each(function(t6) {
                      t6.hasConfigured(gd) && gd.set(t6, n4);
                    });
                  });
                } };
              }, onAction: t4.onAction, onSetup: t4.onSetup, triggersSubmenu: false, itemBehaviours: vt.from(r2.itemBehaviours).getOr([]) }, i2, e4, o3.providers)));
              var t4, e4, o3, r2, i2;
            });
          default:
            return ao("Autocompleter.Item", Vp, t3).fold(rh, function(t4) {
              return vt.some(function(n3, e4, t5, o3, r2, i2, u3, a3) {
                void 0 === a3 && (a3 = true);
                var c3 = Ev({ presets: o3, textContent: vt.none(), htmlContent: t5 ? n3.text.map(function(t6) {
                  return Bv(t6, e4);
                }) : vt.none(), ariaLabel: n3.text, iconContent: n3.icon, shortcutContent: vt.none(), checkMark: vt.none(), caret: vt.none(), value: n3.value }, u3.providers, a3, n3.icon);
                return yv({ data: xv(n3), disabled: n3.disabled, getApi: rt2({}), onAction: function(t6) {
                  return r2(n3.value, n3.meta);
                }, onSetup: rt2(st), triggersSubmenu: false, itemBehaviours: Dv(n3.meta, u3) }, c3, i2, u3.providers);
              }(t4, u2, e3, "normal", a2, c2, s2, o2));
            });
        }
      }));
    }
    function Gb(t2, n2, e3, o2, r2) {
      var i2 = oh(n2), u2 = et(M(n2, function(t3) {
        function n3(t4) {
          return function(t5, n4, e4, o3, r3) {
            function i3(t6) {
              return r3 ? lt2(lt2({}, t6), { shortcut: vt.none(), icon: t6.text.isSome() ? vt.none() : t6.icon }) : t6;
            }
            var u3 = e4.shared.providers;
            switch (t5.type) {
              case "menuitem":
                return ao("menuitem", Xh, t5).fold(rh, function(t6) {
                  return vt.some(Nb(i3(t6), n4, u3, o3));
                });
              case "nestedmenuitem":
                return ao("nestedmenuitem", Yh, t5).fold(rh, function(t6) {
                  return vt.some(Lb(i3(t6), n4, u3, o3, r3));
                });
              case "togglemenuitem":
                return ao("togglemenuitem", qh, t5).fold(rh, function(t6) {
                  return vt.some(Wb(i3(t6), n4, u3, o3));
                });
              case "separator":
                return ao("separatormenuitem", Rp, t5).fold(rh, function(t6) {
                  return vt.some(zb(t6));
                });
              case "fancymenuitem":
                return ao("fancymenuitem", Gh, t5).fold(rh, function(t6) {
                  return Ub(i3(t6), e4);
                });
              default:
                return console.error("Unknown item in general menu", t5), vt.none();
            }
          }(t4, e3, o2, r2 ? !Tt(t4, "text") : i2, r2);
        }
        return "nestedmenuitem" === t3.type && t3.getSubmenuItems().length <= 0 ? n3(lt2(lt2({}, t3), { disabled: true })) : n3(t3);
      }));
      return (r2 ? ih : uh)(t2, i2, u2, 1, "normal");
    }
    function Xb(t2) {
      return ip.singleData(t2.value, t2);
    }
    function Yb(t2, n2, e3) {
      return Ru(t2, n2, e3).isSome();
    }
    function qb(e3, o2) {
      var r2 = null;
      return { cancel: function() {
        null !== r2 && (clearTimeout(r2), r2 = null);
      }, schedule: function() {
        for (var t2 = [], n2 = 0; n2 < arguments.length; n2++)
          t2[n2] = arguments[n2];
        r2 = setTimeout(function() {
          e3.apply(null, t2), r2 = null;
        }, o2);
      } };
    }
    function Kb(t2) {
      var n2 = t2.raw;
      return void 0 === n2.touches || 1 !== n2.touches.length ? vt.none() : vt.some(n2.touches[0]);
    }
    function Jb() {
      return le().browser.isFirefox();
    }
    function $b(n2, t2) {
      var e3, o2, r2, i2, u2, a2, c2, s2, l2, f2 = lt2({ stopBackspace: true }, t2), d2 = (u2 = f2, a2 = gc(), c2 = Po(false), s2 = qb(function(t3) {
        u2.triggerEvent(Pi(), t3), c2.set(true);
      }, 400), l2 = lr([{ key: si(), value: function(e4) {
        return Kb(e4).each(function(t3) {
          s2.cancel();
          var n3 = { x: t3.clientX, y: t3.clientY, target: e4.target };
          s2.schedule(e4), c2.set(false), a2.set(n3);
        }), vt.none();
      } }, { key: li(), value: function(t3) {
        return s2.cancel(), Kb(t3).each(function(i3) {
          a2.on(function(t4) {
            var n3 = i3, e4 = t4, o3 = Math.abs(n3.clientX - e4.x), r3 = Math.abs(n3.clientY - e4.y);
            (5 < o3 || 5 < r3) && a2.clear();
          });
        }), vt.none();
      } }, { key: fi(), value: function(n3) {
        return s2.cancel(), a2.get().filter(function(t3) {
          return Lt(t3.target, n3.target);
        }).map(function(t3) {
          return c2.get() ? (n3.prevent(), false) : u2.triggerEvent(Vi(), n3);
        });
      } }]), { fireIfReady: function(n3, t3) {
        return tt(l2, t3).bind(function(t4) {
          return t4(n3);
        });
      } }), m3 = M(["touchstart", "touchmove", "touchend", "touchcancel", "gesturestart", "mousedown", "mouseup", "mouseover", "mousemove", "mouseout", "click"].concat(["selectstart", "input", "contextmenu", "change", "transitionend", "transitioncancel", "drag", "dragstart", "dragend", "dragenter", "dragleave", "dragover", "drop", "keyup"]), function(t3) {
        return pc(n2, t3, function(n3) {
          d2.fireIfReady(n3, t3).each(function(t4) {
            t4 && n3.kill();
          }), f2.triggerEvent(t3, n3) && n3.kill();
        });
      }), g2 = gc(), p2 = pc(n2, "paste", function(n3) {
        d2.fireIfReady(n3, "paste").each(function(t3) {
          t3 && n3.kill();
        }), f2.triggerEvent("paste", n3) && n3.kill(), g2.set(setTimeout(function() {
          f2.triggerEvent(Ai(), n3);
        }, 0));
      }), h2 = pc(n2, "keydown", function(t3) {
        var n3;
        f2.triggerEvent("keydown", t3) ? t3.kill() : !f2.stopBackspace || (n3 = t3).raw.which !== vd[0] || wt(["input", "textarea"], Ft(n3.target)) || Yb(n3.target, '[contenteditable="true"]') || t3.prevent();
      }), v4 = (e3 = n2, o2 = function(t3) {
        f2.triggerEvent("focusin", t3) && t3.kill();
      }, Jb() ? hc(e3, "focus", o2) : pc(e3, "focusin", o2)), b2 = gc(), y2 = (r2 = n2, i2 = function(t3) {
        f2.triggerEvent("focusout", t3) && t3.kill(), b2.set(setTimeout(function() {
          f2.triggerEvent(Mi(), t3);
        }, 0));
      }, Jb() ? hc(r2, "blur", i2) : pc(r2, "focusout", i2));
      return { unbind: function() {
        St(m3, function(t3) {
          t3.unbind();
        }), h2.unbind(), v4.unbind(), y2.unbind(), p2.unbind(), g2.on(clearTimeout), b2.on(clearTimeout);
      } };
    }
    function Qb(t2, n2) {
      return Po(tt(t2, "target").getOr(n2));
    }
    function Zb(t2, o2, n2, e3, r2, i2) {
      var u2, a2, c2 = t2(o2, e3), s2 = (u2 = Po(false), a2 = Po(false), { stop: function() {
        u2.set(true);
      }, cut: function() {
        a2.set(true);
      }, isStopped: u2.get, isCut: a2.get, event: n2, setSource: r2.set, getSource: r2.get });
      return c2.fold(function() {
        return i2.logEventNoHandlers(o2, e3), ay.complete();
      }, function(n3) {
        var e4 = n3.descHandler;
        return Wr(e4)(s2), s2.isStopped() ? (i2.logEventStopped(o2, n3.element, e4.purpose), ay.stopped()) : s2.isCut() ? (i2.logEventCut(o2, n3.element, e4.purpose), ay.complete()) : Yt(n3.element).fold(function() {
          return i2.logNoParent(o2, n3.element, e4.purpose), ay.complete();
        }, function(t3) {
          return i2.logEventResponse(o2, n3.element, e4.purpose), ay.resume(t3);
        });
      });
    }
    function ty() {
      function r2(t2) {
        Rr(t2.element).each(function(t3) {
          delete a2[t3], i2.unregisterId(t3);
        });
      }
      var u2, i2 = (u2 = {}, { registerId: function(r3, i3, t2) {
        J(t2, function(t3, n2) {
          var e3, o2 = void 0 !== u2[n2] ? u2[n2] : {};
          o2[i3] = { cHandler: C.apply(void 0, [(e3 = t3).handler].concat(r3)), purpose: e3.purpose }, u2[n2] = o2;
        });
      }, unregisterId: function(e3) {
        J(u2, function(t2, n2) {
          Tt(t2, e3) && delete t2[e3];
        });
      }, filterByType: function(t2) {
        return tt(u2, t2).map(function(t3) {
          return $(t3, function(t4, n2) {
            return { id: n2, descHandler: t4 };
          });
        }).getOr([]);
      }, find: function(t2, n2, e3) {
        return tt(u2, n2).bind(function(o2) {
          return mr(e3, function(t3) {
            return n3 = o2, Rr(e4 = t3).bind(function(t4) {
              return tt(n3, t4);
            }).map(function(t4) {
              return { element: e4, descHandler: t4 };
            });
            var n3, e4;
          }, t2);
        });
      } }), a2 = {};
      return { find: function(t2, n2, e3) {
        return i2.find(t2, n2, e3);
      }, filter: function(t2) {
        return i2.filterByType(t2);
      }, register: function(t2) {
        var e3, o2 = Rr((e3 = t2).element).getOrThunk(function() {
          return t3 = e3.element, n2 = Ir(du + "uid-"), gu(t3, n2), n2;
          var t3, n2;
        });
        nt(a2, o2) && function(t3) {
          var n2 = a2[o2];
          if (n2 !== t3)
            throw new Error('The tagId "' + o2 + '" is already used by: ' + Fr(n2.element) + "\nCannot use it for: " + Fr(t3.element) + "\nThe conflicting element is" + (ve(n2.element) ? " " : " not ") + "already in the DOM");
          r2(t3);
        }(t2), i2.registerId([t2], o2, t2.events), a2[o2] = t2;
      }, unregister: r2, getById: function(t2) {
        return tt(a2, t2);
      } };
    }
    function ny(e3) {
      function o2(n3) {
        return Yt(e3.element).fold(D, function(t3) {
          return Lt(n3, t3);
        });
      }
      function s2(t3, n3) {
        return i2.find(o2, t3, n3);
      }
      function r2(n3) {
        var t3 = i2.filter(Fi());
        St(t3, function(t4) {
          Wr(t4.descHandler)(n3);
        });
      }
      var i2 = ty(), t2 = $b(e3.element, { triggerEvent: function(n3, e4) {
        return Lu(n3, e4.target, function(t3) {
          return sy(s2, n3, e4, e4.target, t3);
        });
      } }), u2 = { debugInfo: rt2("real"), triggerEvent: function(n3, e4, o3) {
        Lu(n3, e4, function(t3) {
          return sy(s2, n3, o3, e4, t3);
        });
      }, triggerFocus: function(a3, c3) {
        Rr(a3).fold(function() {
          ka(a3);
        }, function(t3) {
          Lu(Bi(), a3, function(t4) {
            var n3, e4, o3 = s2, r3 = Bi(), i3 = t4, u3 = Qb(n3 = { originator: c3, kill: st, prevent: st, target: a3 }, e4 = a3);
            return Zb(o3, r3, n3, e4, u3, i3), false;
          });
        });
      }, triggerEscape: function(t3, n3) {
        u2.triggerEvent("keydown", t3.element, n3.event);
      }, getByUid: function(t3) {
        return g2(t3);
      }, getByDom: function(t3) {
        return p2(t3);
      }, build: Tu, addToGui: function(t3) {
        c2(t3);
      }, removeFromGui: function(t3) {
        l2(t3);
      }, addToWorld: function(t3) {
        n2(t3);
      }, removeFromWorld: function(t3) {
        a2(t3);
      }, broadcast: function(t3) {
        f2(t3);
      }, broadcastOn: function(t3, n3) {
        d2(t3, n3);
      }, broadcastEvent: function(t3, n3) {
        m3(t3, n3);
      }, isConnected: D }, n2 = function(t3) {
        t3.connect(u2), Yn(t3.element) || (i2.register(t3), St(t3.components(), n2), u2.triggerEvent(Ni(), t3.element, { target: t3.element }));
      }, a2 = function(t3) {
        Yn(t3.element) || (St(t3.components(), a2), i2.unregister(t3)), t3.disconnect();
      }, c2 = function(t3) {
        Vs(e3, t3);
      }, l2 = function(t3) {
        Hs(t3);
      }, f2 = function(t3) {
        r2({ universal: true, data: t3 });
      }, d2 = function(t3, n3) {
        r2({ universal: false, channels: t3, data: n3 });
      }, m3 = function(t3, n3) {
        var e4, o3, r3 = i2.filter(t3);
        return o3 = { stop: function() {
          e4.set(true);
        }, cut: st, isStopped: (e4 = Po(false)).get, isCut: T, event: n3, setSource: _("Cannot set source of a broadcasted event"), getSource: _("Cannot get source of a broadcasted event") }, St(r3, function(t4) {
          Wr(t4.descHandler)(o3);
        }), o3.isStopped();
      }, g2 = function(t3) {
        return i2.getById(t3).fold(function() {
          return Ve.error(new Error('Could not find component with uid: "' + t3 + '" in system.'));
        }, Ve.value);
      }, p2 = function(t3) {
        var n3 = Rr(t3).getOr("not found");
        return g2(n3);
      };
      return n2(e3), { root: e3, element: e3.element, destroy: function() {
        t2.unbind(), Ee(e3.element);
      }, add: c2, remove: l2, getByUid: g2, getByDom: p2, addToWorld: n2, removeFromWorld: a2, broadcast: f2, broadcastOn: d2, broadcastEvent: m3 };
    }
    function ey(t2, n2, e3, o2) {
      var r2 = vy(t2, n2, e3, o2);
      return my.sketch(r2);
    }
    function oy(t2, n2) {
      return my.parts.label({ dom: { tag: "label", classes: ["tox-label"], innerHtml: n2.translate(t2) } });
    }
    function ry(t2) {
      return nc([Hg.config({ onFocus: t2.selectOnFocus ? function(t3) {
        var n2 = t3.element, e3 = Qr(n2);
        n2.dom.setSelectionRange(0, e3.length);
      } : st })]);
    }
    function iy(t2) {
      return { tag: t2.tag, attributes: lt2({ type: "text" }, t2.inputAttributes), styles: t2.inputStyles, classes: t2.inputClasses };
    }
    (Db = Eb = {})[Db.ContentFocus = 0] = "ContentFocus", Db[Db.UiFocus = 1] = "UiFocus";
    function uy(f2, c2) {
      function e3() {
        return r2.get().isSome();
      }
      function s2() {
        e3() && up.hide(d2);
      }
      var o2, t2, r2 = gc(), l2 = Po(false), d2 = Tu(up.sketch({ dom: { tag: "div", classes: ["tox-autocompleter"] }, components: [], fireDismissalEventInstead: {}, inlineBehaviours: nc([mm("dismissAutocompleter", [Cr(Yi(), function() {
        return m3();
      })])]), lazySink: c2.getSink })), m3 = function() {
        var t3;
        e3() && (t3 = r2.get().map(function(t4) {
          return t4.element;
        }), Mp(t3.getOr(At.fromDom(f2.selection.getNode()))).each(In), s2(), r2.clear(), l2.set(false));
      }, u2 = Rt(function() {
        return e4 = dt(f2.ui.registry.getAll().popups, function(t4) {
          return ao("Autocompleter", Pp, t4).fold(function(t5) {
            throw new Error(ur(t5));
          }, h);
        }), t3 = $(e4, function(t4) {
          return t4.ch;
        }), n3 = {}, St(t3, function(t4) {
          n3[t4] = {};
        }), o3 = Ct(n3), r3 = Z(e4), { dataset: e4, triggerChars: o3, lookupByChar: function(n4) {
          return F(r3, function(t4) {
            return t4.ch === n4;
          });
        } };
        var t3, n3, e4, o3, r3;
      }), g2 = function(t3) {
        var n3 = t3;
        r2.get().map(function(t4) {
          return kp(f2.dom, f2.selection.getRng(), t4.triggerChar).bind(function(t5) {
            return Tp(f2, u2, t5, n3);
          });
        }).getOrThunk(function() {
          return n4 = f2, t4 = (e4 = u2)(), o3 = n4.selection.getRng(), r3 = n4.dom, i3 = o3, K(t4.triggerChars, function(t5) {
            return kp(r3, i3, t5);
          }).bind(function(t5) {
            return Tp(n4, e4, t5);
          });
          var n4, e4, t4, o3, r3, i3;
        }).fold(m3, function(a2) {
          var t4, n4 = a2.context;
          e3() || (t4 = yp(f2, n4.range), r2.set({ triggerChar: n4.triggerChar, element: t4, matchLength: n4.text.length }), l2.set(false)), a2.lookupData.then(function(u3) {
            r2.get().map(function(t5) {
              var n5, e4, o3, r3, i3 = a2.context;
              t5.triggerChar === i3.triggerChar && (e4 = i3.triggerChar, r3 = K(o3 = u3, function(t6) {
                return vt.from(t6.columns);
              }).getOr(1), 0 < (n5 = z(o3, function(i4) {
                return jb(i4.items, i4.matchText, function(o4, r4) {
                  var t6 = f2.selection.getRng();
                  kp(f2.dom, t6, e4).fold(function() {
                    return console.error("Lost context. Cursor probably moved");
                  }, function(t7) {
                    var n6 = t7.range, e5 = { hide: function() {
                      m3();
                    }, reload: function(t8) {
                      s2(), g2(t8);
                    } };
                    l2.set(true), i4.onAction(e5, n6, o4, r4), l2.set(false);
                  });
                }, r3, Sh.BUBBLE_TO_SANDBOX, c2, i4.highlightOn);
              })).length ? function(t6, n6, e5, o4) {
                t6.matchLength = n6.text.length;
                var r4, i4, u4, a3, c3, s3, l3 = K(e5, function(t7) {
                  return vt.from(t7.columns);
                }).getOr(1);
                up.showAt(d2, tp.sketch((r4 = uh("autocompleter-value", true, o4, l3, "normal"), i4 = l3, a3 = ((u4 = Eb.ContentFocus) === Eb.ContentFocus ? Ul : Wl)(), c3 = _b2(i4, "normal"), s3 = Qp("normal"), { dom: r4.dom, components: r4.components, items: r4.items, value: r4.value, markers: { selectedItem: s3.selectedItem, item: s3.item }, movement: c3, fakeFocus: u4 === Eb.ContentFocus, focusManager: a3, menuBehaviours: Kh("auto" !== i4 ? [] : [ou(function(o5, t7) {
                  ah(o5, 4, s3.item).each(function(t8) {
                    var n7 = t8.numColumns, e6 = t8.numRows;
                    Fg.setGridSize(o5, e6, n7);
                  });
                })]) })), { anchor: { type: "node", root: At.fromDom(f2.getBody()), node: vt.from(t6.element) } }), up.getContent(d2).each(hd.highlightFirst);
              }(t5, i3, u3, n5) : (10 <= i3.text.length - t5.matchLength ? m3 : s2)());
            });
          });
        });
      }, n2 = { onKeypress: vp(function(t3) {
        27 !== t3.which && g2();
      }, 50), cancelIfNecessary: m3, isMenuOpen: function() {
        return up.isOpen(d2);
      }, isActive: e3, isProcessingAction: l2.get, getView: function() {
        return up.getContent(d2);
      } };
      function i2(t3, n3) {
        br(t3, xi(), { raw: n3 });
      }
      false === f2.hasPlugin("rtc") && (o2 = n2, (t2 = f2).on("keypress compositionend", o2.onKeypress.throttle), t2.on("remove", o2.onKeypress.cancel), t2.on("keydown", function(n3) {
        function t3() {
          return o2.getView().bind(hd.getHighlighted);
        }
        8 === n3.which && o2.onKeypress.throttle(n3), o2.isActive() && (27 === n3.which && o2.cancelIfNecessary(), o2.isMenuOpen() ? 13 === n3.which ? (t3().each(yr), n3.preventDefault()) : 40 === n3.which ? (t3().fold(function() {
          o2.getView().each(hd.highlightFirst);
        }, function(t4) {
          i2(t4, n3);
        }), n3.preventDefault(), n3.stopImmediatePropagation()) : 37 !== n3.which && 38 !== n3.which && 39 !== n3.which || t3().each(function(t4) {
          i2(t4, n3), n3.preventDefault(), n3.stopImmediatePropagation();
        }) : 13 !== n3.which && 38 !== n3.which && 40 !== n3.which || o2.cancelIfNecessary());
      }), t2.on("NodeChange", function(t3) {
        o2.isActive() && !o2.isProcessingAction() && Mp(At.fromDom(t3.element)).isNone() && o2.cancelIfNecessary();
      }));
    }
    var ay = Ho([{ stopped: [] }, { resume: ["element"] }, { complete: [] }]), cy = function(n2, e3, o2, t2, r2, i2) {
      return Zb(n2, e3, o2, t2, r2, i2).fold(D, function(t3) {
        return cy(n2, e3, o2, t3, r2, i2);
      }, T);
    }, sy = function(t2, n2, e3, o2, r2) {
      var i2 = Qb(e3, o2);
      return cy(t2, n2, e3, o2, i2, r2);
    }, ly = kl({ name: "Container", factory: function(t2) {
      var n2 = t2.dom, e3 = n2.attributes, o2 = B(n2, ["attributes"]);
      return { uid: t2.uid, dom: lt2({ tag: "div", attributes: lt2({ role: "presentation" }, e3) }, o2), components: t2.components, behaviours: tl(t2.containerBehaviours), events: t2.events, domModification: t2.domModification, eventOrder: t2.eventOrder };
    }, configFields: [Eo("components", []), Zs("containerBehaviours", []), Eo("events", {}), Eo("domModification", {}), Eo("eventOrder", {})] }), fy = rt2([Eo("prefix", "form-field"), Zs("fieldBehaviours", [cd, Df])]), dy = rt2([Qf({ schema: [mo("dom")], name: "label" }), Qf({ factory: { sketch: function(t2) {
      return { uid: t2.uid, dom: { tag: "span", styles: { display: "none" }, attributes: { "aria-hidden": "true" }, innerHtml: t2.text } };
    } }, schema: [mo("text")], name: "aria-descriptor" }), Jf({ factory: { sketch: function(t2) {
      var e3, o2, n2 = (e3 = ["factory"], o2 = {}, J(t2, function(t3, n3) {
        wt(e3, n3) || (o2[n3] = t3);
      }), o2);
      return t2.factory.sketch(n2);
    } }, schema: [mo("factory")], name: "field" })]), my = Cl({ name: "FormField", configFields: fy(), partFields: dy(), factory: function(r2, t2, n2, e3) {
      var o2 = nl(r2.fieldBehaviours, [cd.config({ find: function(t3) {
        return ml(t3, r2, "field");
      } }), Df.config({ store: { mode: "manual", getValue: function(t3) {
        return cd.getCurrent(t3).bind(Df.getValue);
      }, setValue: function(t3, n3) {
        cd.getCurrent(t3).each(function(t4) {
          Df.setValue(t4, n3);
        });
      } } })]), i2 = eu([ou(function(t3, n3) {
        var o3 = pl(t3, r2, ["label", "field", "aria-descriptor"]);
        o3.field().each(function(e4) {
          var n4 = Ir(r2.prefix);
          o3.label().each(function(t4) {
            on(t4.element, "for", n4), on(e4.element, "id", n4);
          }), o3["aria-descriptor"]().each(function(t4) {
            var n5 = Ir(r2.prefix);
            on(t4.element, "id", n5), on(e4.element, "aria-describedby", n5);
          });
        });
      })]);
      return { uid: r2.uid, dom: r2.dom, components: t2, behaviours: o2, events: i2, apis: { getField: function(t3) {
        return ml(t3, r2, "field");
      }, getLabel: function(t3) {
        return ml(t3, r2, "label");
      } } };
    }, apis: { getField: function(t2, n2) {
      return t2.getField(n2);
    }, getLabel: function(t2, n2) {
      return t2.getLabel(n2);
    } } }), gy = Object.freeze({ __proto__: null, exhibit: function(t2, n2) {
      return Lr({ attributes: lr([{ key: n2.tabAttr, value: "true" }]) });
    } }), py = xa({ fields: [Eo("tabAttr", "data-alloy-tabstop")], name: "tabstopping", active: gy }), hy = tinymce.util.Tools.resolve("tinymce.html.Entities"), vy = function(t2, n2, e3, o2) {
      return { dom: by(e3), components: t2.toArray().concat([n2]), fieldBehaviours: nc(o2) };
    }, by = function(t2) {
      return { tag: "div", classes: ["tox-form__group"].concat(t2) };
    }, yy = Ir("form-component-change"), xy = Ir("form-close"), wy = Ir("form-cancel"), Sy = Ir("form-action"), ky = Ir("form-submit"), Cy = Ir("form-block"), Oy = Ir("form-unblock"), _y = Ir("form-tabchange"), Ty = Ir("form-resize"), Ey = rt2([wo("data"), Eo("inputAttributes", {}), Eo("inputStyles", {}), Eo("tag", "input"), Eo("inputClasses", []), Ju("onSetValue"), Eo("styles", {}), Eo("eventOrder", {}), Zs("inputBehaviours", [Df, Hg]), Eo("selectOnFocus", true)]), Dy = kl({ name: "Input", configFields: Ey(), factory: function(t2, n2) {
      return { uid: t2.uid, dom: iy(t2), components: [], behaviours: lt2(lt2({}, ry(e3 = t2)), nl(e3.inputBehaviours, [Df.config({ store: lt2(lt2({ mode: "manual" }, e3.data.map(function(t3) {
        return { initialValue: t3 };
      }).getOr({})), { getValue: function(t3) {
        return Qr(t3.element);
      }, setValue: function(t3, n3) {
        Qr(t3.element) !== n3 && Zr(t3.element, n3);
      } }), onSetValue: e3.onSetValue })])), eventOrder: t2.eventOrder };
      var e3;
    } }), By = {}, My = { exports: By };
    function Ay(t2) {
      setTimeout(function() {
        throw t2;
      }, 0);
    }
    function Fy(t2) {
      var n2 = Ft(t2);
      return wt(Xy, n2);
    }
    function Iy(t2, n2) {
      qr(n2.getRoot(t2).getOr(t2.element), n2.invalidClass), n2.notify.each(function(n3) {
        Fy(t2.element) && on(t2.element, "aria-invalid", false), n3.getContainer(t2).each(function(t3) {
          Ar(t3, n3.validHtml);
        }), n3.onValid(t2);
      });
    }
    function Ry(n2, t2, e3, o2) {
      Yr(t2.getRoot(n2).getOr(n2.element), t2.invalidClass), t2.notify.each(function(t3) {
        Fy(n2.element) && on(n2.element, "aria-invalid", true), t3.getContainer(n2).each(function(t4) {
          Ar(t4, o2);
        }), t3.onInvalid(n2, o2);
      });
    }
    function Vy(n2, t2, e3) {
      return t2.validator.fold(function() {
        return Gy(Ve.value(true));
      }, function(t3) {
        return t3.validate(n2);
      });
    }
    function Py(n2, e3, t2) {
      return e3.notify.each(function(t3) {
        t3.onValidate(n2);
      }), Vy(n2, e3).map(function(t3) {
        return n2.getSystem().isConnected() ? t3.fold(function(t4) {
          return Ry(n2, e3, 0, t4), Ve.error(t4);
        }, function(t4) {
          return Iy(n2, e3), Ve.value(t4);
        }) : Ve.error("No longer in system");
      });
    }
    !function() {
      var t2 = this, n2 = function() {
        var t3, n3, e3, o2 = { exports: {} };
        function r2() {
        }
        function i2(t4) {
          if ("object" != typeof this)
            throw new TypeError("Promises must be constructed via new");
          if ("function" != typeof t4)
            throw new TypeError("not a function");
          this._state = 0, this._handled = false, this._value = void 0, this._deferreds = [], f2(t4, this);
        }
        function u2(e4, o3) {
          for (; 3 === e4._state; )
            e4 = e4._value;
          0 !== e4._state ? (e4._handled = true, i2._immediateFn(function() {
            var t4, n4 = 1 === e4._state ? o3.onFulfilled : o3.onRejected;
            if (null !== n4) {
              try {
                t4 = n4(e4._value);
              } catch (t5) {
                return void c2(o3.promise, t5);
              }
              a2(o3.promise, t4);
            } else
              (1 === e4._state ? a2 : c2)(o3.promise, e4._value);
          })) : e4._deferreds.push(o3);
        }
        function a2(n4, t4) {
          try {
            if (t4 === n4)
              throw new TypeError("A promise cannot be resolved with itself.");
            if (t4 && ("object" == typeof t4 || "function" == typeof t4)) {
              var e4 = t4.then;
              if (t4 instanceof i2)
                return n4._state = 3, n4._value = t4, void s2(n4);
              if ("function" == typeof e4)
                return void f2((o3 = e4, r3 = t4, function() {
                  o3.apply(r3, arguments);
                }), n4);
            }
            n4._state = 1, n4._value = t4, s2(n4);
          } catch (t5) {
            c2(n4, t5);
          }
          var o3, r3;
        }
        function c2(t4, n4) {
          t4._state = 2, t4._value = n4, s2(t4);
        }
        function s2(t4) {
          2 === t4._state && 0 === t4._deferreds.length && i2._immediateFn(function() {
            t4._handled || i2._unhandledRejectionFn(t4._value);
          });
          for (var n4 = 0, e4 = t4._deferreds.length; n4 < e4; n4++)
            u2(t4, t4._deferreds[n4]);
          t4._deferreds = null;
        }
        function l2(t4, n4, e4) {
          this.onFulfilled = "function" == typeof t4 ? t4 : null, this.onRejected = "function" == typeof n4 ? n4 : null, this.promise = e4;
        }
        function f2(t4, n4) {
          var e4 = false;
          try {
            t4(function(t5) {
              e4 || (e4 = true, a2(n4, t5));
            }, function(t5) {
              e4 || (e4 = true, c2(n4, t5));
            });
          } catch (t5) {
            if (e4)
              return;
            e4 = true, c2(n4, t5);
          }
        }
        t3 = o2, n3 = "undefined" != typeof globalThis ? globalThis : "undefined" != typeof window ? window : "undefined" != typeof global ? global : "undefined" != typeof self ? self : {}, e3 = setTimeout, i2.prototype.catch = function(t4) {
          return this.then(null, t4);
        }, i2.prototype.then = function(t4, n4) {
          var e4 = new this.constructor(r2);
          return u2(this, new l2(t4, n4, e4)), e4;
        }, i2.all = function(t4) {
          var a3 = Array.prototype.slice.call(t4);
          return new i2(function(r3, i3) {
            if (0 === a3.length)
              return r3([]);
            for (var u3 = a3.length, t5 = 0; t5 < a3.length; t5++)
              !function n4(e4, t6) {
                try {
                  if (t6 && ("object" == typeof t6 || "function" == typeof t6)) {
                    var o3 = t6.then;
                    if ("function" == typeof o3)
                      return o3.call(t6, function(t7) {
                        n4(e4, t7);
                      }, i3), 0;
                  }
                  a3[e4] = t6, 0 == --u3 && r3(a3);
                } catch (t7) {
                  i3(t7);
                }
              }(t5, a3[t5]);
          });
        }, i2.resolve = function(n4) {
          return n4 && "object" == typeof n4 && n4.constructor === i2 ? n4 : new i2(function(t4) {
            t4(n4);
          });
        }, i2.reject = function(e4) {
          return new i2(function(t4, n4) {
            n4(e4);
          });
        }, i2.race = function(r3) {
          return new i2(function(t4, n4) {
            for (var e4 = 0, o3 = r3.length; e4 < o3; e4++)
              r3[e4].then(t4, n4);
          });
        }, i2._immediateFn = "function" == typeof setImmediate ? function(t4) {
          setImmediate(t4);
        } : function(t4) {
          e3(t4, 0);
        }, i2._unhandledRejectionFn = function(t4) {
          "undefined" != typeof console && console && console.warn("Possible Unhandled Promise Rejection:", t4);
        }, i2._setImmediateFn = function(t4) {
          i2._immediateFn = t4;
        }, i2._setUnhandledRejectionFn = function(t4) {
          i2._unhandledRejectionFn = t4;
        }, t3.exports ? t3.exports = i2 : n3.Promise || (n3.Promise = i2);
        var d2 = o2.exports;
        return { boltExport: ("undefined" != typeof window ? window : Function("return this;")()).Promise || d2 };
      };
      "object" == typeof By && void 0 !== My ? My.exports = n2() : (t2 = "undefined" != typeof globalThis ? globalThis : t2 || self).EphoxContactWrapper = n2();
    }();
    var Hy, zy, Ny = My.exports.boltExport, Ly = function(t2) {
      function o2(t3) {
        r2() ? i2(t3) : n2.push(t3);
      }
      var e3 = vt.none(), n2 = [], r2 = function() {
        return e3.isSome();
      }, i2 = function(n3) {
        e3.each(function(t3) {
          setTimeout(function() {
            n3(t3);
          }, 0);
        });
      };
      return t2(function(t3) {
        r2() || (e3 = vt.some(t3), St(n2, i2), n2 = []);
      }), { get: o2, map: function(e4) {
        return Ly(function(n3) {
          o2(function(t3) {
            n3(e4(t3));
          });
        });
      }, isReady: r2 };
    }, Wy = { nu: Ly, pure: function(n2) {
      return Ly(function(t2) {
        t2(n2);
      });
    } }, Uy = function(e3) {
      function t2(t3) {
        e3().then(t3, Ay);
      }
      return { map: function(t3) {
        return Uy(function() {
          return e3().then(t3);
        });
      }, bind: function(n2) {
        return Uy(function() {
          return e3().then(function(t3) {
            return n2(t3).toPromise();
          });
        });
      }, anonBind: function(t3) {
        return Uy(function() {
          return e3().then(function() {
            return t3.toPromise();
          });
        });
      }, toLazy: function() {
        return Wy.nu(t2);
      }, toCached: function() {
        var t3 = null;
        return Uy(function() {
          return t3 = null === t3 ? e3() : t3;
        });
      }, toPromise: e3, get: t2 };
    }, jy = function(t2) {
      return Uy(function() {
        return new Ny(t2);
      });
    }, Gy = function(t2) {
      return Uy(function() {
        return Ny.resolve(t2);
      });
    }, Xy = ["input", "textarea"], Yy = Object.freeze({ __proto__: null, markValid: Iy, markInvalid: Ry, query: Vy, run: Py, isInvalid: function(t2, n2) {
      return Kr(n2.getRoot(t2).getOr(t2.element), n2.invalidClass);
    } }), qy = Object.freeze({ __proto__: null, events: function(n2, t2) {
      return n2.validator.map(function(t3) {
        return eu([Cr(t3.onEvent, function(t4) {
          Py(t4, n2).get(h);
        })].concat(t3.validateOnLoad ? [ou(function(t4) {
          Py(t4, n2).get(st);
        })] : []));
      }).getOr({});
    } }), Ky = xa({ fields: [mo("invalidClass"), Eo("getRoot", vt.none), To("notify", [Eo("aria", "alert"), Eo("getContainer", vt.none), Eo("validHtml", ""), Ju("onValid"), Ju("onInvalid"), Ju("onValidate")]), To("validator", [mo("validate"), Eo("onEvent", "input"), Eo("validateOnLoad", true)])], name: "invalidating", active: qy, apis: Yy, extra: { validation: function(e3) {
      return function(t2) {
        var n2 = Df.getValue(t2);
        return Gy(e3(n2));
      };
    } } }), Jy = Object.freeze({ __proto__: null, getCoupled: function(t2, n2, e3, o2) {
      return e3.getOrCreate(t2, n2, o2);
    } }), $y = xa({ fields: [go("others", uo(Ve.value, Zo()))], name: "coupling", apis: Jy, state: Object.freeze({ __proto__: null, init: function() {
      var i2 = {}, t2 = rt2({});
      return wu({ readState: t2, getOrCreate: function(e3, o2, r2) {
        var t3 = Ct(o2.others);
        if (t3)
          return tt(i2, r2).getOrThunk(function() {
            var t4 = tt(o2.others, r2).getOrDie("No information found for coupled component: " + r2)(e3), n2 = e3.getSystem().build(t4);
            return i2[r2] = n2;
          });
        throw new Error("Cannot find coupled component: " + r2 + ". Known coupled components: " + JSON.stringify(t3, null, 2));
      } });
    } }) }), Qy = rt2("sink"), Zy = rt2(Qf({ name: Qy(), overrides: rt2({ dom: { tag: "div" }, behaviours: nc([ff.config({ useFixed: D })]), events: eu([Dr(xi()), Dr(mi()), Dr(Ci())]) }) }));
    function tx(t2, n2) {
      var e3 = t2.getHotspot(n2).getOr(n2), o2 = t2.getAnchorOverrides();
      return t2.layouts.fold(function() {
        return { type: "hotspot", hotspot: e3, overrides: o2 };
      }, function(t3) {
        return { type: "hotspot", hotspot: e3, overrides: o2, layouts: t3 };
      });
    }
    function nx(t2, n2, e3, o2, r2, i2, u2) {
      var a2, c2 = tx(t2, e3), s2 = e3, l2 = o2, f2 = r2, d2 = u2, m3 = n2, g2 = (0, (a2 = t2).fetch)(s2).map(m3), p2 = mw(s2, a2);
      return g2.map(function(t3) {
        return t3.bind(function(t4) {
          return vt.from(ip.sketch(lt2(lt2({}, f2.menu()), { uid: pu(""), data: t4, highlightImmediately: d2 === Hy.HighlightFirst, onOpenMenu: function(t5, n3) {
            var e4 = p2().getOrDie();
            ff.position(e4, n3, { anchor: c2 }), bf.decloak(l2);
          }, onOpenSubmenu: function(t5, n3, e4) {
            var o3 = p2().getOrDie();
            ff.position(o3, e4, { anchor: { type: "submenu", item: n3 } }), bf.decloak(l2);
          }, onRepositionMenu: function(t5, n3, e4) {
            var o3 = p2().getOrDie();
            ff.position(o3, n3, { anchor: c2 }), St(e4, function(t6) {
              ff.position(o3, t6.triggeredMenu, { anchor: { type: "submenu", item: t6.triggeringItem } });
            });
          }, onEscape: function() {
            return Hg.focus(s2), bf.close(l2), vt.some(true);
          } })));
        });
      }).map(function(t3) {
        return t3.fold(function() {
          bf.isOpen(o2) && bf.close(o2);
        }, function(t4) {
          bf.cloak(o2), bf.open(o2, t4), i2(o2);
        }), o2;
      });
    }
    function ex(t2, n2, e3, o2, r2, i2) {
      var u2 = $y.getCoupled(e3, "sandbox");
      return (bf.isOpen(u2) ? function(t3, n3, e4, o3, r3, i3, u3) {
        return bf.close(o3), Gy(o3);
      } : nx)(t2, n2, e3, u2, o2, r2, i2);
    }
    function ox(t2) {
      bf.getState(t2).each(function(t3) {
        ip.repositionMenus(t3);
      });
    }
    function rx(s2, l2, f2) {
      var d2 = Vu(), t2 = mw(l2, s2);
      return { dom: { tag: "div", classes: s2.sandboxClasses, attributes: { id: d2.id, role: "listbox" } }, behaviours: Mf(s2.sandboxBehaviours, [Df.config({ store: { mode: "memory", initialValue: l2 } }), bf.config({ onOpen: function(t3, n2) {
        var e3, o2, r2, i2, u2, a2, c2 = tx(s2, l2);
        d2.link(l2.element), s2.matchWidth && (e3 = c2.hotspot, o2 = n2, r2 = s2.useMinWidth, u2 = cd.getCurrent(o2).getOr(o2), a2 = On(e3.element), r2 ? dn(u2.element, "min-width", a2 + "px") : (i2 = u2.element, Oe.set(i2, a2))), s2.onOpen(c2, t3, n2), void 0 !== f2 && void 0 !== f2.onOpen && f2.onOpen(t3, n2);
      }, onClose: function(t3, n2) {
        d2.unlink(l2.element), void 0 !== f2 && void 0 !== f2.onClose && f2.onClose(t3, n2);
      }, isPartOf: function(t3, n2, e3) {
        return zu(n2, e3) || zu(l2, e3);
      }, getAttachPoint: function() {
        return t2().getOrDie();
      } }), cd.config({ find: function(t3) {
        return bf.getState(t3).bind(function(t4) {
          return cd.getCurrent(t4);
        });
      } }), ic.config({ channels: lt2(lt2({}, Xs({ isExtraPart: T })), Ys({ doReposition: ox })) })]) };
    }
    function ix(t2) {
      ox($y.getCoupled(t2, "sandbox"));
    }
    function ux() {
      return [Eo("sandboxClasses", []), Bf("sandboxBehaviours", [cd, ic, bf, Df])];
    }
    function ax(n2) {
      return Qf({ name: n2 + "-edge", overrides: function(t2) {
        return t2.model.manager.edgeActions[n2].fold(function() {
          return {};
        }, function(o2) {
          return { events: eu([Or(si(), function(t3, n3, e3) {
            return o2(t3, e3);
          }, [t2]), Or(mi(), function(t3, n3, e3) {
            return o2(t3, e3);
          }, [t2]), Or(gi(), function(t3, n3, e3) {
            e3.mouseIsDown.get() && o2(t3, e3);
          }, [t2])]) };
        });
      } });
    }
    function cx(t2) {
      var n2 = t2.event.raw;
      return -1 === n2.type.indexOf("touch") ? void 0 !== n2.clientX ? vt.some(n2).map(function(t3) {
        return ke(t3.clientX, t3.clientY);
      }) : vt.none() : void 0 !== n2.touches && 1 === n2.touches.length ? vt.some(n2.touches[0]).map(function(t3) {
        return ke(t3.clientX, t3.clientY);
      }) : vt.none();
    }
    function sx(t2) {
      return t2.model.minX;
    }
    function lx(t2) {
      return t2.model.minY;
    }
    function fx(t2) {
      return t2.model.minX - 1;
    }
    function dx(t2) {
      return t2.model.minY - 1;
    }
    function mx(t2) {
      return t2.model.maxX;
    }
    function gx(t2) {
      return t2.model.maxY;
    }
    function px(t2) {
      return t2.model.maxX + 1;
    }
    function hx(t2) {
      return t2.model.maxY + 1;
    }
    function vx(t2, n2, e3) {
      return n2(t2) - e3(t2);
    }
    function bx(t2) {
      return vx(t2, mx, sx);
    }
    function yx(t2) {
      return vx(t2, gx, lx);
    }
    function xx(t2) {
      return bx(t2) / 2;
    }
    function wx2(t2) {
      return yx(t2) / 2;
    }
    function Sx(t2) {
      return t2.stepSize;
    }
    function kx(t2) {
      return t2.snapToGrid;
    }
    function Cx(t2) {
      return t2.snapStart;
    }
    function Ox(t2) {
      return t2.rounded;
    }
    function _x(t2, n2) {
      return void 0 !== t2[n2 + "-edge"];
    }
    function Tx(t2) {
      return _x(t2, "left");
    }
    function Ex(t2) {
      return _x(t2, "right");
    }
    function Dx(t2) {
      return _x(t2, "top");
    }
    function Bx(t2) {
      return _x(t2, "bottom");
    }
    function Mx(t2) {
      return t2.model.value.get();
    }
    function Ax(t2, n2) {
      return { x: t2, y: n2 };
    }
    function Fx(t2, n2) {
      br(t2, Bw(), { value: n2 });
    }
    function Ix(t2, n2, e3, o2) {
      return t2 < n2 ? t2 : e3 < t2 ? e3 : t2 === n2 ? n2 - 1 : Math.max(n2, t2 - o2);
    }
    function Rx(t2, n2, e3, o2) {
      return e3 < t2 ? t2 : t2 < n2 ? n2 : t2 === e3 ? e3 + 1 : Math.min(e3, t2 + o2);
    }
    function Vx(t2, n2, e3) {
      return Math.max(n2, Math.min(e3, t2));
    }
    function Px(t2) {
      var n2 = t2.min, e3 = t2.max, o2 = t2.range, r2 = t2.value, i2 = t2.step, u2 = t2.snap, a2 = t2.snapStart, c2 = t2.rounded, s2 = t2.hasMinEdge, l2 = t2.hasMaxEdge, f2 = t2.minBound, d2 = t2.maxBound, m3 = t2.screenRange, g2 = s2 ? n2 - 1 : n2, p2 = l2 ? e3 + 1 : e3;
      if (r2 < f2)
        return g2;
      if (d2 < r2)
        return p2;
      var h2, v4, b2, y2, x2, w2 = Vx((x2 = f2, Math.min(d2, Math.max(r2, x2)) - x2) / m3 * o2 + n2, g2, p2);
      return u2 && n2 <= w2 && w2 <= e3 ? (h2 = w2, v4 = n2, b2 = e3, y2 = i2, a2.fold(function() {
        var t3 = Math.round((h2 - v4) / y2) * y2;
        return Vx(v4 + t3, v4 - 1, b2 + 1);
      }, function(t3) {
        var n3 = Math.round((h2 - t3) % y2 / y2), e4 = Math.floor((h2 - t3) / y2), o3 = Math.floor((b2 - t3) / y2), r3 = Math.min(o3, e4 + n3);
        return Math.max(t3, t3 + r3 * y2);
      })) : c2 ? Math.round(w2) : w2;
    }
    function Hx(t2) {
      var n2 = t2.min, e3 = t2.max, o2 = t2.range, r2 = t2.value, i2 = t2.hasMinEdge, u2 = t2.hasMaxEdge, a2 = t2.maxBound, c2 = t2.maxOffset, s2 = t2.centerMinEdge, l2 = t2.centerMaxEdge;
      return r2 < n2 ? i2 ? 0 : s2 : e3 < r2 ? u2 ? a2 : l2 : (r2 - n2) / o2 * c2;
    }
    function zx(t2) {
      return t2.element.dom.getBoundingClientRect();
    }
    function Nx(t2) {
      return zx(t2)[Mw];
    }
    function Lx(t2) {
      return zx(t2).right;
    }
    function Wx(t2) {
      return zx(t2).top;
    }
    function Ux(t2) {
      return zx(t2).bottom;
    }
    function jx(t2) {
      return zx(t2).width;
    }
    function Gx(t2) {
      return zx(t2).height;
    }
    function Xx(t2, n2) {
      var e3 = zx(t2), o2 = zx(n2);
      return (e3[Mw] + e3.right) / 2 - o2[Mw];
    }
    function Yx(t2, n2) {
      var e3 = zx(t2), o2 = zx(n2);
      return (e3.top + e3.bottom) / 2 - o2.top;
    }
    function qx(t2, n2) {
      br(t2, Bw(), { value: n2 });
    }
    function Kx(t2, n2, e3) {
      return Px({ min: sx(n2), max: mx(n2), range: bx(n2), value: e3, step: Sx(n2), snap: kx(n2), snapStart: Cx(n2), rounded: Ox(n2), hasMinEdge: Tx(n2), hasMaxEdge: Ex(n2), minBound: Nx(t2), maxBound: Lx(t2), screenRange: jx(t2) });
    }
    function Jx(r2) {
      return function(t2, n2) {
        return qx(t2, { x: o2 = (0 < r2 ? Rx : Ix)(Mx(e3 = n2).x, sx(e3), mx(e3), Sx(e3)) }), vt.some(o2).map(D);
        var e3, o2;
      };
    }
    function $x(t2, n2, e3, o2, r2, i2) {
      var u2, a2, c2, s2, l2, f2, d2, m3, g2 = (a2 = i2, c2 = e3, s2 = o2, l2 = r2, f2 = jx(u2 = n2), d2 = s2.bind(function(t3) {
        return vt.some(Xx(t3, u2));
      }).getOr(0), m3 = l2.bind(function(t3) {
        return vt.some(Xx(t3, u2));
      }).getOr(f2), Hx({ min: sx(a2), max: mx(a2), range: bx(a2), value: c2, hasMinEdge: Tx(a2), hasMaxEdge: Ex(a2), minBound: Nx(u2), minOffset: 0, maxBound: Lx(u2), maxOffset: f2, centerMinEdge: d2, centerMaxEdge: m3 }));
      return Nx(n2) - Nx(t2) + g2;
    }
    function Qx(t2, n2) {
      br(t2, Bw(), { value: n2 });
    }
    function Zx(t2, n2, e3) {
      return Px({ min: lx(n2), max: gx(n2), range: yx(n2), value: e3, step: Sx(n2), snap: kx(n2), snapStart: Cx(n2), rounded: Ox(n2), hasMinEdge: Dx(n2), hasMaxEdge: Bx(n2), minBound: Wx(t2), maxBound: Ux(t2), screenRange: Gx(t2) });
    }
    function t0(r2) {
      return function(t2, n2) {
        return Qx(t2, { y: o2 = (0 < r2 ? Rx : Ix)(Mx(e3 = n2).y, lx(e3), gx(e3), Sx(e3)) }), vt.some(o2).map(D);
        var e3, o2;
      };
    }
    function n0(t2, n2, e3, o2, r2, i2) {
      var u2, a2, c2, s2, l2, f2, d2, m3, g2 = (a2 = i2, c2 = e3, s2 = o2, l2 = r2, f2 = Gx(u2 = n2), d2 = s2.bind(function(t3) {
        return vt.some(Yx(t3, u2));
      }).getOr(0), m3 = l2.bind(function(t3) {
        return vt.some(Yx(t3, u2));
      }).getOr(f2), Hx({ min: lx(a2), max: gx(a2), range: yx(a2), value: c2, hasMinEdge: Dx(a2), hasMaxEdge: Bx(a2), minBound: Wx(u2), minOffset: 0, maxBound: Ux(u2), maxOffset: f2, centerMinEdge: d2, centerMaxEdge: m3 }));
      return Wx(n2) - Wx(t2) + g2;
    }
    function e0(t2, n2) {
      br(t2, Bw(), { value: n2 });
    }
    function o0(t2, n2) {
      return { x: t2, y: n2 };
    }
    function r0(u2, a2) {
      return function(t2, n2) {
        return o2 = n2, r2 = 0 < u2 ? Rx : Ix, e0(t2, o0(i2 = (e3 = a2) ? Mx(o2).x : r2(Mx(o2).x, sx(o2), mx(o2), Sx(o2)), e3 ? r2(Mx(o2).y, lx(o2), gx(o2), Sx(o2)) : Mx(o2).y)), vt.some(i2).map(D);
        var e3, o2, r2, i2;
      };
    }
    function i0(t2) {
      return "<alloy.field." + t2 + ">";
    }
    function u0(f2, d2, m3, g2) {
      function p2(t2, n2, e3, o2, r2) {
        var i2, u2, a2 = f2(uS + "range"), c2 = [my.parts.label({ dom: { tag: "label", innerHtml: e3, attributes: { "aria-label": o2 } } }), my.parts.field({ data: r2, factory: Dy, inputAttributes: lt2({ type: "text" }, "hex" === n2 ? { "aria-live": "polite" } : {}), inputClasses: [d2("textfield")], inputBehaviours: nc([(i2 = n2, u2 = t2, Ky.config({ invalidClass: d2("invalid"), notify: { onValidate: function(t3) {
          br(t3, iS, { type: i2 });
        }, onValid: function(t3) {
          br(t3, oS, { type: i2, value: Df.getValue(t3) });
        }, onInvalid: function(t3) {
          br(t3, rS, { type: i2, value: Df.getValue(t3) });
        } }, validator: { validate: function(t3) {
          var n3 = Df.getValue(t3), e4 = u2(n3) ? Ve.value(true) : Ve.error(f2("aria.input.invalid"));
          return Gy(e4);
        }, validateOnLoad: false } })), py.config({})]), onSetValue: function(t3) {
          Ky.isInvalid(t3) && Ky.run(t3).get(st);
        } })], s2 = "hex" !== n2 ? [my.parts["aria-descriptor"]({ text: a2 })] : [];
        return { dom: { tag: "div", attributes: { role: "presentation" } }, components: c2.concat(s2) };
      }
      function h2(t2, n2) {
        var e3 = n2.red, o2 = n2.green, r2 = n2.blue;
        Df.setValue(t2, { red: e3, green: o2, blue: r2 });
      }
      function v4(t2, n2) {
        b2.getOpt(t2).each(function(t3) {
          dn(t3.element, "background-color", "#" + n2.value);
        });
      }
      var b2 = zm({ dom: { tag: "div", classes: [d2("rgba-preview")], styles: { "background-color": "white" }, attributes: { role: "presentation" } } });
      return kl({ factory: function() {
        function a2(t3) {
          return o2[t3].get();
        }
        function c2(t3, n3) {
          o2[t3].set(n3);
        }
        function n2(t3, n3) {
          var e4 = n3.event;
          "hex" !== e4.type ? c2(e4.type, vt.none()) : g2(t3);
        }
        function e3(t3, n3) {
          var r3, e4, o3, i3, u3 = n3.event;
          "hex" === u3.type ? function(t4, n4) {
            m3(t4);
            var e5 = Mv(n4);
            c2("hex", vt.some(n4));
            var o4 = Hv(e5);
            h2(t4, o4), s2(o4), br(t4, Qw, { hex: e5 }), v4(t4, e5);
          }(t3, u3.value) : (r3 = t3, e4 = u3.type, o3 = u3.value, i3 = parseInt(o3, 10), c2(e4, vt.some(i3)), a2("red").bind(function(e5) {
            return a2("green").bind(function(n4) {
              return a2("blue").map(function(t4) {
                return Rv(e5, n4, t4, 1);
              });
            });
          }).each(function(t4) {
            var n4, e5, o4 = (n4 = r3, e5 = Iv(t4), eS.getField(n4, "hex").each(function(t5) {
              Hg.isFocused(t5) || Df.setValue(n4, { hex: e5.value });
            }), e5);
            br(r3, Qw, { hex: o4 }), v4(r3, o4);
          }));
        }
        function t2(t3) {
          return { label: f2(uS + t3 + ".label"), description: f2(uS + t3 + ".description") };
        }
        function s2(t3) {
          var n3 = t3.red, e4 = t3.green, o3 = t3.blue;
          c2("red", vt.some(n3)), c2("green", vt.some(e4)), c2("blue", vt.some(o3));
        }
        var o2 = { red: Po(vt.some(255)), green: Po(vt.some(255)), blue: Po(vt.some(255)), hex: Po(vt.some("ffffff")) }, r2 = t2("red"), i2 = t2("green"), u2 = t2("blue"), l2 = t2("hex");
        return Yo(eS.sketch(function(t3) {
          return { dom: { tag: "form", classes: [d2("rgb-form")], attributes: { "aria-label": f2("aria.color.picker") } }, components: [t3.field("red", my.sketch(p2(Vv, "red", r2.label, r2.description, 255))), t3.field("green", my.sketch(p2(Vv, "green", i2.label, i2.description, 255))), t3.field("blue", my.sketch(p2(Vv, "blue", u2.label, u2.description, 255))), t3.field("hex", my.sketch(p2(Av, "hex", l2.label, l2.description, "ffffff"))), b2.asSpec()], formBehaviours: nc([Ky.config({ invalidClass: d2("form-invalid") }), mm("rgb-form-events", [Cr(oS, e3), Cr(rS, n2), Cr(iS, n2)])]) };
        }), { apis: { updateHex: function(t3, n3) {
          var e4;
          Df.setValue(t3, { hex: n3.value }), h2(t3, e4 = Hv(n3)), s2(e4), v4(t3, n3);
        } } });
      }, name: "RgbForm", configFields: [], apis: { updateHex: function(t2, n2, e3) {
        t2.updateHex(n2, e3);
      } }, extraApis: {} });
    }
    function a0(x2, w2) {
      return kl({ name: "ColourPicker", configFields: [mo("dom"), Eo("onValidHex", st), Eo("onInvalidHex", st)], factory: function(t2) {
        function n2(t3, n3, e4) {
          v4.getOpt(t3).each(function(t4) {
            g2.setHue(t4, e4);
          });
        }
        function e3(t3, n3) {
          b2.getOpt(t3).each(function(t4) {
            m3.updateHex(t4, n3);
          });
        }
        function r2(n3, e4, o3, t3) {
          var r3 = o3, i3 = Hv(e4);
          p2.paletteRgba.set(i3), p2.paletteHue.set(r3), St(t3, function(t4) {
            t4(n3, e4, o3);
          });
        }
        var o2, i2, u2, a2, c2, s2, l2, f2, d2, m3 = u0(x2, w2, t2.onValidHex, t2.onInvalidHex), g2 = (l2 = w2, f2 = $w.parts.spectrum({ dom: { tag: "canvas", attributes: { role: "presentation" }, classes: [l2("sv-palette-spectrum")] } }), d2 = $w.parts.thumb({ dom: { tag: "div", attributes: { role: "presentation" }, classes: [l2("sv-palette-thumb")], innerHtml: "<div class=" + l2("sv-palette-inner-thumb") + ' role="presentation"></div>' } }), kl({ factory: function(t3) {
          var n3 = rt2({ x: 0, y: 0 }), e4 = nc([cd.config({ find: vt.some }), Hg.config({})]);
          return $w.sketch({ dom: { tag: "div", attributes: { role: "presentation" }, classes: [l2("sv-palette")] }, model: { mode: "xy", getInitialValue: n3 }, rounded: false, components: [f2, d2], onChange: function(t4, n4, e5) {
            br(t4, tS, { value: e5 });
          }, onInit: function(t4, n4, e5, o3) {
            y2(e5.element.dom, Lv(fb));
          }, sliderBehaviours: e4 });
        }, name: "SaturationBrightnessPalette", configFields: [], apis: { setHue: function(t3, n3, e4) {
          var o3 = e4;
          y2(n3.components()[0].element.dom, Lv(Pv(Uv(o3, 100, 100))));
        }, setThumb: function(t3, n3, e4) {
          var o3 = n3, r3 = jv(Hv(e4));
          $w.setValue(o3, { x: r3.saturation, y: 100 - r3.value });
        } }, extraApis: {} })), p2 = { paletteRgba: Po(fb), paletteHue: Po(0) }, h2 = zm((i2 = $w.parts.spectrum({ dom: { tag: "div", classes: [(o2 = w2)("hue-slider-spectrum")], attributes: { role: "presentation" } } }), u2 = $w.parts.thumb({ dom: { tag: "div", classes: [o2("hue-slider-thumb")], attributes: { role: "presentation" } } }), $w.sketch({ dom: { tag: "div", classes: [o2("hue-slider")], attributes: { role: "presentation" } }, rounded: false, model: { mode: "y", getInitialValue: rt2({ y: 0 }) }, components: [i2, u2], sliderBehaviours: nc([Hg.config({})]), onChange: function(t3, n3, e4) {
          br(t3, Zw, { value: e4 });
        } }))), v4 = zm(g2.sketch({})), b2 = zm(m3.sketch({}));
        function y2(t3, n3) {
          var e4, o3, r3 = t3.width, i3 = t3.height, u3 = t3.getContext("2d");
          null !== u3 && (u3.fillStyle = n3, u3.fillRect(0, 0, r3, i3), (e4 = u3.createLinearGradient(0, 0, r3, 0)).addColorStop(0, "rgba(255,255,255,1)"), e4.addColorStop(1, "rgba(255,255,255,0)"), u3.fillStyle = e4, u3.fillRect(0, 0, r3, i3), (o3 = u3.createLinearGradient(0, 0, 0, i3)).addColorStop(0, "rgba(0,0,0,0)"), o3.addColorStop(1, "rgba(0,0,0,1)"), u3.fillStyle = o3, u3.fillRect(0, 0, r3, i3));
        }
        return { uid: t2.uid, dom: t2.dom, components: [v4.asSpec(), h2.asSpec(), b2.asSpec()], behaviours: nc([mm("colour-picker-events", [Cr(Qw, (s2 = [n2, function(t3, n3, e4) {
          h2.getOpt(t3).each(function(t4) {
            $w.setValue(t4, { y: 100 - e4 / 360 * 100 });
          });
        }, function(t3, n3) {
          v4.getOpt(t3).each(function(t4) {
            g2.setThumb(t4, n3);
          });
        }], function(t3, n3) {
          var e4 = n3.event.hex;
          r2(t3, e4, jv(Hv(e4)).hue, s2);
        })), Cr(tS, (c2 = [e3], function(t3, n3) {
          var e4 = n3.event.value, o3 = p2.paletteHue.get();
          r2(t3, Gv(Uv(o3, e4.x, 100 - e4.y)), o3, c2);
        })), Cr(Zw, (a2 = [n2, e3], function(t3, n3) {
          var e4 = (100 - n3.event.value.y) / 100 * 360, o3 = jv(p2.paletteRgba.get());
          r2(t3, Gv(Uv(e4, o3.saturation, o3.value)), e4, a2);
        }))]), cd.config({ find: function(t3) {
          return b2.getOpt(t3);
        } }), Fg.config({ mode: "acyclic" })]) };
      } });
    }
    function c0(t2) {
      return sS[t2];
    }
    function s0(t2, n2, e3) {
      return Df.config(Yo({ store: { mode: "manual", getValue: n2, setValue: e3 } }, t2.map(function(t3) {
        return { store: { initialValue: t3 } };
      }).getOr({})));
    }
    function l0(r2, i2) {
      function n2(t2, n3) {
        n3.stop();
      }
      function e3(t2) {
        return function(n3, e4) {
          St(t2, function(t3) {
            t3(n3, e4);
          });
        };
      }
      function o2(t2, n3) {
        var e4;
        gd.isDisabled(t2) || (e4 = n3.event.raw, a2(t2, e4.dataTransfer.files));
      }
      function u2(t2, n3) {
        var e4 = n3.event.raw.target;
        a2(t2, e4.files);
      }
      function a2(t2, n3) {
        var e4, o3;
        Df.setValue(t2, (e4 = n3, o3 = fS.explode(i2.getSetting("images_file_types", "jpeg,jpg,jpe,jfi,jif,jfif,png,gif,bmp,webp", "string")), F(kt(e4), function(n4) {
          return d(o3, function(t3) {
            return Bt(n4.name.toLowerCase(), "." + t3.toLowerCase());
          });
        }))), br(t2, yy, { name: r2.name });
      }
      var c2 = zm({ dom: { tag: "input", attributes: { type: "file", accept: "image/*" }, styles: { display: "none" } }, behaviours: nc([mm("input-file-events", [Dr(Ci()), Dr(Vi())])]) });
      return ey(r2.label.map(function(t2) {
        return oy(t2, i2);
      }), my.parts.field({ factory: { sketch: function(t2) {
        return { uid: t2.uid, dom: { tag: "div", classes: ["tox-dropzone-container"] }, behaviours: nc([pS([]), aw(), gd.config({}), Lg.config({ toggleClass: "dragenter", toggleOnExecute: false }), mm("dropzone-events", [Cr("dragenter", e3([n2, Lg.toggle])), Cr("dragleave", e3([n2, Lg.toggle])), Cr("dragover", n2), Cr("drop", e3([n2, o2])), Cr(ki(), u2)])]), components: [{ dom: { tag: "div", classes: ["tox-dropzone"], styles: {} }, components: [{ dom: { tag: "p", innerHtml: i2.translate("Drop an image here") } }, fp.sketch({ dom: { tag: "button", innerHtml: i2.translate("Browse for an image"), styles: { position: "relative" }, classes: ["tox-button", "tox-button--secondary"] }, components: [c2.asSpec()], action: function(t3) {
          c2.get(t3).element.dom.click();
        }, buttonBehaviours: nc([py.config({}), $v(i2.isDisabled), pv()]) })] }] };
      } } }), ["tox-form__group--stretched"], []);
    }
    function f0(t2) {
      return { dom: { tag: "div", styles: { width: "1px", height: "1px", outline: "none" }, attributes: { tabindex: "0" }, classes: t2 }, behaviours: nc([Hg.config({ ignore: true }), py.config({})]) };
    }
    function d0(t2) {
      return { dom: { tag: "div", classes: ["tox-navobj"] }, components: [f0([hS]), t2, f0([vS])], behaviours: nc([cS(1)]) };
    }
    function m0(t2, n2) {
      br(t2, xi(), { raw: { which: 9, shiftKey: n2 } });
    }
    function g0(t2, n2) {
      var e3 = n2.element;
      Kr(e3, hS) ? m0(t2, true) : Kr(e3, vS) && m0(t2, false);
    }
    function p0(t2) {
      return Yb(t2, ["." + hS, "." + vS].join(","), T);
    }
    function h0(t2, n2) {
      return xS(document.createElement("canvas"), t2, n2);
    }
    function v0(t2) {
      var n2 = h0(t2.width, t2.height);
      return yS(n2).drawImage(t2, 0, 0), n2;
    }
    function b0(t2) {
      return t2.naturalWidth || t2.width;
    }
    function y0(t2) {
      return t2.naturalHeight || t2.height;
    }
    function x0(t2, o2, r2) {
      return o2 = o2 || "image/png", S(HTMLCanvasElement.prototype.toBlob) ? new Ny(function(n2, e3) {
        t2.toBlob(function(t3) {
          t3 ? n2(t3) : e3();
        }, o2, r2);
      }) : (g2 = t2.toDataURL(o2, r2), new Ny(function(t3, n2) {
        !function() {
          var t4 = g2.split(","), n3 = /data:([^;]+)/.exec(t4[0]);
          if (!n3)
            return vt.none();
          for (var e3 = n3[1], o3 = t4[1], r3 = atob(o3), i2 = r3.length, u2 = Math.ceil(i2 / 1024), a2 = new Array(u2), c2 = 0; c2 < u2; ++c2) {
            for (var s2 = 1024 * c2, l2 = Math.min(1024 + s2, i2), f2 = new Array(l2 - s2), d2 = s2, m3 = 0; d2 < l2; ++m3, ++d2)
              f2[m3] = r3[d2].charCodeAt(0);
            a2[c2] = new Uint8Array(f2);
          }
          return vt.some(new Blob(a2, { type: e3 }));
        }().fold(function() {
          n2("uri is not base64: " + g2);
        }, t3);
      }));
      var g2;
    }
    function w0(t2, n2, e3) {
      function o2(n3, e4) {
        return t2.then(function(t3) {
          return t3.toDataURL(n3 || "image/png", e4);
        });
      }
      return { getType: rt2(n2.type), toBlob: function() {
        return Ny.resolve(n2);
      }, toDataURL: rt2(e3), toBase64: function() {
        return e3.split(",")[1];
      }, toAdjustedBlob: function(n3, e4) {
        return t2.then(function(t3) {
          return x0(t3, n3, e4);
        });
      }, toAdjustedDataURL: o2, toAdjustedBase64: function(t3, n3) {
        return o2(t3, n3).then(function(t4) {
          return t4.split(",")[1];
        });
      }, toCanvas: function() {
        return t2.then(v0);
      } };
    }
    function S0(n2, t2) {
      return x0(n2, t2).then(function(t3) {
        return w0(Ny.resolve(n2), t3, n2.toDataURL());
      });
    }
    function k0(n2) {
      return e3 = n2, new Ny(function(t2) {
        var n3 = new FileReader();
        n3.onloadend = function() {
          t2(n3.result);
        }, n3.readAsDataURL(e3);
      }).then(function(t2) {
        return w0((a2 = n2, new Ny(function(t3, n3) {
          function e4() {
            r2.removeEventListener("load", i2), r2.removeEventListener("error", u2);
          }
          var o2 = URL.createObjectURL(a2), r2 = new Image(), i2 = function() {
            e4(), t3(r2);
          }, u2 = function() {
            e4(), n3("Unable to load data of type " + a2.type + ": " + o2);
          };
          r2.addEventListener("load", i2), r2.addEventListener("error", u2), r2.src = o2, r2.complete && setTimeout(i2, 0);
        }).then(function(t3) {
          wS(t3);
          var n3 = h0(b0(t3), y0(t3));
          return yS(n3).drawImage(t3, 0, 0), n3;
        })), n2, t2);
        var a2;
      });
      var e3;
    }
    function C0(t2, n2, e3) {
      var o2 = "string" == typeof t2 ? parseFloat(t2) : t2;
      return e3 < o2 ? o2 = e3 : o2 < n2 && (o2 = n2), o2;
    }
    function O0() {
      return [1, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 1];
    }
    function _0(t2, n2) {
      for (var e3 = [], o2 = new Array(25), r2 = 0; r2 < 5; r2++) {
        for (var i2 = 0; i2 < 5; i2++)
          e3[i2] = n2[i2 + 5 * r2];
        for (i2 = 0; i2 < 5; i2++) {
          for (var u2 = 0, a2 = 0; a2 < 5; a2++)
            u2 += t2[i2 + 5 * a2] * e3[a2];
          o2[i2 + 5 * r2] = u2;
        }
      }
      return o2;
    }
    function T0(n2, e3) {
      return n2.toCanvas().then(function(t2) {
        return kS(t2, n2.getType(), e3);
      });
    }
    function E0(e3) {
      return function(t2, n2) {
        return T0(t2, e3(O0(), n2));
      };
    }
    function D0(t2, n2) {
      void 0 === n2 && (n2 = 2);
      var e3 = Math.pow(10, n2), o2 = Math.round(t2 * e3);
      return Math.ceil(o2 / e3);
    }
    function B0(t2) {
      return CS(t2);
    }
    function M0(t2) {
      return TS(t2);
    }
    function A0(t2, n2) {
      return ES(t2, n2);
    }
    function F0(t2, n2) {
      return OS(t2, n2);
    }
    function I0(t2, n2) {
      return _S(t2, n2);
    }
    function R0(t2, n2) {
      return o2 = n2, (e3 = t2).toCanvas().then(function(t3) {
        return AS(t3, e3.getType(), o2);
      });
      var e3, o2;
    }
    function V0(t2, n2) {
      return o2 = n2, (e3 = t2).toCanvas().then(function(t3) {
        return MS(t3, e3.getType(), o2);
      });
      var e3, o2;
    }
    function P0(t2, n2, e3) {
      return Xm(t2, { tag: "span", classes: ["tox-icon", "tox-tbtn__icon-wrap"], behaviours: e3 }, n2);
    }
    function H0(t2, n2) {
      return P0(t2, n2, []);
    }
    function z0(t2, n2) {
      return P0(t2, n2, [Rg.config({})]);
    }
    function N0(t2, n2, e3) {
      return { dom: { tag: "span", innerHtml: e3.translate(t2), classes: [n2 + "__select-label"] }, behaviours: nc([Rg.config({})]) };
    }
    function L0(n2, e3, o2) {
      function t2(t3, n3) {
        var e4 = Df.getValue(t3);
        return Hg.focus(e4), br(e4, "keydown", { raw: n3.event.raw }), hw.close(e4), vt.some(true);
      }
      var r2 = Po(st), i2 = n2.text.map(function(t3) {
        return zm(N0(t3, e3, o2.providers));
      }), u2 = n2.icon.map(function(t3) {
        return zm(z0(t3, o2.providers.icons));
      }), a2 = n2.role.fold(function() {
        return {};
      }, function(t3) {
        return { role: t3 };
      }), c2 = n2.tooltip.fold(function() {
        return {};
      }, function(t3) {
        var n3 = o2.providers.translate(t3);
        return { title: n3, "aria-label": n3 };
      }), s2 = Xm("chevron-down", { tag: "div", classes: [e3 + "__select-chevron"] }, o2.providers.icons);
      return zm(hw.sketch(lt2(lt2(lt2({}, n2.uid ? { uid: n2.uid } : {}), a2), { dom: { tag: "button", classes: [e3, e3 + "--select"].concat(M(n2.classes, function(t3) {
        return e3 + "--" + t3;
      })), attributes: lt2({}, c2) }, components: tb([u2.map(function(t3) {
        return t3.asSpec();
      }), i2.map(function(t3) {
        return t3.asSpec();
      }), vt.some(s2)]), matchWidth: true, useMinWidth: true, dropdownBehaviours: nc(H(H([], n2.dropdownBehaviours, true), [$v(function() {
        return n2.disabled || o2.providers.isDisabled();
      }), pv(), vw.config({}), Rg.config({}), mm("dropdown-events", [vv(n2, r2), bv(n2, r2)]), mm("menubutton-update-display-text", [Cr(VS, function(n3, e4) {
        i2.bind(function(t3) {
          return t3.getOpt(n3);
        }).each(function(t3) {
          Rg.set(t3, [ri(o2.providers.translate(e4.event.text))]);
        });
      }), Cr(PS, function(n3, e4) {
        u2.bind(function(t3) {
          return t3.getOpt(n3);
        }).each(function(t3) {
          Rg.set(t3, [z0(e4.event.icon, o2.providers.icons)]);
        });
      })])], false)), eventOrder: Yo(RS, { mousedown: ["focusing", "alloy.base.behaviour", "item-type-events", "normal-dropdown-events"] }), sandboxBehaviours: nc([Fg.config({ mode: "special", onLeft: t2, onRight: t2 })]), lazySink: o2.getSink, toggleClass: e3 + "--active", parts: { menu: Zp(0, n2.columns, n2.presets) }, fetch: function(t3) {
        return jy(C(n2.fetch, t3));
      } }))).asSpec();
    }
    function W0(t2) {
      return "separator" === t2.type;
    }
    function U0(t2, e3, o2, n2) {
      var r2 = Ir("primary-menu"), i2 = zS(t2, o2.shared.providers.menuItems());
      if (0 === i2.items.length)
        return vt.none();
      var u2 = Gb(r2, i2.items, e3, o2, n2), a2 = dt(i2.menus, function(t3, n3) {
        return Gb(n3, t3, e3, o2, false);
      }), c2 = Yo(a2, sr(r2, u2));
      return vt.from(ip.tieredData(r2, c2, i2.expansions));
    }
    function j0(e3) {
      return { isDisabled: function() {
        return gd.isDisabled(e3);
      }, setDisabled: function(t2) {
        return gd.set(e3, t2);
      }, setActive: function(t2) {
        var n2 = e3.element;
        t2 ? (Yr(n2, "tox-tbtn--enabled"), on(n2, "aria-pressed", true)) : (qr(n2, "tox-tbtn--enabled"), sn(n2, "aria-pressed"));
      }, isActive: function() {
        return Kr(e3.element, "tox-tbtn--enabled");
      } };
    }
    function G0(e3, t2, o2, n2) {
      return L0({ text: e3.text, icon: e3.icon, tooltip: e3.tooltip, role: n2, fetch: function(t3, n3) {
        e3.fetch(function(t4) {
          n3(U0(t4, Sh.CLOSE_ON_EXECUTE, o2, false));
        });
      }, onSetup: e3.onSetup, getApi: j0, columns: 1, presets: "normal", classes: [], dropdownBehaviours: [py.config({})] }, t2, o2.shared);
    }
    function X0(t2, n2, e3, o2, r2, i2) {
      void 0 === e3 && (e3 = []);
      var u2 = n2.fold(function() {
        return {};
      }, function(t3) {
        return { action: t3 };
      }), a2 = lt2({ buttonBehaviours: nc([$v(function() {
        return t2.disabled || i2.isDisabled();
      }), pv(), py.config({}), mm("button press", [kr("click"), kr("mousedown")])].concat(e3)), eventOrder: { click: ["button press", "alloy.base.behaviour"], mousedown: ["button press", "alloy.base.behaviour"] } }, u2), c2 = Yo(a2, { dom: o2 });
      return Yo(c2, { components: r2 });
    }
    function Y0(t2, n2, e3, o2) {
      void 0 === o2 && (o2 = []);
      var r2 = { tag: "button", classes: ["tox-tbtn"], attributes: t2.tooltip.map(function(t3) {
        return { "aria-label": e3.translate(t3), title: e3.translate(t3) };
      }).getOr({}) }, i2 = t2.icon.map(function(t3) {
        return H0(t3, e3.icons);
      });
      return X0(t2, n2, o2, r2, tb([i2]), e3);
    }
    function q0(t2, n2, e3, o2) {
      void 0 === o2 && (o2 = []);
      var r2 = Y0(t2, vt.some(n2), e3, o2);
      return fp.sketch(r2);
    }
    function K0(t2, n2, e3, o2, r2) {
      void 0 === o2 && (o2 = []), void 0 === r2 && (r2 = []);
      var i2 = e3.translate(t2.text), u2 = t2.icon ? t2.icon.map(function(t3) {
        return H0(t3, e3.icons);
      }) : vt.none(), a2 = u2.isSome() ? tb([u2]) : [], c2 = u2.isSome() ? {} : { innerHtml: i2 }, s2 = H(H(H(H([], t2.primary || t2.borderless ? ["tox-button"] : ["tox-button", "tox-button--secondary"], true), u2.isSome() ? ["tox-button--icon"] : [], true), t2.borderless ? ["tox-button--naked"] : [], true), r2, true);
      return X0(t2, n2, o2, lt2(lt2({ tag: "button", classes: s2 }, c2), { attributes: { title: i2 } }), a2, e3);
    }
    function J0(t2, n2, e3, o2, r2) {
      void 0 === o2 && (o2 = []), void 0 === r2 && (r2 = []);
      var i2 = K0(t2, vt.some(n2), e3, o2, r2);
      return fp.sketch(i2);
    }
    function $0(n2, e3) {
      return function(t2) {
        "custom" === e3 ? br(t2, Sy, { name: n2, value: {} }) : "submit" === e3 ? vr(t2, ky) : "cancel" === e3 ? vr(t2, wy) : console.error("Unknown button type: ", e3);
      };
    }
    function Q0(n2, t2, e3) {
      if ("menu" === t2) {
        var o2 = n2, r2 = zm(G0(lt2(lt2({}, n2), { onSetup: function(t3) {
          return t3.setDisabled(n2.disabled), st;
        }, fetch: (i2 = o2.items, u2 = function() {
          return r2;
        }, a2 = e3, function(t3) {
          t3(M(i2, function(t4) {
            var n3, e4, o3 = t4.text.fold(function() {
              return {};
            }, function(t5) {
              return { text: t5 };
            });
            return lt2(lt2({ type: t4.type, active: false }, o3), { onAction: function(t5) {
              var n4 = !t5.isActive();
              t5.setActive(n4), e4.storage.set(n4), a2.shared.getSink().each(function(t6) {
                u2().getOpt(t6).each(function(t7) {
                  ka(t7.element), br(t7, Sy, { name: e4.name, value: e4.storage.get() });
                });
              });
            }, onSetup: (n3 = e4 = t4, function(t5) {
              t5.setActive(n3.storage.get());
            }) });
          }));
        }) }), "tox-tbtn", e3, vt.none()));
        return r2.asSpec();
      }
      var i2, u2, a2;
      if ("custom" === t2 || "cancel" === t2 || "submit" === t2) {
        var c2 = $0(n2.name, t2);
        return J0(lt2(lt2({}, n2), { borderless: false }), c2, e3.shared.providers, []);
      }
      console.error("Unknown footer button type: ", t2);
    }
    function Z0(t2, n2) {
      return Jf({ factory: my, name: t2, overrides: function(o2) {
        return { fieldBehaviours: nc([mm("coupled-input-behaviour", [Cr(Si(), function(e3) {
          ml(e3, o2, n2).bind(cd.getCurrent).each(function(n3) {
            ml(e3, o2, "lock").each(function(t3) {
              Lg.isOn(t3) && o2.onLockedChange(e3, n3, t3);
            });
          });
        })])]) };
      } });
    }
    function tw(t2) {
      var n2 = /^\s*(\d+(?:\.\d+)?)\s*(|cm|mm|in|px|pt|pc|em|ex|ch|rem|vw|vh|vmin|vmax|%)\s*$/.exec(t2);
      if (null === n2)
        return Ve.error(t2);
      var e3 = parseFloat(n2[1]), o2 = n2[2];
      return Ve.value({ value: e3, unit: o2 });
    }
    function nw(t2, n2) {
      function e3(t3) {
        return Tt(o2, t3);
      }
      var o2 = { "": 96, px: 96, pt: 72, cm: 2.54, pc: 12, mm: 25.4, in: 1 };
      return t2.unit === n2 ? vt.some(t2.value) : e3(t2.unit) && e3(n2) ? o2[t2.unit] === o2[n2] ? vt.some(t2.value) : vt.some(t2.value / o2[t2.unit] * o2[n2]) : vt.none();
    }
    function ew(t2) {
      return vt.none();
    }
    function ow(o2, n2) {
      function t2(t3) {
        return Xm(t3, { tag: "span", classes: ["tox-icon", "tox-lock-icon__" + t3] }, n2.icons);
      }
      function e3(t3) {
        return { dom: { tag: "div", classes: ["tox-form__group"] }, components: t3 };
      }
      function r2(e4) {
        return my.parts.field({ factory: Dy, inputClasses: ["tox-textfield"], inputBehaviours: nc([gd.config({ disabled: function() {
          return o2.disabled || n2.isDisabled();
        } }), pv(), py.config({}), mm("size-input-events", [Cr(bi(), function(t3, n3) {
          br(t3, u2, { isField1: e4 });
        }), Cr(ki(), function(t3, n3) {
          br(t3, yy, { name: o2.name });
        })])]), selectOnFocus: false });
      }
      function i2(t3) {
        return { dom: { tag: "label", classes: ["tox-label"], innerHtml: n2.translate(t3) } };
      }
      var l2 = ew, u2 = Ir("ratio-event"), a2 = WS.parts.lock({ dom: { tag: "button", classes: ["tox-lock", "tox-button", "tox-button--naked", "tox-button--icon"], attributes: { title: n2.translate(o2.label.getOr("Constrain proportions")) } }, components: [t2("lock"), t2("unlock")], buttonBehaviours: nc([gd.config({ disabled: function() {
        return o2.disabled || n2.isDisabled();
      } }), pv(), py.config({})]) }), c2 = WS.parts.field1(e3([my.parts.label(i2("Width")), r2(true)])), s2 = WS.parts.field2(e3([my.parts.label(i2("Height")), r2(false)]));
      return WS.sketch({ dom: { tag: "div", classes: ["tox-form__group"] }, components: [{ dom: { tag: "div", classes: ["tox-form__controls-h-stack"] }, components: [c2, s2, e3([i2("&nbsp;"), a2])] }], field1Name: "width", field2Name: "height", locked: true, markers: { lockClass: "tox-locked" }, onLockedChange: function(t3, i3, n3) {
        tw(Df.getValue(t3)).each(function(t4) {
          l2(t4).each(function(t5) {
            var n4, e4, o3, r3;
            Df.setValue(i3, (r3 = -1 !== (r3 = (n4 = t5).value.toFixed((e4 = n4.unit) in (o3 = { "": 0, px: 0, pt: 1, mm: 1, pc: 2, ex: 2, em: 2, ch: 2, rem: 2, cm: 3, in: 4, "%": 4 }) ? o3[e4] : 1)).indexOf(".") ? r3.replace(/\.?0*$/, "") : r3) + n4.unit);
          });
        });
      }, coupledFieldBehaviours: nc([gd.config({ disabled: function() {
        return o2.disabled || n2.isDisabled();
      }, onDisabled: function(t3) {
        WS.getField1(t3).bind(my.getField).each(gd.disable), WS.getField2(t3).bind(my.getField).each(gd.disable), WS.getLock(t3).each(gd.disable);
      }, onEnabled: function(t3) {
        WS.getField1(t3).bind(my.getField).each(gd.enable), WS.getField2(t3).bind(my.getField).each(gd.enable), WS.getLock(t3).each(gd.enable);
      } }), pv(), mm("size-input-events2", [Cr(u2, function(t3, n3) {
        var e4, o3, r3, i3 = n3.event.isField1, u3 = i3 ? WS.getField1(t3) : WS.getField2(t3), a3 = i3 ? WS.getField2(t3) : WS.getField1(t3), c3 = u3.map(Df.getValue).getOr(""), s3 = a3.map(Df.getValue).getOr("");
        e4 = s3, o3 = tw(c3).toOptional(), r3 = tw(e4).toOptional(), l2 = Et(o3, r3, function(t4, o4) {
          return nw(t4, o4.unit).map(function(t5) {
            return o4.value / t5;
          }).map(function(t5) {
            return n4 = t5, e5 = o4.unit, function(t6) {
              return nw(t6, e5).map(function(t7) {
                return { value: t7 * n4, unit: e5 };
              });
            };
            var n4, e5;
          }).getOr(ew);
        }).getOr(ew);
      })])]) });
    }
    function rw(f2, c2) {
      function t2(t3, n3, e4, o3) {
        return zm(J0({ name: t3, text: t3, disabled: e4, primary: o3, icon: vt.none(), borderless: false }, n3, c2));
      }
      function n2(t3, n3, e4, o3) {
        return zm(q0({ name: t3, icon: vt.some(t3), tooltip: vt.some(n3), disabled: o3, primary: false, borderless: false }, e4, c2));
      }
      function d2(t3, e4) {
        t3.map(function(t4) {
          var n3 = t4.get(e4);
          n3.hasConfigured(gd) && gd.disable(n3);
        });
      }
      function m3(t3, e4) {
        t3.map(function(t4) {
          var n3 = t4.get(e4);
          n3.hasConfigured(gd) && gd.enable(n3);
        });
      }
      function r2(t3, n3, e4) {
        br(t3, n3, e4);
      }
      function i2(t3) {
        return vr(t3, YS.disable()), 0;
      }
      function u2(t3) {
        return vr(t3, YS.enable()), 0;
      }
      function g2(t3, n3) {
        i2(t3), r2(t3, US.transform(), { transform: n3 }), u2(t3);
      }
      function e3(t3) {
        return function() {
          q2.getOpt(t3).each(function(t4) {
            Rg.set(t4, [Y2]);
          });
        };
      }
      function s2(t3, n3) {
        i2(t3), r2(t3, US.transformApply(), { transform: n3, swap: e3(t3) }), u2(t3);
      }
      function p2() {
        return t2("Back", function(t3) {
          return r2(t3, US.back(), { swap: e3(t3) });
        }, false, false);
      }
      function o2() {
        return zm({ dom: { tag: "div", classes: ["tox-spacer"] }, behaviours: nc([gd.config({})]) });
      }
      function h2() {
        return t2("Apply", function(t3) {
          return r2(t3, US.apply(), { swap: e3(t3) });
        }, true, true);
      }
      function v4(n3, e4) {
        return function(t3) {
          return n3(t3, e4);
        };
      }
      function a2(t3, n3) {
        var e4, o3 = n3;
        i2(e4 = t3), r2(e4, US.tempTransform(), { transform: o3 }), u2(e4);
      }
      function b2(t3, n3, e4, o3, r3) {
        var i3 = $w.parts.label({ dom: { tag: "label", classes: ["tox-label"], innerHtml: c2.translate(t3) } }), u3 = $w.parts.spectrum({ dom: { tag: "div", classes: ["tox-slider__rail"], attributes: { role: "presentation" } } }), a3 = $w.parts.thumb({ dom: { tag: "div", classes: ["tox-slider__handle"], attributes: { role: "presentation" } } });
        return zm($w.sketch({ dom: { tag: "div", classes: ["tox-slider"], attributes: { role: "presentation" } }, model: { mode: "x", minX: e4, maxX: r3, getInitialValue: rt2({ x: o3 }) }, components: [i3, u3, a3], sliderBehaviours: nc([Hg.config({})]), onChoose: n3 }));
      }
      function l2(t3, n3, e4, o3, r3) {
        var i3, u3, a3, c3, s3, l3, f3 = (i3 = t3, u3 = n3, a3 = e4, c3 = o3, s3 = r3, [p2(), (l3 = u3, b2(i3, function(t4, n4, e5) {
          g2(t4, v4(l3, e5.x / 100));
        }, a3, c3, s3)), h2()]);
        return ly.sketch({ dom: w2, components: f3.map(function(t4) {
          return t4.asSpec();
        }), containerBehaviours: nc([mm("image-tools-filter-panel-buttons-events", [Cr(YS.disable(), function(t4, n4) {
          d2(f3, t4);
        }), Cr(YS.enable(), function(t4, n4) {
          m3(f3, t4);
        })])]) });
      }
      function y2(t3) {
        return b2(t3, function(l3, t4, n3) {
          var e4 = z2.getOpt(l3), o3 = L2.getOpt(l3), r3 = N2.getOpt(l3);
          e4.each(function(s3) {
            o3.each(function(c3) {
              r3.each(function(t5) {
                var o4, r4, i3, n4 = Df.getValue(s3).x / 100, e5 = Df.getValue(t5).x / 100, u3 = Df.getValue(c3).x / 100, a3 = (o4 = n4, r4 = e5, i3 = u3, function(t6) {
                  return T0(t6, (n5 = r4, e6 = i3, _0(O0(), [C0(o4, 0, 2), 0, 0, 0, 0, 0, C0(n5, 0, 2), 0, 0, 0, 0, 0, C0(e6, 0, 2), 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 1])));
                  var n5, e6;
                });
                g2(l3, a3);
              });
            });
          });
        }, 0, 100, 200);
      }
      function x2(n3, e4, o3) {
        return function(t3) {
          r2(t3, US.swap(), { transform: e4, swap: function() {
            q2.getOpt(t3).each(function(t4) {
              Rg.set(t4, [n3]), o3(t4);
            });
          } });
        };
      }
      var w2 = { tag: "div", classes: ["tox-image-tools__toolbar", "tox-image-tools-edit-panel"] }, S2 = st, k2 = [p2(), o2(), t2("Apply", function(t3) {
        s2(t3, function(t4) {
          var n3, e4, o3, r3, i3, u3, a3, c3, s3, l3 = f2.getRect();
          return n3 = l3.x, e4 = l3.y, o3 = l3.w, r3 = l3.h, u3 = n3, a3 = e4, c3 = o3, s3 = r3, (i3 = t4).toCanvas().then(function(t5) {
            return FS(t5, i3.getType(), u3, a3, c3, s3);
          });
        }), f2.hideCrop();
      }, false, true)], C2 = ly.sketch({ dom: w2, components: k2.map(function(t3) {
        return t3.asSpec();
      }), containerBehaviours: nc([mm("image-tools-crop-buttons-events", [Cr(YS.disable(), function(t3, n3) {
        d2(k2, t3);
      }), Cr(YS.enable(), function(t3, n3) {
        m3(k2, t3);
      })])]) }), O2 = zm(ow({ name: "size", label: vt.none(), constrain: true, disabled: false }, c2)), _2 = [p2(), o2(), O2, o2(), t2("Apply", function(a3) {
        O2.getOpt(a3).each(function(t3) {
          var r3, i3, n3 = Df.getValue(t3), e4 = parseInt(n3.width, 10), o3 = parseInt(n3.height, 10), u3 = (r3 = e4, i3 = o3, function(t4) {
            return e5 = r3, o4 = i3, (n4 = t4).toCanvas().then(function(t5) {
              return DS(t5, e5, o4).then(function(t6) {
                return S0(t6, n4.getType());
              });
            });
            var n4, e5, o4;
          });
          s2(a3, u3);
        });
      }, false, true)], T2 = ly.sketch({ dom: w2, components: _2.map(function(t3) {
        return t3.asSpec();
      }), containerBehaviours: nc([mm("image-tools-resize-buttons-events", [Cr(YS.disable(), function(t3, n3) {
        d2(_2, t3);
      }), Cr(YS.enable(), function(t3, n3) {
        m3(_2, t3);
      })])]) }), E2 = v4(R0, "h"), D2 = v4(R0, "v"), B2 = v4(V0, -90), M2 = v4(V0, 90), A2 = [p2(), o2(), n2("flip-horizontally", "Flip horizontally", function(t3) {
        a2(t3, E2);
      }, false), n2("flip-vertically", "Flip vertically", function(t3) {
        a2(t3, D2);
      }, false), n2("rotate-left", "Rotate counterclockwise", function(t3) {
        a2(t3, B2);
      }, false), n2("rotate-right", "Rotate clockwise", function(t3) {
        a2(t3, M2);
      }, false), o2(), h2()], F2 = ly.sketch({ dom: w2, components: A2.map(function(t3) {
        return t3.asSpec();
      }), containerBehaviours: nc([mm("image-tools-fliprotate-buttons-events", [Cr(YS.disable(), function(t3, n3) {
        d2(A2, t3);
      }), Cr(YS.enable(), function(t3, n3) {
        m3(A2, t3);
      })])]) }), I2 = [p2(), o2(), h2()], R2 = ly.sketch({ dom: w2, components: I2.map(function(t3) {
        return t3.asSpec();
      }) }), V2 = l2("Brightness", F0, -100, 0, 100), P2 = l2("Contrast", I0, -100, 0, 100), H2 = l2("Gamma", A0, -100, 0, 100), z2 = y2("R"), N2 = y2("G"), L2 = y2("B"), W2 = [p2(), z2, N2, L2, h2()], U2 = ly.sketch({ dom: w2, components: W2.map(function(t3) {
        return t3.asSpec();
      }) }), j2 = vt.some(M0), G2 = vt.some(B0), X2 = [n2("crop", "Crop", x2(C2, vt.none(), function(t3) {
        f2.showCrop();
      }), false), n2("resize", "Resize", x2(T2, vt.none(), function(t3) {
        O2.getOpt(t3).each(function(t4) {
          var n3 = f2.getMeasurements(), e4 = n3.width, o3 = n3.height;
          Df.setValue(t4, { width: e4, height: o3 });
        });
      }), false), n2("orientation", "Orientation", x2(F2, vt.none(), S2), false), n2("brightness", "Brightness", x2(V2, vt.none(), S2), false), n2("sharpen", "Sharpen", x2(R2, j2, S2), false), n2("contrast", "Contrast", x2(P2, vt.none(), S2), false), n2("color-levels", "Color levels", x2(U2, vt.none(), S2), false), n2("gamma", "Gamma", x2(H2, vt.none(), S2), false), n2("invert", "Invert", x2(R2, G2, S2), false)], Y2 = ly.sketch({ dom: w2, components: X2.map(function(t3) {
        return t3.asSpec();
      }) }), q2 = zm(ly.sketch({ dom: { tag: "div" }, components: [Y2], containerBehaviours: nc([Rg.config({})]) }));
      return { memContainer: q2, getApplyButton: function(t3) {
        return q2.getOpt(t3).map(function(t4) {
          var n3 = t4.components()[0];
          return n3.components()[n3.components().length - 1];
        });
      } };
    }
    function iw(t2) {
      if (k(t2.changedTouches))
        for (var n2 = "screenX screenY pageX pageY clientX clientY".split(" "), e3 = 0; e3 < n2.length; e3++)
          t2[n2[e3]] = t2.changedTouches[0][n2[e3]];
    }
    (zy = Hy = Hy || {})[zy.HighlightFirst = 0] = "HighlightFirst", zy[zy.HighlightNone = 1] = "HighlightNone";
    function uw(o2, t2) {
      return { uid: o2.uid, dom: o2.dom, components: t2, behaviours: nl(o2.formBehaviours, [Df.config({ store: { mode: "manual", getValue: function(t3) {
        return dt(hl(t3, o2), function(t4, o3) {
          return t4().bind(function(t5) {
            var n2 = cd.getCurrent(t5), e3 = new Error("Cannot find a current component to extract the value from for form part '" + o3 + "': " + Fr(t5.element));
            return n2.fold(function() {
              return Ve.error(e3);
            }, Ve.value);
          }).map(Df.getValue);
        });
      }, setValue: function(e3, t3) {
        J(t3, function(n2, t4) {
          ml(e3, o2, t4).each(function(t5) {
            cd.getCurrent(t5).each(function(t6) {
              Df.setValue(t6, n2);
            });
          });
        });
      } } })]), apis: { getField: function(t3, n2) {
        return ml(t3, o2, n2).bind(cd.getCurrent);
      } } };
    }
    function aw() {
      return cd.config({ find: vt.some });
    }
    function cw(t2) {
      return n2 = Mr, e3 = Ar, s0(t2, function(t3) {
        return n2(t3.element);
      }, function(t3, n3) {
        return e3(t3.element, n3);
      });
      var n2, e3;
    }
    var sw, lw, fw, dw, mw = function(n2, t2) {
      return n2.getSystem().getByUid(t2.uid + "-" + Qy()).map(function(t3) {
        return function() {
          return Ve.value(t3);
        };
      }).getOrThunk(function() {
        return t2.lazySink.fold(function() {
          return function() {
            return Ve.error(new Error("No internal sink is specified, nor could an external sink be found"));
          };
        }, function(t3) {
          return function() {
            return t3(n2);
          };
        });
      });
    }, gw = rt2([mo("dom"), mo("fetch"), Ju("onOpen"), $u("onExecute"), Eo("getHotspot", vt.some), Eo("getAnchorOverrides", rt2({})), Wc(), Zs("dropdownBehaviours", [Lg, $y, Fg, Hg]), mo("toggleClass"), Eo("eventOrder", {}), wo("lazySink"), Eo("matchWidth", false), Eo("useMinWidth", false), wo("role")].concat(ux())), pw = rt2([$f({ schema: [Yu()], name: "menu", defaults: function(t2) {
      return { onExecute: t2.onExecute };
    } }), Zy()]), hw = Cl({ name: "Dropdown", configFields: gw(), partFields: pw(), factory: function(n2, t2, e3, o2) {
      function r2(t3) {
        bf.getState(t3).each(function(t4) {
          ip.highlightPrimary(t4);
        });
      }
      function i2(t3, n3) {
        return yr(t3), vt.some(true);
      }
      var u2, a2 = { expand: function(t3) {
        Lg.isOn(t3) || ex(n2, h, t3, o2, st, Hy.HighlightNone).get(st);
      }, open: function(t3) {
        Lg.isOn(t3) || ex(n2, h, t3, o2, st, Hy.HighlightFirst).get(st);
      }, isOpen: Lg.isOn, close: function(t3) {
        Lg.isOn(t3) && ex(n2, h, t3, o2, st, Hy.HighlightFirst).get(st);
      }, repositionMenus: function(t3) {
        Lg.isOn(t3) && ix(t3);
      } };
      return { uid: n2.uid, dom: n2.dom, components: t2, behaviours: nl(n2.dropdownBehaviours, [Lg.config({ toggleClass: n2.toggleClass, aria: { mode: "expanded" } }), $y.config({ others: { sandbox: function(t3) {
        return rx(n2, t3, { onOpen: function() {
          return Lg.on(t3);
        }, onClose: function() {
          return Lg.off(t3);
        } });
      } } }), Fg.config({ mode: "special", onSpace: i2, onEnter: i2, onDown: function(t3, n3) {
        return hw.isOpen(t3) ? r2($y.getCoupled(t3, "sandbox")) : hw.open(t3), vt.some(true);
      }, onEscape: function(t3, n3) {
        return hw.isOpen(t3) ? (hw.close(t3), vt.some(true)) : vt.none();
      } }), Hg.config({})]), events: Sm(vt.some(function(t3) {
        ex(n2, h, t3, o2, r2, Hy.HighlightFirst).get(st);
      })), eventOrder: lt2(lt2({}, n2.eventOrder), ((u2 = {})[Ii()] = ["disabling", "toggling", "alloy.base.behaviour"], u2)), apis: a2, domModification: { attributes: lt2(lt2({ "aria-haspopup": "true" }, n2.role.fold(function() {
        return {};
      }, function(t3) {
        return { role: t3 };
      })), "button" === n2.dom.tag ? { type: tt(n2.dom, "attributes").bind(function(t3) {
        return tt(t3, "type");
      }).getOr("button") } : {}) } };
    }, apis: { open: function(t2, n2) {
      return t2.open(n2);
    }, expand: function(t2, n2) {
      return t2.expand(n2);
    }, close: function(t2, n2) {
      return t2.close(n2);
    }, isOpen: function(t2, n2) {
      return t2.isOpen(n2);
    }, repositionMenus: function(t2, n2) {
      return t2.repositionMenus(n2);
    } } }), vw = xa({ fields: [], name: "unselecting", active: Object.freeze({ __proto__: null, events: function() {
      return eu([Sr(Ei(), D)]);
    }, exhibit: function() {
      return Lr({ styles: { "-webkit-user-select": "none", "user-select": "none", "-ms-user-select": "none", "-moz-user-select": "-moz-none" }, attributes: { unselectable: "on" } });
    } }) }), bw = Ir("color-input-change"), yw = Ir("color-swatch-change"), xw = Ir("color-picker-cancel"), ww = Qf({ schema: [mo("dom")], name: "label" }), Sw = ax("top-left"), kw = ax("top"), Cw = ax("top-right"), Ow = ax("right"), _w = ax("bottom-right"), Tw = ax("bottom"), Ew = ax("bottom-left"), Dw = [ww, ax("left"), Ow, kw, Tw, Sw, Cw, Ew, _w, Jf({ name: "thumb", defaults: rt2({ dom: { styles: { position: "absolute" } } }), overrides: function(t2) {
      return { events: eu([Tr(si(), t2, "spectrum"), Tr(li(), t2, "spectrum"), Tr(fi(), t2, "spectrum"), Tr(mi(), t2, "spectrum"), Tr(gi(), t2, "spectrum"), Tr(hi(), t2, "spectrum")]) };
    } }), Jf({ schema: [cr("mouseIsDown", function() {
      return Po(false);
    })], name: "spectrum", overrides: function(e3) {
      function o2(n2, t2) {
        return r2.getValueFromEvent(t2).map(function(t3) {
          return r2.setValueFrom(n2, e3, t3);
        });
      }
      var r2 = e3.model.manager;
      return { behaviours: nc([Fg.config({ mode: "special", onLeft: function(t2) {
        return r2.onLeft(t2, e3);
      }, onRight: function(t2) {
        return r2.onRight(t2, e3);
      }, onUp: function(t2) {
        return r2.onUp(t2, e3);
      }, onDown: function(t2) {
        return r2.onDown(t2, e3);
      } }), Hg.config({})]), events: eu([Cr(si(), o2), Cr(li(), o2), Cr(mi(), o2), Cr(gi(), function(t2, n2) {
        e3.mouseIsDown.get() && o2(t2, n2);
      })]) };
    } })], Bw = rt2("slider.change.value"), Mw = "left", Aw = Jx(-1), Fw = Jx(1), Iw = vt.none, Rw = vt.none, Vw = { "top-left": vt.none(), top: vt.none(), "top-right": vt.none(), right: vt.some(function(t2, n2) {
      Fx(t2, { x: px(n2) });
    }), "bottom-right": vt.none(), bottom: vt.none(), "bottom-left": vt.none(), left: vt.some(function(t2, n2) {
      Fx(t2, { x: fx(n2) });
    }) }, Pw = Object.freeze({ __proto__: null, setValueFrom: function(t2, n2, e3) {
      var o2 = Kx(t2, n2, e3);
      return qx(t2, { x: o2 }), o2;
    }, setToMin: function(t2, n2) {
      qx(t2, { x: sx(n2) });
    }, setToMax: function(t2, n2) {
      qx(t2, { x: mx(n2) });
    }, findValueOfOffset: Kx, getValueFromEvent: function(t2) {
      return cx(t2).map(function(t3) {
        return t3.left;
      });
    }, findPositionOfValue: $x, setPositionFromValue: function(t2, n2, e3, o2) {
      var r2 = Mx(e3), i2 = $x(t2, o2.getSpectrum(t2), r2.x, o2.getLeftEdge(t2), o2.getRightEdge(t2), e3), u2 = On(n2.element) / 2;
      dn(n2.element, "left", i2 - u2 + "px");
    }, onLeft: Aw, onRight: Fw, onUp: Iw, onDown: Rw, edgeActions: Vw }), Hw = vt.none, zw = vt.none, Nw = t0(-1), Lw = t0(1), Ww = { "top-left": vt.none(), top: vt.some(function(t2, n2) {
      Fx(t2, { y: dx(n2) });
    }), "top-right": vt.none(), right: vt.none(), "bottom-right": vt.none(), bottom: vt.some(function(t2, n2) {
      Fx(t2, { y: hx(n2) });
    }), "bottom-left": vt.none(), left: vt.none() }, Uw = Object.freeze({ __proto__: null, setValueFrom: function(t2, n2, e3) {
      var o2 = Zx(t2, n2, e3);
      return Qx(t2, { y: o2 }), o2;
    }, setToMin: function(t2, n2) {
      Qx(t2, { y: lx(n2) });
    }, setToMax: function(t2, n2) {
      Qx(t2, { y: gx(n2) });
    }, findValueOfOffset: Zx, getValueFromEvent: function(t2) {
      return cx(t2).map(function(t3) {
        return t3.top;
      });
    }, findPositionOfValue: n0, setPositionFromValue: function(t2, n2, e3, o2) {
      var r2 = Mx(e3), i2 = n0(t2, o2.getSpectrum(t2), r2.y, o2.getTopEdge(t2), o2.getBottomEdge(t2), e3), u2 = wn(n2.element) / 2;
      dn(n2.element, "top", i2 - u2 + "px");
    }, onLeft: Hw, onRight: zw, onUp: Nw, onDown: Lw, edgeActions: Ww }), jw = cx, Gw = r0(-1, false), Xw = r0(1, false), Yw = r0(-1, true), qw = r0(1, true), Kw = { "top-left": vt.some(function(t2, n2) {
      Fx(t2, Ax(fx(n2), dx(n2)));
    }), top: vt.some(function(t2, n2) {
      Fx(t2, Ax(xx(n2), dx(n2)));
    }), "top-right": vt.some(function(t2, n2) {
      Fx(t2, Ax(px(n2), dx(n2)));
    }), right: vt.some(function(t2, n2) {
      Fx(t2, Ax(px(n2), wx2(n2)));
    }), "bottom-right": vt.some(function(t2, n2) {
      Fx(t2, Ax(px(n2), hx(n2)));
    }), bottom: vt.some(function(t2, n2) {
      Fx(t2, Ax(xx(n2), hx(n2)));
    }), "bottom-left": vt.some(function(t2, n2) {
      Fx(t2, Ax(fx(n2), hx(n2)));
    }), left: vt.some(function(t2, n2) {
      Fx(t2, Ax(fx(n2), wx2(n2)));
    }) }, Jw = Object.freeze({ __proto__: null, setValueFrom: function(t2, n2, e3) {
      var o2 = o0(Kx(t2, n2, e3.left), Zx(t2, n2, e3.top));
      return e0(t2, o2), o2;
    }, setToMin: function(t2, n2) {
      e0(t2, o0(sx(n2), lx(n2)));
    }, setToMax: function(t2, n2) {
      e0(t2, o0(mx(n2), gx(n2)));
    }, getValueFromEvent: jw, setPositionFromValue: function(t2, n2, e3, o2) {
      var r2 = Mx(e3), i2 = $x(t2, o2.getSpectrum(t2), r2.x, o2.getLeftEdge(t2), o2.getRightEdge(t2), e3), u2 = n0(t2, o2.getSpectrum(t2), r2.y, o2.getTopEdge(t2), o2.getBottomEdge(t2), e3), a2 = On(n2.element) / 2, c2 = wn(n2.element) / 2;
      dn(n2.element, "left", i2 - a2 + "px"), dn(n2.element, "top", u2 - c2 + "px");
    }, onLeft: Gw, onRight: Xw, onUp: Yw, onDown: qw, edgeActions: Kw }), $w = Cl({ name: "Slider", configFields: [Eo("stepSize", 1), Eo("onChange", st), Eo("onChoose", st), Eo("onInit", st), Eo("onDragStart", st), Eo("onDragEnd", st), Eo("snapToGrid", false), Eo("rounded", true), wo("snapStart"), go("model", lo("mode", { x: [Eo("minX", 0), Eo("maxX", 100), cr("value", function(t2) {
      return Po(t2.mode.minX);
    }), mo("getInitialValue"), ta("manager", Pw)], y: [Eo("minY", 0), Eo("maxY", 100), cr("value", function(t2) {
      return Po(t2.mode.minY);
    }), mo("getInitialValue"), ta("manager", Uw)], xy: [Eo("minX", 0), Eo("maxX", 100), Eo("minY", 0), Eo("maxY", 100), cr("value", function(t2) {
      return Po({ x: t2.mode.minX, y: t2.mode.minY });
    }), mo("getInitialValue"), ta("manager", Jw)] })), Zs("sliderBehaviours", [Fg, Df]), cr("mouseIsDown", function() {
      return Po(false);
    })], partFields: Dw, factory: function(i2, t2, n2, e3) {
      function u2(t3) {
        return gl(t3, i2, "thumb");
      }
      function a2(t3) {
        return gl(t3, i2, "spectrum");
      }
      function o2(t3) {
        return ml(t3, i2, "left-edge");
      }
      function r2(t3) {
        return ml(t3, i2, "right-edge");
      }
      function c2(t3) {
        return ml(t3, i2, "top-edge");
      }
      function s2(t3) {
        return ml(t3, i2, "bottom-edge");
      }
      function l2(t3, n3) {
        v4.setPositionFromValue(t3, n3, i2, { getLeftEdge: o2, getRightEdge: r2, getTopEdge: c2, getBottomEdge: s2, getSpectrum: a2 });
      }
      function f2(t3, n3) {
        h2.value.set(n3), l2(t3, u2(t3));
      }
      function d2(e4) {
        var t3 = i2.mouseIsDown.get();
        i2.mouseIsDown.set(false), t3 && ml(e4, i2, "thumb").each(function(t4) {
          var n3 = h2.value.get();
          i2.onChoose(e4, t4, n3);
        });
      }
      function m3(t3, n3) {
        n3.stop(), i2.mouseIsDown.set(true), i2.onDragStart(t3, u2(t3));
      }
      function g2(t3, n3) {
        n3.stop(), i2.onDragEnd(t3, u2(t3)), d2(t3);
      }
      var p2, h2 = i2.model, v4 = h2.manager;
      return { uid: i2.uid, dom: i2.dom, components: t2, behaviours: nl(i2.sliderBehaviours, [Fg.config({ mode: "special", focusIn: function(t3) {
        return ml(t3, i2, "spectrum").map(Fg.focusIn).map(D);
      } }), Df.config({ store: { mode: "manual", getValue: function(t3) {
        return h2.value.get();
      } } }), ic.config({ channels: ((p2 = {})[wf()] = { onReceive: d2 }, p2) })]), events: eu([Cr(Bw(), function(t3, n3) {
        !function(t4, n4) {
          f2(t4, n4);
          var e4 = u2(t4);
          i2.onChange(t4, e4, n4), vt.some(true);
        }(t3, n3.event.value);
      }), ou(function(t3, n3) {
        var e4 = h2.getInitialValue();
        h2.value.set(e4);
        var o3 = u2(t3);
        l2(t3, o3);
        var r3 = a2(t3);
        i2.onInit(t3, o3, r3, h2.value.get());
      }), Cr(si(), m3), Cr(fi(), g2), Cr(mi(), m3), Cr(hi(), g2)]), apis: { resetToMin: function(t3) {
        v4.setToMin(t3, i2);
      }, resetToMax: function(t3) {
        v4.setToMax(t3, i2);
      }, setValue: f2, refresh: l2 }, domModification: { styles: { position: "relative" } } };
    }, apis: { setValue: function(t2, n2, e3) {
      t2.setValue(n2, e3);
    }, resetToMin: function(t2, n2) {
      t2.resetToMin(n2);
    }, resetToMax: function(t2, n2) {
      t2.resetToMax(n2);
    }, refresh: function(t2, n2) {
      t2.refresh(n2);
    } } }), Qw = Ir("rgb-hex-update"), Zw = Ir("slider-update"), tS = Ir("palette-update"), nS = [Zs("formBehaviours", [Df])], eS = { getField: zr(function(t2, n2, e3) {
      return t2.getField(n2, e3);
    }), sketch: function(t2) {
      var e3, n2 = { field: function(t3, n3) {
        return e3.push(t3), cl("form", i0(t3), n3);
      }, record: rt2(e3 = []) }, o2 = t2(n2), r2 = M(n2.record(), function(t3) {
        return Jf({ name: t3, pname: i0(t3) });
      });
      return Sl("form", nS, r2, uw, o2);
    } }, oS = Ir("valid-input"), rS = Ir("invalid-input"), iS = Ir("validating-input"), uS = "colorcustom.rgb.", aS = function(t2) {
      return cd.config({ find: t2.getOpt });
    }, cS = function(t2) {
      return cd.config({ find: function(n2) {
        return Jt(n2.element, t2).bind(function(t3) {
          return n2.getSystem().getByDom(t3).toOptional();
        });
      } });
    }, sS = { "colorcustom.rgb.red.label": "R", "colorcustom.rgb.red.description": "Red component", "colorcustom.rgb.green.label": "G", "colorcustom.rgb.green.description": "Green component", "colorcustom.rgb.blue.label": "B", "colorcustom.rgb.blue.description": "Blue component", "colorcustom.rgb.hex.label": "#", "colorcustom.rgb.hex.description": "Hex color code", "colorcustom.rgb.range": "Range 0 to 255", "colorcustom.sb.saturation": "Saturation", "colorcustom.sb.brightness": "Brightness", "colorcustom.sb.picker": "Saturation and Brightness Picker", "colorcustom.sb.palette": "Saturation and Brightness Palette", "colorcustom.sb.instructions": "Use arrow keys to select saturation and brightness, on x and y axes", "colorcustom.hue.hue": "Hue", "colorcustom.hue.slider": "Hue Slider", "colorcustom.hue.palette": "Hue Palette", "colorcustom.hue.instructions": "Use arrow keys to select a hue", "aria.color.picker": "Color Picker", "aria.input.invalid": "Invalid input" }, lS = tinymce.util.Tools.resolve("tinymce.Resource"), fS = tinymce.util.Tools.resolve("tinymce.util.Tools"), dS = $o([Eo("preprocess", h), Eo("postprocess", h)]), mS = function(r2, t2) {
      var i2 = so("RepresentingConfigs.memento processors", dS, t2);
      return Df.config({ store: { mode: "manual", getValue: function(t3) {
        var n2 = r2.get(t3), e3 = Df.getValue(n2);
        return i2.postprocess(e3);
      }, setValue: function(t3, n2) {
        var e3 = i2.preprocess(n2), o2 = r2.get(t3);
        Df.setValue(o2, e3);
      } } });
    }, gS = s0, pS = function(t2) {
      return Df.config({ store: { mode: "memory", initialValue: t2 } });
    }, hS = Ir("alloy-fake-before-tabstop"), vS = Ir("alloy-fake-after-tabstop"), bS = !(le().browser.isIE() || le().browser.isEdge()), yS = function(t2) {
      return t2.getContext("2d");
    }, xS = function(t2, n2, e3) {
      return t2.width = n2, t2.height = e3, t2;
    }, wS = function(t2) {
      URL.revokeObjectURL(t2.src);
    }, SS = [0, 0.01, 0.02, 0.04, 0.05, 0.06, 0.07, 0.08, 0.1, 0.11, 0.12, 0.14, 0.15, 0.16, 0.17, 0.18, 0.2, 0.21, 0.22, 0.24, 0.25, 0.27, 0.28, 0.3, 0.32, 0.34, 0.36, 0.38, 0.4, 0.42, 0.44, 0.46, 0.48, 0.5, 0.53, 0.56, 0.59, 0.62, 0.65, 0.68, 0.71, 0.74, 0.77, 0.8, 0.83, 0.86, 0.89, 0.92, 0.95, 0.98, 1, 1.06, 1.12, 1.18, 1.24, 1.3, 1.36, 1.42, 1.48, 1.54, 1.6, 1.66, 1.72, 1.78, 1.84, 1.9, 1.96, 2, 2.12, 2.25, 2.37, 2.5, 2.62, 2.75, 2.87, 3, 3.2, 3.4, 3.6, 3.8, 4, 4.3, 4.7, 4.9, 5, 5.5, 6, 6.5, 6.8, 7, 7.3, 7.5, 7.8, 8, 8.4, 8.7, 9, 9.4, 9.6, 9.8, 10], kS = function(t2, n2, T2) {
      var e3 = yS(t2), o2 = function(t3) {
        for (var n3, e4, o3, r2, i2 = t3.data, u2 = T2[0], a2 = T2[1], c2 = T2[2], s2 = T2[3], l2 = T2[4], f2 = T2[5], d2 = T2[6], m3 = T2[7], g2 = T2[8], p2 = T2[9], h2 = T2[10], v4 = T2[11], b2 = T2[12], y2 = T2[13], x2 = T2[14], w2 = T2[15], S2 = T2[16], k2 = T2[17], C2 = T2[18], O2 = T2[19], _2 = 0; _2 < i2.length; _2 += 4)
          n3 = i2[_2], e4 = i2[_2 + 1], o3 = i2[_2 + 2], r2 = i2[_2 + 3], i2[_2] = n3 * u2 + e4 * a2 + o3 * c2 + r2 * s2 + l2, i2[_2 + 1] = n3 * f2 + e4 * d2 + o3 * m3 + r2 * g2 + p2, i2[_2 + 2] = n3 * h2 + e4 * v4 + o3 * b2 + r2 * y2 + x2, i2[_2 + 3] = n3 * w2 + e4 * S2 + o3 * k2 + r2 * C2 + O2;
        return t3;
      }(e3.getImageData(0, 0, t2.width, t2.height));
      return e3.putImageData(o2, 0, 0), S0(t2, n2);
    }, CS = (sw = [-1, 0, 0, 0, 255, 0, -1, 0, 0, 255, 0, 0, -1, 0, 255, 0, 0, 0, 1, 0, 0, 0, 0, 0, 1], function(t2) {
      return T0(t2, sw);
    }), OS = E0(function(t2, n2) {
      return _0(t2, [1, 0, 0, 0, n2 = C0(255 * n2, -255, 255), 0, 1, 0, 0, n2, 0, 0, 1, 0, n2, 0, 0, 0, 1, 0, 0, 0, 0, 0, 1]);
    }), _S = E0(function(t2, n2) {
      var e3;
      return n2 = C0(n2, -1, 1), _0(t2, [(e3 = (n2 *= 100) < 0 ? 127 + n2 / 100 * 127 : 127 * (0 == (e3 = n2 % 1) ? SS[n2] : SS[Math.floor(n2)] * (1 - e3) + SS[Math.floor(n2) + 1] * e3) + 127) / 127, 0, 0, 0, 0.5 * (127 - e3), 0, e3 / 127, 0, 0, 0.5 * (127 - e3), 0, 0, e3 / 127, 0, 0.5 * (127 - e3), 0, 0, 0, 1, 0, 0, 0, 0, 0, 1]);
    }), TS = (lw = [0, -1, 0, -1, 5, -1, 0, -1, 0], function(t2) {
      return a2 = lw, (u2 = t2).toCanvas().then(function(t3) {
        return n2 = t3, e3 = u2.getType(), o2 = a2, r2 = yS(n2), i2 = function(t4, n3, e4) {
          for (var o3 = function(t5, n4, e5) {
            return e5 < t5 ? t5 = e5 : t5 < n4 && (t5 = n4), t5;
          }, r3 = Math.round(Math.sqrt(e4.length)), i3 = Math.floor(r3 / 2), u3 = t4.data, a3 = n3.data, c2 = t4.width, s2 = t4.height, l2 = 0; l2 < s2; l2++)
            for (var f2 = 0; f2 < c2; f2++) {
              for (var d2 = 0, m3 = 0, g2 = 0, p2 = 0; p2 < r3; p2++)
                for (var h2 = 0; h2 < r3; h2++) {
                  var v4 = o3(f2 + h2 - i3, 0, c2 - 1), b2 = 4 * (o3(l2 + p2 - i3, 0, s2 - 1) * c2 + v4), y2 = e4[p2 * r3 + h2];
                  d2 += u3[b2] * y2, m3 += u3[1 + b2] * y2, g2 += u3[2 + b2] * y2;
                }
              var x2 = 4 * (l2 * c2 + f2);
              a3[x2] = o3(d2, 0, 255), a3[1 + x2] = o3(m3, 0, 255), a3[2 + x2] = o3(g2, 0, 255);
            }
          return n3;
        }(r2.getImageData(0, 0, n2.width, n2.height), r2.getImageData(0, 0, n2.width, n2.height), o2), r2.putImageData(i2, 0, 0), S0(n2, e3);
        var n2, e3, o2, r2, i2;
      });
      var u2, a2;
    }), ES = (fw = function(t2, n2) {
      return 255 * Math.pow(t2 / 255, 1 - n2);
    }, function(n2, e3) {
      return n2.toCanvas().then(function(t2) {
        return function(t3, n3, e4) {
          for (var o2 = yS(t3), r2 = new Array(256), i2 = 0; i2 < r2.length; i2++)
            r2[i2] = fw(i2, e4);
          var u2 = function(t4, n4) {
            for (var e5 = t4.data, o3 = 0; o3 < e5.length; o3 += 4)
              e5[o3] = n4[e5[o3]], e5[o3 + 1] = n4[e5[o3 + 1]], e5[o3 + 2] = n4[e5[o3 + 2]];
            return t4;
          }(o2.getImageData(0, 0, t3.width, t3.height), r2);
          return o2.putImageData(u2, 0, 0), S0(t3, n3);
        }(t2, n2.getType(), e3);
      });
    }), DS = function(t2, n2, e3) {
      var o2 = b0(t2), r2 = y0(t2), i2 = n2 / o2, u2 = e3 / r2, a2 = false;
      (i2 < 0.5 || 2 < i2) && (i2 = i2 < 0.5 ? 0.5 : 2, a2 = true), (u2 < 0.5 || 2 < u2) && (u2 = u2 < 0.5 ? 0.5 : 2, a2 = true);
      var c2 = BS(t2, i2, u2);
      return a2 ? c2.then(function(t3) {
        return DS(t3, n2, e3);
      }) : c2;
    }, BS = function(u2, a2, c2) {
      return new Ny(function(t2) {
        var n2 = b0(u2), e3 = y0(u2), o2 = Math.floor(n2 * a2), r2 = Math.floor(e3 * c2), i2 = h0(o2, r2);
        yS(i2).drawImage(u2, 0, 0, n2, e3, 0, 0, o2, r2), t2(i2);
      });
    }, MS = function(t2, n2, e3) {
      var o2 = (e3 < 0 ? 360 + e3 : e3) * Math.PI / 180, r2 = t2.width, i2 = t2.height, u2 = Math.sin(o2), a2 = Math.cos(o2), c2 = D0(Math.abs(r2 * a2) + Math.abs(i2 * u2)), s2 = D0(Math.abs(r2 * u2) + Math.abs(i2 * a2)), l2 = h0(c2, s2), f2 = yS(l2);
      return f2.translate(c2 / 2, s2 / 2), f2.rotate(o2), f2.drawImage(t2, -r2 / 2, -i2 / 2), S0(l2, n2);
    }, AS = function(t2, n2, e3) {
      var o2 = h0(t2.width, t2.height), r2 = yS(o2);
      return "v" === e3 ? (r2.scale(1, -1), r2.drawImage(t2, 0, -o2.height)) : (r2.scale(-1, 1), r2.drawImage(t2, -o2.width, 0)), S0(o2, n2);
    }, FS = function(t2, n2, e3, o2, r2, i2) {
      var u2 = h0(r2, i2);
      return yS(u2).drawImage(t2, -e3, -o2), S0(u2, n2);
    }, IS = Ir("toolbar.button.execute"), RS = ((dw = {})[Ii()] = ["disabling", "alloy.base.behaviour", "toggling", "toolbar-button-events"], dw), VS = Ir("update-menu-text"), PS = Ir("update-menu-icon"), HS = { type: "separator" }, zS = function(t2, l2) {
      var n2, e3, o2;
      return I((n2 = y(t2) ? t2.split(" ") : t2, e3 = l2, 0 < (o2 = R(n2, function(t3, n3) {
        return y(n3) ? "" === n3 ? t3 : "|" === n3 ? 0 < t3.length && !W0(t3[t3.length - 1]) ? t3.concat([HS]) : t3 : Tt(e3, n3.toLowerCase()) ? t3.concat([e3[n3.toLowerCase()]]) : t3 : t3.concat([n3]);
      }, [])).length && W0(o2[o2.length - 1]) && o2.pop(), o2), function(t3, n3) {
        var e4, o3, r2, i2, u2, a2, c2 = function(t4) {
          if (W0(t4))
            return t4;
          var n4 = tt(t4, "value").getOrThunk(function() {
            return Ir("generated-menu-item");
          });
          return Yo({ value: n4 }, t4);
        }(n3), s2 = (o3 = l2, Tt(e4 = c2, "getSubmenuItems") ? (i2 = o3, u2 = (r2 = e4).getSubmenuItems(), a2 = zS(u2, i2), { item: r2, menus: Yo(a2.menus, sr(r2.value, a2.items)), expansions: Yo(a2.expansions, sr(r2.value, r2.value)) }) : { item: e4, menus: {}, expansions: {} });
        return { menus: Yo(t3.menus, s2.menus), items: [s2.item].concat(t3.items), expansions: Yo(t3.expansions, s2.expansions) };
      }, { menus: {}, expansions: {}, items: [] });
    }, NS = rt2([Eo("field1Name", "field1"), Eo("field2Name", "field2"), Qu("onLockedChange"), qu(["lockClass"]), Eo("locked", false), Bf("coupledFieldBehaviours", [cd, Df])]), LS = rt2([Z0("field1", "field2"), Z0("field2", "field1"), Jf({ factory: fp, schema: [mo("dom")], name: "lock", overrides: function(t2) {
      return { buttonBehaviours: nc([Lg.config({ selected: t2.locked, toggleClass: t2.markers.lockClass, aria: { mode: "pressed" } })]) };
    } })]), WS = Cl({ name: "FormCoupledInputs", configFields: NS(), partFields: LS(), factory: function(o2, t2, n2, e3) {
      return { uid: o2.uid, dom: o2.dom, components: t2, behaviours: Mf(o2.coupledFieldBehaviours, [cd.config({ find: vt.some }), Df.config({ store: { mode: "manual", getValue: function(t3) {
        var n3 = bl(t3, o2, ["field1", "field2"]), e4 = {};
        return e4[o2.field1Name] = Df.getValue(n3.field1()), e4[o2.field2Name] = Df.getValue(n3.field2()), e4;
      }, setValue: function(t3, n3) {
        var e4 = bl(t3, o2, ["field1", "field2"]);
        nt(n3, o2.field1Name) && Df.setValue(e4.field1(), n3[o2.field1Name]), nt(n3, o2.field2Name) && Df.setValue(e4.field2(), n3[o2.field2Name]);
      } } })]), apis: { getField1: function(t3) {
        return ml(t3, o2, "field1");
      }, getField2: function(t3) {
        return ml(t3, o2, "field2");
      }, getLock: function(t3) {
        return ml(t3, o2, "lock");
      } } };
    }, apis: { getField1: function(t2, n2) {
      return t2.getField1(n2);
    }, getField2: function(t2, n2) {
      return t2.getField2(n2);
    }, getLock: function(t2, n2) {
      return t2.getLock(n2);
    } } }), US = { undo: rt2(Ir("undo")), redo: rt2(Ir("redo")), zoom: rt2(Ir("zoom")), back: rt2(Ir("back")), apply: rt2(Ir("apply")), swap: rt2(Ir("swap")), transform: rt2(Ir("transform")), tempTransform: rt2(Ir("temp-transform")), transformApply: rt2(Ir("transform-apply")) }, jS = rt2("save-state"), GS = rt2("disable"), XS = rt2("enable"), YS = { formActionEvent: Sy, saveState: jS, disable: GS, enable: XS }, qS = tinymce.util.Tools.resolve("tinymce.geom.Rect"), KS = tinymce.util.Tools.resolve("tinymce.util.Observable"), JS = tinymce.util.Tools.resolve("tinymce.util.VK");
    function $S(t2, d2) {
      function n2(t3) {
        var n3, e4, o3, r3, i3, u3, a2, c2, s2 = t3.raw, l2 = (n3 = Math.max, e4 = y2.documentElement, o3 = y2.body, r3 = n3(e4.scrollWidth, o3.scrollWidth), i3 = n3(e4.clientWidth, o3.clientWidth), u3 = n3(e4.offsetWidth, o3.offsetWidth), a2 = n3(e4.scrollHeight, o3.scrollHeight), c2 = n3(e4.clientHeight, o3.clientHeight), { width: r3 < u3 ? i3 : r3, height: a2 < n3(e4.offsetHeight, o3.offsetHeight) ? c2 : a2 });
        iw(s2), t3.prevent(), p2 = s2.button, h2 = s2.screenX, v4 = s2.screenY;
        var f2 = pn(w2, "cursor");
        mn(g2 = At.fromTag("div", y2), { position: "absolute", top: "0", left: "0", width: l2.width + "px", height: l2.height + "px", "z-index": "2147483647", opacity: "0.0001", cursor: f2 }), Te(ye(x2), g2), b2.push(pc(x2, "mousemove", m3), pc(x2, "touchmove", m3), pc(x2, "mouseup", S2), pc(x2, "touchend", S2)), d2.start(s2);
      }
      function m3(t3) {
        var n3 = t3.raw;
        if (iw(n3), n3.button !== p2)
          return S2(t3);
        n3.deltaX = n3.screenX - h2, n3.deltaY = n3.screenY - v4, t3.prevent(), d2.drag(n3);
      }
      var e3, o2, r2, g2, p2, h2, v4, i2 = [], b2 = [], y2 = null !== (e3 = d2.document) && void 0 !== e3 ? e3 : document, u2 = null !== (o2 = d2.root) && void 0 !== o2 ? o2 : y2, x2 = At.fromDom(y2), w2 = At.fromDom(u2.getElementById(null !== (r2 = d2.handle) && void 0 !== r2 ? r2 : t2)), S2 = function(t3) {
        iw(t3.raw), St(b2, function(t4) {
          return t4.unbind();
        }), b2 = [], Ee(g2), d2.stop && d2.stop(t3.raw);
      };
      return i2.push(pc(w2, "mousedown", n2), pc(w2, "touchstart", n2)), { destroy: function() {
        St(b2.concat(i2), function(t3) {
          return t3.unbind();
        }), b2 = [], i2 = [], k(g2) && Ee(g2);
      } };
    }
    function QS(t2, n2, e3, o2, r2) {
      return q0({ name: t2, icon: vt.some(n2), disabled: e3, tooltip: vt.some(t2), primary: false, borderless: false }, o2, r2);
    }
    function ZS(t2, n2) {
      n2 ? gd.enable(t2) : gd.disable(t2);
    }
    var tk = 0, nk = function(s2, n2, l2, t2, e3) {
      function f2(t3, n3) {
        return { x: n3.x - t3.x, y: n3.y - t3.y, w: n3.w, h: n3.h };
      }
      function u2(t3, n3, e4, o3) {
        var r3 = n3.x + e4 * t3.deltaX, i3 = n3.y + o3 * t3.deltaY, u3 = Math.max(20, n3.w + e4 * t3.deltaW), a3 = Math.max(20, n3.h + o3 * t3.deltaH), c3 = (s2 = qS.clamp({ x: r3, y: i3, w: u3, h: a3 }, l2, "move" === t3.name), f2(l2, s2));
        b2.fire("updateRect", { rect: c3 }), h2(c3);
      }
      function o2(t3) {
        r2(s2 = t3);
      }
      function r2(e4) {
        function t3(t4, n3) {
          Iu(m3, "#" + d2 + "-" + t4).each(function(t5) {
            mn(t5, { left: n3.x + "px", top: n3.y + "px", width: Math.max(0, n3.w) + "px", height: Math.max(0, n3.h) + "px" });
          });
        }
        St(g2, function(n3) {
          Iu(m3, "#" + d2 + "-" + n3.name).each(function(t4) {
            mn(t4, { left: e4.w * n3.xMul + e4.x + "px", top: e4.h * n3.yMul + e4.y + "px" });
          });
        }), t3("top", { x: n2.x, y: n2.y, w: n2.w, h: e4.y - n2.y }), t3("right", { x: e4.x + e4.w, y: e4.y, w: n2.w - e4.x - e4.w + n2.x, h: e4.h }), t3("bottom", { x: n2.x, y: e4.y + e4.h, w: n2.w, h: n2.h - e4.y - e4.h + n2.y }), t3("left", { x: n2.x, y: e4.y, w: e4.x - n2.x, h: e4.h }), t3("move", e4);
      }
      var i2, a2, c2 = [], d2 = "tox-crid-" + tk++, m3 = At.fromDom(t2), g2 = [{ name: "move", xMul: 0, yMul: 0, deltaX: 1, deltaY: 1, deltaW: 0, deltaH: 0, label: "Crop Mask" }, { name: "nw", xMul: 0, yMul: 0, deltaX: 1, deltaY: 1, deltaW: -1, deltaH: -1, label: "Top Left Crop Handle" }, { name: "ne", xMul: 1, yMul: 0, deltaX: 0, deltaY: 1, deltaW: 1, deltaH: -1, label: "Top Right Crop Handle" }, { name: "sw", xMul: 0, yMul: 1, deltaX: 1, deltaY: 0, deltaW: -1, deltaH: 1, label: "Bottom Left Crop Handle" }, { name: "se", xMul: 1, yMul: 1, deltaX: 0, deltaY: 0, deltaW: 1, deltaH: 1, label: "Bottom Right Crop Handle" }], p2 = ["top", "right", "bottom", "left"], h2 = function(t3) {
        var n3;
        o2((n3 = l2, { x: t3.x + n3.x, y: t3.y + n3.y, w: t3.w, h: t3.h }));
      };
      function v4(t3) {
        on(t3.target, "aria-grabbed", "focus" === t3.raw.type ? "true" : "false");
      }
      rn(a2 = At.fromTag("div"), { id: d2, class: "tox-croprect-container", role: "grid", "aria-dropeffect": "execute" }), Te(m3, a2), St(p2, function(e4) {
        Iu(m3, "#" + d2).each(function(t3) {
          var n3 = At.fromTag("div");
          rn(n3, { id: d2 + "-" + e4, class: "tox-croprect-block", "data-mce-bogus": "all" }), dn(n3, "display", "none"), Te(t3, n3);
        });
      }), St(g2, function(e4) {
        Iu(m3, "#" + d2).each(function(t3) {
          var n3 = At.fromTag("div");
          rn(n3, { id: d2 + "-" + e4.name, "aria-label": e4.label, "aria-grabbed": "false", "data-mce-bogus": "all", role: "gridcell", tabindex: "-1", title: e4.label }), Jr(n3, ["tox-croprect-handle", "tox-croprect-handle-" + e4.name]), dn(n3, "display", "none"), Te(t3, n3);
        });
      }), i2 = M(g2, function(n3) {
        var e4;
        return $S(d2, { document: t2.ownerDocument, root: ge(m3).dom, handle: d2 + "-" + n3.name, start: function() {
          e4 = s2;
        }, drag: function(t3) {
          u2(n3, e4, t3.deltaX, t3.deltaY);
        } });
      }), r2(s2), c2.push(pc(m3, "focusin", v4), pc(m3, "focusout", v4), pc(m3, "keydown", function(n3) {
        var i3;
        function t3(t4, n4, e4, o3, r3) {
          t4.stopPropagation(), t4.preventDefault(), u2(i3, e4, o3, r3);
        }
        switch (St(g2, function(t4) {
          if (un(n3.target, "id") === d2 + "-" + t4.name)
            return i3 = t4, false;
        }), n3.raw.keyCode) {
          case JS.LEFT:
            t3(n3, 0, s2, -10, 0);
            break;
          case JS.RIGHT:
            t3(n3, 0, s2, 10, 0);
            break;
          case JS.UP:
            t3(n3, 0, s2, 0, -10);
            break;
          case JS.DOWN:
            t3(n3, 0, s2, 0, 10);
            break;
          case JS.ENTER:
          case JS.SPACEBAR:
            n3.prevent(), e3();
        }
      }));
      var b2 = lt2(lt2({}, KS), { toggleVisibility: function(t3) {
        var n3 = H(H([], M(g2, function(t4) {
          return "#" + d2 + "-" + t4.name;
        }), true), M(p2, function(t4) {
          return "#" + d2 + "-" + t4;
        }), true).join(","), e4 = vs(m3, n3);
        St(e4, t3 ? function(t4) {
          return bn(t4, "display");
        } : function(t4) {
          return dn(t4, "display", "none");
        });
      }, setClampRect: function(t3) {
        l2 = t3, r2(s2);
      }, setRect: o2, getInnerRect: function() {
        return f2(l2, s2);
      }, setInnerRect: h2, setViewPortRect: function(t3) {
        n2 = t3, r2(s2);
      }, destroy: function() {
        St(i2, function(t3) {
          return t3.destroy();
        }), i2 = [], St(c2, function(t3) {
          return t3.unbind();
        }), c2 = [];
      } });
      return b2;
    };
    function ek(t2) {
      var e3, o2, n2, r2, i2 = Po(t2), u2 = gc(), a2 = (o2 = -1, { data: e3 = [], add: function(t3) {
        var n3 = e3.splice(++o2);
        return e3.push(t3), { state: t3, removed: n3 };
      }, undo: function() {
        if (n2())
          return e3[--o2];
      }, redo: function() {
        if (r2())
          return e3[++o2];
      }, canUndo: n2 = function() {
        return 0 < o2;
      }, canRedo: r2 = function() {
        return -1 !== o2 && o2 < e3.length - 1;
      } });
      function c2(t3) {
        i2.set(t3);
      }
      function s2(t3) {
        URL.revokeObjectURL(t3.url);
      }
      function l2(t3) {
        var n3 = f2(t3);
        c2(n3);
        var e4 = a2.add(n3).removed;
        return fS.each(e4, s2), n3.url;
      }
      a2.add(t2);
      function f2(t3) {
        return { blob: t3, url: URL.createObjectURL(t3) };
      }
      function d2() {
        u2.on(s2), u2.clear();
      }
      return { getBlobState: function() {
        return i2.get();
      }, setBlobState: c2, addBlobState: l2, getTempState: function() {
        return u2.get().getOrThunk(i2.get);
      }, updateTempState: function(t3) {
        var n3 = f2(t3);
        return d2(), u2.set(n3), n3.url;
      }, addTempState: function(t3) {
        var n3 = f2(t3);
        return u2.set(n3), n3.url;
      }, applyTempState: function(n3) {
        return u2.get().fold(st, function(t3) {
          l2(t3.blob), n3();
        });
      }, destroyTempState: d2, undo: function() {
        var t3 = a2.undo();
        return c2(t3), t3.url;
      }, redo: function() {
        var t3 = a2.redo();
        return c2(t3), t3.url;
      }, getHistoryStates: function() {
        return { undoEnabled: a2.canUndo(), redoEnabled: a2.canRedo() };
      } };
    }
    function ok(t2, n2) {
      function i2(t3) {
        var n3 = y2.getHistoryStates();
        k2.updateButtonUndoStates(t3, n3.undoEnabled, n3.redoEnabled), br(t3, YS.formActionEvent, { name: YS.saveState(), value: n3.undoEnabled });
      }
      function u2(t3) {
        return t3.toBlob();
      }
      function a2(t3) {
        br(t3, YS.formActionEvent, { name: YS.disable(), value: {} });
      }
      function c2(n3, t3, e4, o3, r3) {
        a2(n3), k0(t3).then(e4).then(u2).then(o3).then(function(t4) {
          return w2(n3, t4);
        }).then(function() {
          i2(n3), r3(), x2(n3);
        }).catch(function(t4) {
          console.log(t4), n3.getSystem().isConnected() && x2(n3);
        });
      }
      function r2(t3, n3, e4) {
        c2(t3, y2.getBlobState().blob, n3, function(t4) {
          return y2.updateTempState(t4);
        }, e4);
      }
      function s2(t3) {
        var n3 = y2.getBlobState().url;
        return y2.destroyTempState(), i2(t3), n3;
      }
      var e3, o2, l2, f2, d2, m3, g2, p2, h2, v4, b2, y2 = ek(t2.currentState), x2 = function(t3) {
        C2.getApplyButton(t3).each(function(t4) {
          gd.enable(t4);
        }), br(t3, YS.formActionEvent, { name: YS.enable(), value: {} });
      }, w2 = function(t3, n3) {
        return a2(t3), S2.updateSrc(t3, n3);
      }, S2 = (f2 = t2.currentState.url, m3 = zm({ dom: { tag: "div", classes: ["tox-image-tools__image-bg"], attributes: { role: "presentation" } } }), g2 = Po(1), d2 = dc(), p2 = lt2(lt2({}, d2), { run: function(t3) {
        return d2.get().each(t3);
      } }), h2 = Po({ x: 0, y: 0, w: 1, h: 1 }), v4 = Po({ x: 0, y: 0, w: 1, h: 1 }), { memContainer: b2 = zm(ly.sketch({ dom: { tag: "div", classes: ["tox-image-tools__image"] }, components: [m3.asSpec(), { dom: { tag: "img", attributes: { src: f2 } } }, { dom: { tag: "div" }, behaviours: nc([mm("image-panel-crop-events", [ou(function(t3) {
        b2.getOpt(t3).each(function(t4) {
          var n3 = t4.element.dom, e4 = nk({ x: 10, y: 10, w: 100, h: 100 }, { x: 0, y: 0, w: 200, h: 200 }, { x: 0, y: 0, w: 200, h: 200 }, n3, st);
          e4.toggleVisibility(false), e4.on("updateRect", function(t5) {
            var n4 = t5.rect, e5 = g2.get(), o3 = { x: Math.round(n4.x / e5), y: Math.round(n4.y / e5), w: Math.round(n4.w / e5), h: Math.round(n4.h / e5) };
            h2.set(o3);
          }), p2.set(e4);
        });
      }), ru(function() {
        p2.clear();
      })])]) }], containerBehaviours: nc([Rg.config({}), mm("image-panel-events", [ou(function(t3) {
        _2(t3, f2);
      })])]) })), updateSrc: _2, zoom: function(t3, n3) {
        var e4 = g2.get(), o3 = 0 < n3 ? Math.min(2, e4 + 0.1) : Math.max(0.1, e4 - 0.1);
        g2.set(o3), b2.getOpt(t3).each(function(t4) {
          var n4 = t4.components()[1].element;
          O2(t4, n4);
        });
      }, showCrop: function() {
        p2.run(function(t3) {
          t3.toggleVisibility(true);
        });
      }, hideCrop: function() {
        p2.run(function(t3) {
          t3.toggleVisibility(false);
        });
      }, getRect: function() {
        return h2.get();
      }, getMeasurements: function() {
        var t3 = v4.get();
        return { width: t3.w, height: t3.h };
      } }), k2 = (o2 = zm(QS("Undo", "undo", true, function(t3) {
        br(t3, US.undo(), { direction: 1 });
      }, e3 = n2)), l2 = zm(QS("Redo", "redo", true, function(t3) {
        br(t3, US.redo(), { direction: 1 });
      }, e3)), { container: ly.sketch({ dom: { tag: "div", classes: ["tox-image-tools__toolbar", "tox-image-tools__sidebar"] }, components: [o2.asSpec(), l2.asSpec(), QS("Zoom in", "zoom-in", false, function(t3) {
        br(t3, US.zoom(), { direction: 1 });
      }, e3), QS("Zoom out", "zoom-out", false, function(t3) {
        br(t3, US.zoom(), { direction: -1 });
      }, e3)] }), updateButtonUndoStates: function(t3, n3, e4) {
        o2.getOpt(t3).each(function(t4) {
          ZS(t4, n3);
        }), l2.getOpt(t3).each(function(t4) {
          ZS(t4, e4);
        });
      } }), C2 = rw(S2, n2);
      function O2(t3, s3) {
        b2.getOpt(t3).each(function(t4) {
          var e4 = g2.get(), o3 = On(t4.element), r3 = wn(t4.element), i3 = s3.dom.naturalWidth * e4, u3 = s3.dom.naturalHeight * e4, a3 = Math.max(0, o3 / 2 - i3 / 2), c3 = Math.max(0, r3 / 2 - u3 / 2), n3 = { left: a3.toString() + "px", top: c3.toString() + "px", width: i3.toString() + "px", height: u3.toString() + "px", position: "absolute" };
          mn(s3, n3), m3.getOpt(t4).each(function(t5) {
            mn(t5.element, n3);
          }), p2.run(function(t5) {
            var n4 = h2.get();
            t5.setRect({ x: n4.x * e4 + a3, y: n4.y * e4 + c3, w: n4.w * e4, h: n4.h * e4 }), t5.setClampRect({ x: a3, y: c3, w: i3, h: u3 }), t5.setViewPortRect({ x: 0, y: 0, w: o3, h: r3 });
          });
        });
      }
      function _2(t3, n3) {
        var e4, i3 = At.fromTag("img");
        return on(i3, "src", n3), e4 = i3.dom, new Ap(function(t4) {
          var n4 = function() {
            e4.removeEventListener("load", n4), t4(e4);
          };
          e4.complete ? t4(e4) : e4.addEventListener("load", n4);
        }).then(function() {
          t3.getSystem().isConnected() && b2.getOpt(t3).map(function(t4) {
            var n4 = Ou({ element: i3 });
            Rg.replaceAt(t4, 1, vt.some(n4));
            var e5 = v4.get(), o3 = { x: 0, y: 0, w: i3.dom.naturalWidth, h: i3.dom.naturalHeight };
            v4.set(o3);
            var u3, r3 = qS.inflate(o3, -20, -20);
            h2.set(r3), e5.w === o3.w && e5.h === o3.h || (u3 = i3, b2.getOpt(t4).each(function(t5) {
              var n5 = On(t5.element), e6 = wn(t5.element), o4 = u3.dom.naturalWidth, r4 = u3.dom.naturalHeight, i4 = Math.min(n5 / o4, e6 / r4);
              1 <= i4 ? g2.set(1) : g2.set(i4);
            })), O2(t4, i3);
          });
        });
      }
      return { dom: { tag: "div", attributes: { role: "presentation" } }, components: [C2.memContainer.asSpec(), S2.memContainer.asSpec(), k2.container], behaviours: nc([Df.config({ store: { mode: "manual", getValue: function() {
        return y2.getBlobState();
      } } }), mm("image-tools-events", [Cr(US.undo(), function(n3, t3) {
        var e4 = y2.undo();
        w2(n3, e4).then(function(t4) {
          x2(n3), i2(n3);
        });
      }), Cr(US.redo(), function(n3, t3) {
        var e4 = y2.redo();
        w2(n3, e4).then(function(t4) {
          x2(n3), i2(n3);
        });
      }), Cr(US.zoom(), function(t3, n3) {
        var e4 = n3.event.direction;
        S2.zoom(t3, e4);
      }), Cr(US.back(), function(t3, n3) {
        var e4, o3 = s2(e4 = t3);
        w2(e4, o3).then(function(t4) {
          x2(e4);
        }), (0, n3.event.swap)(), S2.hideCrop();
      }), Cr(US.apply(), function(t3, n3) {
        y2.applyTempState(function() {
          s2(t3), (0, n3.event.swap)();
        });
      }), Cr(US.transform(), function(t3, n3) {
        return r2(t3, n3.event.transform, st);
      }), Cr(US.tempTransform(), function(t3, n3) {
        var e4 = n3.event.transform;
        c2(t3, y2.getTempState().blob, e4, function(t4) {
          return y2.addTempState(t4);
        }, st);
      }), Cr(US.transformApply(), function(t3, n3) {
        var e4 = t3, o3 = n3.event.transform, r3 = n3.event.swap, i3 = y2.getBlobState().blob;
        c2(e4, i3, o3, function(t4) {
          var n4 = y2.addBlobState(t4);
          return s2(e4), n4;
        }, r3);
      }), Cr(US.swap(), function(n3, t3) {
        k2.updateButtonUndoStates(n3, false, false);
        var e4 = t3.event.transform, o3 = t3.event.swap;
        e4.fold(function() {
          o3();
        }, function(t4) {
          r2(n3, t4, o3);
        });
      })]), aw()]) };
    }
    function rk(t2) {
      return !Tt(t2, "items");
    }
    function ik(t2, n2) {
      function e3(t3) {
        return { dom: { tag: "td", innerHtml: n2.translate(t3) } };
      }
      return { dom: { tag: "table", classes: ["tox-dialog__table"] }, components: [{ dom: { tag: "thead" }, components: [{ dom: { tag: "tr" }, components: M(t2.header, function(t3) {
        return { dom: { tag: "th", innerHtml: n2.translate(t3) } };
      }) }] }, { dom: { tag: "tbody" }, components: M(t2.cells, function(t3) {
        return { dom: { tag: "tr" }, components: M(t3, e3) };
      }) }], behaviours: nc([py.config({}), Hg.config({})]) };
    }
    function uk(e3, n2) {
      var t2 = e3.label.map(function(t3) {
        return oy(t3, n2);
      }), o2 = [gd.config({ disabled: function() {
        return e3.disabled || n2.isDisabled();
      } }), pv(), Fg.config({ mode: "execution", useEnter: true !== e3.multiline, useControlEnter: true === e3.multiline, execute: function(t3) {
        return vr(t3, ky), vt.some(true);
      } }), mm("textfield-change", [Cr(Si(), function(t3, n3) {
        br(t3, yy, { name: e3.name });
      }), Cr(Ai(), function(t3, n3) {
        br(t3, yy, { name: e3.name });
      })]), py.config({})], r2 = e3.validation.map(function(o3) {
        return Ky.config({ getRoot: function(t3) {
          return Yt(t3.element);
        }, invalidClass: "tox-invalid", validator: { validate: function(t3) {
          var n3 = Df.getValue(t3), e4 = o3.validator(n3);
          return Gy(true === e4 ? Ve.value(n3) : Ve.error(e4));
        }, validateOnLoad: o3.validateOnLoad } });
      }).toArray(), i2 = e3.placeholder.fold(rt2({}), function(t3) {
        return { placeholder: n2.translate(t3) };
      }), u2 = e3.inputMode.fold(rt2({}), function(t3) {
        return { inputmode: t3 };
      }), a2 = lt2(lt2({}, i2), u2);
      return ey(t2, my.parts.field({ tag: true === e3.multiline ? "textarea" : "input", inputAttributes: a2, inputClasses: [e3.classname], inputBehaviours: nc(ft([o2, r2])), selectOnFocus: false, factory: Dy }), (e3.flex ? ["tox-form__group--stretched"] : []).concat(e3.maximized ? ["tox-form-group--maximize"] : []), [gd.config({ disabled: function() {
        return e3.disabled || n2.isDisabled();
      }, onDisabled: function(t3) {
        my.getField(t3).each(gd.disable);
      }, onEnabled: function(t3) {
        my.getField(t3).each(gd.enable);
      } }), pv()]);
    }
    function ak(t2) {
      var n2 = Po(null);
      return wu({ readState: function() {
        return { timer: null !== n2.get() ? "set" : "unset" };
      }, setTimer: function(t3) {
        n2.set(t3);
      }, cancel: function() {
        var t3 = n2.get();
        null !== t3 && t3.cancel();
      } });
    }
    function ck(t2, n2, e3) {
      var o2 = Df.getValue(e3);
      Df.setValue(n2, o2), s1(n2);
    }
    function sk(t2, n2) {
      var e3 = t2.element, o2 = Qr(e3), r2 = e3.dom;
      "number" !== un(e3, "type") && n2(r2, o2);
    }
    function lk(t2) {
      return { type: "menuitem", value: t2.url, text: t2.title, meta: { attach: t2.attach }, onAction: st };
    }
    function fk(t2, n2) {
      return { type: "menuitem", value: n2, text: t2, meta: { attach: void 0 }, onAction: st };
    }
    function dk(t2, n2) {
      return e3 = t2, M(F(n2, function(t3) {
        return t3.type === e3;
      }), lk);
      var e3;
    }
    function mk(t2, n2) {
      var e3 = t2.toLowerCase();
      return F(n2, function(t3) {
        return ut((void 0 !== t3.meta && void 0 !== t3.meta.text ? t3.meta : t3).text.toLowerCase(), e3) || ut(t3.value.toLowerCase(), e3);
      });
    }
    function gk(u2, a2, c2) {
      function r2(t3) {
        var n3 = Df.getValue(t3);
        c2.addToHistory(n3.value, u2.filetype);
      }
      var t2, n2, e3, o2, i2 = a2.shared.providers, s2 = my.parts.field({ factory: m1, dismissOnBlur: true, inputClasses: ["tox-textfield"], sandboxClasses: ["tox-dialog__popups"], inputAttributes: { "aria-errormessage": v12, type: "url" }, minChars: 0, responseTime: 0, fetch: function(t3) {
        var e4, o3, n3, r3, i3 = U0((e4 = u2.filetype, o3 = c2, n3 = Df.getValue(t3), r3 = void 0 !== n3.meta.text ? n3.meta.text : n3.value, o3.getLinkInformation().fold(function() {
          return [];
        }, function(t4) {
          var n4 = mk(r3, M(o3.getHistory(e4), function(t5) {
            return fk(t5, t5);
          }));
          return "file" === e4 ? R([n4, mk(r3, dk("header", t4.targets)), mk(r3, ft([vt.from(t4.anchorTop).map(function(t5) {
            return fk("<top>", t5);
          }).toArray(), dk("anchor", t4.targets), vt.from(t4.anchorBottom).map(function(t5) {
            return fk("<bottom>", t5);
          }).toArray()]))], function(t5, n5) {
            return 0 === t5.length || 0 === n5.length ? t5.concat(n5) : t5.concat(h1, n5);
          }, []) : n4;
        })), Sh.BUBBLE_TO_SANDBOX, a2, false);
        return Gy(i3);
      }, getHotspot: function(t3) {
        return p2.getOpt(t3);
      }, onSetValue: function(t3, n3) {
        t3.hasConfigured(Ky) && Ky.run(t3).get(st);
      }, typeaheadBehaviours: nc(ft([c2.getValidationHandler().map(function(e4) {
        return Ky.config({ getRoot: function(t3) {
          return Yt(t3.element);
        }, invalidClass: "tox-control-wrap--status-invalid", notify: { onInvalid: function(t3, n3) {
          f2.getOpt(t3).each(function(t4) {
            on(t4.element, "title", i2.translate(n3));
          });
        } }, validator: { validate: function(t3) {
          var n3 = Df.getValue(t3);
          return p1(function(o3) {
            e4({ type: u2.filetype, url: n3.value }, function(t4) {
              var n4, e5;
              "invalid" === t4.status ? (n4 = Ve.error(t4.message), o3(n4)) : (e5 = Ve.value(t4.message), o3(e5));
            });
          });
        }, validateOnLoad: false } });
      }).toArray(), [gd.config({ disabled: function() {
        return u2.disabled || i2.isDisabled();
      } }), py.config({}), mm("urlinput-events", ft(["file" === u2.filetype ? [Cr(Si(), function(t3) {
        br(t3, yy, { name: u2.name });
      })] : [], [Cr(ki(), function(t3) {
        br(t3, yy, { name: u2.name }), r2(t3);
      }), Cr(Ai(), function(t3) {
        br(t3, yy, { name: u2.name }), r2(t3);
      })]]))]])), eventOrder: ((t2 = {})[Si()] = ["streaming", "urlinput-events", "invalidating"], t2), model: { getDisplayText: function(t3) {
        return t3.value;
      }, selectsOver: false, populateFromBrowse: false }, markers: { openClass: "tox-textfield--popup-open" }, lazySink: a2.shared.getSink, parts: { menu: Zp(0, 0, "normal") }, onExecute: function(t3, n3, e4) {
        br(n3, ky, {});
      }, onItemExecute: function(t3, n3, e4, o3) {
        r2(t3), br(t3, yy, { name: u2.name });
      } }), l2 = u2.label.map(function(t3) {
        return oy(t3, i2);
      }), f2 = zm((n2 = "invalid", e3 = vt.some(v12), Xm("warning", { tag: "div", classes: ["tox-icon", "tox-control-wrap__status-icon-" + n2], attributes: lt2({ title: i2.translate(o2 = void 0 === o2 ? n2 : o2), "aria-live": "polite" }, e3.fold(function() {
        return {};
      }, function(t3) {
        return { id: t3 };
      })) }, i2.icons))), d2 = zm({ dom: { tag: "div", classes: ["tox-control-wrap__status-icon-wrap"] }, components: [f2.asSpec()] }), m3 = c2.getUrlPicker(u2.filetype), g2 = Ir("browser.url.event"), p2 = zm({ dom: { tag: "div", classes: ["tox-control-wrap"] }, components: [s2, d2.asSpec()], behaviours: nc([gd.config({ disabled: function() {
        return u2.disabled || i2.isDisabled();
      } })]) }), h2 = zm(J0({ name: u2.name, icon: vt.some("browse"), text: u2.label.getOr(""), disabled: u2.disabled, primary: false, borderless: true }, function(t3) {
        return vr(t3, g2);
      }, i2, [], ["tox-browse-url"]));
      return my.sketch({ dom: by([]), components: l2.toArray().concat([{ dom: { tag: "div", classes: ["tox-form__controls-h-stack"] }, components: ft([[p2.asSpec()], m3.map(function() {
        return h2.asSpec();
      }).toArray()]) }]), fieldBehaviours: nc([gd.config({ disabled: function() {
        return u2.disabled || i2.isDisabled();
      }, onDisabled: function(t3) {
        my.getField(t3).each(gd.disable), h2.getOpt(t3).each(gd.disable);
      }, onEnabled: function(t3) {
        my.getField(t3).each(gd.enable), h2.getOpt(t3).each(gd.enable);
      } }), pv(), mm("url-input-events", [Cr(g2, function(o3) {
        cd.getCurrent(o3).each(function(n3) {
          var t3 = Df.getValue(n3), e4 = lt2({ fieldname: u2.name }, t3);
          m3.each(function(t4) {
            t4(e4).get(function(t5) {
              Df.setValue(n3, t5), br(o3, yy, { name: u2.name });
            });
          });
        });
      })])]) });
    }
    function pk(r2) {
      return function(n2, e3, o2) {
        return tt(e3, "name").fold(function() {
          return r2(e3, o2);
        }, function(t2) {
          return n2.field(t2, r2(e3, o2));
        });
      };
    }
    function hk(n2, t2, e3) {
      var o2 = Yo(e3, { shared: { interpreter: function(t3) {
        return x1(n2, t3, o2);
      } } });
      return x1(n2, t2, o2);
    }
    function vk(t2, n2, e3) {
      function o2() {
        return At.fromDom(t2.getContentAreaContainer());
      }
      function r2() {
        return p2 || !e3();
      }
      var i2, u2, a2, c2, s2, l2, f2, d2, m3, g2, p2 = sv(t2);
      return { inlineDialog: (f2 = o2, d2 = n2, m3 = r2, g2 = { maxHeightFunction: Vc() }, function() {
        return m3() ? { type: "node", root: tn(f2()), node: vt.from(f2()), bubble: Sc(12, 12, w1), layouts: { onRtl: function() {
          return [Am];
        }, onLtr: function() {
          return [Mm];
        } }, overrides: g2 } : { type: "hotspot", hotspot: d2(), bubble: Sc(-12, 12, w1), layouts: { onRtl: function() {
          return [Xa];
        }, onLtr: function() {
          return [Ya];
        } }, overrides: g2 };
      }), banner: (c2 = o2, s2 = n2, l2 = r2, function() {
        return l2() ? { type: "node", root: tn(c2()), node: vt.from(c2()), layouts: { onRtl: function() {
          return [cp];
        }, onLtr: function() {
          return [cp];
        } } } : { type: "hotspot", hotspot: s2(), layouts: { onRtl: function() {
          return [$a];
        }, onLtr: function() {
          return [$a];
        } } };
      }), cursor: (u2 = t2, function() {
        return { type: "selection", root: a2(), getSelection: function() {
          var t3 = u2.selection.getRng();
          return vt.some(ms.range(At.fromDom(t3.startContainer), t3.startOffset, At.fromDom(t3.endContainer), t3.endOffset));
        } };
      }), node: (i2 = a2 = function() {
        return At.fromDom(t2.getBody());
      }, function(t3) {
        return { type: "node", root: i2(), node: t3 };
      }) };
    }
    function bk(i2) {
      return vt.from(i2.getParam("style_formats")).filter(c).map(function(t2) {
        var n2, e3, o2 = (n2 = i2, e3 = k1(t2), n2.formatter ? r2(e3.customFormats) : n2.on("init", function() {
          r2(e3.customFormats);
        }), e3.formats);
        function r2(t3) {
          St(t3, function(t4) {
            n2.formatter.has(t4.name) || n2.formatter.register(t4.name, t4.format);
          });
        }
        return i2.getParam("style_formats_merge", false, "boolean") ? S1.concat(o2) : o2;
      }).getOr(S1);
    }
    function yk(t2, n2, e3) {
      var o2 = { type: "formatter", isSelected: n2(t2.format), getStylePreview: e3(t2.format) };
      return Yo(t2, o2);
    }
    function xk(c2, t2, s2, l2) {
      var f2 = function(t3) {
        return M(t3, function(t4) {
          var n2, e3, o2, r2, i2, u2 = Ct(t4);
          if (nt(t4, "items")) {
            var a2 = f2(t4.items);
            return Yo(Yo(t4, { type: "submenu" }), { getStyleItems: rt2(a2) });
          }
          return nt(t4, "format") ? yk(t4, s2, l2) : 1 === u2.length && wt(u2, "title") ? Yo(t4, { type: "separator" }) : (r2 = { type: "formatter", format: o2 = "custom-" + (e3 = y((n2 = t4).name) ? n2.name : Ir(n2.title)), isSelected: s2(o2), getStylePreview: l2(o2) }, i2 = Yo(n2, r2), c2.formatter.register(e3, i2), i2);
        });
      };
      return f2(t2);
    }
    function wk(e3) {
      return function(t2) {
        if (k(n2 = t2) && 1 === n2.nodeType) {
          if (t2.contentEditable === e3)
            return true;
          if (t2.getAttribute("data-mce-contenteditable") === e3)
            return true;
        }
        var n2;
        return false;
      };
    }
    function Sk(t2, n2, e3, o2, r2) {
      return { type: t2, title: n2, url: e3, level: o2, attach: r2 };
    }
    function kk(t2) {
      return t2.innerText || t2.textContent;
    }
    function Ck(t2) {
      return t2 && "A" === t2.nodeName && void 0 !== (t2.id || t2.name) && JC(t2);
    }
    function Ok(t2) {
      return t2 && /^(H[1-6])$/.test(t2.nodeName);
    }
    function _k(t2) {
      return Ok(t2) && JC(t2);
    }
    function Tk(t2) {
      var n2, e3 = t2.id || Ir("h");
      return Sk("header", kk(t2), "#" + e3, Ok(n2 = t2) ? parseInt(n2.nodeName.substr(1), 10) : 0, function() {
        t2.id = e3;
      });
    }
    function Ek(t2) {
      var n2 = t2.id || t2.name;
      return Sk("anchor", kk(t2) || "#" + n2, "#" + n2, 0, st);
    }
    function Dk(t2) {
      return 0 < C1(t2.title).length;
    }
    function Bk(t2) {
      return y(t2) && /^https?/.test(t2);
    }
    function Mk(t2) {
      return x(t2) && Q(t2, function(t3) {
        return !(c(n2 = t3) && n2.length <= 5 && N(n2, Bk));
        var n2;
      }).isNone();
    }
    function Ak() {
      var t2, n2 = db.getItem(E1);
      if (null === n2)
        return {};
      try {
        t2 = JSON.parse(n2);
      } catch (t3) {
        if (t3 instanceof SyntaxError)
          return console.log("Local storage " + E1 + " was not valid JSON", t3), {};
        throw t3;
      }
      return Mk(t2) ? t2 : (console.log("Local storage " + E1 + " was not valid format", t2), {});
    }
    function Fk(t2) {
      return tt(Ak(), t2).getOr([]);
    }
    function Ik(n2, t2) {
      var e3, o2;
      Bk(n2) && (o2 = F(tt(e3 = Ak(), t2).getOr([]), function(t3) {
        return t3 !== n2;
      }), e3[t2] = [n2].concat(o2).slice(0, 5), function(t3) {
        if (!Mk(t3))
          throw new Error("Bad format for history:\n" + JSON.stringify(t3));
        db.setItem(E1, JSON.stringify(t3));
      }(e3));
    }
    function Rk(t2) {
      return !!t2;
    }
    function Vk(t2) {
      return dt(fS.makeMap(t2, /[, ]/), Rk);
    }
    function Pk(t2) {
      return vt.from(t2.getParam("file_picker_callback")).filter(S);
    }
    function Hk(t2) {
      return vt.from(t2).filter(y).getOrUndefined();
    }
    function zk(l2) {
      return { getHistory: Fk, addToHistory: Ik, getLinkInformation: function() {
        return false === (t2 = l2).getParam("typeahead_urls") ? vt.none() : vt.some({ targets: T1(t2.getBody()), anchorTop: Hk(t2.getParam("anchor_top", "#top")), anchorBottom: Hk(t2.getParam("anchor_bottom", "#bottom")) });
        var t2;
      }, getValidationHandler: function() {
        return vt.from(void 0 === (n2 = (t2 = l2).getParam("file_picker_validator_handler", void 0, "function")) ? t2.getParam("filepicker_validator_handler", void 0, "function") : n2);
        var t2, n2;
      }, getUrlPicker: function(t2) {
        return n2 = c2 = l2, e3 = s2 = t2, r2 = vt.some((o2 = n2).getParam("file_picker_types")).filter(Rk), i2 = vt.some(o2.getParam("file_browser_callback_types")).filter(Rk), u2 = r2.or(i2).map(Vk), a2 = Pk(o2).fold(T, function(t3) {
          return u2.fold(D, function(t4) {
            return 0 < Ct(t4).length && t4;
          });
        }), (w(a2) ? a2 ? Pk(n2) : vt.none() : a2[e3] ? Pk(n2) : vt.none()).map(function(o3) {
          return function(n3) {
            return jy(function(e4) {
              var t3 = lt2({ filetype: s2, fieldname: n3.fieldname }, vt.from(n3.meta).getOr({}));
              o3.call(c2, function(t4, n4) {
                if (!y(t4))
                  throw new Error("Expected value to be string");
                if (void 0 !== n4 && !x(n4))
                  throw new Error("Expected meta to be a object");
                e4({ value: t4, meta: n4 });
              }, n3.value, t3);
            });
          };
        });
        var n2, e3, o2, r2, i2, u2, a2, c2, s2;
      } };
    }
    function Nk(t2, n2, e3) {
      var o2, r2, i2, u2, a2, c2, s2, l2, f2, d2, m3, g2, p2, h2 = Po(false), v4 = { isPositionedAtTop: function() {
        return "top" === o2.get();
      }, getDockingMode: (o2 = Po(av(n2) ? "bottom" : "top")).get, setDockingMode: o2.set }, b2 = { shared: { providers: { icons: function() {
        return n2.ui.registry.getAll().icons;
      }, menuItems: function() {
        return n2.ui.registry.getAll().menuItems;
      }, translate: dp.translate, isDisabled: function() {
        return n2.mode.isReadOnly() || n2.ui.isDisabled();
      }, getSetting: n2.getParam.bind(n2) }, interpreter: function(t3) {
        return x1(y1, t3, b2);
      }, anchors: vk(n2, e3, v4.isPositionedAtTop), header: v4, getSink: function() {
        return Ve.value(t2);
      } }, urlinput: zk(n2), styleselect: (f2 = Po([]), d2 = Po([]), m3 = Po([]), g2 = Po([]), p2 = Po(!(l2 = function(t3) {
        var n3 = t3.items;
        return void 0 !== n3 && 0 < n3.length ? z(n3, l2) : [t3.format];
      })), (s2 = n2).on("PreInit", function(t3) {
        var n3 = bk(s2), e4 = xk(s2, n3, y2, x2);
        f2.set(e4), d2.set(z(e4, l2));
      }), s2.on("addStyleModifications", function(t3) {
        var n3 = xk(s2, t3.items, y2, x2);
        m3.set(n3), p2.set(t3.replace), g2.set(z(n3, l2));
      }), { getData: function() {
        var t3 = p2.get() ? [] : f2.get(), n3 = m3.get();
        return t3.concat(n3);
      }, getFlattenedKeys: function() {
        var t3 = p2.get() ? [] : d2.get(), n3 = g2.get();
        return t3.concat(n3);
      } }), colorinput: { colorPicker: function(t3, n3) {
        Ib(c2)(t3, n3);
      }, hasCustomColors: function() {
        return gb(a2);
      }, getColors: function() {
        return pb(u2);
      }, getColorCols: (i2 = u2 = a2 = c2 = n2, function() {
        return vb(i2);
      }) }, dialog: { isDraggableModal: (r2 = n2, function() {
        return r2.getParam("draggable_modal", false, "boolean");
      }) }, isContextMenuOpen: function() {
        return h2.get();
      }, setContextMenuState: function(t3) {
        return h2.set(t3);
      } };
      function y2(t3) {
        return function() {
          return s2.formatter.match(t3);
        };
      }
      function x2(n3) {
        return function() {
          var t3 = s2.formatter.get(n3);
          return void 0 !== t3 ? vt.some({ tag: 0 < t3.length && (t3[0].inline || t3[0].block) || "div", styles: s2.dom.parseStyle(s2.formatter.getCssText(n3)) }) : vt.none();
        };
      }
      return b2;
    }
    function Lk(t2) {
      return (mt(hn(t2, "position"), "fixed") ? vt.none() : qt(t2)).orThunk(function() {
        var e3 = At.fromTag("span");
        return Yt(t2).bind(function(t3) {
          Te(t3, e3);
          var n2 = qt(e3);
          return Ee(e3), n2;
        });
      });
    }
    function Wk(t2) {
      return Lk(t2).map(Cn).getOrThunk(function() {
        return ke(0, 0);
      });
    }
    function Uk(t2, n2) {
      var e3 = t2.element;
      Yr(e3, n2.transitionClass), qr(e3, n2.fadeOutClass), Yr(e3, n2.fadeInClass), n2.onShow(t2);
    }
    function jk(t2, n2) {
      var e3 = t2.element;
      Yr(e3, n2.transitionClass), qr(e3, n2.fadeInClass), Yr(e3, n2.fadeOutClass), n2.onHide(t2);
    }
    function Gk(t2, n2, e3) {
      return N(t2, function(t3) {
        switch (t3) {
          case "bottom":
            return n2.bottom <= e3.bottom;
          case "top":
            return n2.y >= e3.y;
        }
      });
    }
    function Xk(n2, t2) {
      return t2.getInitialPos().map(function(t3) {
        return Me(t3.bounds.x, t3.bounds.y, On(n2), wn(n2));
      });
    }
    function Yk(e3, o2, r2) {
      return r2.getInitialPos().bind(function(t2) {
        switch (r2.clearInitialPos(), t2.position) {
          case "static":
            return vt.some(z1.static());
          case "absolute":
            var n2 = Lk(e3).map(Ae).getOrThunk(function() {
              return Ae(be());
            });
            return vt.some(z1.absolute(Ea("absolute", tt(t2.style, "left").map(function(t3) {
              return o2.x - n2.x;
            }), tt(t2.style, "top").map(function(t3) {
              return o2.y - n2.y;
            }), tt(t2.style, "right").map(function(t3) {
              return n2.right - o2.right;
            }), tt(t2.style, "bottom").map(function(t3) {
              return n2.bottom - o2.bottom;
            }))));
          default:
            return vt.none();
        }
      });
    }
    function qk(t2, n2, e3) {
      var o2, r2, i2, u2 = t2.element;
      return mt(hn(u2, "position"), "fixed") ? (r2 = n2, Xk(o2 = u2, i2 = e3).filter(function(t3) {
        return Gk(i2.getModes(), t3, r2);
      }).bind(function(t3) {
        return Yk(o2, t3, i2);
      })) : function(t3, n3, e4) {
        var r3, o3, i3 = Ae(t3);
        if (Gk(e4.getModes(), i3, n3))
          return vt.none();
        r3 = t3, o3 = i3, e4.setInitialPos({ style: function() {
          var t4 = {}, n4 = r3.dom;
          if (ct(n4))
            for (var e5 = 0; e5 < n4.style.length; e5++) {
              var o4 = n4.style.item(e5);
              t4[o4] = n4.style[o4];
            }
          return t4;
        }(), position: pn(r3, "position") || "static", bounds: o3 });
        var u3 = Fe(), a2 = i3.x - u3.x, c2 = n3.y - u3.y, s2 = u3.bottom - n3.bottom, l2 = i3.y <= n3.y;
        return vt.some(z1.fixed(Ea("fixed", vt.some(a2), l2 ? vt.some(c2) : vt.none(), vt.none(), l2 ? vt.none() : vt.some(s2))));
      }(u2, n2, e3);
    }
    function Kk(n2, t2, e3) {
      e3.setDocked(false), St(["left", "right", "top", "bottom", "position"], function(t3) {
        return bn(n2.element, t3);
      }), t2.onUndocked(n2);
    }
    function Jk(t2, n2, e3, o2) {
      var r2 = "fixed" === o2.position;
      e3.setDocked(r2), Da(t2.element, o2), (r2 ? n2.onDocked : n2.onUndocked)(t2);
    }
    function $k(o2, t2, r2, i2, u2) {
      void 0 === u2 && (u2 = false), t2.contextual.each(function(e3) {
        e3.lazyContext(o2).each(function(t3) {
          var n2 = t3.y < i2.bottom && t3.bottom > i2.y;
          n2 !== r2.isVisible() && (r2.setVisible(n2), u2 && !n2 ? (Jr(o2.element, [e3.fadeOutClass]), e3.onHide(o2)) : (n2 ? Uk : jk)(o2, e3));
        });
      });
    }
    function Qk(t2, n2, e3) {
      var o2, r2, i2, u2, a2, c2;
      e3.isDocked() && (r2 = n2, i2 = e3, c2 = (o2 = t2).element, i2.setDocked(false), Xk(a2 = o2.element, u2 = i2).bind(function(t3) {
        return Yk(a2, t3, u2);
      }).each(function(t3) {
        t3.fold(function() {
          return Kk(o2, r2, i2);
        }, function(t4) {
          return Jk(o2, r2, i2, t4);
        }, st);
      }), i2.setVisible(true), r2.contextual.each(function(t3) {
        $r(c2, [t3.fadeInClass, t3.fadeOutClass, t3.transitionClass]), t3.onShow(o2);
      }), N1(o2, r2, i2));
    }
    function Zk(t2, n2) {
      return wt(U1.getModes(t2), n2);
    }
    function tC(r2) {
      var i2 = r2.element;
      Yt(i2).each(function(t2) {
        var n2, e3, o2 = "padding-" + U1.getModes(r2)[0];
        U1.isDocked(r2) ? (n2 = On(t2), dn(i2, "width", n2 + "px"), dn(t2, o2, Sn(e3 = i2) + (parseInt(pn(e3, "margin-top"), 10) || 0) + (parseInt(pn(e3, "margin-bottom"), 10) || 0) + "px")) : (bn(i2, "width"), bn(t2, o2));
      });
    }
    function nC(t2, n2) {
      n2 ? (qr(t2, G1.fadeOutClass), Jr(t2, [G1.transitionClass, G1.fadeInClass])) : (qr(t2, G1.fadeInClass), Jr(t2, [G1.fadeOutClass, G1.transitionClass]));
    }
    function eC(t2, n2) {
      var e3 = At.fromDom(t2.getContainer());
      n2 ? (Yr(e3, X1), qr(e3, Y1)) : (Yr(e3, Y1), qr(e3, X1));
    }
    function oC(u2, t2) {
      function o2(n3) {
        r2().each(function(t3) {
          return n3(t3.element);
        });
      }
      function n2(t3) {
        u2.inline || tC(t3), eC(u2, U1.isDocked(t3)), t3.getSystem().broadcastOn([xf()], {}), r2().each(function(t4) {
          return t4.getSystem().broadcastOn([xf()], {});
        });
      }
      var e3, i2 = gc(), r2 = t2.getSink, a2 = u2.inline ? [] : [ic.config({ channels: ((e3 = {})[j1()] = { onReceive: tC }, e3) })];
      return H([Hg.config({}), U1.config({ contextual: lt2({ lazyContext: function(t3) {
        var n3 = Sn(t3.element), e4 = u2.inline ? u2.getContentAreaContainer() : u2.getContainer(), o3 = Ae(At.fromDom(e4)), r3 = o3.height - n3, i3 = o3.y + (Zk(t3, "top") ? 0 : n3);
        return vt.some(Me(o3.x, i3, o3.width, r3));
      }, onShow: function() {
        o2(function(t3) {
          return nC(t3, true);
        });
      }, onShown: function(r3) {
        o2(function(t3) {
          return $r(t3, [G1.transitionClass, G1.fadeInClass]);
        }), i2.get().each(function(t3) {
          var n3, e4 = r3.element, o3 = Ut(n3 = t3);
          Oa(o3).filter(function(t4) {
            return !Lt(n3, t4);
          }).filter(function(t4) {
            return Lt(t4, At.fromDom(o3.dom.body)) || Wt(e4, t4);
          }).each(function() {
            return ka(n3);
          }), i2.clear();
        });
      }, onHide: function(t3) {
        var n3 = t3.element, e4 = r2;
        _a2(n3).orThunk(function() {
          return e4().toOptional().bind(function(t4) {
            return _a2(t4.element);
          });
        }).fold(i2.clear, i2.set), o2(function(t4) {
          return nC(t4, false);
        });
      }, onHidden: function() {
        o2(function(t3) {
          return $r(t3, [G1.transitionClass]);
        });
      } }, G1), lazyViewport: function(t3) {
        var n3 = Fe(), e4 = u2.getParam("toolbar_sticky_offset", 0, "number"), o3 = n3.y + (Zk(t3, "top") ? e4 : 0), r3 = n3.height - (Zk(t3, "bottom") ? e4 : 0);
        return Me(n3.x, o3, n3.width, r3);
      }, modes: [t2.header.getDockingMode()], onDocked: n2, onUndocked: n2 })], a2, true);
    }
    function rC(t2) {
      return ao("menubutton", $1, t2);
    }
    function iC(n2, t2) {
      return t2.getAnimationRoot.fold(function() {
        return n2.element;
      }, function(t3) {
        return t3(n2);
      });
    }
    function uC(t2) {
      return t2.dimension.property;
    }
    function aC(t2, n2) {
      return t2.dimension.getDimension(n2);
    }
    function cC(t2, n2) {
      $r(iC(t2, n2), [n2.shrinkingClass, n2.growingClass]);
    }
    function sC(t2, n2) {
      qr(t2.element, n2.openClass), Yr(t2.element, n2.closedClass), dn(t2.element, uC(n2), "0px"), yn(t2.element);
    }
    function lC(t2, n2) {
      qr(t2.element, n2.closedClass), Yr(t2.element, n2.openClass), bn(t2.element, uC(n2));
    }
    function fC(t2, n2, e3, o2) {
      e3.setCollapsed(), dn(t2.element, uC(n2), aC(n2, t2.element)), yn(t2.element), cC(t2, n2), sC(t2, n2), n2.onStartShrink(t2), n2.onShrunk(t2);
    }
    function dC(t2, n2, e3) {
      var o2 = aC(n2, t2.element);
      ("0px" === o2 ? fC : function(t3, n3, e4, o3) {
        var r2 = o3.getOrThunk(function() {
          return aC(n3, t3.element);
        });
        e4.setCollapsed(), dn(t3.element, uC(n3), r2), yn(t3.element);
        var i2 = iC(t3, n3);
        qr(i2, n3.growingClass), Yr(i2, n3.shrinkingClass), sC(t3, n3), n3.onStartShrink(t3);
      })(t2, n2, e3, vt.some(o2));
    }
    function mC(t2, n2, e3) {
      var o2 = iC(t2, n2), r2 = Kr(o2, n2.shrinkingClass), i2 = aC(n2, t2.element);
      lC(t2, n2);
      var u2 = aC(n2, t2.element);
      (r2 ? function() {
        dn(t2.element, uC(n2), i2), yn(t2.element);
      } : function() {
        sC(t2, n2);
      })(), qr(o2, n2.shrinkingClass), Yr(o2, n2.growingClass), lC(t2, n2), dn(t2.element, uC(n2), u2), e3.setExpanded(), n2.onStartGrow(t2);
    }
    function gC(t2, n2, e3) {
      return true === Kr(iC(t2, n2), n2.growingClass);
    }
    function pC(t2, n2, e3) {
      return true === Kr(iC(t2, n2), n2.shrinkingClass);
    }
    function hC(t2) {
      return "<alloy.field." + t2 + ">";
    }
    function vC(t2) {
      return { element: function() {
        return t2.element.dom;
      } };
    }
    function bC(t2, e3) {
      cd.getCurrent(t2).each(function(t3) {
        return Rg.set(t3, [(n2 = e3, uO.sketch(function(t4) {
          return { dom: { tag: "div", classes: ["tox-sidebar__pane-container"] }, components: (e4 = t4, r2 = M(Ct(o2 = n2), function(t5) {
            var n3 = o2[t5], e5 = co(ao("sidebar", aO, n3));
            return { name: t5, getApi: vC, onSetup: e5.onSetup, onShow: e5.onShow, onHide: e5.onHide };
          }), M(r2, function(t5) {
            var n3 = Po(st);
            return e4.slot(t5.name, { dom: { tag: "div", classes: ["tox-sidebar__pane"] }, behaviours: Kh([vv(t5, n3), bv(t5, n3), Cr(Ji(), function(n4, t6) {
              var e5 = t6.event;
              V(r2, function(t7) {
                return t7.name === e5.name;
              }).each(function(t7) {
                (e5.visible ? t7.onShow : t7.onHide)(t7.getApi(n4));
              });
            })]) });
          })), slotBehaviours: Kh([ou(function(t5) {
            return uO.hideAllSlots(t5);
          })]) };
          var e4, o2, r2;
        }))]);
        var n2;
      });
    }
    function yC(t2) {
      return cd.getCurrent(t2).bind(function(t3) {
        return eO.isGrowing(t3) || eO.hasGrown(t3) ? cd.getCurrent(t3).bind(function(n2) {
          return V(uO.getSlotNames(n2), function(t4) {
            return uO.isShowing(n2, t4);
          });
        }) : vt.none();
      });
    }
    function xC(t2) {
      var n2 = At.fromHtml(t2), e3 = Kt(n2), o2 = R(void 0 !== n2.dom.attributes ? n2.dom.attributes : [], function(t3, n3) {
        var e4;
        return "class" === n3.name ? t3 : lt2(lt2({}, t3), ((e4 = {})[n3.name] = n3.value, e4));
      }, {}), r2 = Array.prototype.slice.call(n2.dom.classList, 0), i2 = 0 === e3.length ? {} : { innerHtml: Mr(n2) };
      return lt2({ tag: Ft(n2), classes: r2, attributes: o2 }, i2);
    }
    function wC(t2) {
      return cd.getCurrent(t2).each(function(t3) {
        return ka(t3.element);
      });
    }
    function SC(f2, d2, m3) {
      function n2(t2) {
        var n3;
        !g2.get() || "focusin" === (n3 = t2).type && (n3.composed ? Y(n3.composedPath()) : vt.from(n3.target)).map(At.fromDom).filter(Xn).exists(function(t3) {
          return Kr(t3, "mce-pastebin");
        }) || (t2.preventDefault(), wC(d2()), f2.editorManager.setActive(f2));
      }
      var g2 = Po(false), e3 = gc();
      function o2(t2) {
        var n3, e4, o3, r2, i2, u2, a2, c2, s2, l2;
        t2 !== g2.get() && (g2.set(t2), n3 = f2, e4 = d2(), o3 = t2, r2 = m3.providers, c2 = e4.element, s2 = o3, l2 = "data-mce-" + (i2 = "tabindex"), vt.from(n3.iframeElement).map(At.fromDom).each(function(n4) {
          s2 ? (an(n4, i2).each(function(t3) {
            return on(n4, l2, t3);
          }), on(n4, i2, -1)) : (sn(n4, i2), an(n4, l2).each(function(t3) {
            on(n4, i2, t3), sn(n4, l2);
          }));
        }), o3 ? (fO.block(e4, (a2 = r2, function(t3, n4) {
          return { dom: { tag: "div", attributes: { "aria-label": a2.translate("Loading..."), tabindex: "0" }, classes: ["tox-throbber__busy-spinner"] }, components: [{ dom: xC('<div class="tox-spinner"><div></div><div></div><div></div></div>') }] };
        })), bn(c2, "display"), sn(c2, "aria-hidden"), n3.hasFocus() && wC(e4)) : (u2 = cd.getCurrent(e4).exists(function(t3) {
          return Ca(t3.element);
        }), fO.unblock(e4), dn(c2, "display", "none"), on(c2, "aria-hidden", "true"), u2 && n3.focus()), f2.fire("AfterProgressState", { state: t2 }));
      }
      f2.inline || f2.on("PreInit", function() {
        f2.dom.bind(f2.getWin(), "focusin", n2), f2.on("BeforeExecCommand", function(t2) {
          "mcefocus" === t2.command.toLowerCase() && true !== t2.value && n2(t2);
        });
      }), f2.on("ProgressState", function(t2) {
        var n3;
        e3.on(lp.clearTimeout), u(t2.time) ? (n3 = lp.setEditorTimeout(f2, function() {
          return o2(t2.state);
        }, t2.time), e3.set(n3)) : (o2(t2.state), e3.clear());
      });
    }
    function kC(t2, n2, e3) {
      return { within: t2, extra: n2, withinWidth: e3 };
    }
    function CC(t2, n2, o2) {
      var e3, r2 = (e3 = function(t3, n3) {
        var e4 = o2(t3);
        return vt.some({ element: t3, start: n3, finish: n3 + e4, width: e4 });
      }, R(t2, function(n3, t3) {
        return e3(t3, n3.len).fold(rt2(n3), function(t4) {
          return { len: t4.finish, list: n3.list.concat([t4]) };
        });
      }, { len: 0, list: [] }).list), i2 = F(r2, function(t3) {
        return t3.finish <= n2;
      }), u2 = I(i2, function(t3, n3) {
        return t3 + n3.width;
      }, 0);
      return { within: i2, extra: r2.slice(i2.length), withinWidth: u2 };
    }
    function OC(t2) {
      return M(t2, function(t3) {
        return t3.element;
      });
    }
    function _C(t2, n2) {
      var e3 = M(n2, function(t3) {
        return Eu(t3);
      });
      V1.setGroups(t2, e3);
    }
    function TC(t2, n2, e3) {
      var o2, r2, i2, u2, a2, c2, s2, l2, f2, d2, m3, g2, p2, h2, v4, b2, y2, x2, w2, S2, k2 = n2.builtGroups.get();
      0 !== k2.length && (o2 = gl(t2, n2, "primary"), r2 = $y.getCoupled(t2, "overflowGroup"), dn(o2.element, "visibility", "hidden"), u2 = K(i2 = k2.concat([r2]), function(n3) {
        return _a2(n3.element).bind(function(t3) {
          return n3.getSystem().getByDom(t3).toOptional();
        });
      }), e3([]), _C(o2, i2), a2 = On(o2.element), 0 === (s2 = a2, l2 = n2.builtGroups.get(), d2 = r2, y2 = (0 === (m3 = CC(l2, s2, f2 = function(t3) {
        return On(t3.element);
      })).extra.length ? vt.some(m3) : vt.none()).getOrThunk(function() {
        return CC(l2, s2 - f2(d2), f2);
      }), x2 = y2.within, w2 = y2.extra, S2 = y2.withinWidth, (c2 = 1 === w2.length && w2[0].width <= f2(d2) ? (b2 = S2, kC(OC(x2.concat(w2)), [], b2)) : 1 <= w2.length ? (p2 = w2, h2 = d2, v4 = S2, kC(OC(x2).concat([h2]), OC(p2), v4)) : (g2 = S2, kC(OC(x2), [], g2))).extra.length) ? (Rg.remove(o2, r2), e3([])) : (_C(o2, c2.within), e3(c2.extra)), bn(o2.element, "visibility"), yn(o2.element), u2.each(Hg.focus));
    }
    function EC(t2, n2) {
      var e3 = $y.getCoupled(t2, "toolbarSandbox");
      bf.isOpen(e3) ? bf.close(e3) : bf.open(e3, n2.toolbar());
    }
    function DC(t2, n2, e3, o2) {
      var r2 = e3.getBounds.map(function(t3) {
        return t3();
      }), i2 = e3.lazySink(t2).getOrDie();
      ff.positionWithinBounds(i2, n2, { anchor: { type: "hotspot", hotspot: t2, layouts: o2, overrides: { maxWidthFunction: pO() } } }, r2);
    }
    function BC(t2, n2, e3, o2, r2) {
      V1.setGroups(n2, r2), DC(t2, n2, e3, o2), Lg.on(t2);
    }
    function MC(t2) {
      return M(t2, function(t3) {
        return Eu(t3);
      });
    }
    function AC(t2, e3, o2) {
      TC(t2, o2, function(n2) {
        o2.overflowGroups.set(n2), e3.getOpt(t2).each(function(t3) {
          bO.setGroups(t3, MC(n2));
        });
      });
    }
    function FC(n2, e3) {
      ml(n2, e3, "overflow-button").bind(function() {
        return ml(n2, e3, "overflow");
      }).each(function(t2) {
        QC(n2, e3), eO.toggleGrow(t2);
      });
    }
    function IC(t2) {
      var n2 = t2.title.fold(function() {
        return {};
      }, function(t3) {
        return { attributes: { title: t3 } };
      });
      return { dom: lt2({ tag: "div", classes: ["tox-toolbar__group"] }, n2), components: [wO.parts.items({})], items: t2.items, markers: { itemSelector: "*:not(.tox-split-button) > .tox-tbtn:not([disabled]), .tox-split-button:not([disabled]), .tox-toolbar-nav-js:not([disabled])" }, tgroupBehaviours: nc([py.config({}), Hg.config({})]) };
    }
    function RC(t2) {
      return wO.sketch(IC(t2));
    }
    function VC(e3, t2) {
      var n2 = ou(function(t3) {
        var n3 = M(e3.initGroups, RC);
        V1.setGroups(t3, n3);
      });
      return nc([Qv(e3.providers.isDisabled), pv(), Fg.config({ mode: t2, onEscape: e3.onEscape, selector: ".tox-toolbar__group" }), mm("toolbar-events", [n2])]);
    }
    function PC(t2) {
      var n2 = t2.cyclicKeying ? "cyclic" : "acyclic";
      return { uid: t2.uid, dom: { tag: "div", classes: ["tox-toolbar-overlord"] }, parts: { "overflow-group": IC({ title: vt.none(), items: [] }), "overflow-button": Y0({ name: "more", icon: vt.some("more-drawer"), disabled: false, tooltip: vt.some("More..."), primary: false, borderless: false }, vt.none(), t2.providers) }, splitToolbarBehaviours: VC(t2, n2) };
    }
    function HC(t2) {
      var n2 = t2.cyclicKeying ? "cyclic" : "acyclic";
      return V1.sketch({ uid: t2.uid, dom: { tag: "div", classes: ["tox-toolbar"].concat(t2.type === bh.scrolling ? ["tox-toolbar--scrolling"] : []) }, components: [V1.parts.groups({})], toolbarBehaviours: VC(t2, n2) });
    }
    function zC(t2) {
      return "string" == typeof t2 ? t2.split(" ") : t2;
    }
    function NC(i2, u2) {
      var a2 = lt2(lt2({}, IO), u2.menus), e3 = 0 < Ct(u2.menus).length, t2 = F(void 0 === u2.menubar || true === u2.menubar ? zC("file edit view insert format tools table help") : zC(false === u2.menubar ? "" : u2.menubar), function(t3) {
        var n2 = Tt(IO, t3);
        return e3 ? n2 || tt(u2.menus, t3).exists(function(t4) {
          return Tt(t4, "items");
        }) : n2;
      });
      return F(M(t2, function(t3) {
        var n2 = a2[t3], e4 = { title: n2.title, items: zC(n2.items) }, o2 = u2, r2 = i2.getParam("removed_menuitems", "").split(/[ ,]/);
        return { text: e4.title, getItems: function() {
          return z(e4.items, function(t4) {
            var n3 = t4.toLowerCase();
            return 0 === n3.trim().length || d(r2, function(t5) {
              return t5 === n3;
            }) ? [] : "separator" === n3 || "|" === n3 ? [{ type: "separator" }] : o2.menuItems[n3] ? [o2.menuItems[n3]] : [];
          });
        } };
      }), function(t3) {
        return 0 < t3.getItems().length && d(t3.getItems(), function(t4) {
          return "separator" !== t4.type;
        });
      });
    }
    function LC(t2) {
      function n2() {
        t2._skinLoaded = true, t2.fire("SkinLoaded");
      }
      return function() {
        t2.initialized ? n2() : t2.on("init", n2);
      };
    }
    function WC(e3, o2, r2) {
      return new Ap(function(t2, n2) {
        r2.load(o2, t2, n2), e3.on("remove", function() {
          return r2.unload(o2);
        });
      });
    }
    function UC(t2, n2) {
      var e3, o2, r2, i2, u2, a2, c2, s2, l2, f2 = (r2 = (e3 = n2).getParam("skin"), i2 = e3.getParam("skin_url"), false !== r2 && (o2 = r2 || "oxide", i2 = i2 ? e3.documentBaseURI.toAbsolute(i2) : ov.baseURL + "/skins/ui/" + o2), i2);
      f2 && n2.contentCSS.push(f2 + (t2 ? "/content.inline" : "/content") + ".min.css"), false === n2.getParam("skin") == 0 && y(f2) ? Ap.all([WC(n2, f2 + "/skin.min.css", n2.ui.styleSheetLoader), (c2 = n2, s2 = f2, l2 = At.fromDom(c2.getElement()), pe(l2).isSome() ? WC(c2, s2 + "/skin.shadowdom.min.css", ev.DOM.styleSheetLoader) : Ap.resolve())]).then(LC(n2), (u2 = n2, a2 = "Skin could not be loaded", function() {
        return u2.fire("SkinLoadError", { message: a2 });
      })) : LC(n2)();
    }
    function jC(o2, r2) {
      return function(n2) {
        function t2() {
          n2.setActive(o2.formatter.match(r2));
          var t3 = o2.formatter.formatChanged(r2, n2.setActive);
          e3.set(t3);
        }
        var e3 = mc();
        return o2.initialized ? t2() : o2.once("init", t2), function() {
          o2.off("init", t2), e3.clear();
        };
      };
    }
    function GC(o2, r2, i2) {
      return function(t2) {
        function n2() {
          return i2(t2);
        }
        function e3() {
          i2(t2), o2.on(r2, n2);
        }
        return o2.initialized ? e3() : o2.once("init", e3), function() {
          o2.off("init", e3), o2.off(r2, n2);
        };
      };
    }
    function XC(n2) {
      return function(t2) {
        return function() {
          n2.undoManager.transact(function() {
            n2.focus(), n2.execCommand("mceToggleFormat", false, t2.format);
          });
        };
      };
    }
    function YC(t2, n2) {
      return function() {
        return t2.execCommand(n2);
      };
    }
    function qC(t2, n2, e3) {
      var u2, a2, c2, o2 = e3.dataset, r2 = "basic" === o2.type ? function() {
        return M(o2.data, function(t3) {
          return yk(t3, e3.isSelectedFor, e3.getPreviewFor);
        });
      } : o2.getData;
      return { items: (u2 = n2, a2 = e3, c2 = function(t3, n3, e4) {
        var o3 = "formatter" === t3.type && a2.isInvalid(t3);
        return 0 === n3 ? o3 ? [] : i2(t3, n3, false, e4).toArray() : i2(t3, n3, o3, e4).toArray();
      }, { validateItems: s2, getFetch: function(e4, o3) {
        return function(t3, n3) {
          n3(U0(s2(o3()), Sh.CLOSE_ON_EXECUTE, e4, false));
        };
      } }), getStyleItems: r2 };
      function i2(t3, n3, e4, o3) {
        var r3 = u2.shared.providers.translate(t3.title);
        if ("separator" === t3.type)
          return vt.some({ type: "separator", text: r3 });
        if ("submenu" !== t3.type)
          return vt.some(lt2({ type: "togglemenuitem", text: r3, icon: t3.icon, active: t3.isSelected(o3), disabled: e4, onAction: a2.onAction(t3) }, t3.getStylePreview().fold(function() {
            return {};
          }, function(t4) {
            return { meta: { style: t4 } };
          })));
        var i3 = z(t3.getStyleItems(), function(t4) {
          return c2(t4, n3, o3);
        });
        return 0 === n3 && i3.length <= 0 ? vt.none() : vt.some({ type: "nestedmenuitem", text: r3, disabled: i3.length <= 0, getSubmenuItems: function() {
          return z(t3.getStyleItems(), function(t4) {
            return c2(t4, n3, o3);
          });
        } });
      }
      function s2(t3) {
        var n3 = a2.getCurrentValue(), e4 = a2.shouldHide ? 0 : 1;
        return z(t3, function(t4) {
          return c2(t4, e4, n3);
        });
      }
    }
    function KC(t2, n2, e3) {
      var o2 = qC(0, n2, e3), r2 = o2.items, i2 = o2.getStyleItems, u2 = GC(t2, "NodeChange", function(t3) {
        var n3 = t3.getComponent();
        e3.updateText(n3);
      });
      return L0({ text: e3.icon.isSome() ? vt.none() : e3.text, icon: e3.icon, tooltip: vt.from(e3.tooltip), role: vt.none(), fetch: r2.getFetch(n2, i2), onSetup: u2, getApi: function(t3) {
        return { getComponent: rt2(t3) };
      }, columns: 1, presets: "normal", classes: e3.icon.isSome() ? [] : ["bespoke"], dropdownBehaviours: [] }, "tox-tbtn", n2.shared);
    }
    function JC(t2) {
      return function(t3) {
        for (; t3 = t3.parentNode; ) {
          var n2 = t3.contentEditable;
          if (n2 && "inherit" !== n2)
            return O1(t3);
        }
        return false;
      }(t2) && !_1(t2);
    }
    function $C(r2, t2) {
      function n2(t3) {
        return vl(r2);
      }
      function e3(e4, o3) {
        return function(t3, n3) {
          return ml(t3, r2, n3).map(function(t4) {
            return e4(t4, n3);
          }).getOr(o3);
        };
      }
      function o2(t3, n3) {
        return "true" !== un(t3.element, "aria-hidden");
      }
      var i2, u2 = e3(o2, false), a2 = e3(function(t3, n3) {
        var e4;
        o2(t3) && (dn(e4 = t3.element, "display", "none"), on(e4, "aria-hidden", "true"), br(t3, Ji(), { name: n3, visible: false }));
      }), c2 = (i2 = a2, function(n3, t3) {
        St(t3, function(t4) {
          return i2(n3, t4);
        });
      }), s2 = e3(function(t3, n3) {
        var e4;
        o2(t3) || (bn(e4 = t3.element, "display"), sn(e4, "aria-hidden"), br(t3, Ji(), { name: n3, visible: true }));
      });
      return { uid: r2.uid, dom: r2.dom, components: t2, behaviours: tl(r2.slotBehaviours), apis: { getSlotNames: n2, getSlot: function(t3, n3) {
        return ml(t3, r2, n3);
      }, isShowing: u2, hideSlot: a2, hideAllSlots: function(t3) {
        return c2(t3, n2());
      }, showSlot: s2 } };
    }
    function QC(t2, n2) {
      ml(t2, n2, "overflow").each(function(e3) {
        TC(t2, n2, function(t3) {
          var n3 = M(t3, function(t4) {
            return Eu(t4);
          });
          V1.setGroups(e3, n3);
        }), ml(t2, n2, "overflow-button").each(function(t3) {
          eO.hasGrown(e3) && Lg.on(t3);
        }), eO.refresh(e3);
      });
    }
    var ZC, t1, n1, e1 = "data-value", o1 = function(n2, e3, t2, o2) {
      return M(t2, function(t3) {
        return rk(t3) ? { type: "togglemenuitem", text: t3.text, value: t3.value, active: t3.value === o2, onAction: function() {
          Df.setValue(n2, t3.value), br(n2, yy, { name: e3 }), Hg.focus(n2);
        } } : { type: "nestedmenuitem", text: t3.text, getSubmenuItems: function() {
          return o1(n2, e3, t3.items, o2);
        } };
      });
    }, r1 = function(t2, n2) {
      return K(t2, function(t3) {
        return rk(t3) ? ot(t3.value === n2, t3) : r1(t3.items, n2);
      });
    }, i1 = kl({ name: "HtmlSelect", configFields: [mo("options"), Zs("selectBehaviours", [Hg, Df]), Eo("selectClasses", []), Eo("selectAttributes", {}), wo("data")], factory: function(e3, t2) {
      var n2 = M(e3.options, function(t3) {
        return { dom: { tag: "option", value: t3.value, innerHtml: t3.text } };
      }), o2 = e3.data.map(function(t3) {
        return sr("initialValue", t3);
      }).getOr({});
      return { uid: e3.uid, dom: { tag: "select", classes: e3.selectClasses, attributes: e3.selectAttributes }, components: n2, behaviours: nl(e3.selectBehaviours, [Hg.config({}), Df.config({ store: lt2({ mode: "manual", getValue: function(t3) {
        return Qr(t3.element);
      }, setValue: function(t3, n3) {
        V(e3.options, function(t4) {
          return t4.value === n3;
        }).isSome() && Zr(t3.element, n3);
      } }, o2) })]) };
    } }), u1 = Object.freeze({ __proto__: null, events: function(t2, n2) {
      var e3 = t2.stream.streams.setup(t2, n2);
      return eu([Cr(t2.event, e3), ru(function() {
        return n2.cancel();
      })].concat(t2.cancelEvent.map(function(t3) {
        return [Cr(t3, function() {
          return n2.cancel();
        })];
      }).getOr([])));
    } }), a1 = Object.freeze({ __proto__: null, throttle: ak, init: function(t2) {
      return t2.stream.streams.state(t2);
    } }), c1 = xa({ fields: [go("stream", lo("mode", { throttle: [mo("delay"), Eo("stopEvent", true), ta("streams", { setup: function(t2, n2) {
      var e3 = t2.stream, o2 = vp(t2.onStream, e3.delay);
      return n2.setTimer(o2), function(t3, n3) {
        o2.throttle(t3, n3), e3.stopEvent && n3.stop();
      };
    }, state: ak })] })), Eo("event", "input"), wo("cancelEvent"), Qu("onStream")], name: "streaming", active: u1, state: a1 }), s1 = function(t2) {
      sk(t2, function(t3, n2) {
        return t3.setSelectionRange(n2.length, n2.length);
      });
    }, l1 = rt2("alloy.typeahead.itemexecute"), f1 = rt2([wo("lazySink"), mo("fetch"), Eo("minChars", 5), Eo("responseTime", 1e3), Ju("onOpen"), Eo("getHotspot", vt.some), Eo("getAnchorOverrides", rt2({})), Eo("layouts", vt.none()), Eo("eventOrder", {}), Vo("model", {}, [Eo("getDisplayText", function(t2) {
      return void 0 !== t2.meta && void 0 !== t2.meta.text ? t2.meta.text : t2.value;
    }), Eo("selectsOver", true), Eo("populateFromBrowse", true)]), Ju("onSetValue"), $u("onExecute"), Ju("onItemExecute"), Eo("inputClasses", []), Eo("inputAttributes", {}), Eo("inputStyles", {}), Eo("matchWidth", true), Eo("useMinWidth", false), Eo("dismissOnBlur", true), qu(["openClass"]), wo("initialData"), Zs("typeaheadBehaviours", [Hg, Df, c1, Fg, Lg, $y]), cr("previewing", function() {
      return Po(true);
    })].concat(Ey()).concat(ux())), d1 = rt2([$f({ schema: [Yu()], name: "menu", overrides: function(o2) {
      return { fakeFocus: true, onHighlight: function(n2, e3) {
        o2.previewing.get() ? n2.getSystem().getByUid(o2.uid).each(function(t2) {
          !function(t3, n3, o3) {
            if (t3.selectsOver) {
              var e4 = Df.getValue(n3), r2 = t3.getDisplayText(e4), i2 = Df.getValue(o3);
              return 0 === t3.getDisplayText(i2).indexOf(r2) ? vt.some(function() {
                var e5;
                ck(0, n3, o3), e5 = r2.length, sk(n3, function(t4, n4) {
                  return t4.setSelectionRange(e5, n4.length);
                });
              }) : vt.none();
            }
            return vt.none();
          }(o2.model, t2, e3).fold(function() {
            return hd.dehighlight(n2, e3);
          }, function(t3) {
            return t3();
          });
        }) : n2.getSystem().getByUid(o2.uid).each(function(t2) {
          o2.model.populateFromBrowse && ck(o2.model, t2, e3);
        }), o2.previewing.set(false);
      }, onExecute: function(t2, n2) {
        return t2.getSystem().getByUid(o2.uid).toOptional().map(function(t3) {
          return br(t3, l1(), { item: n2 }), true;
        });
      }, onHover: function(t2, n2) {
        o2.previewing.set(false), t2.getSystem().getByUid(o2.uid).each(function(t3) {
          o2.model.populateFromBrowse && ck(o2.model, t3, n2);
        });
      } };
    } })]), m1 = Cl({ name: "Typeahead", configFields: f1(), partFields: d1(), factory: function(r2, t2, n2, i2) {
      function e3(t3, n3, e4) {
        r2.previewing.set(false);
        var o3 = $y.getCoupled(t3, "sandbox");
        bf.isOpen(o3) ? cd.getCurrent(o3).each(function(t4) {
          hd.getHighlighted(t4).fold(function() {
            e4(t4);
          }, function() {
            wr(o3, t4.element, "keydown", n3);
          });
        }) : nx(r2, u2(t3), t3, o3, i2, function(t4) {
          cd.getCurrent(t4).each(e4);
        }, Hy.HighlightFirst).get(st);
      }
      function u2(e4) {
        return function(t3) {
          return t3.map(function(t4) {
            var n3 = z(Z(t4.menus), function(t5) {
              return F(t5.items, function(t6) {
                return "item" === t6.type;
              });
            });
            return Df.getState(e4).update(M(n3, function(t5) {
              return t5.data;
            })), t4;
          });
        };
      }
      var o2 = ry(r2), a2 = [Hg.config({}), Df.config({ onSetValue: r2.onSetValue, store: lt2({ mode: "dataset", getDataKey: function(t3) {
        return Qr(t3.element);
      }, getFallbackEntry: function(t3) {
        return { value: t3, meta: {} };
      }, setValue: function(t3, n3) {
        Zr(t3.element, r2.model.getDisplayText(n3));
      } }, r2.initialData.map(function(t3) {
        return sr("initialValue", t3);
      }).getOr({})) }), c1.config({ stream: { mode: "throttle", delay: r2.responseTime, stopEvent: false }, onStream: function(t3, n3) {
        var e4, o3 = $y.getCoupled(t3, "sandbox");
        Hg.isFocused(t3) && Qr(t3.element).length >= r2.minChars && (e4 = cd.getCurrent(o3).bind(function(t4) {
          return hd.getHighlighted(t4).map(Df.getValue);
        }), r2.previewing.set(true), nx(r2, u2(t3), t3, o3, i2, function(t4) {
          cd.getCurrent(o3).each(function(t5) {
            e4.fold(function() {
              r2.model.selectsOver && hd.highlightFirst(t5);
            }, function(n4) {
              hd.highlightBy(t5, function(t6) {
                return Df.getValue(t6).value === n4.value;
              }), hd.getHighlighted(t5).orThunk(function() {
                return hd.highlightFirst(t5), vt.none();
              });
            });
          });
        }, Hy.HighlightFirst).get(st));
      }, cancelEvent: zi() }), Fg.config({ mode: "special", onDown: function(t3, n3) {
        return e3(t3, n3, hd.highlightFirst), vt.some(true);
      }, onEscape: function(t3) {
        var n3 = $y.getCoupled(t3, "sandbox");
        return bf.isOpen(n3) ? (bf.close(n3), vt.some(true)) : vt.none();
      }, onUp: function(t3, n3) {
        return e3(t3, n3, hd.highlightLast), vt.some(true);
      }, onEnter: function(n3) {
        var t3 = $y.getCoupled(n3, "sandbox"), e4 = bf.isOpen(t3);
        if (e4 && !r2.previewing.get())
          return cd.getCurrent(t3).bind(function(t4) {
            return hd.getHighlighted(t4);
          }).map(function(t4) {
            return br(n3, l1(), { item: t4 }), true;
          });
        var o3 = Df.getValue(n3);
        return vr(n3, zi()), r2.onExecute(t3, n3, o3), e4 && bf.close(t3), vt.some(true);
      } }), Lg.config({ toggleClass: r2.markers.openClass, aria: { mode: "expanded" } }), $y.config({ others: { sandbox: function(t3) {
        return rx(r2, t3, { onOpen: function() {
          return Lg.on(t3);
        }, onClose: function() {
          return Lg.off(t3);
        } });
      } } }), mm("typeaheadevents", [uu(function(t3) {
        ex(r2, u2(t3), t3, i2, st, Hy.HighlightFirst).get(st);
      }), Cr(l1(), function(t3, n3) {
        var e4 = $y.getCoupled(t3, "sandbox");
        ck(r2.model, t3, n3.event.item), vr(t3, zi()), r2.onItemExecute(t3, e4, n3.event.item, Df.getValue(t3)), bf.close(e4), s1(t3);
      })].concat(r2.dismissOnBlur ? [Cr(Mi(), function(t3) {
        var n3 = $y.getCoupled(t3, "sandbox");
        _a2(n3.element).isNone() && bf.close(n3);
      })] : []))];
      return { uid: r2.uid, dom: iy(Yo(r2, { inputAttributes: { role: "combobox", "aria-autocomplete": "list", "aria-haspopup": "true" } })), behaviours: lt2(lt2({}, o2), nl(r2.typeaheadBehaviours, a2)), eventOrder: r2.eventOrder };
    } }), g1 = function(i2) {
      return lt2(lt2({}, i2), { toCached: function() {
        return g1(i2.toCached());
      }, bindFuture: function(n2) {
        return g1(i2.bind(function(t2) {
          return t2.fold(function(t3) {
            return Gy(Ve.error(t3));
          }, function(t3) {
            return n2(t3);
          });
        }));
      }, bindResult: function(n2) {
        return g1(i2.map(function(t2) {
          return t2.bind(n2);
        }));
      }, mapResult: function(n2) {
        return g1(i2.map(function(t2) {
          return t2.map(n2);
        }));
      }, mapError: function(n2) {
        return g1(i2.map(function(t2) {
          return t2.mapError(n2);
        }));
      }, foldResult: function(n2, e3) {
        return i2.map(function(t2) {
          return t2.fold(n2, e3);
        });
      }, withTimeout: function(t2, r2) {
        return g1(jy(function(n2) {
          var e3 = false, o2 = setTimeout(function() {
            e3 = true, n2(Ve.error(r2()));
          }, t2);
          i2.get(function(t3) {
            e3 || (clearTimeout(o2), n2(t3));
          });
        }));
      } });
    }, p1 = function(t2) {
      return g1(jy(t2));
    }, h1 = { type: "separator" }, v12 = Ir("aria-invalid"), b1 = { bar: pk(function(t2, n2) {
      return e3 = n2.shared, { dom: { tag: "div", classes: ["tox-bar", "tox-form__controls-h-stack"] }, components: M(t2.items, e3.interpreter) };
      var e3;
    }), collection: pk(function(t2, n2) {
      return u2 = t2, a2 = n2.shared.providers, c2 = u2.label.map(function(t3) {
        return oy(t3, a2);
      }), s2 = e3(function(t3, n3, e4, o3) {
        n3.stop(), a2.isDisabled() || br(t3, Sy, { name: u2.name, value: o3 });
      }), l2 = [Cr(vi(), e3(function(t3, n3, e4) {
        ka(e4);
      })), Cr(Ci(), s2), Cr(Vi(), s2), Cr(bi(), e3(function(t3, n3, e4) {
        Iu(t3.element, "." + Mh).each(function(t4) {
          qr(t4, Mh);
        }), Yr(e4, Mh);
      })), Cr(yi(), e3(function(t3) {
        Iu(t3.element, "." + Mh).each(function(t4) {
          qr(t4, Mh);
        });
      })), uu(e3(function(t3, n3, e4, o3) {
        br(t3, Sy, { name: u2.name, value: o3 });
      }))], ey(c2, my.parts.field({ dom: { tag: "div", classes: ["tox-collection"].concat(1 !== u2.columns ? ["tox-collection--grid"] : ["tox-collection--list"]) }, components: [], factory: { sketch: h }, behaviours: nc([gd.config({ disabled: a2.isDisabled, onDisabled: function(t3) {
        o2(t3, function(t4) {
          Yr(t4, "tox-collection__item--state-disabled"), on(t4, "aria-disabled", true);
        });
      }, onEnabled: function(t3) {
        o2(t3, function(t4) {
          qr(t4, "tox-collection__item--state-disabled"), sn(t4, "aria-disabled");
        });
      } }), pv(), Rg.config({}), Df.config({ store: { mode: "memory", initialValue: [] }, onSetValue: function(o3, t3) {
        var n3 = o3, e4 = M(t3, function(t4) {
          var n4 = dp.translate(t4.text), e5 = 1 === u2.columns ? '<div class="tox-collection__item-label">' + n4 + "</div>" : "", o4 = '<div class="tox-collection__item-icon">' + t4.icon + "</div>", r4 = { _: " ", " - ": " ", "-": " " }, i3 = n4.replace(/\_| \- |\-/g, function(t5) {
            return r4[t5];
          });
          return '<div class="tox-collection__item' + (a2.isDisabled() ? " tox-collection__item--state-disabled" : "") + '" tabindex="-1" data-collection-item-value="' + hy.encodeAllRaw(t4.value) + '" title="' + i3 + '" aria-label="' + i3 + '">' + o4 + e5 + "</div>";
        }), r3 = M("auto" !== u2.columns && 1 < u2.columns ? p(e4, u2.columns) : [e4], function(t4) {
          return '<div class="tox-collection__group">' + t4.join("") + "</div>";
        });
        Ar(n3.element, r3.join("")), "auto" === u2.columns && ah(o3, 5, "tox-collection__item").each(function(t4) {
          var n4 = t4.numRows, e5 = t4.numColumns;
          Fg.setGridSize(o3, n4, e5);
        }), vr(o3, Ty);
      } }), py.config({}), Fg.config(1 === (i2 = u2.columns) ? { mode: "menu", moveOnTab: false, selector: ".tox-collection__item" } : "auto" === i2 ? { mode: "flatgrid", selector: ".tox-collection__item", initSize: { numColumns: 1, numRows: 1 } } : { mode: "matrix", selectors: { row: ".tox-collection__group", cell: "." + Ch } }), mm("collection-events", l2)]), eventOrder: ((r2 = {})[Ii()] = ["disabling", "alloy.base.behaviour", "collection-events"], r2) }), ["tox-form__group--collection"], []);
      function e3(o3) {
        return function(n3, e4) {
          Ru(e4.event.target, "[data-collection-item-value]").each(function(t3) {
            o3(n3, e4, t3, un(t3, "data-collection-item-value"));
          });
        };
      }
      function o2(t3, n3) {
        return M(vs(t3.element, ".tox-collection__item"), n3);
      }
      var u2, a2, r2, i2, c2, s2, l2;
    }), alertbanner: pk(function(t2, n2) {
      return o2 = n2.shared.providers, ly.sketch({ dom: { tag: "div", attributes: { role: "alert" }, classes: ["tox-notification", "tox-notification--in", "tox-notification--" + (e3 = t2).level] }, components: [{ dom: { tag: "div", classes: ["tox-notification__icon"] }, components: [fp.sketch({ dom: { tag: "button", classes: ["tox-button", "tox-button--naked", "tox-button--icon"], innerHtml: Um(e3.icon, o2.icons), attributes: { title: o2.translate(e3.iconTooltip) } }, action: function(t3) {
        br(t3, Sy, { name: "alert-banner", value: e3.url });
      }, buttonBehaviours: nc([jm()]) })] }, { dom: { tag: "div", classes: ["tox-notification__body"], innerHtml: o2.translate(e3.text) } }] });
      var e3, o2;
    }), input: pk(function(t2, n2) {
      return o2 = n2.shared.providers, uk({ name: (e3 = t2).name, multiline: false, label: e3.label, inputMode: e3.inputMode, placeholder: e3.placeholder, flex: false, disabled: e3.disabled, classname: "tox-textfield", validation: vt.none(), maximized: e3.maximized }, o2);
      var e3, o2;
    }), textarea: pk(function(t2, n2) {
      return o2 = n2.shared.providers, uk({ name: (e3 = t2).name, multiline: true, label: e3.label, inputMode: vt.none(), placeholder: e3.placeholder, flex: true, disabled: e3.disabled, classname: "tox-textarea", validation: vt.none(), maximized: e3.maximized }, o2);
      var e3, o2;
    }), label: pk(function(t2, n2) {
      return r2 = { dom: { tag: "label", innerHtml: (o2 = n2.shared).providers.translate((e3 = t2).label), classes: ["tox-label"] } }, i2 = M(e3.items, o2.interpreter), { dom: { tag: "div", classes: ["tox-form__group"] }, components: [r2].concat(i2), behaviours: nc([aw(), Rg.config({}), cw(vt.none()), Fg.config({ mode: "acyclic" })]) };
      var e3, o2, r2, i2;
    }), iframe: (ZC = function(t2, n2) {
      return e3 = t2, o2 = n2.shared.providers, u2 = bS && e3.sandboxed, a2 = lt2(lt2({}, e3.label.map(function(t3) {
        return { title: t3 };
      }).getOr({})), u2 ? { sandbox: "allow-scripts allow-same-origin" } : {}), r2 = u2, i2 = Po(""), c2 = { getValue: function(t3) {
        return i2.get();
      }, setValue: function(t3, n3) {
        var e4;
        r2 ? on(t3.element, "srcdoc", n3) : (on(t3.element, "src", "javascript:''"), (e4 = t3.element.dom.contentWindow.document).open(), e4.write(n3), e4.close()), i2.set(n3);
      } }, ey(e3.label.map(function(t3) {
        return oy(t3, o2);
      }), my.parts.field({ factory: { sketch: function(t3) {
        return d0({ uid: t3.uid, dom: { tag: "iframe", attributes: a2 }, behaviours: nc([py.config({}), Hg.config({}), gS(vt.none(), c2.getValue, c2.setValue)]) });
      } } }), ["tox-form__group--stretched"], []);
      var e3, o2, r2, i2, u2, a2, c2;
    }, function(t2, n2, e3) {
      var o2 = Yo(n2, { source: "dynamic" });
      return pk(ZC)(t2, o2, e3);
    }), button: pk(function(t2, n2) {
      return e3 = t2, o2 = n2.shared.providers, r2 = $0(e3.name, "custom"), ey(vt.none(), my.parts.field(lt2({ factory: fp }, K0(e3, vt.some(r2), o2, [pS(""), aw()]))), [], []);
      var e3, o2, r2;
    }), checkbox: pk(function(t2, n2) {
      return r2 = t2, i2 = n2.shared.providers, u2 = Df.config({ store: { mode: "manual", getValue: function(t3) {
        return t3.element.dom.checked;
      }, setValue: function(t3, n3) {
        t3.element.dom.checked = n3;
      } } }), a2 = my.parts.field({ factory: { sketch: h }, dom: { tag: "input", classes: ["tox-checkbox__input"], attributes: { type: "checkbox" } }, behaviours: nc([aw(), gd.config({ disabled: function() {
        return r2.disabled || i2.isDisabled();
      } }), py.config({}), Hg.config({}), u2, Fg.config({ mode: "special", onEnter: e3, onSpace: e3, stopSpaceKeyup: true }), mm("checkbox-events", [Cr(ki(), function(t3, n3) {
        br(t3, yy, { name: r2.name });
      })])]) }), c2 = my.parts.label({ dom: { tag: "span", classes: ["tox-checkbox__label"], innerHtml: i2.translate(r2.label) }, behaviours: nc([vw.config({})]) }), s2 = zm({ dom: { tag: "div", classes: ["tox-checkbox__icons"] }, components: [o2("checked"), o2("unchecked")] }), my.sketch({ dom: { tag: "label", classes: ["tox-checkbox"] }, components: [a2, s2.asSpec(), c2], fieldBehaviours: nc([gd.config({ disabled: function() {
        return r2.disabled || i2.isDisabled();
      }, disableClass: "tox-checkbox--disabled", onDisabled: function(t3) {
        my.getField(t3).each(gd.disable);
      }, onEnabled: function(t3) {
        my.getField(t3).each(gd.enable);
      } }), pv()]) });
      function e3(t3) {
        return t3.element.dom.click(), vt.some(true);
      }
      function o2(t3) {
        return Xm("checked" === t3 ? "selected" : "unselected", { tag: "span", classes: ["tox-icon", "tox-checkbox-icon__" + t3] }, i2.icons);
      }
      var r2, i2, u2, a2, c2, s2;
    }), colorinput: pk(function(t2, n2) {
      return e3 = t2, r2 = n2.shared, i2 = n2.colorinput, c2 = my.parts.field({ factory: Dy, inputClasses: ["tox-textfield"], onSetValue: function(t3) {
        return Ky.run(t3).get(st);
      }, inputBehaviours: nc([gd.config({ disabled: r2.providers.isDisabled }), pv(), py.config({}), Ky.config({ invalidClass: "tox-textbox-field-invalid", getRoot: function(t3) {
        return Yt(t3.element);
      }, notify: { onValid: function(t3) {
        var n3 = Df.getValue(t3);
        br(t3, bw, { color: n3 });
      } }, validator: { validateOnLoad: false, validate: function(t3) {
        var n3 = Df.getValue(t3);
        if (0 === n3.length)
          return Gy(Ve.value(true));
        var e4 = At.fromTag("span");
        dn(e4, "background-color", n3);
        var o3 = hn(e4, "background-color").fold(function() {
          return Ve.error("blah");
        }, function(t4) {
          return Ve.value(n3);
        });
        return Gy(o3);
      } } })]), selectOnFocus: false }), s2 = e3.label.map(function(t3) {
        return oy(t3, r2.providers);
      }), l2 = zm((u2 = { dom: { tag: "span", attributes: { "aria-label": r2.providers.translate("Color swatch") } }, layouts: { onRtl: function() {
        return [Ya, Xa, $a];
      }, onLtr: function() {
        return [Xa, Ya, $a];
      } }, components: [], fetch: wb(i2.getColors(), i2.hasCustomColors()), columns: i2.getColorCols(), presets: "color", onItemAction: function(t3, e4) {
        l2.getOpt(t3).each(function(n3) {
          "custom" === e4 ? i2.colorPicker(function(t4) {
            t4.fold(function() {
              return vr(n3, xw);
            }, function(t5) {
              o2(n3, t5), hb(t5);
            });
          }, "#ffffff") : o2(n3, "remove" === e4 ? "" : e4);
        });
      } }, hw.sketch({ dom: u2.dom, components: u2.components, toggleClass: "mce-active", dropdownBehaviours: nc([$v((a2 = r2).providers.isDisabled), pv(), vw.config({}), py.config({})]), layouts: u2.layouts, sandboxClasses: ["tox-dialog__popups"], lazySink: a2.getSink, fetch: function(n3) {
        return jy(function(t3) {
          return u2.fetch(t3);
        }).map(function(t3) {
          return vt.from(Xb(Yo(Ob(Ir("menu-value"), t3, function(t4) {
            u2.onItemAction(n3, t4);
          }, u2.columns, u2.presets, Sh.CLOSE_ON_EXECUTE, T, a2.providers), { movement: _b2(u2.columns, u2.presets) })));
        });
      }, parts: { menu: Zp(0, 0, u2.presets) } }))), my.sketch({ dom: { tag: "div", classes: ["tox-form__group"] }, components: s2.toArray().concat([{ dom: { tag: "div", classes: ["tox-color-input"] }, components: [c2, l2.asSpec()] }]), fieldBehaviours: nc([mm("form-field-events", [Cr(bw, function(t3, n3) {
        l2.getOpt(t3).each(function(t4) {
          dn(t4.element, "background-color", n3.event.color);
        }), br(t3, yy, { name: e3.name });
      }), Cr(yw, function(n3, e4) {
        my.getField(n3).each(function(t3) {
          Df.setValue(t3, e4.event.value), cd.getCurrent(n3).each(Hg.focus);
        });
      }), Cr(xw, function(n3, t3) {
        my.getField(n3).each(function(t4) {
          cd.getCurrent(n3).each(Hg.focus);
        });
      })])]) });
      function o2(t3, n3) {
        br(t3, yw, { value: n3 });
      }
      var e3, r2, i2, u2, a2, c2, s2, l2;
    }), colorpicker: pk(function(t2) {
      var r2 = zm(a0(c0, function(t3) {
        return "tox-" + t3;
      }).sketch({ dom: { tag: "div", classes: ["tox-color-picker-container"], attributes: { role: "presentation" } }, onValidHex: function(t3) {
        br(t3, Sy, { name: "hex-valid", value: true });
      }, onInvalidHex: function(t3) {
        br(t3, Sy, { name: "hex-valid", value: false });
      } }));
      return { dom: { tag: "div" }, components: [r2.asSpec()], behaviours: nc([Df.config({ store: { mode: "manual", getValue: function(t3) {
        var n2 = r2.get(t3);
        return cd.getCurrent(n2).bind(function(t4) {
          return Df.getValue(t4).hex;
        }).map(function(t4) {
          return "#" + t4;
        }).getOr("");
      }, setValue: function(t3, n2) {
        var e3 = /^#([a-fA-F0-9]{3}(?:[a-fA-F0-9]{3})?)/.exec(n2), o2 = r2.get(t3);
        cd.getCurrent(o2).fold(function() {
          console.log("Can not find form");
        }, function(t4) {
          Df.setValue(t4, { hex: vt.from(e3[1]).getOr("") }), eS.getField(t4, "hex").each(function(t5) {
            vr(t5, Si());
          });
        });
      } } }), aw()]) };
    }), dropzone: pk(function(t2, n2) {
      return l0(t2, n2.shared.providers);
    }), grid: pk(function(t2, n2) {
      return e3 = n2.shared, { dom: { tag: "div", classes: ["tox-form__grid", "tox-form__grid--" + t2.columns + "col"] }, components: M(t2.items, e3.interpreter) };
      var e3;
    }), listbox: pk(function(t2, n2) {
      return e3 = t2, r2 = (o2 = n2).shared.providers, i2 = Y(e3.items).filter(rk), u2 = e3.label.map(function(t3) {
        return oy(t3, r2);
      }), a2 = { dom: { tag: "div", classes: ["tox-listboxfield"] }, components: [my.parts.field({ dom: {}, factory: { sketch: function(t3) {
        return L0({ uid: t3.uid, text: i2.map(function(t4) {
          return t4.text;
        }), icon: vt.none(), tooltip: e3.label, role: vt.none(), fetch: function(t4, n3) {
          n3(U0(o1(t4, e3.name, e3.items, Df.getValue(t4)), Sh.CLOSE_ON_EXECUTE, o2, false));
        }, onSetup: rt2(st), getApi: rt2({}), columns: 1, presets: "normal", classes: [], dropdownBehaviours: [py.config({}), Df.config({ store: { mode: "manual", initialValue: i2.map(function(t4) {
          return t4.value;
        }).getOr(""), getValue: function(t4) {
          return un(t4.element, e1);
        }, setValue: function(n3, t4) {
          r1(e3.items, t4).each(function(t5) {
            on(n3.element, e1, t5.value), br(n3, VS, { text: t5.text });
          });
        } } })] }, "tox-listbox", o2.shared);
      } } })] }, my.sketch({ dom: { tag: "div", classes: ["tox-form__group"] }, components: ft([u2.toArray(), [a2]]), fieldBehaviours: nc([gd.config({ disabled: rt2(e3.disabled), onDisabled: function(t3) {
        my.getField(t3).each(gd.disable);
      }, onEnabled: function(t3) {
        my.getField(t3).each(gd.enable);
      } })]) });
      var e3, o2, r2, i2, u2, a2;
    }), selectbox: pk(function(t2, n2) {
      return e3 = t2, o2 = n2.shared.providers, r2 = M(e3.items, function(t3) {
        return { text: o2.translate(t3.text), value: t3.value };
      }), i2 = e3.label.map(function(t3) {
        return oy(t3, o2);
      }), u2 = { dom: { tag: "div", classes: ["tox-selectfield"] }, components: ft([[my.parts.field({ dom: {}, selectAttributes: { size: e3.size }, options: r2, factory: i1, selectBehaviours: nc([gd.config({ disabled: function() {
        return e3.disabled || o2.isDisabled();
      } }), py.config({}), mm("selectbox-change", [Cr(ki(), function(t3, n3) {
        br(t3, yy, { name: e3.name });
      })])]) })], (1 < e3.size ? vt.none() : vt.some(Xm("chevron-down", { tag: "div", classes: ["tox-selectfield__icon-js"] }, o2.icons))).toArray()]) }, my.sketch({ dom: { tag: "div", classes: ["tox-form__group"] }, components: ft([i2.toArray(), [u2]]), fieldBehaviours: nc([gd.config({ disabled: function() {
        return e3.disabled || o2.isDisabled();
      }, onDisabled: function(t3) {
        my.getField(t3).each(gd.disable);
      }, onEnabled: function(t3) {
        my.getField(t3).each(gd.enable);
      } }), pv()]) });
      var e3, o2, r2, i2, u2;
    }), sizeinput: pk(function(t2, n2) {
      return ow(t2, n2.shared.providers);
    }), urlinput: pk(function(t2, n2) {
      return gk(t2, n2, n2.urlinput);
    }), customeditor: pk(function(e3) {
      var o2 = gc(), n2 = zm({ dom: { tag: e3.tag } }), r2 = gc();
      return { dom: { tag: "div", classes: ["tox-custom-editor"] }, behaviours: nc([mm("custom-editor-events", [ou(function(t2) {
        n2.getOpt(t2).each(function(n3) {
          (Tt(e3, "init") ? e3.init(n3.element.dom) : lS.load(e3.scriptId, e3.scriptUrl).then(function(t3) {
            return t3(n3.element.dom, e3.settings);
          })).then(function(n4) {
            r2.on(function(t3) {
              n4.setValue(t3);
            }), r2.clear(), o2.set(n4);
          });
        });
      })]), Df.config({ store: { mode: "manual", getValue: function() {
        return o2.get().fold(function() {
          return r2.get().getOr("");
        }, function(t2) {
          return t2.getValue();
        });
      }, setValue: function(t2, n3) {
        o2.get().fold(function() {
          r2.set(n3);
        }, function(t3) {
          return t3.setValue(n3);
        });
      } } }), aw()]), components: [n2.asSpec()] };
    }), htmlpanel: pk(function(t2) {
      return "presentation" === t2.presets ? ly.sketch({ dom: { tag: "div", classes: ["tox-form__group"], innerHtml: t2.html } }) : ly.sketch({ dom: { tag: "div", classes: ["tox-form__group"], innerHtml: t2.html, attributes: { role: "document" } }, containerBehaviours: nc([py.config({}), Hg.config({})]) });
    }), imagetools: pk(function(t2, n2) {
      return ok(t2, n2.shared.providers);
    }), table: pk(function(t2, n2) {
      return ik(t2, n2.shared.providers);
    }), panel: pk(function(t2, n2) {
      return { dom: { tag: "div", classes: t2.classes }, components: M(t2.items, n2.shared.interpreter) };
    }) }, y1 = { field: function(t2, n2) {
      return n2;
    } }, x1 = function(n2, e3, o2) {
      return tt(b1, e3.type).fold(function() {
        return console.error('Unknown factory type "' + e3.type + '", defaulting to container: ', e3), e3;
      }, function(t2) {
        return t2(n2, e3, o2);
      });
    }, w1 = { valignCentre: [], alignCentre: [], alignLeft: [], alignRight: [], right: [], left: [], bottom: [], top: [] }, S1 = [{ title: "Headings", items: [{ title: "Heading 1", format: "h1" }, { title: "Heading 2", format: "h2" }, { title: "Heading 3", format: "h3" }, { title: "Heading 4", format: "h4" }, { title: "Heading 5", format: "h5" }, { title: "Heading 6", format: "h6" }] }, { title: "Inline", items: [{ title: "Bold", format: "bold" }, { title: "Italic", format: "italic" }, { title: "Underline", format: "underline" }, { title: "Strikethrough", format: "strikethrough" }, { title: "Superscript", format: "superscript" }, { title: "Subscript", format: "subscript" }, { title: "Code", format: "code" }] }, { title: "Blocks", items: [{ title: "Paragraph", format: "p" }, { title: "Blockquote", format: "blockquote" }, { title: "Div", format: "div" }, { title: "Pre", format: "pre" }] }, { title: "Align", items: [{ title: "Left", format: "alignleft" }, { title: "Center", format: "aligncenter" }, { title: "Right", format: "alignright" }, { title: "Justify", format: "alignjustify" }] }], k1 = function(t2) {
      return R(t2, function(t3, n2) {
        if (Tt(n2, "items")) {
          var e3 = k1(n2.items);
          return { customFormats: t3.customFormats.concat(e3.customFormats), formats: t3.formats.concat([{ title: n2.title, items: e3.formats }]) };
        }
        if (Tt(n2, "inline") || Tt(n2, "block") || Tt(n2, "selector")) {
          var o2 = "custom-" + (y(n2.name) ? n2.name : n2.title.toLowerCase());
          return { customFormats: t3.customFormats.concat([{ name: o2, format: n2 }]), formats: t3.formats.concat([{ title: n2.title, format: o2, icon: n2.icon }]) };
        }
        return lt2(lt2({}, t3), { formats: t3.formats.concat(n2) });
      }, { customFormats: [], formats: [] });
    }, C1 = fS.trim, O1 = wk("true"), _1 = wk("false"), T1 = function(t2) {
      var n2 = M(vs(At.fromDom(t2), "h1,h2,h3,h4,h5,h6,a:not([href])"), function(t3) {
        return t3.dom;
      });
      return F(M(F(n2, _k), Tk).concat(M(F(n2, Ck), Ek)), Dk);
    }, E1 = "tinymce-url-history", D1 = od, B1 = nd, M1 = rt2([Eo("shell", false), mo("makeItem"), Eo("setupItem", st), Bf("listBehaviours", [Rg])]), A1 = rt2([Qf({ name: "items", overrides: function() {
      return { behaviours: nc([Rg.config({})]) };
    } })]), F1 = Cl({ name: rt2("CustomList")(), configFields: M1(), partFields: A1(), factory: function(s2, t2, n2, e3) {
      var o2 = s2.shell ? { behaviours: [Rg.config({})], components: [] } : { behaviours: [], components: t2 };
      return { uid: s2.uid, dom: s2.dom, components: o2.components, behaviours: nl(s2.listBehaviours, o2.behaviours), apis: { setItems: function(a2, c2) {
        var t3;
        t3 = a2, (s2.shell ? vt.some(t3) : ml(t3, s2, "items")).fold(function() {
          throw console.error("Custom List was defined to not be a shell, but no item container was specified in components"), new Error("Custom List was defined to not be a shell, but no item container was specified in components");
        }, function(n3) {
          var t4 = Rg.contents(n3), e4 = c2.length, o3 = e4 - t4.length, r2 = 0 < o3 ? m2(o3, function() {
            return s2.makeItem();
          }) : [], i2 = t4.slice(e4);
          St(i2, function(t5) {
            return Rg.remove(n3, t5);
          }), St(r2, function(t5) {
            return Rg.append(n3, t5);
          });
          var u2 = Rg.contents(n3);
          St(u2, function(t5, n4) {
            s2.setupItem(a2, t5, c2[n4], n4);
          });
        });
      } } };
    }, apis: { setItems: function(t2, n2, e3) {
      t2.setItems(n2, e3);
    } } }), I1 = rt2([mo("dom"), Eo("shell", true), Zs("toolbarBehaviours", [Rg])]), R1 = rt2([Qf({ name: "groups", overrides: function() {
      return { behaviours: nc([Rg.config({})]) };
    } })]), V1 = Cl({ name: "Toolbar", configFields: I1(), partFields: R1(), factory: function(o2, t2, n2, e3) {
      var r2 = o2.shell ? { behaviours: [Rg.config({})], components: [] } : { behaviours: [], components: t2 };
      return { uid: o2.uid, dom: o2.dom, components: r2.components, behaviours: nl(o2.toolbarBehaviours, r2.behaviours), apis: { setGroups: function(t3, n3) {
        var e4;
        e4 = t3, (o2.shell ? vt.some(e4) : ml(e4, o2, "groups")).fold(function() {
          throw console.error("Toolbar was defined to not be a shell, but no groups container was specified in components"), new Error("Toolbar was defined to not be a shell, but no groups container was specified in components");
        }, function(t4) {
          Rg.set(t4, n3);
        });
      } }, domModification: { attributes: { role: "group" } } };
    }, apis: { setGroups: function(t2, n2, e3) {
      t2.setGroups(n2, e3);
    } } }), P1 = rt2([]), H1 = Object.freeze({ __proto__: null, setup: st, isDocked: T, getBehaviours: P1 }), z1 = Ho([{ static: [] }, { absolute: ["positionCss"] }, { fixed: ["positionCss"] }]), N1 = function(t2, n2, e3) {
      var o2, r2, i2, u2;
      t2.getSystem().isConnected() && (i2 = e3, u2 = (r2 = n2).lazyViewport(o2 = t2), i2.isDocked() && $k(o2, r2, i2, u2), qk(o2, u2, i2).each(function(t3) {
        t3.fold(function() {
          return Kk(o2, r2, i2);
        }, function(t4) {
          return Jk(o2, r2, i2, t4);
        }, function(t4) {
          $k(o2, r2, i2, u2, true), Jk(o2, r2, i2, t4);
        });
      }));
    }, L1 = Object.freeze({ __proto__: null, refresh: N1, reset: Qk, isDocked: function(t2, n2, e3) {
      return e3.isDocked();
    }, getModes: function(t2, n2, e3) {
      return e3.getModes();
    }, setModes: function(t2, n2, e3, o2) {
      return e3.setModes(o2);
    } }), W1 = Object.freeze({ __proto__: null, events: function(o2, r2) {
      return eu([Br(_i(), function(n2, e3) {
        o2.contextual.each(function(t2) {
          Kr(n2.element, t2.transitionClass) && ($r(n2.element, [t2.transitionClass, t2.fadeInClass]), (r2.isVisible() ? t2.onShown : t2.onHidden)(n2)), e3.stop();
        });
      }), Cr(Ui(), function(t2, n2) {
        N1(t2, o2, r2);
      }), Cr(ji(), function(t2, n2) {
        Qk(t2, o2, r2);
      })]);
    } }), U1 = xa({ fields: [To("contextual", [po("fadeInClass"), po("fadeOutClass"), po("transitionClass"), vo("lazyContext"), Ju("onShow"), Ju("onShown"), Ju("onHide"), Ju("onHidden")]), Io("lazyViewport", Fe), Ro("modes", ["top", "bottom"], nr), Ju("onDocked"), Ju("onUndocked")], name: "docking", active: W1, apis: L1, state: Object.freeze({ __proto__: null, init: function(t2) {
      var n2 = Po(false), e3 = Po(true), o2 = gc(), r2 = Po(t2.modes);
      return wu({ isDocked: n2.get, setDocked: n2.set, getInitialPos: o2.get, setInitialPos: o2.set, clearInitialPos: o2.clear, isVisible: e3.get, setVisible: e3.set, getModes: r2.get, setModes: r2.set, readState: function() {
        return "docked:  " + n2.get() + ", visible: " + e3.get() + ", modes: " + r2.get().join(",");
      } });
    } }) }), j1 = rt2(Ir("toolbar-height-change")), G1 = { fadeInClass: "tox-editor-dock-fadein", fadeOutClass: "tox-editor-dock-fadeout", transitionClass: "tox-editor-dock-transition" }, X1 = "tox-tinymce--toolbar-sticky-on", Y1 = "tox-tinymce--toolbar-sticky-off", q1 = Object.freeze({ __proto__: null, setup: function(t2, n2, e3) {
      t2.inline || (n2.header.isPositionedAtTop() || t2.on("ResizeEditor", function() {
        e3().each(U1.reset);
      }), t2.on("ResizeWindow ResizeEditor", function() {
        e3().each(tC);
      }), t2.on("SkinLoaded", function() {
        e3().each(function(t3) {
          U1.isDocked(t3) ? U1.reset(t3) : U1.refresh(t3);
        });
      }), t2.on("FullscreenStateChanged", function() {
        e3().each(U1.reset);
      })), t2.on("AfterScrollIntoView", function(b2) {
        e3().each(function(t3) {
          U1.refresh(t3);
          var n3, e4, o2, r2, i2, u2, a2, c2, s2, l2, f2, d2, m3, g2, p2, h2, v4 = t3.element;
          Pd(v4) && (n3 = b2, r2 = (o2 = Ut(e4 = v4)).dom.defaultView.innerHeight, i2 = Rn(o2), a2 = Nn(u2 = At.fromDom(n3.elm)), c2 = wn(u2), l2 = (s2 = a2.y) + c2, f2 = Cn(e4), d2 = wn(e4), g2 = (m3 = f2.top) + d2, p2 = Math.abs(m3 - i2.top) < 2, h2 = Math.abs(g2 - (i2.top + r2)) < 2, p2 && s2 < g2 ? Vn(i2.left, s2 - d2, o2) : h2 && m3 < l2 && Vn(i2.left, s2 - r2 + c2 + d2, o2));
        });
      }), t2.on("PostRender", function() {
        eC(t2, false);
      });
    }, isDocked: function(t2) {
      return t2().map(U1.isDocked).getOr(false);
    }, getBehaviours: oC }), K1 = $o([po("type"), go("items", eo([Qo([po("name"), xo("items", nr)]), nr]))].concat(Hp)), J1 = [Co("text"), Co("tooltip"), Co("icon"), vo("fetch"), Io("onSetup", function() {
      return st;
    })], $1 = $o(H([po("type")], J1, true)), Q1 = $o([po("type"), Co("tooltip"), Co("icon"), Co("text"), Oo("select"), vo("fetch"), Io("onSetup", function() {
      return st;
    }), Ao("presets", "normal", ["normal", "color", "listpreview"]), Eo("columns", 1), vo("onAction"), vo("onItemAction")]), Z1 = kl({ factory: function(n2, o2) {
      var t2 = { focus: Fg.focusIn, setMenus: function(t3, n3) {
        var e3 = M(n3, function(n4) {
          return G0(rC({ type: "menubutton", text: n4.text, fetch: function(t4) {
            t4(n4.getItems());
          } }).mapError(function(t4) {
            return ur(t4);
          }).getOrDie(), "tox-mbtn", o2.backstage, vt.some("menuitem"));
        });
        Rg.set(t3, e3);
      } };
      return { uid: n2.uid, dom: n2.dom, components: [], behaviours: nc([Rg.config({}), mm("menubar-events", [ou(function(t3) {
        n2.onSetup(t3);
      }), Cr(vi(), function(e3, t3) {
        Iu(e3.element, ".tox-mbtn--active").each(function(n3) {
          Ru(t3.event.target, ".tox-mbtn").each(function(t4) {
            Lt(n3, t4) || e3.getSystem().getByDom(n3).each(function(n4) {
              e3.getSystem().getByDom(t4).each(function(t5) {
                hw.expand(t5), hw.close(n4), Hg.focus(t5);
              });
            });
          });
        });
      }), Cr(Ki(), function(e3, t3) {
        t3.event.prevFocus.bind(function(t4) {
          return e3.getSystem().getByDom(t4).toOptional();
        }).each(function(n3) {
          t3.event.newFocus.bind(function(t4) {
            return e3.getSystem().getByDom(t4).toOptional();
          }).each(function(t4) {
            hw.isOpen(n3) && (hw.expand(t4), hw.close(n3));
          });
        });
      })]), Fg.config({ mode: "flow", selector: ".tox-mbtn", onEscape: function(t3) {
        return n2.onEscape(t3), vt.some(true);
      } }), py.config({})]), apis: t2, domModification: { attributes: { role: "menubar" } } };
    }, name: "silver.Menubar", configFields: [mo("dom"), mo("uid"), mo("onEscape"), mo("backstage"), Eo("onSetup", st)], apis: { focus: function(t2, n2) {
      t2.focus(n2);
    }, setMenus: function(t2, n2, e3) {
      t2.setMenus(n2, e3);
    } } }), tO = Object.freeze({ __proto__: null, refresh: function(t2, n2, e3) {
      var o2;
      e3.isExpanded() && (bn(t2.element, uC(n2)), o2 = aC(n2, t2.element), dn(t2.element, uC(n2), o2));
    }, grow: function(t2, n2, e3) {
      e3.isExpanded() || mC(t2, n2, e3);
    }, shrink: function(t2, n2, e3) {
      e3.isExpanded() && dC(t2, n2, e3);
    }, immediateShrink: function(t2, n2, e3) {
      e3.isExpanded() && fC(t2, n2, e3);
    }, hasGrown: function(t2, n2, e3) {
      return e3.isExpanded();
    }, hasShrunk: function(t2, n2, e3) {
      return e3.isCollapsed();
    }, isGrowing: gC, isShrinking: pC, isTransitioning: function(t2, n2, e3) {
      return gC(t2, n2) || pC(t2, n2);
    }, toggleGrow: function(t2, n2, e3) {
      (e3.isExpanded() ? dC : mC)(t2, n2, e3);
    }, disableTransitions: cC }), nO = Object.freeze({ __proto__: null, exhibit: function(t2, n2, e3) {
      return Lr(n2.expanded ? { classes: [n2.openClass], styles: {} } : { classes: [n2.closedClass], styles: sr(n2.dimension.property, "0px") });
    }, events: function(e3, o2) {
      return eu([Br(_i(), function(t2, n2) {
        n2.event.raw.propertyName === e3.dimension.property && (cC(t2, e3), o2.isExpanded() && bn(t2.element, e3.dimension.property), (o2.isExpanded() ? e3.onGrown : e3.onShrunk)(t2));
      })]);
    } }), eO = xa({ fields: [mo("closedClass"), mo("openClass"), mo("shrinkingClass"), mo("growingClass"), wo("getAnimationRoot"), Ju("onShrunk"), Ju("onStartShrink"), Ju("onGrown"), Ju("onStartGrow"), Eo("expanded", false), go("dimension", lo("property", { width: [ta("property", "width"), ta("getDimension", function(t2) {
      return On(t2) + "px";
    })], height: [ta("property", "height"), ta("getDimension", function(t2) {
      return wn(t2) + "px";
    })] }))], name: "sliding", active: nO, apis: tO, state: Object.freeze({ __proto__: null, init: function(t2) {
      var n2 = Po(t2.expanded);
      return wu({ isExpanded: function() {
        return true === n2.get();
      }, isCollapsed: function() {
        return false === n2.get();
      }, setCollapsed: C(n2.set, false), setExpanded: C(n2.set, true), readState: function() {
        return "expanded: " + n2.get();
      } });
    } }) }), oO = "container", rO = [Zs("slotBehaviours", [])], iO = dt({ getSlotNames: function(t2, n2) {
      return t2.getSlotNames(n2);
    }, getSlot: function(t2, n2, e3) {
      return t2.getSlot(n2, e3);
    }, isShowing: function(t2, n2, e3) {
      return t2.isShowing(n2, e3);
    }, hideSlot: function(t2, n2, e3) {
      return t2.hideSlot(n2, e3);
    }, hideAllSlots: function(t2, n2) {
      return t2.hideAllSlots(n2);
    }, showSlot: function(t2, n2, e3) {
      return t2.showSlot(n2, e3);
    } }, zr), uO = lt2(lt2({}, iO), { sketch: function(t2) {
      var e3, n2 = { slot: function(t3, n3) {
        return e3.push(t3), cl(oO, hC(t3), n3);
      }, record: rt2(e3 = []) }, o2 = t2(n2), r2 = M(n2.record(), function(t3) {
        return Jf({ name: t3, pname: hC(t3) });
      });
      return Sl(oO, rO, r2, $C, o2);
    } }), aO = $o([Co("icon"), Co("tooltip"), Io("onShow", st), Io("onHide", st), Io("onSetup", function() {
      return st;
    })]), cO = Ir("FixSizeEvent"), sO = Ir("AutoSizeEvent"), lO = Object.freeze({ __proto__: null, block: function(t2, n2, e3, o2) {
      on(t2.element, "aria-busy", true);
      var r2 = n2.getRoot(t2).getOr(t2), i2 = nc([Fg.config({ mode: "special", onTab: function() {
        return vt.some(true);
      }, onShiftTab: function() {
        return vt.some(true);
      } }), Hg.config({})]), u2 = o2(r2, i2), a2 = r2.getSystem().build(u2);
      Rg.append(r2, Eu(a2)), a2.hasConfigured(Fg) && n2.focus && Fg.focusIn(a2), e3.isBlocked() || n2.onBlock(t2), e3.blockWith(function() {
        return Rg.remove(r2, a2);
      });
    }, unblock: function(t2, n2, e3) {
      sn(t2.element, "aria-busy"), e3.isBlocked() && n2.onUnblock(t2), e3.clear();
    } }), fO = xa({ fields: [Io("getRoot", vt.none), Fo("focus", true), Ju("onBlock"), Ju("onUnblock")], name: "blocking", apis: lO, state: Object.freeze({ __proto__: null, init: function() {
      var n2 = dc();
      return wu({ readState: n2.isSet, blockWith: function(t2) {
        n2.set({ destroy: t2 });
      }, clear: n2.clear, isBlocked: n2.isSet });
    } }) }), dO = rt2([Zs("splitToolbarBehaviours", [$y]), cr("builtGroups", function() {
      return Po([]);
    })]), mO = rt2([qu(["overflowToggledClass"]), Oo("getOverflowBounds"), mo("lazySink"), cr("overflowGroups", function() {
      return Po([]);
    })].concat(dO())), gO = rt2([Jf({ factory: V1, schema: I1(), name: "primary" }), $f({ schema: I1(), name: "overflow" }), $f({ name: "overflow-button" }), $f({ name: "overflow-group" })]), pO = rt2(function(t2, n2) {
      var e3 = t2, o2 = Math.floor(n2);
      dn(e3, "max-width", Oe.max(e3, o2, ["margin-left", "border-left-width", "padding-left", "padding-right", "border-right-width", "margin-right"]) + "px");
    }), hO = rt2([qu(["toggledClass"]), mo("lazySink"), vo("fetch"), Oo("getBounds"), To("fireDismissalEventInstead", [Eo("event", Yi())]), Wc()]), vO = rt2([$f({ name: "button", overrides: function(t2) {
      return { dom: { attributes: { "aria-haspopup": "true" } }, buttonBehaviours: nc([Lg.config({ toggleClass: t2.markers.toggledClass, aria: { mode: "expanded" }, toggleOnExecute: false })]) };
    } }), $f({ factory: V1, schema: I1(), name: "toolbar", overrides: function(n2) {
      return { toolbarBehaviours: nc([Fg.config({ mode: "cyclic", onEscape: function(t2) {
        return ml(t2, n2, "button").each(Hg.focus), vt.none();
      } })]) };
    } })]), bO = Cl({ name: "FloatingToolbarButton", factory: function(u2, t2, a2, n2) {
      return lt2(lt2({}, fp.sketch(lt2(lt2({}, n2.button()), { action: function(t3) {
        EC(t3, n2);
      }, buttonBehaviours: Mf({ dump: n2.button().buttonBehaviours }, [$y.config({ others: { toolbarSandbox: function(t3) {
        return o2 = t3, e3 = a2, r2 = u2, { dom: { tag: "div", attributes: { id: (i2 = Vu()).id } }, behaviours: nc([Fg.config({ mode: "special", onEscape: function(t4) {
          return bf.close(t4), vt.some(true);
        } }), bf.config({ onOpen: function(t4, n3) {
          r2.fetch().get(function(t5) {
            BC(o2, n3, r2, e3.layouts, t5), i2.link(o2.element), Fg.focusIn(n3);
          });
        }, onClose: function() {
          Lg.off(o2), Hg.focus(o2), i2.unlink(o2.element);
        }, isPartOf: function(t4, n3, e4) {
          return zu(n3, e4) || zu(o2, e4);
        }, getAttachPoint: function() {
          return r2.lazySink(o2).getOrDie();
        } }), ic.config({ channels: lt2(lt2({}, Xs(lt2({ isExtraPart: T }, r2.fireDismissalEventInstead.map(function(t4) {
          return { fireEventInstead: { event: t4.event } };
        }).getOr({})))), Ys({ doReposition: function() {
          bf.getState($y.getCoupled(o2, "toolbarSandbox")).each(function(t4) {
            DC(o2, t4, r2, e3.layouts);
          });
        } })) })]) };
        var o2, e3, r2, i2;
      } } })]) }))), { apis: { setGroups: function(n3, e3) {
        bf.getState($y.getCoupled(n3, "toolbarSandbox")).each(function(t3) {
          BC(n3, t3, u2, a2.layouts, e3);
        });
      }, reposition: function(n3) {
        bf.getState($y.getCoupled(n3, "toolbarSandbox")).each(function(t3) {
          DC(n3, t3, u2, a2.layouts);
        });
      }, toggle: function(t3) {
        EC(t3, n2);
      }, getToolbar: function(t3) {
        return bf.getState($y.getCoupled(t3, "toolbarSandbox"));
      }, isOpen: function(t3) {
        return bf.isOpen($y.getCoupled(t3, "toolbarSandbox"));
      } } });
    }, configFields: hO(), partFields: vO(), apis: { setGroups: function(t2, n2, e3) {
      t2.setGroups(n2, e3);
    }, reposition: function(t2, n2) {
      t2.reposition(n2);
    }, toggle: function(t2, n2) {
      t2.toggle(n2);
    }, getToolbar: function(t2, n2) {
      return t2.getToolbar(n2);
    }, isOpen: function(t2, n2) {
      return t2.isOpen(n2);
    } } }), yO = rt2([mo("items"), qu(["itemSelector"]), Zs("tgroupBehaviours", [Fg])]), xO = rt2([Zf({ name: "items", unit: "item" })]), wO = Cl({ name: "ToolbarGroup", configFields: yO(), partFields: xO(), factory: function(t2, n2, e3, o2) {
      return { uid: t2.uid, dom: t2.dom, components: n2, behaviours: nl(t2.tgroupBehaviours, [Fg.config({ mode: "flow", selector: t2.markers.itemSelector })]), domModification: { attributes: { role: "toolbar" } } };
    } }), SO = Cl({ name: "SplitFloatingToolbar", configFields: mO(), partFields: gO(), factory: function(e3, t2, n2, o2) {
      var r2 = zm(bO.sketch({ fetch: function() {
        return jy(function(t3) {
          t3(MC(e3.overflowGroups.get()));
        });
      }, layouts: { onLtr: function() {
        return [Ya, Xa];
      }, onRtl: function() {
        return [Xa, Ya];
      }, onBottomLtr: function() {
        return [Ka, qa];
      }, onBottomRtl: function() {
        return [qa, Ka];
      } }, getBounds: n2.getOverflowBounds, lazySink: e3.lazySink, fireDismissalEventInstead: {}, markers: { toggledClass: e3.markers.overflowToggledClass }, parts: { button: o2["overflow-button"](), toolbar: o2.overflow() } }));
      return { uid: e3.uid, dom: e3.dom, components: t2, behaviours: nl(e3.splitToolbarBehaviours, [$y.config({ others: { overflowGroup: function() {
        return wO.sketch(lt2(lt2({}, o2["overflow-group"]()), { items: [r2.asSpec()] }));
      } } })]), apis: { setGroups: function(t3, n3) {
        e3.builtGroups.set(M(n3, t3.getSystem().build)), AC(t3, r2, e3);
      }, refresh: function(t3) {
        return AC(t3, r2, e3);
      }, toggle: function(t3) {
        r2.getOpt(t3).each(function(t4) {
          bO.toggle(t4);
        });
      }, isOpen: function(t3) {
        return r2.getOpt(t3).map(bO.isOpen).getOr(false);
      }, reposition: function(t3) {
        r2.getOpt(t3).each(function(t4) {
          bO.reposition(t4);
        });
      }, getOverflow: function(t3) {
        return r2.getOpt(t3).bind(bO.getToolbar);
      } }, domModification: { attributes: { role: "group" } } };
    }, apis: { setGroups: function(t2, n2, e3) {
      t2.setGroups(n2, e3);
    }, refresh: function(t2, n2) {
      t2.refresh(n2);
    }, reposition: function(t2, n2) {
      t2.reposition(n2);
    }, toggle: function(t2, n2) {
      t2.toggle(n2);
    }, isOpen: function(t2, n2) {
      return t2.isOpen(n2);
    }, getOverflow: function(t2, n2) {
      return t2.getOverflow(n2);
    } } }), kO = rt2([qu(["closedClass", "openClass", "shrinkingClass", "growingClass", "overflowToggledClass"]), Ju("onOpened"), Ju("onClosed")].concat(dO())), CO = rt2([Jf({ factory: V1, schema: I1(), name: "primary" }), Jf({ factory: V1, schema: I1(), name: "overflow", overrides: function(n2) {
      return { toolbarBehaviours: nc([eO.config({ dimension: { property: "height" }, closedClass: n2.markers.closedClass, openClass: n2.markers.openClass, shrinkingClass: n2.markers.shrinkingClass, growingClass: n2.markers.growingClass, onShrunk: function(t2) {
        ml(t2, n2, "overflow-button").each(function(t3) {
          Lg.off(t3), Hg.focus(t3);
        }), n2.onClosed(t2);
      }, onGrown: function(t2) {
        Fg.focusIn(t2), n2.onOpened(t2);
      }, onStartGrow: function(t2) {
        ml(t2, n2, "overflow-button").each(Lg.on);
      } }), Fg.config({ mode: "acyclic", onEscape: function(t2) {
        return ml(t2, n2, "overflow-button").each(Hg.focus), vt.some(true);
      } })]) };
    } }), $f({ name: "overflow-button", overrides: function(t2) {
      return { buttonBehaviours: nc([Lg.config({ toggleClass: t2.markers.overflowToggledClass, aria: { mode: "pressed" }, toggleOnExecute: false })]) };
    } }), $f({ name: "overflow-group" })]), OO = Cl({ name: "SplitSlidingToolbar", configFields: kO(), partFields: CO(), factory: function(o2, t2, n2, e3) {
      var r2 = "alloy.toolbar.toggle";
      return { uid: o2.uid, dom: o2.dom, components: t2, behaviours: nl(o2.splitToolbarBehaviours, [$y.config({ others: { overflowGroup: function(n3) {
        return wO.sketch(lt2(lt2({}, e3["overflow-group"]()), { items: [fp.sketch(lt2(lt2({}, e3["overflow-button"]()), { action: function(t3) {
          vr(n3, r2);
        } }))] }));
      } } }), mm("toolbar-toggle-events", [Cr(r2, function(t3) {
        FC(t3, o2);
      })])]), apis: { setGroups: function(t3, n3) {
        var e4 = M(n3, t3.getSystem().build);
        o2.builtGroups.set(e4), QC(t3, o2);
      }, refresh: function(t3) {
        return QC(t3, o2);
      }, toggle: function(t3) {
        return FC(t3, o2);
      }, isOpen: function(t3) {
        return ml(t3, o2, "overflow").map(eO.hasGrown).getOr(false);
      } }, domModification: { attributes: { role: "group" } } };
    }, apis: { setGroups: function(t2, n2, e3) {
      t2.setGroups(n2, e3);
    }, refresh: function(t2, n2) {
      t2.refresh(n2);
    }, toggle: function(t2, n2) {
      t2.toggle(n2);
    }, isOpen: function(t2, n2) {
      return t2.isOpen(n2);
    } } }), _O = B1.optional({ factory: Z1, name: "menubar", schema: [mo("backstage")] }), TO = B1.optional({ factory: { sketch: function(t2) {
      return F1.sketch({ uid: t2.uid, dom: t2.dom, listBehaviours: nc([Fg.config({ mode: "acyclic", selector: ".tox-toolbar" })]), makeItem: function() {
        return HC({ type: t2.type, uid: Ir("multiple-toolbar-item"), cyclicKeying: false, initGroups: [], providers: t2.providers, onEscape: function() {
          return t2.onEscape(), vt.some(true);
        } });
      }, setupItem: function(t3, n2, e3, o2) {
        V1.setGroups(n2, e3);
      }, shell: true });
    } }, name: "multiple-toolbar", schema: [mo("dom"), mo("onEscape")] }), EO = B1.optional({ factory: { sketch: function(t2) {
      return (t2.type === bh.sliding ? function(t3) {
        var n2 = OO.parts.primary({ dom: { tag: "div", classes: ["tox-toolbar__primary"] } }), e3 = OO.parts.overflow({ dom: { tag: "div", classes: ["tox-toolbar__overflow"] } }), o2 = PC(t3);
        return OO.sketch(lt2(lt2({}, o2), { components: [n2, e3], markers: { openClass: "tox-toolbar__overflow--open", closedClass: "tox-toolbar__overflow--closed", growingClass: "tox-toolbar__overflow--growing", shrinkingClass: "tox-toolbar__overflow--shrinking", overflowToggledClass: "tox-tbtn--enabled" }, onOpened: function(t4) {
          t4.getSystem().broadcastOn([j1()], { type: "opened" });
        }, onClosed: function(t4) {
          t4.getSystem().broadcastOn([j1()], { type: "closed" });
        } }));
      } : t2.type === bh.floating ? function(i2) {
        var t3 = PC(i2), n2 = SO.parts.primary({ dom: { tag: "div", classes: ["tox-toolbar__primary"] } });
        return SO.sketch(lt2(lt2({}, t3), { lazySink: i2.getSink, getOverflowBounds: function() {
          var t4 = i2.moreDrawerData.lazyHeader().element, n3 = Nn(t4), e3 = Gt(t4), o2 = Nn(e3), r2 = Math.max(e3.dom.scrollHeight, o2.height);
          return Me(n3.x + 4, o2.y, n3.width - 8, r2);
        }, parts: lt2(lt2({}, t3.parts), { overflow: { dom: { tag: "div", classes: ["tox-toolbar__overflow"], attributes: i2.attributes } } }), components: [n2], markers: { overflowToggledClass: "tox-tbtn--enabled" } }));
      } : HC)({ type: t2.type, uid: t2.uid, onEscape: function() {
        return t2.onEscape(), vt.some(true);
      }, cyclicKeying: false, initGroups: [], getSink: t2.getSink, providers: t2.providers, moreDrawerData: { lazyToolbar: t2.lazyToolbar, lazyMoreButton: t2.lazyMoreButton, lazyHeader: t2.lazyHeader }, attributes: t2.attributes });
    } }, name: "toolbar", schema: [mo("dom"), mo("onEscape"), mo("getSink")] }), DO = B1.optional({ factory: { sketch: function(t2) {
      var n2 = t2.editor, e3 = t2.sticky ? oC : P1;
      return { uid: t2.uid, dom: t2.dom, components: t2.components, behaviours: nc(e3(n2, t2.sharedBackstage)) };
    } }, name: "header", schema: [mo("dom")] }), BO = B1.optional({ name: "socket", schema: [mo("dom")] }), MO = B1.optional({ factory: { sketch: function(t2) {
      return { uid: t2.uid, dom: { tag: "div", classes: ["tox-sidebar"], attributes: { role: "complementary" } }, components: [{ dom: { tag: "div", classes: ["tox-sidebar__slider"] }, components: [], behaviours: nc([py.config({}), Hg.config({}), eO.config({ dimension: { property: "width" }, closedClass: "tox-sidebar--sliding-closed", openClass: "tox-sidebar--sliding-open", shrinkingClass: "tox-sidebar--sliding-shrinking", growingClass: "tox-sidebar--sliding-growing", onShrunk: function(t3) {
        cd.getCurrent(t3).each(uO.hideAllSlots), vr(t3, sO);
      }, onGrown: function(t3) {
        vr(t3, sO);
      }, onStartGrow: function(t3) {
        br(t3, cO, { width: hn(t3.element, "width").getOr("") });
      }, onStartShrink: function(t3) {
        br(t3, cO, { width: On(t3.element) + "px" });
      } }), Rg.config({}), cd.config({ find: function(t3) {
        return Y(Rg.contents(t3));
      } })]) }], behaviours: nc([cS(0), mm("sidebar-sliding-events", [Cr(cO, function(t3, n2) {
        dn(t3.element, "width", n2.event.width);
      }), Cr(sO, function(t3, n2) {
        bn(t3.element, "width");
      })])]) };
    } }, name: "sidebar", schema: [mo("dom")] }), AO = B1.optional({ factory: { sketch: function(t2) {
      return { uid: t2.uid, dom: { tag: "div", attributes: { "aria-hidden": "true" }, classes: ["tox-throbber"], styles: { display: "none" } }, behaviours: nc([Rg.config({}), fO.config({ focus: false }), cd.config({ find: function(t3) {
        return Y(t3.components());
      } })]), components: [] };
    } }, name: "throbber", schema: [mo("dom")] }), FO = Cl({ name: "OuterContainer", factory: function(e3, t2, n2) {
      return { uid: e3.uid, dom: e3.dom, components: t2, apis: { getSocket: function(t3) {
        return D1.getPart(t3, e3, "socket");
      }, setSidebar: function(t3, n3) {
        D1.getPart(t3, e3, "sidebar").each(function(t4) {
          return bC(t4, n3);
        });
      }, toggleSidebar: function(t3, n3) {
        D1.getPart(t3, e3, "sidebar").each(function(t4) {
          var e4 = n3;
          cd.getCurrent(t4).each(function(n4) {
            cd.getCurrent(n4).each(function(t5) {
              eO.hasGrown(n4) ? uO.isShowing(t5, e4) ? eO.shrink(n4) : (uO.hideAllSlots(t5), uO.showSlot(t5, e4)) : (uO.hideAllSlots(t5), uO.showSlot(t5, e4), eO.grow(n4));
            });
          });
        });
      }, whichSidebar: function(t3) {
        return D1.getPart(t3, e3, "sidebar").bind(yC).getOrNull();
      }, getHeader: function(t3) {
        return D1.getPart(t3, e3, "header");
      }, getToolbar: function(t3) {
        return D1.getPart(t3, e3, "toolbar");
      }, setToolbar: function(t3, n3) {
        D1.getPart(t3, e3, "toolbar").each(function(t4) {
          t4.getApis().setGroups(t4, n3);
        });
      }, setToolbars: function(t3, n3) {
        D1.getPart(t3, e3, "multiple-toolbar").each(function(t4) {
          F1.setItems(t4, n3);
        });
      }, refreshToolbar: function(t3) {
        D1.getPart(t3, e3, "toolbar").each(function(t4) {
          return t4.getApis().refresh(t4);
        });
      }, toggleToolbarDrawer: function(t3) {
        D1.getPart(t3, e3, "toolbar").each(function(n3) {
          var t4 = n3.getApis().toggle;
          null != t4 ? vt.some(function(t5) {
            return t5(n3);
          }(t4)) : vt.none();
        });
      }, isToolbarDrawerToggled: function(t3) {
        return D1.getPart(t3, e3, "toolbar").bind(function(n3) {
          return vt.from(n3.getApis().isOpen).map(function(t4) {
            return t4(n3);
          });
        }).getOr(false);
      }, getThrobber: function(t3) {
        return D1.getPart(t3, e3, "throbber");
      }, focusToolbar: function(t3) {
        D1.getPart(t3, e3, "toolbar").orThunk(function() {
          return D1.getPart(t3, e3, "multiple-toolbar");
        }).each(function(t4) {
          Fg.focusIn(t4);
        });
      }, setMenubar: function(t3, n3) {
        D1.getPart(t3, e3, "menubar").each(function(t4) {
          Z1.setMenus(t4, n3);
        });
      }, focusMenubar: function(t3) {
        D1.getPart(t3, e3, "menubar").each(function(t4) {
          Z1.focus(t4);
        });
      } }, behaviours: e3.behaviours };
    }, configFields: [mo("dom"), mo("behaviours")], partFields: [DO, _O, EO, TO, BO, MO, AO], apis: { getSocket: function(t2, n2) {
      return t2.getSocket(n2);
    }, setSidebar: function(t2, n2, e3) {
      t2.setSidebar(n2, e3);
    }, toggleSidebar: function(t2, n2, e3) {
      t2.toggleSidebar(n2, e3);
    }, whichSidebar: function(t2, n2) {
      return t2.whichSidebar(n2);
    }, getHeader: function(t2, n2) {
      return t2.getHeader(n2);
    }, getToolbar: function(t2, n2) {
      return t2.getToolbar(n2);
    }, setToolbar: function(t2, n2, e3) {
      var o2 = M(e3, RC);
      t2.setToolbar(n2, o2);
    }, setToolbars: function(t2, n2, e3) {
      var o2 = M(e3, function(t3) {
        return M(t3, RC);
      });
      t2.setToolbars(n2, o2);
    }, refreshToolbar: function(t2, n2) {
      return t2.refreshToolbar(n2);
    }, toggleToolbarDrawer: function(t2, n2) {
      t2.toggleToolbarDrawer(n2);
    }, isToolbarDrawerToggled: function(t2, n2) {
      return t2.isToolbarDrawerToggled(n2);
    }, getThrobber: function(t2, n2) {
      return t2.getThrobber(n2);
    }, setMenubar: function(t2, n2, e3) {
      t2.setMenubar(n2, e3);
    }, focusMenubar: function(t2, n2) {
      t2.focusMenubar(n2);
    }, focusToolbar: function(t2, n2) {
      t2.focusToolbar(n2);
    } } }), IO = { file: { title: "File", items: "newdocument restoredraft | preview | export print | deleteallconversations" }, edit: { title: "Edit", items: "undo redo | cut copy paste pastetext | selectall | searchreplace" }, view: { title: "View", items: "code | visualaid visualchars visualblocks | spellchecker | preview fullscreen | showcomments" }, insert: { title: "Insert", items: "image link media addcomment pageembed template codesample inserttable | charmap emoticons hr | pagebreak nonbreaking anchor toc | insertdatetime" }, format: { title: "Format", items: "bold italic underline strikethrough superscript subscript codeformat | formats blockformats fontformats fontsizes align lineheight | forecolor backcolor | language | removeformat" }, tools: { title: "Tools", items: "spellchecker spellcheckerlanguage | a11ycheck code wordcount" }, table: { title: "Table", items: "inserttable | cell row column | advtablesort | tableprops deletetable" }, help: { title: "Help", items: "help" } }, RO = C(UC, false), VO = C(UC, true);
    function PO(t2, n2, e3, o2) {
      var r2;
      return { type: "basic", data: (r2 = t2.getParam(n2, e3, "string"), M(o2 === t1.SemiColon ? r2.replace(/;$/, "").split(";") : r2.split(" "), function(t3) {
        var n3 = t3, e4 = t3, o3 = t3.split("=");
        return 1 < o3.length && (n3 = o3[0], e4 = o3[1]), { title: n3, format: e4 };
      })) };
    }
    function HO(e3) {
      var t2 = { type: "basic", data: v_ };
      return { tooltip: "Align", text: vt.none(), icon: vt.some("align-left"), isSelectedFor: function(t3) {
        return function() {
          return e3.formatter.match(t3);
        };
      }, getCurrentValue: vt.none, getPreviewFor: function(t3) {
        return vt.none;
      }, onAction: function(n2) {
        return function() {
          return V(v_, function(t3) {
            return t3.format === n2.format;
          }).each(function(t3) {
            return e3.execCommand(t3.command);
          });
        };
      }, updateText: function(t3) {
        var n2 = V(v_, function(t4) {
          return e3.formatter.match(t4.format);
        }).fold(rt2("left"), function(t4) {
          return t4.title.toLowerCase();
        });
        br(t3, PS, { icon: "align-" + n2 });
      }, dataset: t2, shouldHide: false, isInvalid: function(t3) {
        return !e3.formatter.canApply(t3.format);
      } };
    }
    function zO(t2) {
      return M(t2.split(/\s*,\s*/), function(t3) {
        return t3.replace(/^['"]+|['"]+$/g, "");
      });
    }
    function NO(r2) {
      function i2() {
        function e3(t3) {
          return t3 ? zO(t3)[0] : "";
        }
        var t2 = r2.queryCommandValue("FontName"), n2 = a2.data, o2 = t2 ? t2.toLowerCase() : "";
        return { matchOpt: V(n2, function(t3) {
          var n3 = t3.format;
          return n3.toLowerCase() === o2 || e3(n3).toLowerCase() === e3(o2).toLowerCase();
        }).orThunk(function() {
          return ot(0 === (t3 = o2).indexOf("-apple-system") && (n3 = zO(t3.toLowerCase()), N(b_, function(t4) {
            return -1 < n3.indexOf(t4.toLowerCase());
          })), { title: u2, format: o2 });
          var t3, n3;
        }), font: t2 };
      }
      var u2 = "System Font", a2 = PO(r2, "font_formats", "Andale Mono=andale mono,monospace;Arial=arial,helvetica,sans-serif;Arial Black=arial black,sans-serif;Book Antiqua=book antiqua,palatino,serif;Comic Sans MS=comic sans ms,sans-serif;Courier New=courier new,courier,monospace;Georgia=georgia,palatino,serif;Helvetica=helvetica,arial,sans-serif;Impact=impact,sans-serif;Symbol=symbol;Tahoma=tahoma,arial,helvetica,sans-serif;Terminal=terminal,monaco,monospace;Times New Roman=times new roman,times,serif;Trebuchet MS=trebuchet ms,geneva,sans-serif;Verdana=verdana,geneva,sans-serif;Webdings=webdings;Wingdings=wingdings,zapf dingbats", t1.SemiColon);
      return { tooltip: "Fonts", text: vt.some(u2), icon: vt.none(), isSelectedFor: function(n2) {
        return function(t2) {
          return t2.exists(function(t3) {
            return t3.format === n2;
          });
        };
      }, getCurrentValue: function() {
        return i2().matchOpt;
      }, getPreviewFor: function(t2) {
        return function() {
          return vt.some({ tag: "div", styles: -1 === t2.indexOf("dings") ? { "font-family": t2 } : {} });
        };
      }, onAction: function(t2) {
        return function() {
          r2.undoManager.transact(function() {
            r2.focus(), r2.execCommand("FontName", false, t2.format);
          });
        };
      }, updateText: function(t2) {
        var n2 = i2(), e3 = n2.matchOpt, o2 = n2.font, r3 = e3.fold(rt2(o2), function(t3) {
          return t3.title;
        });
        br(t2, VS, { text: r3 });
      }, dataset: a2, shouldHide: false, isInvalid: T };
    }
    function LO(e3) {
      function i2() {
        var a2 = vt.none(), c2 = o2.data, s2 = e3.queryCommandValue("FontSize");
        if (s2)
          for (var t3 = function(t4) {
            var n3, e4, o3, r2, i3 = (e4 = t4, /[0-9.]+px$/.test(n3 = s2) ? (o3 = 72 * parseInt(n3, 10) / 96, r2 = Math.pow(10, e4 || 0), Math.round(o3 * r2) / r2 + "pt") : tt(x_, n3).getOr(n3)), u2 = tt(y_, i3).getOr("");
            a2 = V(c2, function(t5) {
              return t5.format === s2 || t5.format === i3 || t5.format === u2;
            });
          }, n2 = 3; a2.isNone() && 0 <= n2; n2--)
            t3(n2);
        return { matchOpt: a2, size: s2 };
      }
      var t2 = rt2(vt.none), o2 = PO(e3, "fontsize_formats", "8pt 10pt 12pt 14pt 18pt 24pt 36pt", t1.Space);
      return { tooltip: "Font sizes", text: vt.some("12pt"), icon: vt.none(), isSelectedFor: function(n2) {
        return function(t3) {
          return t3.exists(function(t4) {
            return t4.format === n2;
          });
        };
      }, getPreviewFor: t2, getCurrentValue: function() {
        return i2().matchOpt;
      }, onAction: function(t3) {
        return function() {
          e3.undoManager.transact(function() {
            e3.focus(), e3.execCommand("FontSize", false, t3.format);
          });
        };
      }, updateText: function(t3) {
        var n2 = i2(), e4 = n2.matchOpt, o3 = n2.size, r2 = e4.fold(rt2(o3), function(t4) {
          return t4.title;
        });
        br(t3, VS, { text: r2 });
      }, dataset: o2, shouldHide: false, isInvalid: T };
    }
    function WO(t2, n2) {
      var e3 = n2(), o2 = M(e3, function(t3) {
        return t3.format;
      });
      return vt.from(t2.formatter.closest(o2)).bind(function(n3) {
        return V(e3, function(t3) {
          return t3.format === n3;
        });
      }).orThunk(function() {
        return ot(t2.formatter.match("p"), { title: "Paragraph", format: "p" });
      });
    }
    function UO(e3) {
      var o2 = PO(e3, "block_formats", "Paragraph=p;Heading 1=h1;Heading 2=h2;Heading 3=h3;Heading 4=h4;Heading 5=h5;Heading 6=h6;Preformatted=pre", t1.SemiColon);
      return { tooltip: "Blocks", text: vt.some("Paragraph"), icon: vt.none(), isSelectedFor: function(t2) {
        return function() {
          return e3.formatter.match(t2);
        };
      }, getCurrentValue: vt.none, getPreviewFor: function(n2) {
        return function() {
          var t2 = e3.formatter.get(n2);
          return vt.some({ tag: 0 < t2.length && (t2[0].inline || t2[0].block) || "div", styles: e3.dom.parseStyle(e3.formatter.getCssText(n2)) });
        };
      }, onAction: XC(e3), updateText: function(t2) {
        var n2 = WO(e3, function() {
          return o2.data;
        }).fold(rt2("Paragraph"), function(t3) {
          return t3.title;
        });
        br(t2, VS, { text: n2 });
      }, dataset: o2, shouldHide: false, isInvalid: function(t2) {
        return !e3.formatter.canApply(t2.format);
      } };
    }
    function jO(r2, t2) {
      return { tooltip: "Formats", text: vt.some("Paragraph"), icon: vt.none(), isSelectedFor: function(t3) {
        return function() {
          return r2.formatter.match(t3);
        };
      }, getCurrentValue: vt.none, getPreviewFor: function(n2) {
        return function() {
          var t3 = r2.formatter.get(n2);
          return void 0 !== t3 ? vt.some({ tag: 0 < t3.length && (t3[0].inline || t3[0].block) || "div", styles: r2.dom.parseStyle(r2.formatter.getCssText(n2)) }) : vt.none();
        };
      }, onAction: XC(r2), updateText: function(t3) {
        var e3 = function(t4) {
          var n3 = t4.items;
          return void 0 !== n3 && 0 < n3.length ? z(n3, e3) : [{ title: t4.title, format: t4.format }];
        }, n2 = z(bk(r2), e3), o2 = WO(r2, rt2(n2)).fold(rt2("Paragraph"), function(t4) {
          return t4.title;
        });
        br(t3, VS, { text: o2 });
      }, shouldHide: r2.getParam("style_formats_autohide", false, "boolean"), isInvalid: function(t3) {
        return !r2.formatter.canApply(t3.format);
      }, dataset: t2 };
    }
    function GO(n2) {
      return { isDisabled: function() {
        return gd.isDisabled(n2);
      }, setDisabled: function(t2) {
        return gd.set(n2, t2);
      } };
    }
    function XO(n2) {
      return { setActive: function(t2) {
        Lg.set(n2, t2);
      }, isActive: function() {
        return Lg.isOn(n2);
      }, isDisabled: function() {
        return gd.isDisabled(n2);
      }, setDisabled: function(t2) {
        return gd.set(n2, t2);
      } };
    }
    function YO(t2, n2) {
      return t2.map(function(t3) {
        return { "aria-label": n2.translate(t3), title: n2.translate(t3) };
      }).getOr({});
    }
    function qO(n2, e3, t2, o2, r2, i2) {
      var u2;
      return { dom: { tag: "button", classes: ["tox-tbtn"].concat(e3.isSome() ? ["tox-tbtn--select"] : []), attributes: YO(t2, i2) }, components: tb([n2.map(function(t3) {
        return H0(t3, i2.icons);
      }), e3.map(function(t3) {
        return N0(t3, "tox-tbtn", i2);
      })]), eventOrder: ((u2 = {})[mi()] = ["focusing", "alloy.base.behaviour", "common-button-display-events"], u2), buttonBehaviours: nc([Qv(i2.isDisabled), pv(), mm("common-button-display-events", [Cr(mi(), function(t3, n3) {
        n3.event.prevent(), vr(t3, T_);
      })])].concat(o2.map(function(t3) {
        return k_.config({ channel: t3, initialData: { icon: n2, text: e3 }, renderComponents: function(t4, n3) {
          return tb([t4.icon.map(function(t5) {
            return H0(t5, i2.icons);
          }), t4.text.map(function(t5) {
            return N0(t5, "tox-tbtn", i2);
          })]);
        } });
      }).toArray()).concat(r2.getOr([]))) };
    }
    function KO(t2, n2, e3) {
      var o2, r2 = Po(st), i2 = qO(t2.icon, t2.text, t2.tooltip, vt.none(), vt.none(), e3);
      return fp.sketch({ dom: i2.dom, components: i2.components, eventOrder: RS, buttonBehaviours: nc([mm("toolbar-button-events", [(o2 = { onAction: t2.onAction, getApi: n2.getApi }, uu(function(n3, t3) {
        hv(o2, n3)(function(t4) {
          br(n3, IS, { buttonApi: t4 }), o2.onAction(t4);
        });
      })), vv(n2, r2), bv(n2, r2)]), Qv(function() {
        return t2.disabled || e3.isDisabled();
      }), pv()].concat(n2.toolbarButtonBehaviours)) });
    }
    function JO(r2, i2) {
      return function(t2, n2, e3) {
        var o2 = r2(t2).mapError(function(t3) {
          return ur(t3);
        }).getOrDie();
        return i2(o2, n2, e3);
      };
    }
    function $O(e3, t2, o2, r2) {
      var n2, i2 = t2.outerContainer, u2 = o2.toolbar, a2 = o2.buttons;
      f(u2, y) ? (n2 = u2.map(function(t3) {
        var n3 = { toolbar: t3, buttons: a2, allowToolbarGroups: o2.allowToolbarGroups };
        return F_(e3, n3, { backstage: r2 }, vt.none());
      }), FO.setToolbars(i2, n2)) : FO.setToolbar(i2, F_(e3, o2, { backstage: r2 }, vt.none()));
    }
    function QO(t2) {
      return /^[0-9\.]+(|px)$/i.test("" + t2) ? vt.some(parseInt("" + t2, 10)) : vt.none();
    }
    function ZO(t2) {
      return u(t2) ? t2 + "px" : t2;
    }
    function t_(n2, t2, e3) {
      var o2 = t2.filter(function(t3) {
        return n2 < t3;
      }), r2 = e3.filter(function(t3) {
        return t3 < n2;
      });
      return o2.or(r2).getOr(n2);
    }
    function n_(t2) {
      var n2 = lh(t2), e3 = fh(t2), o2 = mh(t2);
      return QO(n2).map(function(t3) {
        return t_(t3, e3, o2);
      });
    }
    function e_(u2, a2, t2, n2, c2) {
      function s2() {
        return x2.get() && !u2.removed;
      }
      function l2(t3) {
        return y2 ? t3.fold(rt2(0), function(t4) {
          return 1 < t4.components().length ? wn(t4.components()[1].element) : 0;
        }) : 0;
      }
      function f2() {
        r2.broadcastOn([xf()], {});
      }
      function o2(t3) {
        var n3, e4, o3, r3, i3;
        void 0 === t3 && (t3 = false), s2() && (m3 || (n3 = p2.getOrThunk(function() {
          var t4 = QO(pn(be(), "margin-left")).getOr(0);
          return On(be()) - Cn(a2).left + t4;
        }), dn(c2.get().element, "max-width", n3 + "px")), y2 && FO.refreshToolbar(d2), m3 || (e4 = l2(FO.getToolbar(d2)), o3 = Ae(a2), r3 = v4() ? Math.max(o3.y - wn(c2.get().element) + e4, 0) : o3.bottom, mn(d2.element, { position: "absolute", top: Math.round(r3) + "px", left: Math.round(o3.x) + "px" })), g2 && (i3 = c2.get(), t3 ? U1.reset(i3) : U1.refresh(i3)), f2());
      }
      function e3(t3) {
        var n3, e4;
        void 0 === t3 && (t3 = true), !m3 && g2 && s2() && (n3 = h2.getDockingMode(), (e4 = function(t4) {
          switch (uv(u2)) {
            case xh.auto:
              var n4 = l2(FO.getToolbar(d2)), e5 = wn(t4.element) - n4, o3 = Ae(a2);
              if (o3.y > e5)
                return "top";
              var r3 = Gt(a2), i3 = Math.max(r3.dom.scrollHeight, wn(r3));
              return o3.bottom < i3 - e5 || Fe().bottom < o3.bottom - e5 ? "bottom" : "top";
            case xh.bottom:
              return "bottom";
            default:
              return xh.top, "top";
          }
        }(c2.get())) !== n3 && (function(t4) {
          var n4 = c2.get();
          U1.setModes(n4, [t4]), h2.setDockingMode(t4);
          var e5 = v4() ? Oc.TopToBottom : Oc.BottomToTop;
          on(n4.element, es, e5);
        }(e4), t3 && o2(true)));
      }
      var r2 = t2.uiMothership, d2 = t2.outerContainer, i2 = ev.DOM, m3 = sv(u2), g2 = dv(u2), p2 = mh(u2).or(n_(u2)), h2 = n2.shared.header, v4 = h2.isPositionedAtTop, b2 = iv(u2), y2 = b2 === bh.sliding || b2 === bh.floating, x2 = Po(false);
      return { isVisible: s2, isPositionedAtTop: v4, show: function() {
        x2.set(true), dn(d2.element, "display", "flex"), i2.addClass(u2.getBody(), "mce-edit-focus"), bn(r2.element, "display"), e3(false), o2();
      }, hide: function() {
        x2.set(false), t2.outerContainer && (dn(d2.element, "display", "none"), i2.removeClass(u2.getBody(), "mce-edit-focus")), dn(r2.element, "display", "none");
      }, update: o2, updateMode: e3, repositionPopups: f2 };
    }
    function o_(t2, n2) {
      var e3 = Ae(t2);
      return { pos: n2 ? e3.y : e3.bottom, bounds: e3 };
    }
    function r_(i2, u2) {
      return Cr(IS, function(t2, n2) {
        var e3, o2 = i2.get(t2), r2 = (e3 = o2, { hide: function() {
          return vr(e3, Hi());
        }, getValue: function() {
          return Df.getValue(e3);
        } });
        u2.onAction(r2, n2.event.buttonApi);
      });
    }
    function i_(t2, n2, e3) {
      return n2.bottom - t2.y >= (e3 = void 0 === e3 ? 0.01 : e3) && t2.bottom - n2.y >= e3;
    }
    function u_(t2) {
      var n2 = function(t3) {
        var n3 = t3.getBoundingClientRect();
        if (n3.height <= 0 && n3.width <= 0) {
          var e4 = Qt(At.fromDom(t3.startContainer), t3.startOffset).element;
          return (Yn(e4) ? Yt(e4) : vt.some(e4)).filter(Xn).map(function(t4) {
            return t4.dom.getBoundingClientRect();
          }).getOr(n3);
        }
        return n3;
      }(t2.selection.getRng());
      if (t2.inline) {
        var e3 = Rn();
        return Me(e3.left + n2.left, e3.top + n2.top, n2.width, n2.height);
      }
      var o2 = Nn(At.fromDom(t2.getBody()));
      return Me(o2.x + n2.left, o2.y + n2.top, n2.width, n2.height);
    }
    function a_(t2, n2, e3, o2) {
      void 0 === o2 && (o2 = 0);
      var r2, i2, u2, a2, c2 = Hn(window), s2 = Ae(At.fromDom(t2.getContentAreaContainer())), l2 = ph(t2) || hh(t2) || rv(t2), f2 = (r2 = s2, i2 = c2, u2 = o2, { x: a2 = Math.max(r2.x + u2, i2.x), width: Math.min(r2.right - u2, i2.right) - a2 }), d2 = f2.x, m3 = f2.width;
      if (t2.inline && !l2)
        return Me(d2, c2.y, m3, c2.height);
      var g2 = function(t3, n3, e4, o3, r3, i3) {
        var u3 = At.fromDom(t3.getContainer()), a3 = Iu(u3, ".tox-editor-header").getOr(u3), c3 = Ae(a3), s3 = c3.y >= n3.bottom, l3 = o3 && !s3;
        if (t3.inline && l3)
          return { y: Math.max(c3.bottom + i3, e4.y), bottom: e4.bottom };
        if (t3.inline && !l3)
          return { y: e4.y, bottom: Math.min(c3.y - i3, e4.bottom) };
        var f3 = "line" === r3 ? Ae(u3) : n3;
        return l3 ? { y: Math.max(c3.bottom + i3, e4.y), bottom: Math.min(f3.bottom - i3, e4.bottom) } : { y: Math.max(f3.y + i3, e4.y), bottom: Math.min(c3.y - i3, e4.bottom) };
      }(t2, s2, c2, n2.header.isPositionedAtTop(), e3, o2), p2 = g2.y, h2 = g2.bottom;
      return Me(d2, p2, m3, h2 - p2);
    }
    function c_(t2) {
      return "node" === t2;
    }
    function s_(t2, r2, n2, i2, e3) {
      var u2 = u_(t2), o2 = i2.lastElement().exists(function(t3) {
        return Lt(n2, t3);
      }), a2 = n2, c2 = t2.selection.getRng(), s2 = Qt(At.fromDom(c2.startContainer), c2.startOffset);
      return c2.startContainer === c2.endContainer && c2.startOffset === c2.endOffset - 1 && Lt(s2.element, a2) ? o2 ? Vm : cp : o2 ? function(n3, t3) {
        var e4 = hn(n3, "position");
        dn(n3, "position", t3);
        var o3 = i_(u2, Ae(r2)) && !i2.isReposition() ? Hm : Vm;
        return e4.each(function(t4) {
          return dn(n3, "position", t4);
        }), o3;
      }(r2, i2.getMode()) : ("fixed" === i2.getMode() ? e3.y + Rn().top : e3.y) + (wn(r2) + 12) <= u2.y ? cp : sp;
    }
    function l_(n2, t2) {
      var e3 = A(F(t2, function(t3) {
        return t3.predicate(n2.dom);
      }), function(t3) {
        return "contexttoolbar" === t3.type;
      });
      return { contextToolbars: e3.pass, contextForms: e3.fail };
    }
    function f_(e3, t2) {
      function o2(t3) {
        return Lt(t3, r2);
      }
      var n2, r2 = At.fromDom(t2.getBody()), i2 = At.fromDom(t2.selection.getNode());
      return o2(n2 = i2) || Wt(r2, n2) ? function(t3, n3, e4) {
        var o3 = l_(t3, n3);
        if (0 < o3.contextForms.length)
          return vt.some({ elem: t3, toolbars: [o3.contextForms[0]] });
        var r3 = l_(t3, e4);
        if (0 < r3.contextForms.length)
          return vt.some({ elem: t3, toolbars: [r3.contextForms[0]] });
        if (0 < o3.contextToolbars.length || 0 < r3.contextToolbars.length) {
          var i3 = function(t4) {
            if (t4.length <= 1)
              return t4;
            function n4(n5) {
              return d(t4, function(t5) {
                return t5.position === n5;
              });
            }
            function e5(n5) {
              return F(t4, function(t5) {
                return t5.position === n5;
              });
            }
            var o4 = n4("selection"), r4 = n4("node");
            if (o4 || r4) {
              if (r4 && o4) {
                var i4 = e5("node"), u2 = M(e5("selection"), function(t5) {
                  return lt2(lt2({}, t5), { position: "node" });
                });
                return i4.concat(u2);
              }
              return e5(o4 ? "selection" : "node");
            }
            return e5("line");
          }(o3.contextToolbars.concat(r3.contextToolbars));
          return vt.some({ elem: t3, toolbars: i3 });
        }
        return vt.none();
      }(i2, e3.inNodeScope, e3.inEditorScope).orThunk(function() {
        return a2 = e3, (t3 = o2)(n3 = i2) ? vt.none() : dr(n3, function(t4) {
          if (Xn(t4)) {
            var n4 = l_(t4, a2.inNodeScope), e4 = n4.contextToolbars, o3 = n4.contextForms, r3 = 0 < o3.length ? o3 : (u2 = e4).length <= 1 ? u2 : i3("selection").orThunk(function() {
              return i3("node");
            }).orThunk(function() {
              return i3("line");
            }).map(function(t5) {
              return t5.position;
            }).fold(function() {
              return [];
            }, function(n5) {
              return F(u2, function(t5) {
                return t5.position === n5;
              });
            });
            return 0 < r3.length ? vt.some({ elem: t4, toolbars: r3 }) : vt.none();
          }
          function i3(n5) {
            return V(u2, function(t5) {
              return t5.position === n5;
            });
          }
          var u2;
          return vt.none();
        }, t3);
        var t3, n3, a2;
      }) : vt.none();
    }
    function d_(a2, c2) {
      var s2 = {}, l2 = [], f2 = [], d2 = {}, m3 = {}, t2 = Ct(a2);
      return St(t2, function(t3) {
        var n2, e3, o2, r2, i2, u2 = a2[t3];
        "contextform" === u2.type ? (o2 = t3, i2 = co(ao("ContextForm", qp, r2 = u2)), (s2[o2] = i2).launch.map(function(t4) {
          d2["form:" + o2] = lt2(lt2({}, r2.launch), { type: "contextformtogglebutton" === t4.type ? "togglebutton" : "button", onAction: function() {
            c2(i2);
          } });
        }), ("editor" === i2.scope ? f2 : l2).push(i2), m3[o2] = i2) : "contexttoolbar" === u2.type && (n2 = t3, ao("ContextToolbar", Kp, e3 = u2).each(function(t4) {
          ("editor" === e3.scope ? f2 : l2).push(t4), m3[n2] = t4;
        }));
      }), { forms: s2, inNodeScope: l2, inEditorScope: f2, lookupTable: m3, formNavigators: d2 };
    }
    function m_(d2, t2, m3, u2) {
      function a2() {
        var t3 = y2.get().getOr("node"), n3 = c_(t3) ? 1 : 0;
        return a_(d2, p2, t3, n3);
      }
      function c2() {
        return !(d2.removed || h2() && g2.isContextMenuOpen());
      }
      function s2() {
        if (c2()) {
          var t3 = a2(), n3 = mt(y2.get(), "node") ? (e4 = d2, v4.get().filter(ve).map(Nn).getOrThunk(function() {
            return u_(e4);
          })) : u_(d2);
          return t3.height <= 0 || !i_(n3, t3);
        }
        return 1;
        var e4;
      }
      function n2() {
        v4.clear(), b2.clear(), y2.clear(), up.hide(x2);
      }
      function e3() {
        var t3;
        up.isOpen(x2) && (bn(t3 = x2.element, "display"), s2() ? dn(t3, "display", "none") : (b2.set(0), up.reposition(x2)));
      }
      function l2(t3) {
        return { dom: { tag: "div", classes: ["tox-pop__dialog"] }, components: [t3], behaviours: nc([Fg.config({ mode: "acyclic" }), mm("pop-dialog-wrap-events", [ou(function(t4) {
          d2.shortcuts.add("ctrl+F9", "focus statusbar", function() {
            return Fg.focusIn(t4);
          });
        }), ru(function(t4) {
          d2.shortcuts.remove("ctrl+F9");
        })])]) };
      }
      function f2(t3, n3) {
        var e4, o3, r3, i3, c3, s3, u3, a3 = "node" === t3 ? p2.anchors.node(n3) : p2.anchors.cursor(), l3 = (e4 = d2, o3 = t3, r3 = h2(), i3 = { lastElement: v4.get, isReposition: function() {
          return mt(b2.get(), 0);
        }, getMode: function() {
          return ff.getMode(m3);
        } }, "line" === o3 ? { bubble: Sc(12, 0, N_), layouts: { onLtr: function() {
          return [la];
        }, onRtl: function() {
          return [fa];
        } }, overrides: L_ } : { bubble: Sc(0, 12, N_, 1 / 12), layouts: (c3 = e4, s3 = i3, u3 = o3, r3 ? { onLtr: function(t4) {
          return [$a, Xa, Ya, qa, Ka, Ja].concat(f3(t4));
        }, onRtl: function(t4) {
          return [$a, Ya, Xa, Ka, qa, Ja].concat(f3(t4));
        } } : { onLtr: function(t4) {
          return [Ja, $a, qa, Xa, Ka, Ya].concat(f3(t4));
        }, onRtl: function(t4) {
          return [Ja, $a, Ka, Ya, qa, Xa].concat(f3(t4));
        } }), overrides: L_ });
        function f3(t4) {
          return c_(u3) ? [(a4 = t4, function(t5, n4, e5, o4, r4) {
            var i4 = s_(c3, o4, a4, s3, r4), u4 = lt2(lt2({}, t5), { y: r4.y, height: r4.height });
            return lt2(lt2({}, i4(u4, n4, e5, o4, r4)), { alwaysFit: true });
          })] : [];
          var a4;
        }
        return Yo(a3, l3);
      }
      function o2(t3, n3) {
        var e4, o3, r3, i3;
        k2.cancel(), c2() && (e4 = S2(t3), r3 = f2(o3 = t3[0].position, n3), y2.set(o3), b2.set(1), bn(i3 = x2.element, "display"), mt(Et(n3, v4.get(), Lt), true) || (qr(i3, X_), ff.reset(m3, x2)), up.showWithinBounds(x2, l2(e4), { anchor: r3, transition: { classes: [X_], mode: "placement" } }, function() {
          return vt.some(a2());
        }), n3.fold(v4.clear, v4.set), s2() && dn(i3, "display", "none"));
      }
      var r2, i2, g2 = u2.backstage, p2 = g2.shared, h2 = le().deviceType.isTouch, v4 = gc(), b2 = gc(), y2 = gc(), x2 = Tu((r2 = { sink: m3, onEscape: function() {
        return d2.focus(), vt.some(true);
      } }, i2 = Po([]), up.sketch({ dom: { tag: "div", classes: ["tox-pop"] }, fireDismissalEventInstead: { event: "doNotDismissYet" }, onShow: function(t3) {
        i2.set([]), up.getContent(t3).each(function(t4) {
          bn(t4.element, "visibility");
        }), qr(t3.element, G_), bn(t3.element, "width");
      }, inlineBehaviours: nc([mm("context-toolbar-events", [Br(_i(), function(t3, n3) {
        "width" === n3.event.raw.propertyName && (qr(t3.element, G_), bn(t3.element, "width"));
      }), Cr(j_, function(t3, n3) {
        var e4 = t3.element;
        bn(e4, "width");
        var o3 = On(e4);
        up.setContent(t3, n3.event.contents), Yr(e4, G_);
        var r3 = On(e4);
        dn(e4, "width", o3 + "px"), up.getContent(t3).each(function(t4) {
          n3.event.focus.bind(function(t5) {
            return ka(t5), _a2(e4);
          }).orThunk(function() {
            return Fg.focusIn(t4), Oa(ge(e4));
          });
        }), lp.setTimeout(function() {
          dn(t3.element, "width", r3 + "px");
        }, 0);
      }), Cr(W_, function(n3, t3) {
        up.getContent(n3).each(function(t4) {
          i2.set(i2.get().concat([{ bar: t4, focus: Oa(ge(n3.element)) }]));
        }), br(n3, j_, { contents: t3.event.forwardContents, focus: vt.none() });
      }), Cr(U_, function(n3, t3) {
        q(i2.get()).each(function(t4) {
          i2.set(i2.get().slice(0, i2.get().length - 1)), br(n3, j_, { contents: Eu(t4.bar), focus: t4.focus });
        });
      })]), Fg.config({ mode: "special", onEscape: function(n3) {
        return q(i2.get()).fold(function() {
          return r2.onEscape();
        }, function(t3) {
          return vr(n3, U_), vt.some(true);
        });
      } })]), lazySink: function() {
        return Ve.value(r2.sink);
      } }))), w2 = Rt(function() {
        return d_(t2, function(t3) {
          var n3 = S2([t3]);
          br(x2, W_, { forwardContents: l2(n3) });
        });
      }), S2 = function(t3) {
        var n3 = d2.ui.registry.getAll().buttons, e4 = w2(), o3 = lt2(lt2({}, n3), e4.formNavigators), r3 = iv(d2) === bh.scrolling ? bh.scrolling : bh.default, i3 = ft(M(t3, function(t4) {
          return "contexttoolbar" === t4.type ? F_(d2, { buttons: o3, toolbar: t4.items, allowToolbarGroups: false }, u2, vt.some(["form:"])) : (n4 = p2.providers, z_(t4, n4));
          var n4;
        }));
        return HC({ type: r3, uid: Ir("context-toolbar"), initGroups: i3, onEscape: vt.none, cyclicKeying: true, providers: p2.providers });
      }, k2 = vp(function() {
        d2.hasFocus() && !d2.removed && (Kr(x2.element, X_) ? k2.throttle() : f_(w2(), d2).fold(n2, function(t3) {
          o2(t3.toolbars, vt.some(t3.elem));
        }));
      }, 17);
      d2.on("init", function() {
        d2.on("remove", n2), d2.on("ScrollContent ScrollWindow ObjectResized ResizeEditor longpress", e3), d2.on("click keyup focus SetContent", k2.throttle), d2.on(H_, n2), d2.on("contexttoolbar-show", function(n3) {
          tt(w2().lookupTable, n3.toolbarKey).each(function(t3) {
            o2([t3], ot(n3.target !== d2, n3.target)), up.getContent(x2).each(Fg.focusIn);
          });
        }), d2.on("focusout", function(t3) {
          lp.setEditorTimeout(d2, function() {
            _a2(m3.element).isNone() && _a2(x2.element).isNone() && n2();
          }, 0);
        }), d2.on("SwitchMode", function() {
          d2.mode.isReadOnly() && n2();
        }), d2.on("AfterProgressState", function(t3) {
          t3.state ? n2() : d2.hasFocus() && k2.throttle();
        }), d2.on("NodeChange", function(t3) {
          _a2(x2.element).fold(k2.throttle, st);
        });
      });
    }
    (n1 = t1 = t1 || {})[n1.SemiColon = 0] = "SemiColon", n1[n1.Space = 1] = "Space";
    var g_, p_, h_, v_ = [{ title: "Left", icon: "align-left", format: "alignleft", command: "JustifyLeft" }, { title: "Center", icon: "align-center", format: "aligncenter", command: "JustifyCenter" }, { title: "Right", icon: "align-right", format: "alignright", command: "JustifyRight" }, { title: "Justify", icon: "align-justify", format: "alignjustify", command: "JustifyFull" }], b_ = ["-apple-system", "Segoe UI", "Roboto", "Helvetica Neue", "sans-serif"], y_ = { "8pt": "1", "10pt": "2", "12pt": "3", "14pt": "4", "18pt": "5", "24pt": "6", "36pt": "7" }, x_ = { "xx-small": "7pt", "x-small": "8pt", small: "10pt", medium: "12pt", large: "14pt", "x-large": "18pt", "xx-large": "24pt" }, w_ = Object.freeze({ __proto__: null, events: function(r2, i2) {
      function u2(e3, o2) {
        r2.updateState.each(function(t2) {
          var n2 = t2(e3, o2);
          i2.set(n2);
        }), r2.renderComponents.each(function(t2) {
          var n2 = M(t2(o2, i2.get()), e3.getSystem().build);
          Rs(e3, n2);
        });
      }
      return eu([Cr(Fi(), function(t2, n2) {
        var e3, o2 = n2;
        o2.universal || (e3 = r2.channel, wt(o2.channels, e3) && u2(t2, o2.data));
      }), ou(function(n2, t2) {
        r2.initialData.each(function(t3) {
          u2(n2, t3);
        });
      })]);
    } }), S_ = Object.freeze({ __proto__: null, getState: function(t2, n2, e3) {
      return e3;
    } }), k_ = xa({ fields: [mo("channel"), wo("renderComponents"), wo("updateState"), wo("initialData")], name: "reflecting", active: w_, apis: S_, state: Object.freeze({ __proto__: null, init: function() {
      var t2 = Po(vt.none());
      return { readState: function() {
        return t2.get().getOr("none");
      }, get: t2.get, set: t2.set, clear: function() {
        return t2.set(vt.none());
      } };
    } }) }), C_ = rt2([mo("toggleClass"), mo("fetch"), Qu("onExecute"), Eo("getHotspot", vt.some), Eo("getAnchorOverrides", rt2({})), Wc(), Qu("onItemExecute"), wo("lazySink"), mo("dom"), Ju("onOpen"), Zs("splitDropdownBehaviours", [$y, Fg, Hg]), Eo("matchWidth", false), Eo("useMinWidth", false), Eo("eventOrder", {}), wo("role")].concat(ux())), O_ = rt2([Jf({ factory: fp, schema: [mo("dom")], name: "arrow", defaults: function() {
      return { buttonBehaviours: nc([Hg.revoke()]) };
    }, overrides: function(n2) {
      return { dom: { tag: "span", attributes: { role: "presentation" } }, action: function(t2) {
        t2.getSystem().getByUid(n2.uid).each(yr);
      }, buttonBehaviours: nc([Lg.config({ toggleOnExecute: false, toggleClass: n2.toggleClass })]) };
    } }), Jf({ factory: fp, schema: [mo("dom")], name: "button", defaults: function() {
      return { buttonBehaviours: nc([Hg.revoke()]) };
    }, overrides: function(e3) {
      return { dom: { tag: "span", attributes: { role: "presentation" } }, action: function(n2) {
        n2.getSystem().getByUid(e3.uid).each(function(t2) {
          e3.onExecute(t2, n2);
        });
      } };
    } }), Qf({ factory: { sketch: function(t2) {
      return { uid: t2.uid, dom: { tag: "span", styles: { display: "none" }, attributes: { "aria-hidden": "true" }, innerHtml: t2.text } };
    } }, schema: [mo("text")], name: "aria-descriptor" }), $f({ schema: [Yu()], name: "menu", defaults: function(o2) {
      return { onExecute: function(n2, e3) {
        n2.getSystem().getByUid(o2.uid).each(function(t2) {
          o2.onItemExecute(t2, n2, e3);
        });
      } };
    } }), Zy()]), __ = Cl({ name: "SplitDropdown", configFields: C_(), partFields: O_(), factory: function(o2, t2, n2, e3) {
      function r2(t3) {
        cd.getCurrent(t3).each(function(t4) {
          hd.highlightFirst(t4), Fg.focusIn(t4);
        });
      }
      function i2(t3) {
        ex(o2, h, t3, e3, r2, Hy.HighlightFirst).get(st);
      }
      function u2(t3) {
        return yr(gl(t3, o2, "button")), vt.some(true);
      }
      var a2, c2 = lt2(lt2({}, eu([ou(function(e4, t3) {
        ml(e4, o2, "aria-descriptor").each(function(t4) {
          var n3 = Ir("aria");
          on(t4.element, "id", n3), on(e4.element, "aria-describedby", n3);
        });
      })])), Sm(vt.some(i2))), s2 = { repositionMenus: function(t3) {
        Lg.isOn(t3) && ix(t3);
      } };
      return { uid: o2.uid, dom: o2.dom, components: t2, apis: s2, eventOrder: lt2(lt2({}, o2.eventOrder), ((a2 = {})[Ii()] = ["disabling", "toggling", "alloy.base.behaviour"], a2)), events: c2, behaviours: nl(o2.splitDropdownBehaviours, [$y.config({ others: { sandbox: function(t3) {
        var n3 = gl(t3, o2, "arrow");
        return rx(o2, t3, { onOpen: function() {
          Lg.on(n3), Lg.on(t3);
        }, onClose: function() {
          Lg.off(n3), Lg.off(t3);
        } });
      } } }), Fg.config({ mode: "special", onSpace: u2, onEnter: u2, onDown: function(t3) {
        return i2(t3), vt.some(true);
      } }), Hg.config({}), Lg.config({ toggleOnExecute: false, aria: { mode: "expanded" } })]), domModification: { attributes: { role: o2.role.getOr("button"), "aria-haspopup": true } } };
    }, apis: { repositionMenus: function(t2, n2) {
      return t2.repositionMenus(n2);
    } } }), T_ = Ir("focus-button"), E_ = function(t2, n2, e3) {
      return KO(t2, { toolbarButtonBehaviours: [].concat(0 < e3.length ? [mm("toolbarButtonWith", e3)] : []), getApi: GO, onSetup: t2.onSetup }, n2);
    }, D_ = function(t2, n2, e3) {
      return Yo(KO(t2, { toolbarButtonBehaviours: [Rg.config({}), Lg.config({ toggleClass: "tox-tbtn--enabled", aria: { mode: "pressed" }, toggleOnExecute: false })].concat(0 < e3.length ? [mm("toolbarToggleButtonWith", e3)] : []), getApi: XO, onSetup: t2.onSetup }, n2));
    }, B_ = [{ name: "history", items: ["undo", "redo"] }, { name: "styles", items: ["styleselect"] }, { name: "formatting", items: ["bold", "italic"] }, { name: "alignment", items: ["alignleft", "aligncenter", "alignright", "alignjustify"] }, { name: "indentation", items: ["outdent", "indent"] }, { name: "permanent pen", items: ["permanentpen"] }, { name: "comments", items: ["addcomment"] }], M_ = { button: JO(Op, function(t2, n2) {
      return e3 = n2.backstage.shared.providers, E_(t2, e3, []);
      var e3;
    }), togglebutton: JO(_p, function(t2, n2) {
      return e3 = n2.backstage.shared.providers, D_(t2, e3, []);
      var e3;
    }), menubutton: JO(rC, function(t2, n2) {
      return G0(t2, "tox-tbtn", n2.backstage, vt.none());
    }), splitbutton: JO(function(t2) {
      return ao("SplitButton", Q1, t2);
    }, function(t2, n2) {
      return o2 = t2, r2 = n2.backstage.shared, s2 = Ir("channel-update-split-dropdown-display"), l2 = Po(st), f2 = { getApi: e3, onSetup: o2.onSetup }, __.sketch({ dom: { tag: "div", classes: ["tox-split-button"], attributes: lt2({ "aria-pressed": false }, YO(o2.tooltip, r2.providers)) }, onExecute: function(t3) {
        o2.onAction(e3(t3));
      }, onItemExecute: function(t3, n3, e4) {
      }, splitDropdownBehaviours: nc([Yv(r2.providers.isDisabled), pv(), mm("split-dropdown-events", [Cr(T_, Hg.focus), vv(f2, l2), bv(f2, l2)]), vw.config({})]), eventOrder: ((i2 = {})[Gi()] = ["alloy.base.behaviour", "split-dropdown-events"], i2), toggleClass: "tox-tbtn--enabled", lazySink: r2.getSink, fetch: (u2 = e3, a2 = o2, c2 = r2.providers, function(n3) {
        return jy(function(t3) {
          return a2.fetch(t3);
        }).map(function(t3) {
          return vt.from(Xb(Yo(Ob(Ir("menu-value"), t3, function(t4) {
            a2.onItemAction(u2(n3), t4);
          }, a2.columns, a2.presets, Sh.CLOSE_ON_EXECUTE, a2.select.getOr(T), c2), { movement: _b2(a2.columns, a2.presets), menuBehaviours: Kh("auto" !== a2.columns ? [] : [ou(function(o3, t4) {
            ah(o3, 4, Jp(a2.presets)).each(function(t5) {
              var n4 = t5.numRows, e4 = t5.numColumns;
              Fg.setGridSize(o3, n4, e4);
            });
          })]) })));
        });
      }), parts: { menu: Zp(0, o2.columns, o2.presets) }, components: [__.parts.button(qO(o2.icon, o2.text, vt.none(), vt.some(s2), vt.some([Lg.config({ toggleClass: "tox-tbtn--enabled", toggleOnExecute: false })]), r2.providers)), __.parts.arrow({ dom: { tag: "button", classes: ["tox-tbtn", "tox-split-button__chevron"], innerHtml: Um("chevron-down", r2.providers.icons) }, buttonBehaviours: nc([Yv(r2.providers.isDisabled), pv(), jm()]) }), __.parts["aria-descriptor"]({ text: r2.providers.translate("To open the popup, press Shift+Enter") })] });
      function e3(e4) {
        return { isDisabled: function() {
          return gd.isDisabled(e4);
        }, setDisabled: function(t3) {
          return gd.set(e4, t3);
        }, setIconFill: function(t3, n3) {
          Iu(e4.element, 'svg path[id="' + t3 + '"], rect[id="' + t3 + '"]').each(function(t4) {
            on(t4, "fill", n3);
          });
        }, setIconStroke: function(t3, n3) {
          Iu(e4.element, 'svg path[id="' + t3 + '"], rect[id="' + t3 + '"]').each(function(t4) {
            on(t4, "stroke", n3);
          });
        }, setActive: function(n3) {
          on(e4.element, "aria-pressed", n3), Iu(e4.element, "span").each(function(t3) {
            e4.getSystem().getByDom(t3).each(function(t4) {
              return Lg.set(t4, n3);
            });
          });
        }, isActive: function() {
          return Iu(e4.element, "span").exists(function(t3) {
            return e4.getSystem().getByDom(t3).exists(Lg.isOn);
          });
        } };
      }
      var o2, r2, i2, u2, a2, c2, s2, l2, f2;
    }), grouptoolbarbutton: JO(function(t2) {
      return ao("GroupToolbarButton", K1, t2);
    }, function(t2, n2, e3) {
      var o2, r2, i2, u2, a2, c2, s2 = e3.ui.registry.getAll().buttons, l2 = ((o2 = {})[es] = n2.backstage.shared.header.isPositionedAtTop() ? Oc.TopToBottom : Oc.BottomToTop, o2);
      if (iv(e3) !== bh.floating)
        throw new Error("Toolbar groups are only supported when using floating toolbar mode");
      return i2 = n2.backstage, u2 = function(t3) {
        return F_(e3, { buttons: s2, toolbar: t3, allowToolbarGroups: false }, n2, vt.none());
      }, a2 = l2, c2 = i2.shared, bO.sketch({ lazySink: c2.getSink, fetch: function() {
        return jy(function(t3) {
          t3(M(u2(r2.items), RC));
        });
      }, markers: { toggledClass: "tox-tbtn--enabled" }, parts: { button: qO((r2 = t2).icon, r2.text, r2.tooltip, vt.none(), vt.none(), c2.providers), toolbar: { dom: { tag: "div", classes: ["tox-toolbar__overflow"], attributes: a2 } } } });
    }), styleSelectButton: function(t2, n2) {
      return KC(t2, e3 = n2.backstage, jO(t2, lt2({ type: "advanced" }, e3.styleselect)));
      var e3;
    }, fontsizeSelectButton: function(t2, n2) {
      return KC(t2, n2.backstage, LO(t2));
    }, fontSelectButton: function(t2, n2) {
      return KC(t2, n2.backstage, NO(t2));
    }, formatButton: function(t2, n2) {
      return KC(t2, n2.backstage, UO(t2));
    }, alignMenuButton: function(t2, n2) {
      return KC(t2, n2.backstage, HO(t2));
    } }, A_ = { styleselect: M_.styleSelectButton, fontsizeselect: M_.fontsizeSelectButton, fontselect: M_.fontSelectButton, formatselect: M_.formatButton, align: M_.alignMenuButton }, F_ = function(o2, c2, s2, l2) {
      var e3, t2, n2, r2, i2 = (n2 = c2.toolbar, r2 = c2.buttons, false === n2 ? [] : void 0 === n2 || true === n2 ? (e3 = r2, t2 = M(B_, function(t3) {
        var n3 = F(t3.items, function(t4) {
          return Tt(e3, t4) || Tt(A_, t4);
        });
        return { name: t3.name, items: n3 };
      }), F(t2, function(t3) {
        return 0 < t3.items.length;
      })) : y(n2) ? M(n2.split("|"), function(t3) {
        return { items: t3.trim().split(" ") };
      }) : f(n2, function(t3) {
        return Tt(t3, "name") && Tt(t3, "items");
      }) ? n2 : (console.error("Toolbar type should be string, string[], boolean or ToolbarGroup[]"), []));
      return F(M(i2, function(t3) {
        var n3 = z(t3.items, function(t4) {
          return 0 === t4.trim().length ? [] : (r3 = o2, n4 = c2.buttons, i3 = t4, u2 = c2.allowToolbarGroups, a2 = s2, e4 = l2, tt(n4, i3.toLowerCase()).orThunk(function() {
            return e4.bind(function(t5) {
              return K(t5, function(t6) {
                return tt(n4, t6 + i3.toLowerCase());
              });
            });
          }).fold(function() {
            return tt(A_, i3.toLowerCase()).map(function(t5) {
              return t5(r3, a2);
            }).orThunk(function() {
              return vt.none();
            });
          }, function(t5) {
            return "grouptoolbarbutton" !== t5.type || u2 ? (e5 = a2, o3 = r3, tt(M_, (n5 = t5).type).fold(function() {
              return console.error("skipping button defined by", n5), vt.none();
            }, function(t6) {
              return vt.some(t6(n5, e5, o3));
            })) : (console.warn("Ignoring the '" + i3 + "' toolbar button. Group toolbar buttons are only supported when using floating toolbar mode and cannot be nested."), vt.none());
            var n5, e5, o3;
          }).toArray());
          var r3, n4, i3, u2, a2, e4;
        });
        return { title: vt.from(o2.translate(t3.name)), items: n3 };
      }), function(t3) {
        return 0 < t3.items.length;
      });
    }, I_ = le(), R_ = I_.os.isiOS() && I_.os.version.major <= 12, V_ = Object.freeze({ __proto__: null, render: function(e3, n2, t2, o2, r2) {
      var i2 = Po(0), u2 = n2.outerContainer;
      RO(e3);
      var a2 = At.fromDom(r2.targetNode), c2 = tn(ge(a2)), s2 = n2.mothership;
      pf(a2, s2, Bn), Ns(c2, n2.uiMothership), e3.on("PostRender", function() {
        $O(e3, n2, t2, o2), i2.set(e3.getWin().innerWidth), FO.setMenubar(u2, NC(e3, t2)), FO.setSidebar(u2, t2.sidebar), function(e4, t3) {
          function n3() {
            var t4 = c3.get();
            t4.left === u3.innerWidth && t4.top === u3.innerHeight || (c3.set(ke(u3.innerWidth, u3.innerHeight)), Wv(e4));
          }
          function o3() {
            var t4 = e4.getDoc().documentElement, n4 = s3.get();
            n4.left === t4.offsetWidth && n4.top === t4.offsetHeight || (s3.set(ke(t4.offsetWidth, t4.offsetHeight)), Wv(e4));
          }
          function r3(t4) {
            return e4.fire("ScrollContent", t4);
          }
          var i3 = e4.dom, u3 = e4.getWin(), a3 = e4.getDoc().documentElement, c3 = Po(ke(u3.innerWidth, u3.innerHeight)), s3 = Po(ke(a3.offsetWidth, a3.offsetHeight));
          i3.bind(u3, "resize", n3), i3.bind(u3, "scroll", r3);
          var l3 = hc(At.fromDom(e4.getBody()), "load", o3), f3 = t3.uiMothership.element;
          e4.on("hide", function() {
            dn(f3, "display", "none");
          }), e4.on("show", function() {
            bn(f3, "display");
          }), e4.on("NodeChange", o3), e4.on("remove", function() {
            l3.unbind(), i3.unbind(u3, "resize", n3), i3.unbind(u3, "scroll", r3), u3 = null;
          });
        }(e3, n2);
      });
      var l2, f2, d2, m3, g2 = FO.getSocket(u2).getOrDie("Could not find expected socket element");
      R_ && (mn(g2.element, { overflow: "scroll", "-webkit-overflow-scrolling": "touch" }), f2 = function() {
        e3.fire("ScrollContent");
      }, d2 = null, m3 = function() {
        for (var t3 = [], n3 = 0; n3 < arguments.length; n3++)
          t3[n3] = arguments[n3];
        b(d2) && (d2 = setTimeout(function() {
          d2 = null, f2.apply(null, t3);
        }, 20));
      }, l2 = pc(g2.element, "scroll", m3), e3.on("remove", l2.unbind)), gv(e3, n2), e3.addCommand("ToggleSidebar", function(t3, n3) {
        FO.toggleSidebar(u2, n3), e3.fire("ToggleSidebar");
      }), e3.addQueryValueHandler("ToggleSidebar", function() {
        return FO.whichSidebar(u2);
      });
      var p2 = iv(e3);
      p2 !== bh.sliding && p2 !== bh.floating || e3.on("ResizeWindow ResizeEditor ResizeContent", function() {
        var t3 = e3.getWin().innerWidth;
        t3 !== i2.get() && (FO.refreshToolbar(n2.outerContainer), i2.set(t3));
      });
      var h2 = { enable: function() {
        mv(n2, false);
      }, disable: function() {
        mv(n2, true);
      }, isDisabled: function() {
        return gd.isDisabled(u2);
      } };
      return { iframeContainer: g2.element.dom, editorContainer: u2.element.dom, api: h2 };
    } }), P_ = Object.freeze({ __proto__: null, render: function(n2, e3, o2, r2, t2) {
      var i2 = e3.mothership, u2 = e3.uiMothership, a2 = e3.outerContainer, c2 = Po(null), s2 = At.fromDom(t2.targetNode), l2 = e_(n2, s2, e3, r2, c2), f2 = n2.getParam("toolbar_persist", false, "boolean");
      function d2() {
        var t3;
        c2.get() ? l2.show() : (c2.set(FO.getHeader(a2).getOrDie()), Ns(t3 = lv(n2), i2), Ns(t3, u2), $O(n2, e3, o2, r2), FO.setMenubar(a2, NC(n2, o2)), l2.show(), function(c3, s3, l3, t4) {
          function n3(t5) {
            var n4 = o_(s3, l3.isPositionedAtTop()), e5 = n4.pos, o3 = n4.bounds, r3 = f3.get(), i3 = r3.pos, u3 = r3.bounds, a3 = o3.height !== u3.height || o3.width !== u3.width;
            f3.set({ pos: e5, bounds: o3 }), a3 && Wv(c3, t5), l3.isVisible() && (i3 !== e5 ? l3.update(true) : a3 && (l3.updateMode(), l3.repositionPopups()));
          }
          var f3 = Po(o_(s3, l3.isPositionedAtTop()));
          t4 || (c3.on("activate", l3.show), c3.on("deactivate", l3.hide)), c3.on("SkinLoaded ResizeWindow", function() {
            return l3.update(true);
          }), c3.on("NodeChange keydown", function(t5) {
            lp.requestAnimationFrame(function() {
              return n3(t5);
            });
          }), c3.on("ScrollWindow", function() {
            return l3.updateMode();
          });
          var e4 = mc();
          e4.set(hc(At.fromDom(c3.getBody()), "load", n3)), c3.on("remove", function() {
            e4.clear();
          });
        }(n2, s2, l2, f2), n2.nodeChanged());
      }
      VO(n2), n2.on("show", d2), n2.on("hide", l2.hide), f2 || (n2.on("focus", d2), n2.on("blur", l2.hide)), n2.on("init", function() {
        (n2.hasFocus() || f2) && d2();
      }), gv(n2, e3);
      var m3 = { show: function() {
        l2.show();
      }, hide: function() {
        l2.hide();
      }, enable: function() {
        mv(e3, false);
      }, disable: function() {
        mv(e3, true);
      }, isDisabled: function() {
        return gd.isDisabled(a2);
      } };
      return { editorContainer: a2.element.dom, api: m3 };
    } }), H_ = "contexttoolbar-hide", z_ = function(t2, n2) {
      var e3, o2, r2, i2, u2 = t2.label.fold(function() {
        return {};
      }, function(t3) {
        return { "aria-label": t3 };
      }), a2 = zm(Dy.sketch({ inputClasses: ["tox-toolbar-textfield", "tox-toolbar-nav-js"], data: t2.initValue(), inputAttributes: u2, selectOnFocus: true, inputBehaviours: nc([Fg.config({ mode: "special", onEnter: function(t3) {
        return c2.findPrimary(t3).map(function(t4) {
          return yr(t4), true;
        });
      }, onLeft: function(t3, n3) {
        return n3.cut(), vt.none();
      }, onRight: function(t3, n3) {
        return n3.cut(), vt.none();
      } })]) })), c2 = (e3 = a2, o2 = t2.commands, r2 = n2, i2 = M(o2, function(t3) {
        return zm(("contextformtogglebutton" === t3.type ? function(t4, n3, e4) {
          var o3 = n3.original;
          o3.primary;
          var r3 = B(o3, ["primary"]), i3 = co(_p(lt2(lt2({}, r3), { type: "togglebutton", onAction: st })));
          return D_(i3, e4.backstage.shared.providers, [r_(t4, n3)]);
        } : function(t4, n3, e4) {
          var o3 = n3.original;
          o3.primary;
          var r3 = B(o3, ["primary"]), i3 = co(Op(lt2(lt2({}, r3), { type: "button", onAction: st })));
          return E_(i3, e4.backstage.shared.providers, [r_(t4, n3)]);
        })(e3, t3, { backstage: { shared: { providers: r2 } } }));
      }), { asSpecs: function() {
        return M(i2, function(t3) {
          return t3.asSpec();
        });
      }, findPrimary: function(e4) {
        return K(o2, function(t3, n3) {
          return t3.primary ? vt.from(i2[n3]).bind(function(t4) {
            return t4.getOpt(e4);
          }).filter(O(gd.isDisabled)) : vt.none();
        });
      } });
      return [{ title: vt.none(), items: [a2.asSpec()] }, { title: vt.none(), items: c2.asSpecs() }];
    }, N_ = { valignCentre: [], alignCentre: [], alignLeft: ["tox-pop--align-left"], alignRight: ["tox-pop--align-right"], right: ["tox-pop--right"], left: ["tox-pop--left"], bottom: ["tox-pop--bottom"], top: ["tox-pop--top"], inset: ["tox-pop--inset"] }, L_ = { maxHeightFunction: Vc(), maxWidthFunction: pO() }, W_ = Ir("forward-slide"), U_ = Ir("backward-slide"), j_ = Ir("change-slide-event"), G_ = "tox-pop--resizing", X_ = "tox-pop--transition", Y_ = { unsupportedLength: ["em", "ex", "cap", "ch", "ic", "rem", "lh", "rlh", "vw", "vh", "vi", "vb", "vmin", "vmax", "cm", "mm", "Q", "in", "pc", "pt", "px"], fixed: ["px", "pt"], relative: ["%"], empty: [""] }, q_ = (h_ = ["Infinity", (g_ = "[0-9]+") + "\\." + K_(g_) + K_(p_ = "[eE][+-]?[0-9]+"), "\\." + g_ + K_(p_), g_ + K_(p_)].join("|"), new RegExp("^([+-]?(?:" + h_ + "))(.*)$"));
    function K_(t2) {
      return "(?:" + t2 + ")?";
    }
    function J_(u2, a2) {
      function n2() {
        var t2 = a2.getOptions(u2), r2 = a2.getCurrent(u2).map(a2.hash), i2 = gc();
        return M(t2, function(o2) {
          return { type: "togglemenuitem", text: a2.display(o2), onSetup: function(n3) {
            function t3(t4) {
              t4 && (i2.on(function(t5) {
                return t5.setActive(false);
              }), i2.set(n3)), n3.setActive(t4);
            }
            t3(mt(r2, a2.hash(o2)));
            var e3 = a2.watcher(u2, o2, t3);
            return function() {
              i2.clear(), e3();
            };
          }, onAction: function() {
            return a2.setCurrent(u2, o2);
          } };
        });
      }
      u2.ui.registry.addMenuButton(a2.name, { tooltip: a2.text, icon: a2.icon, fetch: function(t2) {
        return t2(n2());
      }, onSetup: a2.onToolbarSetup }), u2.ui.registry.addNestedMenuItem(a2.name, { type: "nestedmenuitem", text: a2.text, getSubmenuItems: n2, onSetup: a2.onMenuSetup });
    }
    function $_(t2, n2) {
      return function() {
        t2.execCommand("mceToggleFormat", false, n2);
      };
    }
    function Q_(t2) {
      var n2, e3;
      !function(e4) {
        fS.each([{ name: "bold", text: "Bold", icon: "bold" }, { name: "italic", text: "Italic", icon: "italic" }, { name: "underline", text: "Underline", icon: "underline" }, { name: "strikethrough", text: "Strikethrough", icon: "strike-through" }, { name: "subscript", text: "Subscript", icon: "subscript" }, { name: "superscript", text: "Superscript", icon: "superscript" }], function(t4, n4) {
          e4.ui.registry.addToggleButton(t4.name, { tooltip: t4.text, icon: t4.icon, onSetup: jC(e4, t4.name), onAction: $_(e4, t4.name) });
        });
        for (var t3 = 1; t3 <= 6; t3++) {
          var n3 = "h" + t3;
          e4.ui.registry.addToggleButton(n3, { text: n3.toUpperCase(), tooltip: "Heading " + t3, onSetup: jC(e4, n3), onAction: $_(e4, n3) });
        }
      }(t2), n2 = t2, fS.each([{ name: "cut", text: "Cut", action: "Cut", icon: "cut" }, { name: "copy", text: "Copy", action: "Copy", icon: "copy" }, { name: "paste", text: "Paste", action: "Paste", icon: "paste" }, { name: "help", text: "Help", action: "mceHelp", icon: "help" }, { name: "selectall", text: "Select all", action: "SelectAll", icon: "select-all" }, { name: "newdocument", text: "New document", action: "mceNewDocument", icon: "new-document" }, { name: "removeformat", text: "Clear formatting", action: "RemoveFormat", icon: "remove-formatting" }, { name: "remove", text: "Remove", action: "Delete", icon: "remove" }], function(t3) {
        n2.ui.registry.addButton(t3.name, { tooltip: t3.text, icon: t3.icon, onAction: YC(n2, t3.action) });
      }), e3 = t2, fS.each([{ name: "blockquote", text: "Blockquote", action: "mceBlockQuote", icon: "quote" }], function(t3) {
        e3.ui.registry.addToggleButton(t3.name, { tooltip: t3.text, icon: t3.icon, onAction: YC(e3, t3.action), onSetup: jC(e3, t3.name) });
      });
    }
    function Z_(n2, e3) {
      return GC(n2, "Undo Redo AddUndo TypingUndo ClearUndos SwitchMode", function(t2) {
        t2.setDisabled(n2.mode.isReadOnly() || !n2.undoManager[e3]());
      });
    }
    function tT(t2) {
      var n2;
      t2.ui.registry.addButton("visualaid", { tooltip: "Visual aids", text: "Visual aids", onAction: YC(t2, "mceToggleVisualAid") }), t2.ui.registry.addToggleMenuItem("visualaid", { text: "Visual aids", onSetup: GC(n2 = t2, "VisualAid", function(t3) {
        t3.setActive(n2.hasVisual);
      }), onAction: YC(t2, "mceToggleVisualAid") });
    }
    function nT(t2, n2) {
      var e3, o2, r2, i2, u2, a2, c2, s2, l2, f2, d2, m3, g2, p2, h2, v4, b2, y2, x2, w2, S2, k2, C2, O2, _2, T2 = t2;
      St([{ name: "alignleft", text: "Align left", cmd: "JustifyLeft", icon: "align-left" }, { name: "aligncenter", text: "Align center", cmd: "JustifyCenter", icon: "align-center" }, { name: "alignright", text: "Align right", cmd: "JustifyRight", icon: "align-right" }, { name: "alignjustify", text: "Justify", cmd: "JustifyFull", icon: "align-justify" }], function(t3) {
        T2.ui.registry.addToggleButton(t3.name, { tooltip: t3.text, icon: t3.icon, onAction: YC(T2, t3.cmd), onSetup: jC(T2, t3.name) });
      }), T2.ui.registry.addButton("alignnone", { tooltip: "No alignment", icon: "align-none", onAction: YC(T2, "JustifyNone") }), Q_(O2 = t2), _2 = O2, fS.each([{ name: "bold", text: "Bold", action: "Bold", icon: "bold", shortcut: "Meta+B" }, { name: "italic", text: "Italic", action: "Italic", icon: "italic", shortcut: "Meta+I" }, { name: "underline", text: "Underline", action: "Underline", icon: "underline", shortcut: "Meta+U" }, { name: "strikethrough", text: "Strikethrough", action: "Strikethrough", icon: "strike-through", shortcut: "" }, { name: "subscript", text: "Subscript", action: "Subscript", icon: "subscript", shortcut: "" }, { name: "superscript", text: "Superscript", action: "Superscript", icon: "superscript", shortcut: "" }, { name: "removeformat", text: "Clear formatting", action: "RemoveFormat", icon: "remove-formatting", shortcut: "" }, { name: "newdocument", text: "New document", action: "mceNewDocument", icon: "new-document", shortcut: "" }, { name: "cut", text: "Cut", action: "Cut", icon: "cut", shortcut: "Meta+X" }, { name: "copy", text: "Copy", action: "Copy", icon: "copy", shortcut: "Meta+C" }, { name: "paste", text: "Paste", action: "Paste", icon: "paste", shortcut: "Meta+V" }, { name: "selectall", text: "Select all", action: "SelectAll", icon: "select-all", shortcut: "Meta+A" }], function(t3) {
        _2.ui.registry.addMenuItem(t3.name, { text: t3.text, icon: t3.icon, shortcut: t3.shortcut, onAction: YC(_2, t3.action) });
      }), _2.ui.registry.addMenuItem("codeformat", { text: "Code", icon: "sourcecode", onAction: $_(_2, "code") }), C2 = qC(0, d2 = l2 = n2, HO(f2 = s2 = t2)), f2.ui.registry.addNestedMenuItem("align", { text: d2.shared.providers.translate("Align"), getSubmenuItems: function() {
        return C2.items.validateItems(C2.getStyleItems());
      } }), p2 = qC(0, g2 = l2, NO(m3 = s2)), m3.ui.registry.addNestedMenuItem("fontformats", { text: g2.shared.providers.translate("Fonts"), getSubmenuItems: function() {
        return p2.items.validateItems(p2.getStyleItems());
      } }), h2 = s2, b2 = lt2({ type: "advanced" }, (v4 = l2).styleselect), y2 = qC(0, v4, jO(h2, b2)), h2.ui.registry.addNestedMenuItem("formats", { text: "Formats", getSubmenuItems: function() {
        return y2.items.validateItems(y2.getStyleItems());
      } }), w2 = qC(0, l2, UO(x2 = s2)), x2.ui.registry.addNestedMenuItem("blockformats", { text: "Blocks", getSubmenuItems: function() {
        return w2.items.validateItems(w2.getStyleItems());
      } }), k2 = qC(0, l2, LO(S2 = s2)), S2.ui.registry.addNestedMenuItem("fontsizes", { text: "Font sizes", getSubmenuItems: function() {
        return k2.items.validateItems(k2.getStyleItems());
      } }), (a2 = u2 = t2).ui.registry.addMenuItem("undo", { text: "Undo", icon: "undo", shortcut: "Meta+Z", onSetup: Z_(a2, "hasUndo"), onAction: YC(a2, "undo") }), a2.ui.registry.addMenuItem("redo", { text: "Redo", icon: "redo", shortcut: "Meta+Y", onSetup: Z_(a2, "hasRedo"), onAction: YC(a2, "redo") }), (c2 = u2).ui.registry.addButton("undo", { tooltip: "Undo", icon: "undo", disabled: true, onSetup: Z_(c2, "hasUndo"), onAction: YC(c2, "undo") }), c2.ui.registry.addButton("redo", { tooltip: "Redo", icon: "redo", disabled: true, onSetup: Z_(c2, "hasRedo"), onAction: YC(c2, "redo") }), function(t3) {
        var i3;
        (i3 = t3).addCommand("mceApplyTextcolor", function(t4, n4) {
          var e5, o3 = t4, r3 = n4;
          (e5 = i3).undoManager.transact(function() {
            e5.focus(), e5.formatter.apply(o3, { value: r3 }), e5.nodeChanged();
          });
        }), i3.addCommand("mceRemoveTextcolor", function(t4) {
          var n4, e5 = t4;
          (n4 = i3).undoManager.transact(function() {
            n4.focus(), n4.formatter.remove(e5, { value: null }, null, true), n4.nodeChanged();
          });
        });
        var n3 = Po(Fb), e4 = Po(Fb);
        kb(t3, "forecolor", "forecolor", "Text color", n3), kb(t3, "backcolor", "hilitecolor", "Background color", e4), Cb(t3, "forecolor", "forecolor", "Text color"), Cb(t3, "backcolor", "hilitecolor", "Background color");
      }(t2), tT(t2), (r2 = t2).ui.registry.addButton("outdent", { tooltip: "Decrease indent", icon: "outdent", onSetup: GC(i2 = r2, "NodeChange", function(t3) {
        t3.setDisabled(!i2.queryCommandState("outdent"));
      }), onAction: YC(r2, "outdent") }), r2.ui.registry.addButton("indent", { tooltip: "Increase indent", icon: "indent", onAction: YC(r2, "indent") }), J_(e3 = t2, NT), o2 = e3, vt.from(o2.getParam("content_langs", void 0, "array")).map(function(t3) {
        return { name: "language", text: "Language", icon: "language", getOptions: rt2(t3), hash: function(t4) {
          return E(t4.customCode) ? t4.code : t4.code + "/" + t4.customCode;
        }, display: function(t4) {
          return t4.title;
        }, watcher: function(t4, n3, e4) {
          return t4.formatter.formatChanged("lang", e4, false, { value: n3.code, customValue: n3.customCode }).unbind;
        }, getCurrent: function(t4) {
          return mr(At.fromDom(t4.selection.getNode()), function(t5) {
            return vt.some(t5).filter(Xn).bind(function(n3) {
              return an(n3, "lang").map(function(t6) {
                return { code: t6, customCode: an(n3, "data-mce-lang").getOrUndefined(), title: "" };
              });
            });
          });
        }, setCurrent: function(t4, n3) {
          return t4.execCommand("Lang", false, n3);
        }, onToolbarSetup: function(t4) {
          var n3 = mc();
          return t4.setActive(o2.formatter.match("lang", {}, void 0, true)), n3.set(o2.formatter.formatChanged("lang", t4.setActive, true)), n3.clear;
        } };
      }).each(function(t3) {
        return J_(e3, t3);
      });
    }
    function eT(t2, n2) {
      return { type: "makeshift", x: t2, y: n2 };
    }
    function oT(t2) {
      return "longpress" === t2.type || 0 === t2.type.indexOf("touch");
    }
    function rT(t2, n2) {
      return "contextmenu" === n2.type || "longpress" === n2.type ? t2.inline ? function(t3) {
        if (oT(t3)) {
          var n3 = t3.touches[0];
          return eT(n3.pageX, n3.pageY);
        }
        return eT(t3.pageX, t3.pageY);
      }(n2) : (e3 = t2.getContentAreaContainer(), o2 = function(t3) {
        if (oT(t3)) {
          var n3 = t3.touches[0];
          return eT(n3.clientX, n3.clientY);
        }
        return eT(t3.clientX, t3.clientY);
      }(n2), r2 = ev.DOM.getPos(e3), i2 = r2.x, u2 = r2.y, eT(o2.x + i2, o2.y + u2)) : LT(t2);
      var e3, o2, r2, i2, u2;
    }
    function iT(t2, n2, e3) {
      switch (e3) {
        case "node":
          return { type: "node", node: vt.some(At.fromDom((o2 = t2).selection.getNode())), root: At.fromDom(o2.getBody()) };
        case "point":
          return rT(t2, n2);
        case "selection":
          return LT(t2);
      }
      var o2;
    }
    function uT(f2, d2, m3, g2, p2, h2) {
      function t2() {
        var n3, e4, t3, o2, r2, i2, u2, a2, c2, s2, l2 = m3();
        t3 = l2, o2 = g2, r2 = p2, u2 = !(y2 || v4 || b2 && x2), c2 = iT(n3 = f2, e4 = d2, a2 = i2 = h2), s2 = lt2({ bubble: Sc(0, "point" === a2 ? 12 : 0, UT), layouts: WT, overrides: { maxWidthFunction: pO(), maxHeightFunction: Vc() } }, c2), U0(t3, Sh.CLOSE_ON_EXECUTE, o2, true).map(function(t4) {
          e4.preventDefault(), up.showMenuWithinBounds(r2, { anchor: s2 }, { menu: { markers: Qp("normal"), highlightImmediately: u2 }, data: t4, type: "horizontal" }, function() {
            return vt.some(a_(n3, o2.shared, "node" === i2 ? "node" : "selection"));
          }), n3.fire(H_);
        });
      }
      var n2, e3 = le(), v4 = e3.os.isiOS(), b2 = e3.os.isOSX(), y2 = e3.os.isAndroid(), x2 = e3.deviceType.isTouch();
      (b2 || v4) && "node" !== h2 ? (n2 = function() {
        (function(t3) {
          function n3() {
            lp.setEditorTimeout(t3, function() {
              t3.selection.setRng(e4);
            }, 10), i2();
          }
          var e4 = t3.selection.getRng();
          function o2(t4) {
            t4.preventDefault(), t4.stopImmediatePropagation();
          }
          function r2() {
            return i2();
          }
          t3.once("touchend", n3), t3.on("mousedown", o2, true), t3.once("longpresscancel", r2);
          var i2 = function() {
            t3.off("touchend", n3), t3.off("longpresscancel", r2), t3.off("mousedown", o2);
          };
        })(f2), t2();
      }, function(t3, n3) {
        var e4 = t3.selection;
        if (!(e4.isCollapsed() || n3.touches.length < 1)) {
          var o2 = n3.touches[0], r2 = e4.getRng();
          return xs(t3.getWin(), ms.domRange(r2)).exists(function(t4) {
            return t4.left <= o2.clientX && t4.right >= o2.clientX && t4.top <= o2.clientY && t4.bottom >= o2.clientY;
          });
        }
      }(f2, d2) ? n2() : (f2.once("selectionchange", n2), f2.once("touchend", function() {
        return f2.off("selectionchange", n2);
      }))) : t2();
    }
    function aT(t2) {
      return "string" == typeof t2 ? t2.split(/[ ,]/) : t2;
    }
    function cT(t2) {
      return t2.getParam("contextmenu_never_use_native", false, "boolean");
    }
    function sT(t2) {
      return y(t2) ? "|" === t2 : "separator" === t2.type;
    }
    function lT(t2, n2) {
      if (0 === n2.length)
        return t2;
      var e3 = q(t2).filter(function(t3) {
        return !sT(t3);
      }).fold(function() {
        return [];
      }, function(t3) {
        return [jT];
      });
      return t2.concat(e3).concat(n2).concat([jT]);
    }
    function fT(t2, n2) {
      return "longpress" !== n2.type && (2 !== n2.button || n2.target === t2.getBody() && "" === n2.pointerType);
    }
    function dT(t2, n2) {
      return fT(t2, n2) ? t2.selection.getStart(true) : n2.target;
    }
    function mT(s2, t2, n2) {
      function e3(t3) {
        return up.hide(i2);
      }
      function o2(c2) {
        var t3;
        cT(s2) && c2.preventDefault(), c2.ctrlKey && !cT(s2) || false === s2.getParam("contextmenu") || (t3 = function(t4, n3) {
          var e4 = t4.getParam("contextmenu_avoid_overlap", "", "string"), o3 = fT(t4, n3) ? "selection" : "point";
          if (at(e4)) {
            var r3 = dT(t4, n3);
            return Yb(At.fromDom(r3), e4) ? "node" : o3;
          }
          return o3;
        }(s2, c2), (r2() ? uT : function(t4, n3, e4, o3, r3, i3) {
          var u2 = e4(), a2 = iT(t4, n3, i3);
          U0(u2, Sh.CLOSE_ON_EXECUTE, o3, false).map(function(t5) {
            n3.preventDefault(), up.showMenuAt(r3, { anchor: a2 }, { menu: { markers: Qp("normal") }, data: t5 });
          });
        })(s2, c2, function() {
          var t4, n3, e4, o3 = dT(s2, c2), r3 = s2.ui.registry.getAll(), i3 = (e4 = (n3 = s2).ui.registry.getAll().contextMenus, vt.from(n3.getParam("contextmenu")).map(aT).getOrThunk(function() {
            return F(aT("link linkchecker image imagetools table spellchecker configurepermanentpen"), function(t5) {
              return Tt(e4, t5);
            });
          })), u2 = r3.contextMenus, a2 = o3;
          return 0 < (t4 = R(i3, function(o4, t5) {
            return tt(u2, t5.toLowerCase()).map(function(t6) {
              var n4 = t6.update(a2);
              if (y(n4))
                return lT(o4, n4.split(" "));
              if (0 < n4.length) {
                var e5 = M(n4, GT);
                return lT(o4, e5);
              }
              return o4;
            }).getOrThunk(function() {
              return o4.concat([t5]);
            });
          }, [])).length && sT(t4[t4.length - 1]) && t4.pop(), t4;
        }, n2, i2, t3));
      }
      var r2 = le().deviceType.isTouch, i2 = Tu(up.sketch({ dom: { tag: "div" }, lazySink: t2, onEscape: function() {
        return s2.focus();
      }, onShow: function() {
        return n2.setContextMenuState(true);
      }, onHide: function() {
        return n2.setContextMenuState(false);
      }, fireDismissalEventInstead: {}, inlineBehaviours: nc([mm("dismissContextMenu", [Cr(Yi(), function(t3, n3) {
        bf.close(t3), s2.focus();
      })])]) }));
      s2.on("init", function() {
        var t3 = "ResizeEditor ScrollContent ScrollWindow longpresscancel" + (r2() ? "" : " ResizeWindow");
        s2.on(t3, e3), s2.on("longpress contextmenu", o2);
      });
    }
    function gT(n2) {
      return function(t2) {
        return t2.translate(-n2.left, -n2.top);
      };
    }
    function pT(n2) {
      return function(t2) {
        return t2.translate(n2.left, n2.top);
      };
    }
    function hT(e3) {
      return function(t2, n2) {
        return R(e3, function(t3, n3) {
          return n3(t3);
        }, ke(t2, n2));
      };
    }
    function vT(t2, n2, e3) {
      return t2.fold(hT([pT(e3), gT(n2)]), hT([gT(n2)]), hT([]));
    }
    function bT(t2, n2, e3) {
      return t2.fold(hT([pT(e3)]), hT([]), hT([pT(n2)]));
    }
    function yT(t2, n2, e3) {
      return t2.fold(hT([]), hT([gT(e3)]), hT([pT(n2), gT(e3)]));
    }
    function xT(t2, n2, e3) {
      var o2 = t2.fold(function(t3, n3) {
        return { position: vt.some("absolute"), left: vt.some(t3 + "px"), top: vt.some(n3 + "px") };
      }, function(t3, n3) {
        return { position: vt.some("absolute"), left: vt.some(t3 - e3.left + "px"), top: vt.some(n3 - e3.top + "px") };
      }, function(t3, n3) {
        return { position: vt.some("fixed"), left: vt.some(t3 + "px"), top: vt.some(n3 + "px") };
      });
      return lt2({ right: vt.none(), bottom: vt.none() }, o2);
    }
    function wT(t2, i2, u2, a2) {
      function n2(o2, r2) {
        return function(t3, n3) {
          var e3 = o2(i2, u2, a2);
          return r2(t3.getOr(e3.left), n3.getOr(e3.top));
        };
      }
      return t2.fold(n2(yT, YT), n2(bT, qT), n2(vT, KT));
    }
    function ST(t2, n2) {
      var e3 = un(t2, n2);
      return E(e3) ? NaN : parseInt(e3, 10);
    }
    function kT(t2, n2, e3, o2, r2, i2) {
      var u2, a2, c2, s2, l2, f2, d2 = (u2 = e3, a2 = o2, l2 = ST(s2 = t2.element, (c2 = n2).leftAttr), f2 = ST(s2, c2.topAttr), (isNaN(l2) || isNaN(f2) ? vt.none() : vt.some(ke(l2, f2))).fold(function() {
        return u2;
      }, function(t3) {
        return KT(t3.left + a2.left, t3.top + a2.top);
      })), m3 = (n2.mustSnap ? JT : $T)(t2, n2, d2, r2, i2), g2 = vT(d2, r2, i2), p2 = n2, h2 = g2, v4 = t2.element;
      return on(v4, p2.leftAttr, h2.left + "px"), on(v4, p2.topAttr, h2.top + "px"), m3.fold(function() {
        return { coord: KT(g2.left, g2.top), extra: vt.none() };
      }, function(t3) {
        return { coord: t3.output, extra: t3.extra };
      });
    }
    function CT(t2, c2, s2, l2) {
      return K(t2, function(t3) {
        var n2, e3, o2 = t3.sensor, r2 = t3.range.left, i2 = t3.range.top, u2 = bT(c2, n2 = s2, e3 = l2), a2 = bT(o2, n2, e3);
        return Math.abs(u2.left - a2.left) <= r2 && Math.abs(u2.top - a2.top) <= i2 ? vt.some({ output: wT(t3.output, c2, s2, l2), extra: t3.extra }) : vt.none();
      });
    }
    function OT(t2, n2) {
      var e3;
      t2.getSystem().addToGui(n2), Yt((e3 = n2).element).filter(Xn).each(function(n3) {
        hn(n3, "z-index").each(function(t3) {
          on(n3, ZT, t3);
        }), dn(n3, "z-index", pn(e3.element, "z-index"));
      });
    }
    function _T(t2) {
      Yt(t2.element).filter(Xn).each(function(n2) {
        an(n2, ZT).fold(function() {
          return bn(n2, "z-index");
        }, function(t3) {
          return dn(n2, "z-index", t3);
        }), sn(n2, ZT);
      }), t2.getSystem().removeFromGui(t2);
    }
    function TT(t2, n2, e3) {
      return t2.getSystem().build(ly.sketch({ dom: { styles: { left: "0px", top: "0px", width: "100%", height: "100%", position: "fixed", "z-index": "1000000000000000" }, classes: [n2] }, events: e3 }));
    }
    function ET(t2, n2) {
      return { bounds: t2.getBounds(), height: Sn(n2.element), width: _n(n2.element) };
    }
    function DT(B2, M2, t2, n2, e3) {
      var o2 = t2.update(n2, e3), A2 = t2.getStartData().getOrThunk(function() {
        return ET(M2, B2);
      });
      o2.each(function(t3) {
        var n3, e4, o3, r2, i2, u2, a2, c2, s2, l2, f2, d2, m3, g2, p2, h2, v4, b2, y2, x2, w2, S2, k2, C2, O2, _2 = B2, T2 = A2, E2 = t3, D2 = (n3 = M2).getTarget(_2.element);
        n3.repositionTarget && (e4 = Rn(Ut(_2.element)), o3 = Wk(D2), S2 = hn(w2 = D2, "left"), k2 = hn(w2, "top"), C2 = hn(w2, "position"), O2 = function(t4, n4, e5) {
          return ("fixed" === e5 ? KT : YT)(parseInt(t4, 10), parseInt(n4, 10));
        }, r2 = (S2.isSome() && k2.isSome() && C2.isSome() ? vt.some(O2(S2.getOrDie(), k2.getOrDie(), C2.getOrDie())) : vt.none()).getOrThunk(function() {
          var t4 = Cn(w2);
          return qT(t4.left, t4.top);
        }), i2 = _2, u2 = n3.snaps, a2 = r2, c2 = e4, s2 = o3, l2 = E2, f2 = T2, m3 = u2.fold(function() {
          var e5, o4, t4 = vT((e5 = l2.left, o4 = l2.top, a2.fold(function(t5, n4) {
            return YT(t5 + e5, n4 + o4);
          }, function(t5, n4) {
            return qT(t5 + e5, n4 + o4);
          }, function(t5, n4) {
            return KT(t5 + e5, n4 + o4);
          })), c2, s2);
          return KT(t4.left, t4.top);
        }, function(n4) {
          var t4 = kT(i2, n4, a2, l2, c2, s2);
          return t4.extra.each(function(t5) {
            n4.onSensor(i2, t5);
          }), t4.coord;
        }), g2 = c2, p2 = s2, h2 = (d2 = f2).bounds, v4 = bT(m3, g2, p2), b2 = ja(v4.left, h2.x, h2.x + h2.width - d2.width), y2 = ja(v4.top, h2.y, h2.y + h2.height - d2.height), x2 = qT(b2, y2), gn(D2, xT(m3.fold(function() {
          var t4 = yT(x2, g2, p2);
          return YT(t4.left, t4.top);
        }, rt2(x2), function() {
          var t4 = vT(x2, g2, p2);
          return KT(t4.left, t4.top);
        }), 0, o3))), n3.onDrag(_2, D2, E2);
      });
    }
    function BT(o2, t2, n2, e3) {
      t2.each(_T), n2.snaps.each(function(t3) {
        var n3, e4;
        n3 = t3, sn(e4 = o2.element, n3.leftAttr), sn(e4, n3.topAttr);
      });
      var r2 = n2.getTarget(o2.element);
      e3.reset(), n2.onDrop(o2, r2);
    }
    function MT(t2) {
      return function(n2, e3) {
        function o2(t3) {
          e3.setStartData(ET(n2, t3));
        }
        return eu(H([Cr(Ui(), function(t3) {
          e3.getStartData().each(function() {
            return o2(t3);
          });
        })], t2(n2, e3, o2), true));
      };
    }
    function AT(a2, c2, s2) {
      return [Cr(mi(), function(n2, t2) {
        var e3, o2, r2, i2, u2;
        0 === t2.event.raw.button && (t2.stop(), r2 = { drop: e3 = function() {
          return BT(n2, vt.some(i2), a2, c2);
        }, delayDrop: (o2 = qb(e3, 200)).schedule, forceDrop: e3, move: function(t3) {
          o2.cancel(), DT(n2, a2, c2, eE, t3);
        } }, i2 = TT(n2, a2.blockerClass, (u2 = r2, eu([Cr(mi(), u2.forceDrop), Cr(hi(), u2.drop), Cr(gi(), function(t3, n3) {
          u2.move(n3.event);
        }), Cr(pi(), u2.delayDrop)]))), s2(n2), OT(n2, i2));
      })];
    }
    function FT(a2, c2, s2) {
      function l2(t2) {
        BT(t2, f2.get(), a2, c2), f2.clear();
      }
      var f2 = gc();
      return [Cr(si(), function(n2, t2) {
        function e3() {
          return l2(n2);
        }
        t2.stop();
        var o2, r2, i2, u2 = TT(n2, a2.blockerClass, (r2 = o2 = e3, i2 = function(t3) {
          DT(n2, a2, c2, rE, t3);
        }, eu([Cr(si(), r2), Cr(fi(), o2), Cr(di(), o2), Cr(li(), function(t3, n3) {
          i2(n3.event);
        })])));
        f2.set(u2), s2(n2), OT(n2, u2);
      }), Cr(li(), function(t2, n2) {
        n2.stop(), DT(t2, a2, c2, rE, n2.event);
      }), Cr(fi(), function(t2, n2) {
        n2.stop(), l2(t2);
      }), Cr(di(), l2)];
    }
    function IT(t2, r2, i2, u2, n2, e3) {
      return t2.fold(function() {
        return aE.snap({ sensor: qT(i2 - 20, u2 - 20), range: ke(n2, e3), output: qT(vt.some(i2), vt.some(u2)), extra: { td: r2 } });
      }, function(t3) {
        var n3 = i2 - 20, e4 = u2 - 20, o2 = t3.element.dom.getBoundingClientRect();
        return aE.snap({ sensor: qT(n3, e4), range: ke(40, 40), output: qT(vt.some(i2 - o2.width / 2), vt.some(u2 - o2.height / 2)), extra: { td: r2 } });
      });
    }
    function RT(t2, i2, u2) {
      return { getSnapPoints: t2, leftAttr: "data-drag-left", topAttr: "data-drag-top", onSensor: function(t3, n2) {
        var e3 = n2.td, o2 = i2.get(), r2 = e3;
        o2.exists(function(t4) {
          return Lt(t4, r2);
        }) || (i2.set(e3), u2(e3));
      }, mustSnap: true };
    }
    function VT(t2) {
      return zm(fp.sketch({ dom: { tag: "div", classes: ["tox-selector"] }, buttonBehaviours: nc([aE.config({ mode: "mouseOrTouch", blockerClass: "blocker", snaps: t2 }), vw.config({})]), eventOrder: { mousedown: ["dragging", "alloy.base.behaviour"], touchstart: ["dragging", "alloy.base.behaviour"] } }));
    }
    function PT(a2, e3) {
      function n2(t3) {
        var n3 = Nn(t3);
        return IT(g2.getOpt(e3), t3, n3.x, n3.y, n3.width, n3.height);
      }
      function o2(t3) {
        var n3 = Nn(t3);
        return IT(p2.getOpt(e3), t3, n3.right, n3.bottom, n3.width, n3.height);
      }
      function r2(t3, i3, n3, u3) {
        var e4 = n3(i3);
        aE.snapTo(t3, e4), function(t4) {
          var n4 = i3.dom.getBoundingClientRect();
          bn(t4.element, "display");
          var e5 = Xt(At.fromDom(a2.getBody())).dom.innerHeight, o3 = n4[u3] < 0, r3 = n4[u3] > e5;
          (o3 || r3) && dn(t4.element, "display", "none");
        }(t3);
      }
      function i2(t3) {
        return r2(h2, t3, n2, "top");
      }
      function u2(t3) {
        return r2(v4, t3, o2, "bottom");
      }
      var c2 = Po([]), s2 = Po([]), t2 = Po(false), l2 = gc(), f2 = gc(), d2 = RT(function() {
        return M(c2.get(), n2);
      }, l2, function(n3) {
        f2.get().each(function(t3) {
          a2.fire("TableSelectorChange", { start: n3, finish: t3 });
        });
      }), m3 = RT(function() {
        return M(s2.get(), o2);
      }, f2, function(n3) {
        l2.get().each(function(t3) {
          a2.fire("TableSelectorChange", { start: t3, finish: n3 });
        });
      }), g2 = VT(d2), p2 = VT(m3), h2 = Tu(g2.asSpec()), v4 = Tu(p2.asSpec());
      le().deviceType.isTouch() && (a2.on("TableSelectionChange", function(n3) {
        t2.get() || (Vs(e3, h2), Vs(e3, v4), t2.set(true)), l2.set(n3.start), f2.set(n3.finish), n3.otherCells.each(function(t3) {
          c2.set(t3.upOrLeftCells), s2.set(t3.downOrRightCells), i2(n3.start), u2(n3.finish);
        });
      }), a2.on("ResizeEditor ResizeWindow ScrollContent", function() {
        l2.get().each(i2), f2.get().each(u2);
      }), a2.on("TableSelectionClear", function() {
        t2.get() && (Hs(h2), Hs(v4), t2.set(false)), l2.clear(), f2.clear();
      }));
    }
    var HT, zT, NT = { name: "lineheight", text: "Line height", icon: "line-height", getOptions: function(t2) {
      return t2.getParam("lineheight_formats", "1 1.1 1.2 1.3 1.4 1.5 2", "string").split(" ");
    }, hash: function(t2) {
      return r2 = ["fixed", "relative", "empty"], vt.from(q_.exec(t2)).bind(function(t3) {
        var n2 = Number(t3[1]), e3 = t3[2], o2 = e3;
        return d(r2, function(t4) {
          return d(Y_[t4], function(t5) {
            return o2 === t5;
          });
        }) ? vt.some({ value: n2, unit: e3 }) : vt.none();
      }).map(function(t3) {
        return t3.value + t3.unit;
      }).getOr(t2);
      var r2;
    }, display: h, watcher: function(t2, n2, e3) {
      return t2.formatter.formatChanged("lineheight", e3, false, { value: n2 }).unbind;
    }, getCurrent: function(t2) {
      return vt.from(t2.queryCommandValue("LineHeight"));
    }, setCurrent: function(t2, n2) {
      return t2.execCommand("LineHeight", false, n2);
    } }, LT = function(t2) {
      return { type: "selection", root: At.fromDom(t2.selection.getNode()) };
    }, WT = { onLtr: function() {
      return [$a, Xa, Ya, qa, Ka, Ja, cp, sp, Am, Bm, Mm, Dm];
    }, onRtl: function() {
      return [$a, Ya, Xa, Ka, qa, Ja, cp, sp, Mm, Dm, Am, Bm];
    } }, UT = { valignCentre: [], alignCentre: [], alignLeft: ["tox-pop--align-left"], alignRight: ["tox-pop--align-right"], right: ["tox-pop--right"], left: ["tox-pop--left"], bottom: ["tox-pop--bottom"], top: ["tox-pop--top"] }, jT = { type: "separator" }, GT = function(n2) {
      function t2(t3) {
        return { text: t3.text, icon: t3.icon, disabled: t3.disabled, shortcut: t3.shortcut };
      }
      var e3;
      if (y(n2))
        return n2;
      switch (n2.type) {
        case "separator":
          return jT;
        case "submenu":
          return lt2(lt2({ type: "nestedmenuitem" }, t2(n2)), { getSubmenuItems: function() {
            var t3 = n2.getSubmenuItems();
            return y(t3) ? t3 : M(t3, GT);
          } });
        default:
          return lt2(lt2({ type: "menuitem" }, t2(n2)), { onAction: (e3 = n2.onAction, function() {
            return e3();
          }) });
      }
    }, XT = Ho([{ offset: ["x", "y"] }, { absolute: ["x", "y"] }, { fixed: ["x", "y"] }]), YT = XT.offset, qT = XT.absolute, KT = XT.fixed, JT = function(t2, n2, l2, f2, d2) {
      var e3 = n2.getSnapPoints(t2);
      return CT(e3, l2, f2, d2).orThunk(function() {
        return R(e3, function(n3, e4) {
          var t3, o2, r2, i2, u2, a2, c2, s2 = (t3 = e4.sensor, e4.range.left, e4.range.top, i2 = bT(l2, o2 = f2, r2 = d2), u2 = bT(t3, o2, r2), a2 = Math.abs(i2.left - u2.left), c2 = Math.abs(i2.top - u2.top), ke(a2, c2));
          return n3.deltas.fold(function() {
            return { deltas: vt.some(s2), snap: vt.some(e4) };
          }, function(t4) {
            return (s2.left + s2.top) / 2 <= (t4.left + t4.top) / 2 ? { deltas: vt.some(s2), snap: vt.some(e4) } : n3;
          });
        }, { deltas: vt.none(), snap: vt.none() }).snap.map(function(t3) {
          return { output: wT(t3.output, l2, f2, d2), extra: t3.extra };
        });
      });
    }, $T = function(t2, n2, e3, o2, r2) {
      return CT(n2.getSnapPoints(t2), e3, o2, r2);
    }, QT = Object.freeze({ __proto__: null, snapTo: function(t2, n2, e3, o2) {
      var r2, i2, u2, a2 = n2.getTarget(t2.element);
      n2.repositionTarget && (r2 = Rn(Ut(t2.element)), i2 = Wk(a2), gn(a2, xT({ coord: wT((u2 = o2).output, u2.output, r2, i2), extra: u2.extra }.coord, 0, i2)));
    } }), ZT = "data-initial-z-index", tE = To("snaps", [mo("getSnapPoints"), Ju("onSensor"), mo("leftAttr"), mo("topAttr"), Eo("lazyViewport", Fe), Eo("mustSnap", false)]), nE = [Eo("useFixed", T), mo("blockerClass"), Eo("getTarget", h), Eo("onDrag", st), Eo("repositionTarget", true), Eo("onDrop", st), Io("getBounds", Fe), tE], eE = Object.freeze({ __proto__: null, getData: function(t2) {
      return vt.from(ke(t2.x, t2.y));
    }, getDelta: function(t2, n2) {
      return ke(n2.left - t2.left, n2.top - t2.top);
    } }), oE = H(H([], nE, true), [ta("dragger", { handlers: MT(AT) })], false), rE = Object.freeze({ __proto__: null, getData: function(t2) {
      var n2, e3 = t2.raw.touches;
      return 1 === e3.length ? (n2 = e3[0], vt.some(ke(n2.clientX, n2.clientY))) : vt.none();
    }, getDelta: function(t2, n2) {
      return ke(n2.left - t2.left, n2.top - t2.top);
    } }), iE = H(H([], nE, true), [ta("dragger", { handlers: MT(FT) })], false), uE = H(H([], nE, true), [ta("dragger", { handlers: MT(function(t2, n2, e3) {
      return H(H([], AT(t2, n2, e3), true), FT(t2, n2, e3), true);
    }) })], false), aE = wa({ branchKey: "mode", branches: Object.freeze({ __proto__: null, mouse: oE, touch: iE, mouseOrTouch: uE }), name: "dragging", active: { events: function(t2, n2) {
      return t2.dragger.handlers(t2, n2);
    } }, extra: { snap: function(t2) {
      return { sensor: t2.sensor, range: t2.range, output: t2.output, extra: vt.from(t2.extra) };
    } }, state: Object.freeze({ __proto__: null, init: function() {
      var i2 = vt.none(), n2 = vt.none(), t2 = rt2({});
      return wu({ readState: t2, reset: function() {
        i2 = vt.none(), n2 = vt.none();
      }, update: function(r2, t3) {
        return r2.getData(t3).bind(function(t4) {
          return n3 = r2, e3 = t4, o2 = i2.map(function(t5) {
            return n3.getDelta(t5, e3);
          }), i2 = vt.some(e3), o2;
          var n3, e3, o2;
        });
      }, getStartData: function() {
        return n2;
      }, setStartData: function(t3) {
        n2 = vt.some(t3);
      } });
    } }), apis: QT });
    function cE(t2, n2, e3) {
      var o2, r2, i2, u2, a2, c2, s2 = At.fromDom(t2.getContainer());
      J((o2 = t2, r2 = n2, i2 = e3, u2 = wn(s2), a2 = On(s2), (c2 = {}).height = t_(u2 + r2.top, dh(o2), gh(o2)), i2 === HT.Both && (c2.width = t_(a2 + r2.left, fh(o2), mh(o2))), c2), function(t3, n3) {
        return dn(s2, n3, ZO(t3)), 0;
      }), t2.fire("ResizeEditor");
    }
    function sE(t2, n2, e3, o2) {
      return cE(t2, ke(20 * e3, 20 * o2), n2), vt.some(true);
    }
    function lE(t2, n2) {
      var e3, o2, r2, i2, u2, a2, c2, s2, l2, f2, d2, m3, g2, p2, h2, v4;
      return { dom: { tag: "div", classes: ["tox-statusbar"] }, components: (v4 = [], t2.getParam("elementpath", true, "boolean") && v4.push((g2 = t2, h2 = n2, (p2 = {}).delimiter || (p2.delimiter = "»"), { dom: { tag: "div", classes: ["tox-statusbar__path"], attributes: { role: "navigation" } }, behaviours: nc([Fg.config({ mode: "flow", selector: "div[role=button]" }), gd.config({ disabled: h2.isDisabled }), pv(), py.config({}), Rg.config({}), mm("elementPathEvents", [ou(function(r3, t3) {
        g2.shortcuts.add("alt+F11", "focus statusbar elementpath", function() {
          return Fg.focusIn(r3);
        }), g2.on("NodeChange", function(t4) {
          var n3, o3, e4 = function(t5) {
            for (var n4 = [], e5 = t5.length; 0 < e5--; ) {
              var o4 = t5[e5];
              if (1 === o4.nodeType && !function(t6) {
                if (1 === t6.nodeType) {
                  if ("BR" === t6.nodeName || t6.getAttribute("data-mce-bogus"))
                    return 1;
                  if ("bookmark" === t6.getAttribute("data-mce-type"))
                    return 1;
                }
              }(o4)) {
                var r4 = g2.fire("ResolveName", { name: o4.nodeName.toLowerCase(), target: o4 });
                if (r4.isDefaultPrevented() || n4.push({ name: r4.name, element: o4 }), r4.isPropagationStopped())
                  break;
              }
            }
            return n4;
          }(t4.parents);
          0 < e4.length ? Rg.set(r3, (n3 = M(e4 || [], function(n4, t5) {
            return fp.sketch({ dom: { tag: "div", classes: ["tox-statusbar__path-item"], attributes: { role: "button", "data-index": t5, "tab-index": -1, "aria-level": t5 + 1 }, innerHtml: n4.name }, action: function(t6) {
              g2.focus(), g2.selection.select(n4.element), g2.nodeChanged();
            }, buttonBehaviours: nc([$v(h2.isDisabled), pv()]) });
          }), o3 = { dom: { tag: "div", classes: ["tox-statusbar__path-divider"], attributes: { "aria-hidden": true }, innerHtml: " " + p2.delimiter + " " } }, R(n3.slice(1), function(t5, n4) {
            var e5 = t5;
            return e5.push(o3), e5.push(n4), e5;
          }, [n3[0]]))) : Rg.set(r3, []);
        });
      })])]), components: [] })), t2.hasPlugin("wordcount") && v4.push((f2 = t2, d2 = n2, fp.sketch({ dom: { tag: "button", classes: ["tox-statusbar__wordcount"] }, components: [], buttonBehaviours: nc([$v(d2.isDisabled), pv(), py.config({}), Rg.config({}), Df.config({ store: { mode: "memory", initialValue: { mode: "words", count: { words: 0, characters: 0 } } } }), mm("wordcount-events", [uu(function(t3) {
        var n3 = Df.getValue(t3), e4 = "words" === n3.mode ? "characters" : "words";
        Df.setValue(t3, { mode: e4, count: n3.count }), b2(t3, n3.count, e4);
      }), ou(function(e4) {
        f2.on("wordCountUpdate", function(t3) {
          var n3 = Df.getValue(e4).mode;
          Df.setValue(e4, { mode: n3, count: t3.wordCount }), b2(e4, t3.wordCount, n3);
        });
      })])]), eventOrder: ((m3 = {})[Ii()] = ["disabling", "alloy.base.behaviour", "wordcount-events"], m3) }))), t2.getParam("branding", true, "boolean") && v4.push({ dom: { tag: "span", classes: ["tox-statusbar__branding"], innerHtml: '<a href="https://www.tiny.cloud/?utm_campaign=editor_referral&amp;utm_medium=poweredby&amp;utm_source=tinymce&amp;utm_content=v5" rel="noopener" target="_blank" tabindex="-1" aria-label="' + (l2 = dp.translate(["Powered by {0}", "Tiny"])) + '">' + l2 + "</a>" } }), e3 = 0 < v4.length ? [{ dom: { tag: "div", classes: ["tox-statusbar__text-container"] }, components: v4 }] : [], i2 = n2, a2 = !(u2 = r2 = t2).hasPlugin("autoresize"), o2 = (s2 = false === (c2 = u2.getParam("resize", a2)) ? HT.None : "both" === c2 ? HT.Both : HT.Vertical) === HT.None ? vt.none() : vt.some(Xm("resize-handle", { tag: "div", classes: ["tox-statusbar__resize-handle"], attributes: { title: i2.translate("Resize") }, behaviours: [aE.config({ mode: "mouse", repositionTarget: false, onDrag: function(t3, n3, e4) {
        return cE(r2, e4, s2);
      }, blockerClass: "tox-blocker" }), Fg.config({ mode: "special", onLeft: function() {
        return sE(r2, s2, -1, 0);
      }, onRight: function() {
        return sE(r2, s2, 1, 0);
      }, onUp: function() {
        return sE(r2, s2, 0, -1);
      }, onDown: function() {
        return sE(r2, s2, 0, 1);
      } }), py.config({}), Hg.config({})] }, i2.icons)), e3.concat(o2.toArray())) };
      function b2(t3, n3, e4) {
        return Rg.set(t3, [ri(d2.translate(["{0} " + e4, n3[e4]]))]);
      }
    }
    function fE(d2) {
      function m3() {
        return i2.bind(FO.getHeader);
      }
      function g2() {
        return Ve.value(y2);
      }
      function p2() {
        return i2.bind(function(t3) {
          return FO.getThrobber(t3);
        }).getOrDie("Could not find throbber element");
      }
      var t2, n2, e3, o2, r2 = d2.inline, h2 = r2 ? P_ : V_, v4 = dv(d2) ? q1 : H1, i2 = vt.none(), u2 = le(), a2 = u2.browser.isIE() ? ["tox-platform-ie"] : [], c2 = u2.deviceType.isTouch() ? ["tox-platform-touch"] : [], s2 = av(d2), l2 = lv(d2), f2 = dp.isRtl() ? { attributes: { dir: "rtl" } } : {}, b2 = { attributes: ((t2 = {})[es] = s2 ? Oc.BottomToTop : Oc.TopToBottom, t2) }, y2 = Tu((n2 = Lt(be(), l2) && "grid" === pn(l2, "display"), e3 = { dom: lt2({ tag: "div", classes: ["tox", "tox-silver-sink", "tox-tinymce-aux"].concat(a2).concat(c2) }, f2), behaviours: nc([ff.config({ useFixed: function() {
        return v4.isDocked(m3);
      } })]) }, o2 = { dom: { styles: { width: document.body.clientWidth + "px" } }, events: eu([Cr(ji(), function() {
        dn(J2.element, "width", document.body.clientWidth + "px");
      })]) }, Yo(e3, n2 ? o2 : {}))), x2 = zm({ dom: { tag: "div", classes: ["tox-anchorbar"] } }), w2 = Nk(y2, d2, function() {
        return i2.bind(function(t3) {
          return x2.getOpt(t3);
        }).getOrDie("Could not find a anchor bar element");
      }), S2 = FO.parts.menubar({ dom: { tag: "div", classes: ["tox-menubar"] }, backstage: w2, onEscape: function() {
        d2.focus();
      } }), k2 = iv(d2), C2 = FO.parts.toolbar(lt2({ dom: { tag: "div", classes: ["tox-toolbar"] }, getSink: g2, providers: w2.shared.providers, onEscape: function() {
        d2.focus();
      }, type: k2, lazyToolbar: function() {
        return i2.bind(function(t3) {
          return FO.getToolbar(t3);
        }).getOrDie("Could not find more toolbar element");
      }, lazyHeader: function() {
        return m3().getOrDie("Could not find header element");
      } }, b2)), O2 = FO.parts["multiple-toolbar"]({ dom: { tag: "div", classes: ["tox-toolbar-overlord"] }, providers: w2.shared.providers, onEscape: function() {
        d2.focus();
      }, type: k2 }), _2 = FO.parts.socket({ dom: { tag: "div", classes: ["tox-edit-area"] } }), T2 = FO.parts.sidebar({ dom: { tag: "div", classes: ["tox-sidebar"] } }), E2 = FO.parts.throbber({ dom: { tag: "div", classes: ["tox-throbber"] }, backstage: w2 }), D2 = d2.getParam("statusbar", true, "boolean") && !r2 ? vt.some(lE(d2, w2.shared.providers)) : vt.none(), B2 = { dom: { tag: "div", classes: ["tox-sidebar-wrap"] }, components: [_2, T2] }, M2 = rv(d2), A2 = hh(d2), F2 = ph(d2), I2 = FO.parts.header({ dom: lt2({ tag: "div", classes: ["tox-editor-header"] }, b2), components: ft([F2 ? [S2] : [], M2 ? [O2] : A2 ? [C2] : [], sv(d2) ? [] : [x2.asSpec()]]), sticky: dv(d2), editor: d2, sharedBackstage: w2.shared }), R2 = ft([s2 ? [] : [I2], r2 ? [] : [B2], s2 ? [I2] : []]), V2 = ft([[{ dom: { tag: "div", classes: ["tox-editor-container"] }, components: R2 }], r2 ? [] : D2.toArray(), [E2]]), P2 = fv(d2), H2 = lt2(lt2({ role: "application" }, dp.isRtl() ? { dir: "rtl" } : {}), P2 ? { "aria-hidden": "true" } : {}), z2 = Tu(FO.sketch({ dom: { tag: "div", classes: ["tox", "tox-tinymce"].concat(r2 ? ["tox-tinymce-inline"] : []).concat(s2 ? ["tox-tinymce--toolbar-bottom"] : []).concat(c2).concat(a2), styles: lt2({ visibility: "hidden" }, P2 ? { opacity: "0", border: "0" } : {}), attributes: H2 }, components: V2, behaviours: nc([pv(), gd.config({ disableClass: "tox-tinymce--disabled" }), Fg.config({ mode: "cyclic", selector: ".tox-menubar, .tox-toolbar, .tox-toolbar__primary, .tox-toolbar__overflow--open, .tox-sidebar__overflow--open, .tox-statusbar__path, .tox-statusbar__wordcount, .tox-statusbar__branding a, .tox-statusbar__resize-handle" })]) })), i2 = vt.some(z2);
      d2.shortcuts.add("alt+F9", "focus menubar", function() {
        FO.focusMenubar(z2);
      }), d2.shortcuts.add("alt+F10", "focus toolbar", function() {
        FO.focusToolbar(z2);
      }), d2.addCommand("ToggleToolbarDrawer", function() {
        FO.toggleToolbarDrawer(z2);
      }), d2.addQueryStateHandler("ToggleToolbarDrawer", function() {
        return FO.isToolbarDrawerToggled(z2);
      });
      var N2, L2, W2, U2, j2, G2, X2, Y2, q2, K2 = ny(z2), J2 = ny(y2);
      function $2() {
        var t3, n3, e4, o3, r3, i3, u3 = ZO((o3 = sh(e4 = n3 = d2), r3 = dh(e4), i3 = gh(e4), QO(o3).map(function(t4) {
          return t_(t4, r3, i3);
        }).getOr(sh(n3)))), a3 = ZO(n_(t3 = d2).getOr(lh(t3)));
        return d2.inline || (vn("div", "width", a3) && dn(z2.element, "width", a3), vn("div", "height", u3) ? dn(z2.element, "height", u3) : dn(z2.element, "height", "200px")), u3;
      }
      return N2 = d2, L2 = K2, W2 = J2, U2 = Sa(), j2 = pc(U2, "touchstart", tt2), G2 = pc(U2, "touchmove", function(t3) {
        return Q2(Li(), t3);
      }), X2 = pc(U2, "touchend", function(t3) {
        return Q2(Wi(), t3);
      }), Y2 = pc(U2, "mousedown", tt2), q2 = pc(U2, "mouseup", function(t3) {
        0 === t3.raw.button && Z2(wf(), { target: t3.target });
      }), N2.on("PostRender", function() {
        N2.on("click", nt2), N2.on("tap", nt2), N2.on("mouseup", et2), N2.on("mousedown", ot2), N2.on("ScrollWindow", rt3), N2.on("ResizeWindow", it2), N2.on("ResizeEditor", ut2), N2.on("AfterProgressState", at2), N2.on("DismissPopups", ct2);
      }), N2.on("remove", function() {
        N2.off("click", nt2), N2.off("tap", nt2), N2.off("mouseup", et2), N2.off("mousedown", ot2), N2.off("ScrollWindow", rt3), N2.off("ResizeWindow", it2), N2.off("ResizeEditor", ut2), N2.off("AfterProgressState", at2), N2.off("DismissPopups", ct2), Y2.unbind(), j2.unbind(), G2.unbind(), X2.unbind(), q2.unbind();
      }), N2.on("detach", function() {
        Ls(L2), Ls(W2), L2.destroy(), W2.destroy();
      }), { mothership: K2, uiMothership: J2, backstage: w2, renderUI: function() {
        var o3, r3;
        v4.setup(d2, w2.shared, m3), nT(d2, w2), mT(d2, g2, w2), r3 = (o3 = d2).ui.registry.getAll().sidebars, St(Ct(r3), function(n4) {
          function e5() {
            return mt(vt.from(o3.queryCommandValue("ToggleSidebar")), n4);
          }
          var t4 = r3[n4];
          o3.ui.registry.addToggleButton(n4, { icon: t4.icon, tooltip: t4.tooltip, onAction: function(t5) {
            o3.execCommand("ToggleSidebar", false, n4), t5.setActive(e5());
          }, onSetup: function(t5) {
            function n5() {
              return t5.setActive(e5());
            }
            return o3.on("ToggleSidebar", n5), function() {
              o3.off("ToggleSidebar", n5);
            };
          } });
        }), SC(d2, p2, w2.shared), dt(d2.getParam("toolbar_groups", {}, "object"), function(t4, n4) {
          d2.ui.registry.addGroupToolbarButton(n4, t4);
        });
        var t3, n3 = d2.ui.registry.getAll(), e4 = n3.buttons, i3 = n3.menuItems, u3 = n3.contextToolbars, a3 = n3.sidebars, c3 = vh(d2), s3 = { menuItems: i3, menus: (t3 = d2.getParam("menu")) ? dt(t3, function(t4) {
          return lt2(lt2({}, t4), { items: t4.items });
        }) : {}, menubar: d2.getParam("menubar"), toolbar: c3.getOrThunk(function() {
          return d2.getParam("toolbar", true);
        }), allowToolbarGroups: k2 === bh.floating, buttons: e4, sidebar: a3 };
        m_(d2, u3, y2, { backstage: w2 }), PT(d2, y2);
        var l3 = d2.getElement(), f3 = $2();
        return h2.render(d2, { mothership: K2, uiMothership: J2, outerContainer: z2 }, s3, w2, { targetNode: l3, height: f3 });
      }, getUi: function() {
        return { channels: { broadcastAll: J2.broadcast, broadcastOn: J2.broadcastOn, register: st } };
      } };
      function Q2(n3, e4) {
        St([L2, W2], function(t3) {
          t3.broadcastEvent(n3, e4);
        });
      }
      function Z2(n3, e4) {
        St([L2, W2], function(t3) {
          t3.broadcastOn([n3], e4);
        });
      }
      function tt2(t3) {
        return Z2(yf(), { target: t3.target });
      }
      function nt2(t3) {
        return Z2(yf(), { target: At.fromDom(t3.target) });
      }
      function et2(t3) {
        0 === t3.button && Z2(wf(), { target: At.fromDom(t3.target) });
      }
      function ot2() {
        St(N2.editorManager.get(), function(t3) {
          N2 !== t3 && t3.fire("DismissPopups", { relatedTarget: N2 });
        });
      }
      function rt3(t3) {
        return Q2(Ui(), Ac(t3));
      }
      function it2(t3) {
        Z2(xf(), {}), Q2(ji(), Ac(t3));
      }
      function ut2() {
        return Z2(xf(), {});
      }
      function at2(t3) {
        t3.state && Z2(yf(), { target: At.fromDom(N2.getContainer()) });
      }
      function ct2(t3) {
        Z2(yf(), { target: At.fromDom(t3.relatedTarget.getContainer()) });
      }
    }
    function dE(n2) {
      return ar("items", "items", Ue(), no(io(function(t2) {
        return ao("Checking item of " + n2, nB, t2).fold(function(t3) {
          return Ve.error(ur(t3));
        }, function(t3) {
          return Ve.value(t3);
        });
      })));
    }
    function mE(t2) {
      return y(t2.type) && y(t2.name);
    }
    function gE(t2) {
      return { internalDialog: co(ao("dialog", sB, t2)), dataValidator: (n2 = z(F(dB(t2), mE), function(n3) {
        return vt.from(mB[n3.type]).fold(function() {
          return [];
        }, function(t3) {
          return [go(n3.name, t3)];
        });
      }), $o(n2)), initialData: t2.initialData };
      var n2;
    }
    function pE(t2) {
      var e3 = [], o2 = {};
      return J(t2, function(t3, n2) {
        t3.fold(function() {
          e3.push(n2);
        }, function(t4) {
          o2[n2] = t4;
        });
      }), 0 < e3.length ? Ve.error(e3) : Ve.value(o2);
    }
    function hE(t2, n2) {
      dn(t2, "height", n2 + "px"), le().browser.isIE() ? bn(t2, "flex-basis") : dn(t2, "flex-basis", n2 + "px");
    }
    function vE(t2, d2, n2) {
      Fu(t2, '[role="dialog"]').each(function(f2) {
        Iu(f2, '[role="tablist"]').each(function(l2) {
          n2.get().map(function(t3) {
            return dn(d2, "height", "0"), dn(d2, "flex-basis", "0"), Math.min(t3, (e3 = d2, o2 = l2, r2 = Gt(n3 = f2).dom, i2 = "fixed" === pn(Fu(n3, ".tox-dialog-wrap").getOr(n3), "position") ? Math.max(r2.clientHeight, window.innerHeight) : Math.max(r2.offsetHeight, r2.scrollHeight), u2 = wn(e3), a2 = e3.dom.offsetLeft >= o2.dom.offsetLeft + On(o2) ? Math.max(wn(o2), u2) : u2, c2 = parseInt(pn(n3, "margin-top"), 10) || 0, s2 = parseInt(pn(n3, "margin-bottom"), 10) || 0, i2 - (wn(n3) + c2 + s2 - a2)));
            var n3, e3, o2, r2, i2, u2, a2, c2, s2;
          }).each(function(t3) {
            hE(d2, t3);
          });
        });
      });
    }
    function bE(t2) {
      return Iu(t2, '[role="tabpanel"]');
    }
    function yE(t2, e3) {
      function o2(t3) {
        var n3 = pE(Df.getValue(t3)).getOr({}), e4 = i2.get(), o3 = Yo(e4, n3);
        i2.set(o3);
      }
      function r2(t3) {
        var n3 = i2.get();
        Df.setValue(t3, n3);
      }
      var u2, a2, i2 = Po({}), c2 = Po(null), n2 = M(t2.tabs, function(t3) {
        return { value: t3.name, dom: { tag: "div", classes: ["tox-dialog__body-nav-item"], innerHtml: e3.shared.providers.translate(t3.title) }, view: function() {
          return [eS.sketch(function(n3) {
            return { dom: { tag: "div", classes: ["tox-form"] }, components: M(t3.items, function(t4) {
              return hk(n3, t4, e3);
            }), formBehaviours: nc([Fg.config({ mode: "acyclic", useTabstopAt: O(p0) }), mm("TabView.form.events", [ou(r2), ru(o2)]), ic.config({ channels: lr([{ key: kB, value: { onReceive: o2 } }, { key: CB, value: { onReceive: r2 } }]) })]) };
          })];
        } };
      }), s2 = (u2 = n2, a2 = gc(), { extraEvents: [ou(function(t3) {
        var o3 = t3.element;
        bE(o3).each(function(n3) {
          var e4;
          dn(n3, "visibility", "hidden"), t3.getSystem().getByDom(n3).toOptional().each(function(t4) {
            var o4, r3, i3;
            Y(G((r3 = n3, i3 = t4, M(o4 = u2, function(t5, n4) {
              Rg.set(i3, o4[n4].view());
              var e5 = r3.dom.getBoundingClientRect();
              return Rg.set(i3, []), e5.height;
            })), function(t5, n4) {
              return n4 < t5 ? -1 : t5 < n4 ? 1 : 0;
            })).fold(a2.clear, a2.set);
          }), vE(o3, n3, a2), bn(n3, "visibility"), e4 = t3, Y(u2).each(function(t4) {
            return SB.showTab(e4, t4.value);
          }), lp.requestAnimationFrame(function() {
            vE(o3, n3, a2);
          });
        });
      }), Cr(ji(), function(t3) {
        var n3 = t3.element;
        bE(n3).each(function(t4) {
          vE(n3, t4, a2);
        });
      }), Cr(Ty, function(t3, n3) {
        var r3 = t3.element;
        bE(r3).each(function(n4) {
          var t4 = Oa(ge(n4));
          dn(n4, "visibility", "hidden");
          var e4 = hn(n4, "height").map(function(t5) {
            return parseInt(t5, 10);
          });
          bn(n4, "height"), bn(n4, "flex-basis");
          var o3 = n4.dom.getBoundingClientRect().height;
          e4.forall(function(t5) {
            return t5 < o3;
          }) ? (a2.set(o3), vE(r3, n4, a2)) : e4.each(function(t5) {
            hE(n4, t5);
          }), bn(n4, "visibility"), t4.each(ka);
        });
      })], selectFirst: false });
      return SB.sketch({ dom: { tag: "div", classes: ["tox-dialog__body"] }, onChangeTab: function(t3, n3, e4) {
        var o3 = Df.getValue(n3);
        br(t3, _y, { name: o3, oldName: c2.get() }), c2.set(o3);
      }, tabs: n2, components: [SB.parts.tabbar({ dom: { tag: "div", classes: ["tox-dialog__body-nav"] }, components: [bB.parts.tabs({})], markers: { tabClass: "tox-tab", selectedClass: "tox-dialog__body-nav-item--active" }, tabbarBehaviours: nc([py.config({})]) }), SB.parts.tabview({ dom: { tag: "div", classes: ["tox-dialog__body-content"] } })], selectFirst: s2.selectFirst, tabSectionBehaviours: nc([mm("tabpanel", s2.extraEvents), Fg.config({ mode: "acyclic" }), cd.config({ find: function(t3) {
        return Y(SB.getViewItems(t3));
      } }), Df.config({ store: { mode: "manual", getValue: function(t3) {
        return t3.getSystem().broadcastOn([kB], {}), i2.get();
      }, setValue: function(t3, n3) {
        i2.set(n3), t3.getSystem().broadcastOn([CB], {});
      } } })]) });
    }
    function xE(t2, n2, r2, e3) {
      return { dom: { tag: "div", classes: ["tox-dialog__content-js"], attributes: lt2(lt2({}, n2.map(function(t3) {
        return { id: t3 };
      }).getOr({})), e3 ? { "aria-live": "polite" } : {}) }, components: [], behaviours: nc([cS(0), k_.config({ channel: TB, updateState: function(t3, n3) {
        return vt.some({ isTabPanel: function() {
          return "tabpanel" === n3.body.type;
        } });
      }, renderComponents: function(t3) {
        return "tabpanel" !== t3.body.type ? [(e4 = t3.body, o2 = r2, { dom: { tag: "div", classes: ["tox-dialog__body"] }, components: [{ dom: { tag: "div", classes: ["tox-dialog__body-content"] }, components: [(n3 = zm(eS.sketch(function(n4) {
          return { dom: { tag: "div", classes: ["tox-form"].concat(e4.classes) }, components: M(e4.items, function(t4) {
            return hk(n4, t4, o2);
          }) };
        }))).asSpec()] }], behaviours: nc([Fg.config({ mode: "acyclic", useTabstopAt: O(p0) }), aS(n3), mS(n3, { postprocess: function(t4) {
          return pE(t4).fold(function(t5) {
            return console.error(t5), {};
          }, h);
        } })]) })] : [yE(t3.body, r2)];
        var e4, o2, n3;
      }, initialData: t2 })]) };
    }
    function wE(t2, n2) {
      return { dom: { tag: "div", styles: { display: "none" }, classes: ["tox-dialog__header"] }, components: [t2, n2] };
    }
    function SE(t2, n2) {
      return JE.parts.close(fp.sketch({ dom: { tag: "button", classes: ["tox-button", "tox-button--icon", "tox-button--naked"], attributes: { type: "button", "aria-label": n2.translate("Close") } }, action: t2, buttonBehaviours: nc([py.config({})]) }));
    }
    function kE() {
      return JE.parts.title({ dom: { tag: "div", classes: ["tox-dialog__title"], innerHtml: "", styles: { display: "none" } } });
    }
    function CE(t2, n2) {
      return JE.parts.body({ dom: { tag: "div", classes: ["tox-dialog__body"] }, components: [{ dom: { tag: "div", classes: ["tox-dialog__body-content"] }, components: [{ dom: xC("<p>" + n2.translate(t2) + "</p>") }] }] });
    }
    function OE(t2) {
      return JE.parts.footer({ dom: { tag: "div", classes: ["tox-dialog__footer"] }, components: t2 });
    }
    function _E(t2, n2) {
      return [ly.sketch({ dom: { tag: "div", classes: ["tox-dialog__footer-start"] }, components: t2 }), ly.sketch({ dom: { tag: "div", classes: ["tox-dialog__footer-end"] }, components: n2 })];
    }
    function TE(n2) {
      var t2, e3 = "tox-dialog", o2 = e3 + "-wrap", r2 = o2 + "__backdrop", i2 = e3 + "__disable-scroll";
      return JE.sketch({ lazySink: n2.lazySink, onEscape: function(t3) {
        return n2.onEscape(t3), vt.some(true);
      }, useTabstopAt: function(t3) {
        return !p0(t3);
      }, dom: { tag: "div", classes: [e3].concat(n2.extraClasses), styles: lt2({ position: "relative" }, n2.extraStyles) }, components: H([n2.header, n2.body], n2.footer.toArray(), true), parts: { blocker: { dom: xC('<div class="' + o2 + '"></div>'), components: [{ dom: { tag: "div", classes: BB ? [r2, r2 + "--opaque"] : [r2] } }] } }, dragBlockClass: o2, modalBehaviours: nc(H([Hg.config({}), mm("dialog-events", n2.dialogEvents.concat([Br(bi(), function(t3, n3) {
        Fg.focusIn(t3);
      })])), mm("scroll-lock", [ou(function() {
        Yr(be(), i2);
      }), ru(function() {
        qr(be(), i2);
      })])], n2.extraBehaviours, true)), eventOrder: lt2(((t2 = {})[Ii()] = ["dialog-events"], t2[Gi()] = ["scroll-lock", "dialog-events", "alloy.base.behaviour"], t2[Xi()] = ["alloy.base.behaviour", "dialog-events", "scroll-lock"], t2), n2.eventOrder) });
    }
    function EE(t2) {
      return fp.sketch({ dom: { tag: "button", classes: ["tox-button", "tox-button--icon", "tox-button--naked"], attributes: { type: "button", "aria-label": t2.translate("Close"), title: t2.translate("Close") } }, components: [Xm("close", { tag: "div", classes: ["tox-icon"] }, t2.icons)], action: function(t3) {
        vr(t3, wy);
      } });
    }
    function DE(t2, n2, e3) {
      function o2(t3) {
        return [ri(e3.translate(t3.title))];
      }
      return { dom: { tag: "div", classes: ["tox-dialog__title"], attributes: lt2({}, n2.map(function(t3) {
        return { id: t3 };
      }).getOr({})) }, components: o2(t2), behaviours: nc([k_.config({ channel: _B, renderComponents: o2 })]) };
    }
    function BE() {
      return { dom: xC('<div class="tox-dialog__draghandle"></div>') };
    }
    function ME(t2, n2) {
      return e3 = { title: n2.shared.providers.translate(t2), draggable: n2.dialog.isDraggableModal() }, o2 = n2.shared.providers, r2 = JE.parts.title(DE(e3, vt.none(), o2)), i2 = JE.parts.draghandle(BE()), u2 = JE.parts.close(EE(o2)), a2 = [r2].concat(e3.draggable ? [i2] : []).concat([u2]), ly.sketch({ dom: xC('<div class="tox-dialog__header"></div>'), components: a2 });
      var e3, o2, r2, i2, u2, a2;
    }
    function AE(t2, n2, e3) {
      return { dom: { tag: "div", classes: ["tox-dialog__busy-spinner"], attributes: { "aria-label": e3.translate(t2) }, styles: { left: "0px", right: "0px", bottom: "0px", top: "0px", position: "absolute" } }, behaviours: n2, components: [{ dom: xC('<div class="tox-spinner"><div></div><div></div><div></div></div>') }] };
    }
    function FE(t2, o2, n2) {
      return { onClose: function() {
        return n2.closeWindow();
      }, onBlock: function(e3) {
        JE.setBusy(t2(), function(t3, n3) {
          return AE(e3.message, n3, o2);
        });
      }, onUnblock: function() {
        JE.setIdle(t2());
      } };
    }
    function IE(t2, n2, e3, o2) {
      var r2;
      return Tu(TE(lt2(lt2({}, t2), { lazySink: o2.shared.getSink, extraBehaviours: H([k_.config({ channel: OB, updateState: function(t3, n3) {
        return vt.some(n3);
      }, initialData: n2 }), pS({})], t2.extraBehaviours, true), onEscape: function(t3) {
        vr(t3, wy);
      }, dialogEvents: e3, eventOrder: ((r2 = {})[Fi()] = [k_.name(), ic.name()], r2[Gi()] = ["scroll-lock", k_.name(), "messages", "dialog-events", "alloy.base.behaviour"], r2[Xi()] = ["alloy.base.behaviour", "dialog-events", "messages", k_.name(), "scroll-lock"], r2) })));
    }
    function RE(t2) {
      return M(t2, function(t3) {
        return "menu" === t3.type ? (e3 = M((n2 = t3).items, function(t4) {
          var n3 = Po(false);
          return lt2(lt2({}, t4), { storage: n3 });
        }), lt2(lt2({}, n2), { items: e3 })) : t3;
        var n2, e3;
      });
    }
    function VE(t2) {
      return R(t2, function(t3, n2) {
        return "menu" !== n2.type ? t3 : R(n2.items, function(t4, n3) {
          return t4[n3.name] = n3.storage, t4;
        }, t3);
      }, {});
    }
    function PE(t2, e3) {
      return [Er(bi(), g0), t2(xy, function(t3, n2) {
        e3.onClose(), n2.onClose();
      }), t2(wy, function(t3, n2, e4, o2) {
        n2.onCancel(t3), vr(o2, xy);
      }), Cr(Oy, function(t3, n2) {
        return e3.onUnblock();
      }), Cr(Cy, function(t3, n2) {
        return e3.onBlock(n2.event);
      })];
    }
    function HE(t2, n2) {
      function e3(t3, n3) {
        return ly.sketch({ dom: { tag: "div", classes: ["tox-dialog__footer-" + t3] }, components: M(n3, function(t4) {
          return t4.memento.asSpec();
        }) });
      }
      var o2 = A(n2.map(function(t3) {
        return t3.footerButtons;
      }).getOr([]), function(t3) {
        return "start" === t3.align;
      });
      return [e3("start", o2.pass), e3("end", o2.fail)];
    }
    function zE(t2, e3) {
      return { dom: xC('<div class="tox-dialog__footer"></div>'), components: [], behaviours: nc([k_.config({ channel: EB, initialData: t2, updateState: function(t3, n2) {
        var r2 = M(n2.buttons, function(t4) {
          var n3 = zm(Q0(t4, t4.type, e3));
          return { name: t4.name, align: t4.align, memento: n3 };
        });
        return vt.some({ lookupByName: function(t4, n3) {
          return e4 = t4, o2 = n3, V(r2, function(t5) {
            return t5.name === o2;
          }).bind(function(t5) {
            return t5.memento.getOpt(e4);
          });
          var e4, o2;
        }, footerButtons: r2 });
      }, renderComponents: HE })]) };
    }
    function NE(t2, n2) {
      return JE.parts.footer(zE(t2, n2));
    }
    function LE(n2, e3) {
      if (n2.getRoot().getSystem().isConnected()) {
        var o2 = cd.getCurrent(n2.getFormWrapper()).getOr(n2.getFormWrapper());
        return eS.getField(o2, e3).fold(function() {
          var t2 = n2.getFooter();
          return k_.getState(t2).get().bind(function(t3) {
            return t3.lookupByName(o2, e3);
          });
        }, function(t2) {
          return vt.some(t2);
        });
      }
      return vt.none();
    }
    function WE(c2, o2, s2) {
      function t2(t3) {
        var n2 = c2.getRoot();
        n2.getSystem().isConnected() && t3(n2);
      }
      var l2 = { getData: function() {
        var t3 = c2.getRoot(), n2 = t3.getSystem().isConnected() ? c2.getFormWrapper() : t3, e3 = Df.getValue(n2), o3 = dt(s2, function(t4) {
          return t4.get();
        });
        return lt2(lt2({}, e3), o3);
      }, setData: function(a2) {
        t2(function(t3) {
          var n2, e3, o3 = l2.getData(), r2 = lt2(lt2({}, o3), a2), i2 = (n2 = r2, e3 = c2.getRoot(), k_.getState(e3).get().map(function(t4) {
            return co(ao("data", t4.dataValidator, n2));
          }).getOr(n2)), u2 = c2.getFormWrapper();
          Df.setValue(u2, i2), J(s2, function(t4, n3) {
            Tt(r2, n3) && t4.set(r2[n3]);
          });
        });
      }, disable: function(t3) {
        LE(c2, t3).each(gd.disable);
      }, enable: function(t3) {
        LE(c2, t3).each(gd.enable);
      }, focus: function(t3) {
        LE(c2, t3).each(Hg.focus);
      }, block: function(n2) {
        if (!y(n2))
          throw new Error("The dialogInstanceAPI.block function should be passed a blocking message of type string as an argument");
        t2(function(t3) {
          br(t3, Cy, { message: n2 });
        });
      }, unblock: function() {
        t2(function(t3) {
          vr(t3, Oy);
        });
      }, showTab: function(e3) {
        t2(function(t3) {
          var n2 = c2.getBody();
          k_.getState(n2).get().exists(function(t4) {
            return t4.isTabPanel();
          }) && cd.getCurrent(n2).each(function(t4) {
            SB.showTab(t4, e3);
          });
        });
      }, redial: function(e3) {
        t2(function(t3) {
          var n2 = o2(e3);
          t3.getSystem().broadcastOn([OB], n2), t3.getSystem().broadcastOn([_B], n2.internalDialog), t3.getSystem().broadcastOn([TB], n2.internalDialog), t3.getSystem().broadcastOn([EB], n2.internalDialog), l2.setData(n2.initialData);
        });
      }, close: function() {
        t2(function(t3) {
          vr(t3, xy);
        });
      } };
      return l2;
    }
    function UE(t2) {
      return x(t2) && -1 !== RB.indexOf(t2.mceAction);
    }
    function jE(o2, t2, r2, n2) {
      var e3, i2, u2, a2 = ME(o2.title, n2), c2 = (i2 = { dom: { tag: "div", classes: ["tox-dialog__content-js"] }, components: [{ dom: { tag: "div", classes: ["tox-dialog__body-iframe"] }, components: [d0({ dom: { tag: "iframe", attributes: { src: o2.url } }, behaviours: nc([py.config({}), Hg.config({})]) })] }], behaviours: nc([Fg.config({ mode: "acyclic", useTabstopAt: O(p0) })]) }, JE.parts.body(i2)), s2 = o2.buttons.bind(function(t3) {
        return 0 === t3.length ? vt.none() : vt.some(NE({ buttons: t3 }, n2));
      }), l2 = MB(function() {
        return v4;
      }, FE(function() {
        return h2;
      }, n2.shared.providers, t2)), f2 = lt2(lt2({}, o2.height.fold(function() {
        return {};
      }, function(t3) {
        return { height: t3 + "px", "max-height": t3 + "px" };
      })), o2.width.fold(function() {
        return {};
      }, function(t3) {
        return { width: t3 + "px", "max-width": t3 + "px" };
      })), d2 = o2.width.isNone() && o2.height.isNone() ? ["tox-dialog--width-lg"] : [], m3 = new IB(o2.url, { base_uri: new IB(window.location.href) }), g2 = m3.protocol + "://" + m3.host + (m3.port ? ":" + m3.port : ""), p2 = mc(), h2 = IE({ header: a2, body: c2, footer: s2, extraClasses: d2, extraBehaviours: [mm("messages", [ou(function() {
        var t3 = pc(At.fromDom(window), "message", function(t4) {
          var n3, e4;
          m3.isSameOrigin(new IB(t4.raw.origin)) && (UE(n3 = t4.raw.data) ? function(t5, n4, e5) {
            switch (e5.mceAction) {
              case "insertContent":
                t5.insertContent(e5.content);
                break;
              case "setContent":
                t5.setContent(e5.content);
                break;
              case "execCommand":
                var o3 = !!w(e5.ui) && e5.ui;
                t5.execCommand(e5.cmd, o3, e5.value);
                break;
              case "close":
                n4.close();
                break;
              case "block":
                n4.block(e5.message);
                break;
              case "unblock":
                n4.unblock();
            }
          }(r2, v4, n3) : !UE(e4 = n3) && x(e4) && Tt(e4, "mceAction") && o2.onMessage(v4, n3));
        });
        p2.set(t3);
      }), ru(p2.clear)]), ic.config({ channels: ((e3 = {})[DB] = { onReceive: function(t3, n3) {
        Iu(t3.element, "iframe").each(function(t4) {
          t4.dom.contentWindow.postMessage(n3, g2);
        });
      } }, e3) })], extraStyles: f2 }, o2, l2, n2), v4 = { block: function(n3) {
        if (!y(n3))
          throw new Error("The urlDialogInstanceAPI.block function should be passed a blocking message of type string as an argument");
        b2(function(t3) {
          br(t3, Cy, { message: n3 });
        });
      }, unblock: function() {
        b2(function(t3) {
          vr(t3, Oy);
        });
      }, close: function() {
        b2(function(t3) {
          vr(t3, xy);
        });
      }, sendMessage: function(n3) {
        b2(function(t3) {
          t3.getSystem().broadcastOn([DB], n3);
        });
      } };
      function b2(t3) {
        u2.getSystem().isConnected() && t3(u2);
      }
      return { dialog: u2 = h2, instanceApi: v4 };
    }
    function GE(t2) {
      function o2(t3, y2) {
        return gB.open(function(t4, n2, e4) {
          var o3, r3, i3, u2, a2, c3, s3, l3, f3, d2, m3, g2, p2, h2, v4 = n2, b2 = (r3 = { redial: gB.redial, closeWindow: function() {
            JE.hide(b2.dialog), y2(b2.instanceApi);
          } }, i3 = R2, c3 = ME((o3 = { dataValidator: e4, initialData: v4, internalDialog: t4 }).internalDialog.title, i3), u2 = i3, a2 = xE({ body: o3.internalDialog.body }, vt.none(), u2, false), s3 = JE.parts.body(a2), l3 = RE(o3.internalDialog.buttons), f3 = VE(l3), d2 = NE({ buttons: l3 }, i3), m3 = AB(function() {
            return h2;
          }, FE(function() {
            return p2;
          }, i3.shared.providers, r3), i3.shared.getSink), g2 = function() {
            switch (o3.internalDialog.size) {
              case "large":
                return ["tox-dialog--width-lg"];
              case "medium":
                return ["tox-dialog--width-md"];
              default:
                return [];
            }
          }(), p2 = IE({ header: c3, body: s3, footer: vt.some(d2), extraClasses: g2, extraBehaviours: [], extraStyles: {} }, o3, m3, i3), h2 = WE({ getRoot: rt2(p2), getBody: function() {
            return JE.getBody(p2);
          }, getFooter: function() {
            return JE.getFooter(p2);
          }, getFormWrapper: function() {
            var t5 = JE.getBody(p2);
            return cd.getCurrent(t5).getOr(t5);
          } }, r3.redial, f3), { dialog: p2, instanceApi: h2 });
          return JE.show(b2.dialog), b2.instanceApi.setData(v4), b2.instanceApi;
        }, t3);
      }
      function r2(t3, A2, F2, I2) {
        return gB.open(function(t4, n2, e4) {
          function o3() {
            return E2.on(function(t5) {
              up.reposition(t5), U1.refresh(t5);
            });
          }
          var r3, i3, u2, a2, c3, s3, l3, f3, d2, m3, g2, p2, h2, v4, b2, y2, x2, w2, S2, k2, C2, O2, _2, T2 = co(ao("data", e4, n2)), E2 = gc(), D2 = R2.shared.header.isPositionedAtTop(), B2 = (i3 = { dataValidator: e4, initialData: T2, internalDialog: t4 }, u2 = { redial: gB.redial, closeWindow: function() {
            E2.on(up.hide), V2.off("ResizeEditor", o3), E2.clear(), F2(B2.instanceApi);
          } }, a2 = R2, c3 = I2, v4 = Ir("dialog-label"), b2 = Ir("dialog-content"), y2 = zm((f3 = { title: i3.internalDialog.title, draggable: true }, d2 = v4, m3 = a2.shared.providers, ly.sketch({ dom: xC('<div class="tox-dialog__header"></div>'), components: [DE(f3, vt.some(d2), m3), BE(), EE(m3)], containerBehaviours: nc([aE.config({ mode: "mouse", blockerClass: "blocker", getTarget: function(t5) {
            return Ru(t5, '[role="dialog"]').getOrDie();
          }, snaps: { getSnapPoints: function() {
            return [];
          }, leftAttr: "data-drag-left", topAttr: "data-drag-top" } })]) }))), x2 = zm((g2 = { body: i3.internalDialog.body }, p2 = a2, h2 = c3, xE(g2, vt.some(b2), p2, h2))), w2 = RE(i3.internalDialog.buttons), S2 = VE(w2), k2 = zm(FB({ buttons: w2 }, a2)), C2 = AB(function() {
            return _2;
          }, { onBlock: function(e5) {
            fO.block(O2, function(t5, n3) {
              return AE(e5.message, n3, a2.shared.providers);
            });
          }, onUnblock: function() {
            fO.unblock(O2);
          }, onClose: function() {
            return u2.closeWindow();
          } }, a2.shared.getSink), O2 = Tu({ dom: { tag: "div", classes: ["tox-dialog", "tox-dialog-inline"], attributes: ((s3 = { role: "dialog" })["aria-labelledby"] = v4, s3["aria-describedby"] = b2, s3) }, eventOrder: ((l3 = {})[Fi()] = [k_.name(), ic.name()], l3[Ii()] = ["execute-on-form"], l3[Gi()] = ["reflecting", "execute-on-form"], l3), behaviours: nc([Fg.config({ mode: "cyclic", onEscape: function(t5) {
            return vr(t5, xy), vt.some(true);
          }, useTabstopAt: function(t5) {
            return !p0(t5) && ("button" !== Ft(t5) || "disabled" !== un(t5, "disabled"));
          } }), k_.config({ channel: OB, updateState: function(t5, n3) {
            return vt.some(n3);
          }, initialData: i3 }), Hg.config({}), mm("execute-on-form", C2.concat([Br(bi(), function(t5, n3) {
            Fg.focusIn(t5);
          })])), fO.config({ getRoot: function() {
            return vt.some(O2);
          } }), Rg.config({}), pS({})]), components: [y2.asSpec(), x2.asSpec(), k2.asSpec()] }), _2 = WE({ getRoot: rt2(O2), getFooter: function() {
            return k2.get(O2);
          }, getBody: function() {
            return x2.get(O2);
          }, getFormWrapper: function() {
            var t5 = x2.get(O2);
            return cd.getCurrent(t5).getOr(t5);
          } }, u2.redial, S2), { dialog: O2, instanceApi: _2 }), M2 = Tu(up.sketch(lt2(lt2({ lazySink: R2.shared.getSink, dom: { tag: "div", classes: [] }, fireDismissalEventInstead: {} }, D2 ? {} : { fireRepositionEventInstead: {} }), { inlineBehaviours: nc(H([mm("window-manager-inline-events", [Cr(Yi(), function(t5, n3) {
            vr(B2.dialog, wy);
          })])], (r3 = V2, P2 && D2 ? [] : [U1.config({ contextual: { lazyContext: function() {
            return vt.some(Ae(At.fromDom(r3.getContentAreaContainer())));
          }, fadeInClass: "tox-dialog-dock-fadein", fadeOutClass: "tox-dialog-dock-fadeout", transitionClass: "tox-dialog-dock-transition" }, modes: ["top"] })]), true)), isExtraPart: function(t5, n3) {
            return Yb(e5 = n3, ".tox-alert-dialog") || Yb(e5, ".tox-confirm-dialog");
            var e5;
          } })));
          return E2.set(M2), up.showWithin(M2, Eu(B2.dialog), { anchor: A2 }, vt.some(be())), P2 && D2 || (U1.refresh(M2), V2.on("ResizeEditor", o3)), B2.instanceApi.setData(T2), Fg.focusIn(B2.dialog), B2.instanceApi;
        }, t3);
      }
      var c2, s2, l2, f2, R2 = t2.backstage, V2 = t2.editor, P2 = dv(V2), e3 = (s2 = (c2 = t2).backstage.shared, { open: function(t3, n2) {
        function e4() {
          JE.hide(u2), n2();
        }
        var o3 = zm(Q0({ name: "close-alert", text: "OK", primary: true, align: "end", disabled: false, icon: vt.none() }, "cancel", c2.backstage)), r3 = kE(), i3 = SE(e4, s2.providers), u2 = Tu(TE({ lazySink: function() {
          return s2.getSink();
        }, header: wE(r3, i3), body: CE(t3, s2.providers), footer: vt.some(OE(_E([], [o3.asSpec()]))), onEscape: e4, extraClasses: ["tox-alert-dialog"], extraBehaviours: [], extraStyles: {}, dialogEvents: [Cr(wy, e4)], eventOrder: {} }));
        JE.show(u2);
        var a2 = o3.get(u2);
        Hg.focus(a2);
      } }), i2 = (f2 = (l2 = t2).backstage.shared, { open: function(t3, n2) {
        function e4(t4) {
          JE.hide(a2), n2(t4);
        }
        var o3 = zm(Q0({ name: "yes", text: "Yes", primary: true, align: "end", disabled: false, icon: vt.none() }, "submit", l2.backstage)), r3 = Q0({ name: "no", text: "No", primary: false, align: "end", disabled: false, icon: vt.none() }, "cancel", l2.backstage), i3 = kE(), u2 = SE(function() {
          return e4(false);
        }, f2.providers), a2 = Tu(TE({ lazySink: function() {
          return f2.getSink();
        }, header: wE(i3, u2), body: CE(t3, f2.providers), footer: vt.some(OE(_E([], [r3, o3.asSpec()]))), onEscape: function() {
          return e4(false);
        }, extraClasses: ["tox-confirm-dialog"], extraBehaviours: [], extraStyles: {}, dialogEvents: [Cr(wy, function() {
          return e4(false);
        }), Cr(ky, function() {
          return e4(true);
        })], eventOrder: {} }));
        JE.show(a2);
        var c3 = o3.get(a2);
        Hg.focus(c3);
      } });
      return { open: function(t3, n2, e4) {
        return void 0 !== n2 && "toolbar" === n2.inline ? r2(t3, R2.shared.anchors.inlineDialog(), e4, n2.ariaAttrs) : void 0 !== n2 && "cursor" === n2.inline ? r2(t3, R2.shared.anchors.cursor(), e4, n2.ariaAttrs) : o2(t3, e4);
      }, openUrl: function(t3, n2) {
        return e4 = n2, gB.openUrl(function(t4) {
          var n3 = jE(t4, { closeWindow: function() {
            JE.hide(n3.dialog), e4(n3.instanceApi);
          } }, V2, R2);
          return JE.show(n3.dialog), n3.instanceApi;
        }, t3);
        var e4;
      }, alert: function(t3, n2) {
        e3.open(t3, function() {
          n2();
        });
      }, close: function(t3) {
        t3.close();
      }, confirm: function(t3, n2) {
        i2.open(t3, function(t4) {
          n2(t4);
        });
      } };
    }
    (zT = HT = HT || {})[zT.None = 0] = "None", zT[zT.Both = 1] = "Both", zT[zT.Vertical = 2] = "Vertical";
    var XE, YE = rt2([mo("lazySink"), wo("dragBlockClass"), Io("getBounds", Fe), Eo("useTabstopAt", D), Eo("eventOrder", {}), Zs("modalBehaviours", [Fg]), $u("onExecute"), Zu("onEscape")]), qE = { sketch: h }, KE = rt2([Qf({ name: "draghandle", overrides: function(t2, n2) {
      return { behaviours: nc([aE.config({ mode: "mouse", getTarget: function(t3) {
        return Fu(t3, '[role="dialog"]').getOr(t3);
      }, blockerClass: t2.dragBlockClass.getOrDie(new Error("The drag blocker class was not specified for a dialog with a drag handle: \n" + JSON.stringify(n2, null, 2)).message), getBounds: t2.getDragBounds })]) };
    } }), Jf({ schema: [mo("dom")], name: "title" }), Jf({ factory: qE, schema: [mo("dom")], name: "close" }), Jf({ factory: qE, schema: [mo("dom")], name: "body" }), Qf({ factory: qE, schema: [mo("dom")], name: "footer" }), $f({ factory: { sketch: function(t2, n2) {
      return lt2(lt2({}, t2), { dom: n2.dom, components: n2.components });
    } }, schema: [Eo("dom", { tag: "div", styles: { position: "fixed", left: "0px", top: "0px", right: "0px", bottom: "0px" } }), Eo("components", [])], name: "blocker" })]), JE = Cl({ name: "ModalDialog", configFields: YE(), partFields: KE(), factory: function(a2, t2, n2, r2) {
      var e3, i2 = gc(), o2 = Ir("modal-events"), u2 = lt2(lt2({}, a2.eventOrder), ((e3 = {})[Gi()] = [o2].concat(a2.eventOrder["alloy.system.attached"] || []), e3));
      return { uid: a2.uid, dom: a2.dom, components: t2, apis: { show: function(t3) {
        i2.set(t3);
        var n3 = a2.lazySink(t3).getOrDie(), e4 = r2.blocker(), o3 = n3.getSystem().build(lt2(lt2({}, e4), { components: e4.components.concat([Eu(t3)]), behaviours: nc([Hg.config({}), mm("dialog-blocker-events", [Br(bi(), function() {
          Fg.focusIn(t3);
        })])]) }));
        Vs(n3, o3), Fg.focusIn(t3);
      }, hide: function(n3) {
        i2.clear(), Yt(n3.element).each(function(t3) {
          n3.getSystem().getByDom(t3).each(function(t4) {
            Hs(t4);
          });
        });
      }, getBody: function(t3) {
        return gl(t3, a2, "body");
      }, getFooter: function(t3) {
        return gl(t3, a2, "footer");
      }, setIdle: function(t3) {
        fO.unblock(t3);
      }, setBusy: function(t3, n3) {
        fO.block(t3, n3);
      } }, eventOrder: u2, domModification: { attributes: { role: "dialog", "aria-modal": "true" } }, behaviours: nl(a2.modalBehaviours, [Rg.config({}), Fg.config({ mode: "cyclic", onEnter: a2.onExecute, onEscape: a2.onEscape, useTabstopAt: a2.useTabstopAt }), fO.config({ getRoot: i2.get }), mm(o2, [ou(function(t3) {
        var n3, e4, o3, r3 = t3.element, i3 = gl(t3, a2, "title").element, u3 = an(r3, "id").fold(function() {
          var t4 = Ir("dialog-label");
          return on(i3, "id", t4), t4;
        }, h);
        on(r3, "aria-labelledby", u3), n3 = t3.element, e4 = gl(t3, a2, "body").element, o3 = vt.from(un(n3, "id")).fold(function() {
          var t4 = Ir("dialog-describe");
          return on(e4, "id", t4), t4;
        }, h), on(n3, "aria-describedby", o3);
      })])]) };
    }, apis: { show: function(t2, n2) {
      t2.show(n2);
    }, hide: function(t2, n2) {
      t2.hide(n2);
    }, getBody: function(t2, n2) {
      return t2.getBody(n2);
    }, getFooter: function(t2, n2) {
      return t2.getFooter(n2);
    }, setBusy: function(t2, n2, e3) {
      t2.setBusy(n2, e3);
    }, setIdle: function(t2, n2) {
      t2.setIdle(n2);
    } } }), $E = $o([po("type"), po("name")].concat(Lh)), QE = er, ZE = [ar("name", "name", je(function() {
      return Ir("button-name");
    }), nr), Co("icon"), Ao("align", "end", ["start", "end"]), Fo("primary", false), Fo("disabled", false)], tD = H(H([], ZE, true), [po("text")], false), nD = H([ho("type", ["submit", "cancel", "custom"])], tD, true), eD = lo("type", { submit: nD, cancel: nD, custom: nD, menu: H([ho("type", ["menu"]), Co("text"), Co("tooltip"), Co("icon"), xo("items", $E)], ZE, true) }), oD = [po("type"), po("text"), ho("level", ["info", "warn", "error", "success"]), po("icon"), Eo("url", "")], rD = $o(oD), iD = [po("type"), po("text"), Fo("disabled", false), Fo("primary", false), ar("name", "name", je(function() {
      return Ir("button-name");
    }), nr), Co("icon"), Fo("borderless", false)], uD = $o(iD), aD = [po("type"), po("name"), po("label"), Fo("disabled", false)], cD = $o(aD), sD = er, lD = [po("type"), po("name")], fD = lD.concat([Co("label")]), dD = fD.concat([Eo("columns", "auto")]), mD = $o(dD), gD = Qo([po("value"), po("text"), po("icon")]), pD = $o(fD), hD = nr, vD = $o(fD), bD = nr, yD = lD.concat([Mo("tag", "textarea"), po("scriptId"), po("scriptUrl"), Do("settings", void 0, ir)]), xD = lD.concat([Mo("tag", "textarea"), vo("init")]), wD = io(function(t2) {
      return ao("customeditor.old", to(xD), t2).orThunk(function() {
        return ao("customeditor.new", to(yD), t2);
      });
    }), SD = nr, kD = $o(fD), CD = no(Jo), OD = [po("type"), po("html"), Ao("presets", "presentation", ["presentation", "document"])], _D = $o(OD), TD = fD.concat([Fo("sandboxed", true)]), ED = $o(TD), DD = nr, BD = fD.concat([go("currentState", $o([mo("blob"), po("url")]))]), MD = $o(BD), AD = fD.concat([Co("inputMode"), Co("placeholder"), Fo("maximized", false), Fo("disabled", false)]), FD = $o(AD), ID = nr, RD = [po("text"), po("value")], VD = [po("text"), xo("items", (XE = Rt(function() {
      return PD;
    }), { extract: function(t2, n2) {
      return XE().extract(t2, n2);
    }, toString: function() {
      return XE().toString();
    } }))], PD = eo([$o(RD), $o(VD)]), HD = fD.concat([xo("items", PD), Fo("disabled", false)]), zD = $o(HD), ND = nr, LD = fD.concat([yo("items", [po("text"), po("value")]), Bo("size", 1), Fo("disabled", false)]), WD = $o(LD), UD = nr, jD = fD.concat([Fo("constrain", true), Fo("disabled", false)]), GD = $o(jD), XD = $o([po("width"), po("height")]), YD = [po("type"), xo("header", nr), xo("cells", no(nr))], qD = $o(YD), KD = fD.concat([Co("placeholder"), Fo("maximized", false), Fo("disabled", false)]), JD = $o(KD), $D = nr, QD = fD.concat([Ao("filetype", "file", ["image", "media", "file"]), Eo("disabled", false)]), ZD = $o(QD), tB = $o([po("value"), Eo("meta", {})]), nB = Ze(function() {
      return ro("type", { alertbanner: rD, bar: $o((e3 = dE("bar"), [po("type"), e3])), button: uD, checkbox: cD, colorinput: pD, colorpicker: vD, dropzone: kD, grid: $o((t2 = dE("grid"), [po("type"), go("columns", tr), t2])), iframe: ED, input: FD, listbox: zD, selectbox: WD, sizeinput: GD, textarea: JD, urlinput: ZD, customeditor: wD, htmlpanel: _D, imagetools: MD, collection: mD, label: $o((n2 = dE("label"), [po("type"), po("label"), n2])), table: qD, panel: oB });
      var t2, n2, e3;
    }), eB = [po("type"), Eo("classes", []), xo("items", nB)], oB = $o(eB), rB = [ar("name", "name", je(function() {
      return Ir("tab-name");
    }), nr), po("title"), xo("items", nB)], iB = [po("type"), yo("tabs", rB)], uB = $o(iB), aB = tD, cB = eD, sB = $o([po("title"), go("body", ro("type", { panel: oB, tabpanel: uB })), Mo("size", "normal"), xo("buttons", cB), Eo("initialData", {}), Io("onAction", st), Io("onChange", st), Io("onSubmit", st), Io("onClose", st), Io("onCancel", st), Eo("onTabChange", st)]), lB = $o(H([ho("type", ["cancel", "custom"])], aB, true)), fB = $o([po("title"), po("url"), ko("height"), ko("width"), _o("buttons", lB), Io("onAction", st), Io("onCancel", st), Io("onClose", st), Io("onMessage", st)]), dB = function(t2) {
      return x(t2) ? [t2].concat(z(Z(t2), dB)) : c(t2) ? z(t2, dB) : [];
    }, mB = { checkbox: sD, colorinput: hD, colorpicker: bD, dropzone: CD, input: ID, iframe: DD, sizeinput: XD, selectbox: UD, listbox: ND, size: XD, textarea: $D, urlinput: tB, customeditor: SD, collection: gD, togglemenuitem: QE }, gB = { open: function(t2, n2) {
      var e3 = gE(n2);
      return t2(e3.internalDialog, e3.initialData, e3.dataValidator);
    }, openUrl: function(t2, n2) {
      return t2(co(ao("dialog", fB, n2)));
    }, redial: gE }, pB = kl({ name: "TabButton", configFields: [Eo("uid", void 0), mo("value"), ar("dom", "dom", Ye(function() {
      return { attributes: { role: "tab", id: Ir("aria"), "aria-selected": "false" } };
    }), Zo()), wo("action"), Eo("domModification", {}), Zs("tabButtonBehaviours", [Hg, Fg, Df]), mo("view")], factory: function(t2, n2) {
      return { uid: t2.uid, dom: t2.dom, components: t2.components, events: Sm(t2.action), behaviours: nl(t2.tabButtonBehaviours, [Hg.config({}), Fg.config({ mode: "execution", useSpace: true, useEnter: true }), Df.config({ store: { mode: "memory", initialValue: t2.value } })]), domModification: t2.domModification };
    } }), hB = rt2([mo("tabs"), mo("dom"), Eo("clickToDismiss", false), Zs("tabbarBehaviours", [hd, Fg]), qu(["tabClass", "selectedClass"])]), vB = rt2([Zf({ factory: pB, name: "tabs", unit: "tab", overrides: function(o2) {
      return { action: function(t2) {
        var n2 = t2.getSystem().getByUid(o2.uid).getOrDie(), e3 = hd.isHighlighted(n2, t2);
        (e3 && o2.clickToDismiss ? function(t3, n3) {
          hd.dehighlight(t3, n3), br(t3, Qi(), { tabbar: t3, button: n3 });
        } : e3 ? st : function(t3, n3) {
          hd.highlight(t3, n3), br(t3, $i(), { tabbar: t3, button: n3 });
        })(n2, t2);
      }, domModification: { classes: [o2.markers.tabClass] } };
    } })]), bB = Cl({ name: "Tabbar", configFields: hB(), partFields: vB(), factory: function(t2, n2, e3, o2) {
      return { uid: t2.uid, dom: t2.dom, components: n2, "debug.sketcher": "Tabbar", domModification: { attributes: { role: "tablist" } }, behaviours: nl(t2.tabbarBehaviours, [hd.config({ highlightClass: t2.markers.selectedClass, itemClass: t2.markers.tabClass, onHighlight: function(t3, n3) {
        on(n3.element, "aria-selected", "true");
      }, onDehighlight: function(t3, n3) {
        on(n3.element, "aria-selected", "false");
      } }), Fg.config({ mode: "flow", getInitial: function(t3) {
        return hd.getHighlighted(t3).map(function(t4) {
          return t4.element;
        });
      }, selector: "." + t2.markers.tabClass, executeOnMove: true })]) };
    } }), yB = kl({ name: "Tabview", configFields: [Zs("tabviewBehaviours", [Rg])], factory: function(t2, n2) {
      return { uid: t2.uid, dom: t2.dom, behaviours: nl(t2.tabviewBehaviours, [Rg.config({})]), domModification: { attributes: { role: "tabpanel" } } };
    } }), xB = rt2([Eo("selectFirst", true), Ju("onChangeTab"), Ju("onDismissTab"), Eo("tabs", []), Zs("tabSectionBehaviours", [])]), wB = rt2([Jf({ factory: bB, schema: [mo("dom"), bo("markers", [mo("tabClass"), mo("selectedClass")])], name: "tabbar", defaults: function(t2) {
      return { tabs: t2.tabs };
    } }), Jf({ factory: yB, name: "tabview" })]), SB = Cl({ name: "TabSection", configFields: xB(), partFields: wB(), factory: function(i2, t2, n2, e3) {
      function o2(t3, n3) {
        ml(t3, i2, "tabbar").each(function(t4) {
          n3(t4).each(yr);
        });
      }
      return { uid: i2.uid, dom: i2.dom, components: t2, behaviours: tl(i2.tabSectionBehaviours), events: eu(ft([i2.selectFirst ? [ou(function(t3, n3) {
        o2(t3, hd.getFirst);
      })] : [], [Cr($i(), function(t3, n3) {
        var o3 = n3.event.button, r2 = Df.getValue(o3);
        ml(o3, i2, "tabview").each(function(e4) {
          V(i2.tabs, function(t4) {
            return t4.value === r2;
          }).each(function(t4) {
            var n4 = t4.view();
            an(o3.element, "id").each(function(t5) {
              on(e4.element, "aria-labelledby", t5);
            }), Rg.set(e4, n4), i2.onChangeTab(e4, o3, n4);
          });
        });
      }), Cr(Qi(), function(t3, n3) {
        var e4 = n3.event.button;
        i2.onDismissTab(t3, e4);
      })]])), apis: { getViewItems: function(t3) {
        return ml(t3, i2, "tabview").map(function(t4) {
          return Rg.contents(t4);
        }).getOr([]);
      }, showTab: function(t3, e4) {
        o2(t3, function(n3) {
          return V(hd.getCandidates(n3), function(t4) {
            return Df.getValue(t4) === e4;
          }).filter(function(t4) {
            return !hd.isHighlighted(n3, t4);
          });
        });
      } } };
    }, apis: { getViewItems: function(t2, n2) {
      return t2.getViewItems(n2);
    }, showTab: function(t2, n2, e3) {
      t2.showTab(n2, e3);
    } } }), kB = "send-data-to-section", CB = "send-data-to-view", OB = Ir("update-dialog"), _B = Ir("update-title"), TB = Ir("update-body"), EB = Ir("update-footer"), DB = Ir("body-send-message"), BB = nb.deviceType.isTouch(), MB = function(u2, t2) {
      function n2(t3, i2) {
        return Cr(t3, function(e3, o2) {
          var n3, r2;
          n3 = e3, r2 = function(t4, n4) {
            i2(u2(), t4, o2.event, e3);
          }, k_.getState(n3).get().each(function(t4) {
            r2(t4, n3);
          });
        });
      }
      return H(H([], PE(n2, t2), true), [n2(Sy, function(t3, n3, e3) {
        n3.onAction(t3, { name: e3.name });
      })], false);
    }, AB = function(u2, t2, c2) {
      function n2(t3, i2) {
        return Cr(t3, function(e3, o2) {
          var n3, r2;
          n3 = e3, r2 = function(t4, n4) {
            i2(u2(), t4, o2.event, e3);
          }, k_.getState(n3).get().each(function(t4) {
            r2(t4.internalDialog, n3);
          });
        });
      }
      return H(H([], PE(n2, t2), true), [n2(ky, function(t3, n3) {
        return n3.onSubmit(t3);
      }), n2(yy, function(t3, n3, e3) {
        n3.onChange(t3, { name: e3.name });
      }), n2(Sy, function(t3, n3, e3, o2) {
        function r2() {
          return Fg.focusIn(o2);
        }
        function i2(t4) {
          return cn(t4, "disabled") || an(t4, "aria-disabled").exists(function(t5) {
            return "true" === t5;
          });
        }
        var u3 = ge(o2.element), a2 = Oa(u3);
        n3.onAction(t3, { name: e3.name, value: e3.value }), Oa(u3).fold(r2, function(n4) {
          i2(n4) || a2.exists(function(t4) {
            return Wt(n4, t4) && i2(t4);
          }) ? r2() : c2().toOptional().filter(function(t4) {
            return !Wt(t4.element, n4);
          }).each(r2);
        });
      }), n2(_y, function(t3, n3, e3) {
        n3.onTabChange(t3, { newTabName: e3.name, oldTabName: e3.oldName });
      }), ru(function(t3) {
        var n3 = u2();
        Df.setValue(t3, n3.getData());
      })], false);
    }, FB = zE, IB = tinymce.util.Tools.resolve("tinymce.util.URI"), RB = ["insertContent", "setContent", "execCommand", "close", "block", "unblock"];
    o.add("silver", function(t2) {
      var n2 = fE(t2), e3 = n2.uiMothership, o2 = n2.backstage, r2 = n2.renderUI, i2 = n2.getUi;
      return uy(t2, o2.shared), { renderUI: r2, getWindowManagerImpl: rt2(GE({ editor: t2, backstage: o2 })), getNotificationManagerImpl: function() {
        return u2 = t2, r3 = e3, l2 = { backstage: o2 }.backstage.shared, { open: function(t3, n3) {
          function e4() {
            n3(), up.hide(c2);
          }
          var o3 = !t3.closeButton && t3.timeout && (0 < t3.timeout || t3.timeout < 0), a2 = Tu(hp.sketch({ text: t3.text, level: wt(["success", "error", "warning", "warn", "info"], t3.type) ? t3.type : void 0, progress: true === t3.progressBar, icon: vt.from(t3.icon), closeButton: !o3, onAction: e4, iconProvider: l2.providers.icons, translationProvider: l2.providers.translate })), c2 = Tu(up.sketch(lt2({ dom: { tag: "div", classes: ["tox-notifications-container"] }, lazySink: l2.getSink, fireDismissalEventInstead: {} }, l2.header.isPositionedAtTop() ? {} : { fireRepositionEventInstead: {} })));
          function s2() {
            var t4 = Ae(At.fromDom(u2.getContentAreaContainer())), n4 = Fe(), e5 = ja(n4.x, t4.x, t4.right), o4 = ja(n4.y, t4.y, t4.bottom), r4 = Math.max(t4.right, n4.right), i3 = Math.max(t4.bottom, n4.bottom);
            return vt.some(Me(e5, o4, r4 - e5, i3 - o4));
          }
          return r3.add(c2), 0 < t3.timeout && lp.setTimeout(function() {
            e4();
          }, t3.timeout), { close: e4, moveTo: function(t4, n4) {
            up.showAt(c2, Eu(a2), { anchor: { type: "makeshift", x: t4, y: n4 } });
          }, moveRel: function(t4, n4) {
            var e5, o4, r4, i3 = Eu(a2), u3 = { maxHeightFunction: Vc() };
            "banner" !== n4 && k(t4) ? (e5 = function() {
              switch (n4) {
                case "bc-bc":
                  return sp;
                case "tc-tc":
                  return cp;
                case "tc-bc":
                  return Ja;
                default:
                  return $a;
              }
            }(), o4 = { type: "node", root: be(), node: vt.some(At.fromDom(t4)), overrides: u3, layouts: { onRtl: function() {
              return [e5];
            }, onLtr: function() {
              return [e5];
            } } }, up.showWithinBounds(c2, i3, { anchor: o4 }, s2)) : (r4 = lt2(lt2({}, l2.anchors.banner()), { overrides: u3 }), up.showWithinBounds(c2, i3, { anchor: r4 }, s2));
          }, text: function(t4) {
            hp.updateText(a2, t4);
          }, settings: t3, getEl: function() {
            return a2.element.dom;
          }, progressBar: { value: function(t4) {
            hp.updateProgress(a2, t4);
          } } };
        }, close: function(t3) {
          t3.close();
        }, reposition: function(e4) {
          0 < e4.length && St(e4, function(t3, n3) {
            0 === n3 ? t3.moveRel(null, "banner") : t3.moveRel(e4[n3 - 1].getEl(), "bc-tc");
          });
        }, getArgs: function(t3) {
          return t3.settings;
        } };
        var u2, r3, l2;
      }, ui: i2() };
    });
  }();

  // node_modules/tinymce/icons/default/icons.js
  tinymce.IconManager.add("default", {
    icons: {
      "accessibility-check": '<svg width="24" height="24"><path d="M12 2a2 2 0 012 2 2 2 0 01-2 2 2 2 0 01-2-2c0-1.1.9-2 2-2zm8 7h-5v12c0 .6-.4 1-1 1a1 1 0 01-1-1v-5c0-.6-.4-1-1-1a1 1 0 00-1 1v5c0 .6-.4 1-1 1a1 1 0 01-1-1V9H4a1 1 0 110-2h16c.6 0 1 .4 1 1s-.4 1-1 1z" fill-rule="nonzero"/></svg>',
      "action-next": '<svg width="24" height="24"><path fill-rule="nonzero" d="M5.7 7.3a1 1 0 00-1.4 1.4l7.7 7.7 7.7-7.7a1 1 0 10-1.4-1.4L12 13.6 5.7 7.3z"/></svg>',
      "action-prev": '<svg width="24" height="24"><path fill-rule="nonzero" d="M18.3 15.7a1 1 0 001.4-1.4L12 6.6l-7.7 7.7a1 1 0 001.4 1.4L12 9.4l6.3 6.3z"/></svg>',
      "align-center": '<svg width="24" height="24"><path d="M5 5h14c.6 0 1 .4 1 1s-.4 1-1 1H5a1 1 0 110-2zm3 4h8c.6 0 1 .4 1 1s-.4 1-1 1H8a1 1 0 110-2zm0 8h8c.6 0 1 .4 1 1s-.4 1-1 1H8a1 1 0 010-2zm-3-4h14c.6 0 1 .4 1 1s-.4 1-1 1H5a1 1 0 010-2z" fill-rule="evenodd"/></svg>',
      "align-justify": '<svg width="24" height="24"><path d="M5 5h14c.6 0 1 .4 1 1s-.4 1-1 1H5a1 1 0 110-2zm0 4h14c.6 0 1 .4 1 1s-.4 1-1 1H5a1 1 0 110-2zm0 4h14c.6 0 1 .4 1 1s-.4 1-1 1H5a1 1 0 010-2zm0 4h14c.6 0 1 .4 1 1s-.4 1-1 1H5a1 1 0 010-2z" fill-rule="evenodd"/></svg>',
      "align-left": '<svg width="24" height="24"><path d="M5 5h14c.6 0 1 .4 1 1s-.4 1-1 1H5a1 1 0 110-2zm0 4h8c.6 0 1 .4 1 1s-.4 1-1 1H5a1 1 0 110-2zm0 8h8c.6 0 1 .4 1 1s-.4 1-1 1H5a1 1 0 010-2zm0-4h14c.6 0 1 .4 1 1s-.4 1-1 1H5a1 1 0 010-2z" fill-rule="evenodd"/></svg>',
      "align-none": '<svg width="24" height="24"><path d="M14.2 5L13 7H5a1 1 0 110-2h9.2zm4 0h.8a1 1 0 010 2h-2l1.2-2zm-6.4 4l-1.2 2H5a1 1 0 010-2h6.8zm4 0H19a1 1 0 010 2h-4.4l1.2-2zm-6.4 4l-1.2 2H5a1 1 0 010-2h4.4zm4 0H19a1 1 0 010 2h-6.8l1.2-2zM7 17l-1.2 2H5a1 1 0 010-2h2zm4 0h8a1 1 0 010 2H9.8l1.2-2zm5.2-13.5l1.3.7-9.7 16.3-1.3-.7 9.7-16.3z" fill-rule="evenodd"/></svg>',
      "align-right": '<svg width="24" height="24"><path d="M5 5h14c.6 0 1 .4 1 1s-.4 1-1 1H5a1 1 0 110-2zm6 4h8c.6 0 1 .4 1 1s-.4 1-1 1h-8a1 1 0 010-2zm0 8h8c.6 0 1 .4 1 1s-.4 1-1 1h-8a1 1 0 010-2zm-6-4h14c.6 0 1 .4 1 1s-.4 1-1 1H5a1 1 0 010-2z" fill-rule="evenodd"/></svg>',
      "arrow-left": '<svg width="24" height="24"><path d="M5.6 13l12 6a1 1 0 001.4-1V6a1 1 0 00-1.4-.9l-12 6a1 1 0 000 1.8z" fill-rule="evenodd"/></svg>',
      "arrow-right": '<svg width="24" height="24"><path d="M18.5 13l-12 6A1 1 0 015 18V6a1 1 0 011.4-.9l12 6a1 1 0 010 1.8z" fill-rule="evenodd"/></svg>',
      "bold": '<svg width="24" height="24"><path d="M7.8 19c-.3 0-.5 0-.6-.2l-.2-.5V5.7c0-.2 0-.4.2-.5l.6-.2h5c1.5 0 2.7.3 3.5 1 .7.6 1.1 1.4 1.1 2.5a3 3 0 01-.6 1.9c-.4.6-1 1-1.6 1.2.4.1.9.3 1.3.6s.8.7 1 1.2c.4.4.5 1 .5 1.6 0 1.3-.4 2.3-1.3 3-.8.7-2.1 1-3.8 1H7.8zm5-8.3c.6 0 1.2-.1 1.6-.5.4-.3.6-.7.6-1.3 0-1.1-.8-1.7-2.3-1.7H9.3v3.5h3.4zm.5 6c.7 0 1.3-.1 1.7-.4.4-.4.6-.9.6-1.5s-.2-1-.7-1.4c-.4-.3-1-.4-2-.4H9.4v3.8h4z" fill-rule="evenodd"/></svg>',
      "bookmark": '<svg width="24" height="24"><path d="M6 4v17l6-4 6 4V4c0-.6-.4-1-1-1H7a1 1 0 00-1 1z" fill-rule="nonzero"/></svg>',
      "border-style": '<svg width="24" height="24"><g fill-rule="evenodd"><rect width="18" height="2" x="3" y="6" rx="1"/><rect width="2.8" height="2" x="3" y="16" rx="1"/><rect width="2.8" height="2" x="6.8" y="16" rx="1"/><rect width="2.8" height="2" x="10.6" y="16" rx="1"/><rect width="2.8" height="2" x="14.4" y="16" rx="1"/><rect width="2.8" height="2" x="18.2" y="16" rx="1"/><rect width="8" height="2" x="3" y="11" rx="1"/><rect width="8" height="2" x="13" y="11" rx="1"/></g></svg>',
      "border-width": '<svg width="24" height="24"><g fill-rule="evenodd"><rect width="18" height="5" x="3" y="5" rx="1"/><rect width="18" height="3.5" x="3" y="11.5" rx="1"/><rect width="18" height="2" x="3" y="17" rx="1"/></g></svg>',
      "brightness": '<svg width="24" height="24"><path d="M12 17c.3 0 .5.1.7.3.2.2.3.4.3.7v1c0 .3-.1.5-.3.7a1 1 0 01-.7.3 1 1 0 01-.7-.3 1 1 0 01-.3-.7v-1c0-.3.1-.5.3-.7.2-.2.4-.3.7-.3zm0-10a1 1 0 01-.7-.3A1 1 0 0111 6V5c0-.3.1-.5.3-.7.2-.2.4-.3.7-.3.3 0 .5.1.7.3.2.2.3.4.3.7v1c0 .3-.1.5-.3.7a1 1 0 01-.7.3zm7 4c.3 0 .5.1.7.3.2.2.3.4.3.7 0 .3-.1.5-.3.7a1 1 0 01-.7.3h-1a1 1 0 01-.7-.3 1 1 0 01-.3-.7c0-.3.1-.5.3-.7.2-.2.4-.3.7-.3h1zM7 12c0 .3-.1.5-.3.7a1 1 0 01-.7.3H5a1 1 0 01-.7-.3A1 1 0 014 12c0-.3.1-.5.3-.7.2-.2.4-.3.7-.3h1c.3 0 .5.1.7.3.2.2.3.4.3.7zm10 3.5l.7.8c.2.1.3.4.3.6 0 .3-.1.6-.3.8a1 1 0 01-.8.3 1 1 0 01-.6-.3l-.8-.7a1 1 0 01-.3-.8c0-.2.1-.5.3-.7a1 1 0 011.4 0zm-10-7l-.7-.8a1 1 0 01-.3-.6c0-.3.1-.6.3-.8.2-.2.5-.3.8-.3.2 0 .5.1.7.3l.7.7c.2.2.3.5.3.8 0 .2-.1.5-.3.7a1 1 0 01-.7.3 1 1 0 01-.8-.3zm10 0a1 1 0 01-.8.3 1 1 0 01-.7-.3 1 1 0 01-.3-.7c0-.3.1-.6.3-.8l.8-.7c.1-.2.4-.3.6-.3.3 0 .6.1.8.3.2.2.3.5.3.8 0 .2-.1.5-.3.7l-.7.7zm-10 7c.2-.2.5-.3.8-.3.2 0 .5.1.7.3a1 1 0 010 1.4l-.8.8a1 1 0 01-.6.3 1 1 0 01-.8-.3 1 1 0 01-.3-.8c0-.2.1-.5.3-.6l.7-.8zM12 8a4 4 0 013.7 2.4 4 4 0 010 3.2A4 4 0 0112 16a4 4 0 01-3.7-2.4 4 4 0 010-3.2A4 4 0 0112 8zm0 6.5c.7 0 1.3-.2 1.8-.7.5-.5.7-1.1.7-1.8s-.2-1.3-.7-1.8c-.5-.5-1.1-.7-1.8-.7s-1.3.2-1.8.7c-.5.5-.7 1.1-.7 1.8s.2 1.3.7 1.8c.5.5 1.1.7 1.8.7z" fill-rule="evenodd"/></svg>',
      "browse": '<svg width="24" height="24"><path d="M19 4a2 2 0 012 2v12a2 2 0 01-2 2h-4v-2h4V8H5v10h4v2H5a2 2 0 01-2-2V6c0-1.1.9-2 2-2h14zm-8 9.4l-2.3 2.3a1 1 0 11-1.4-1.4l4-4a1 1 0 011.4 0l4 4a1 1 0 01-1.4 1.4L13 13.4V20a1 1 0 01-2 0v-6.6z" fill-rule="nonzero"/></svg>',
      "cancel": '<svg width="24" height="24"><path d="M12 4.6a7.4 7.4 0 110 14.8 7.4 7.4 0 010-14.8zM12 3a9 9 0 100 18 9 9 0 000-18zm0 8L14.8 8l1 1.1-2.7 2.8 2.7 2.7-1.1 1.1-2.7-2.7-2.7 2.7-1-1.1 2.6-2.7-2.7-2.7 1-1.1 2.8 2.7z" fill-rule="nonzero"/></svg>',
      "cell-background-color": '<svg width="24" height="24"><path d="M15.7 2l1.6 1.6-2.7 2.6 5.9 5.8c.7.7.7 1.7 0 2.4l-6.3 6.1a1.7 1.7 0 01-2.4 0l-6.3-6.1c-.7-.7-.7-1.7 0-2.4L15.7 2zM18 12l-4.5-4L9 12h9zM4 16s2 2.4 2 3.8C6 21 5.1 22 4 22s-2-1-2-2.2C2 18.4 4 16 4 16z"/></svg>',
      "cell-border-color": '<svg width="24" height="24"><g fill-rule="evenodd"><path fill-rule="nonzero" d="M5 13v5h2v2H5a2 2 0 01-2-2v-5h2zm8-7V4h6a2 2 0 012 2h-8z" opacity=".2"/><path fill-rule="nonzero" d="M13 4v2H5v7H3V6c0-1.1.9-2 2-2h8zm-2.6 14.1l.1-.1.1.1.2.3.2.2.2.2c.4.6.8 1.2.8 1.7 0 .8-.7 1.5-1.5 1.5S9 21.3 9 20.5c0-.5.4-1.1.8-1.7l.2-.2.2-.2.2-.3z"/><path d="M13 11l-2 2H5v-2h6V6h2z"/><path fill-rule="nonzero" d="M18.4 8l1 1-1.8 1.9 4 4c.5.4.5 1.1 0 1.6l-4.3 4.2a1.2 1.2 0 01-1.6 0l-4.4-4.2c-.4-.5-.4-1.2 0-1.7l7-6.8zm1.6 7l-3-3-3 3h6z"/></g></svg>',
      "change-case": '<svg width="24" height="24"><path d="M18.4 18.2v-.6c-.5.8-1.3 1.2-2.4 1.2-2.2 0-3.3-1.6-3.3-4.8 0-3.1 1-4.7 3.3-4.7 1.1 0 1.8.3 2.4 1.1v-.6c0-.5.4-.8.8-.8s.8.3.8.8v8.4c0 .5-.4.8-.8.8a.8.8 0 01-.8-.8zm-2-7.4c-1.3 0-1.8.9-1.8 3.2 0 2.4.5 3.3 1.7 3.3 1.3 0 1.8-.9 1.8-3.2 0-2.4-.5-3.3-1.7-3.3zM10 15.7H5.5l-.8 2.6a1 1 0 01-1 .7h-.2a.7.7 0 01-.7-1l4-12a1 1 0 012 0l4 12a.7.7 0 01-.8 1h-.2a1 1 0 01-1-.7l-.8-2.6zm-.3-1.5l-2-6.5-1.9 6.5h3.9z" fill-rule="evenodd"/></svg>',
      "character-count": '<svg width="24" height="24"><path d="M4 11.5h16v1H4v-1zm4.8-6.8V10H7.7V5.8h-1v-1h2zM11 8.3V9h2v1h-3V7.7l2-1v-.9h-2v-1h3v2.4l-2 1zm6.3-3.4V10h-3.1V9h2.1V8h-2.1V6.8h2.1v-1h-2.1v-1h3.1zM5.8 16.4c0-.5.2-.8.5-1 .2-.2.6-.3 1.2-.3l.8.1c.2 0 .4.2.5.3l.4.4v2.8l.2.3H8.2v-.1-.2l-.6.3H7c-.4 0-.7 0-1-.2a1 1 0 01-.3-.9c0-.3 0-.6.3-.8.3-.2.7-.4 1.2-.4l.6-.2h.3v-.2l-.1-.2a.8.8 0 00-.5-.1 1 1 0 00-.4 0l-.3.4h-1zm2.3.8h-.2l-.2.1-.4.1a1 1 0 00-.4.2l-.2.2.1.3.5.1h.4l.4-.4v-.6zm2-3.4h1.2v1.7l.5-.3h.5c.5 0 .9.1 1.2.5.3.4.5.8.5 1.4 0 .6-.2 1.1-.5 1.5-.3.4-.7.6-1.3.6l-.6-.1-.4-.4v.4h-1.1v-5.4zm1.1 3.3c0 .3 0 .6.2.8a.7.7 0 001.2 0l.2-.8c0-.4 0-.6-.2-.8a.7.7 0 00-.6-.3l-.6.3-.2.8zm6.1-.5c0-.2 0-.3-.2-.4a.8.8 0 00-.5-.2c-.3 0-.5.1-.6.3l-.2.9c0 .3 0 .6.2.8.1.2.3.3.6.3.2 0 .4 0 .5-.2l.2-.4h1.1c0 .5-.3.8-.6 1.1a2 2 0 01-1.3.4c-.5 0-1-.2-1.3-.6a2 2 0 01-.5-1.4c0-.6.1-1.1.5-1.5.3-.4.8-.5 1.4-.5.5 0 1 0 1.2.3.4.3.5.7.5 1.2h-1v-.1z" fill-rule="evenodd"/></svg>',
      "checklist-rtl": '<svg width="24" height="24"><path d="M5 17h8c.6 0 1 .4 1 1s-.4 1-1 1H5a1 1 0 010-2zm0-6h8c.6 0 1 .4 1 1s-.4 1-1 1H5a1 1 0 010-2zm0-6h8c.6 0 1 .4 1 1s-.4 1-1 1H5a1 1 0 110-2zm14.2 11c.2-.4.6-.5.9-.3.3.2.4.6.2 1L18 20c-.2.3-.7.4-1 0l-1.3-1.3a.7.7 0 010-1c.3-.2.7-.2 1 0l.7.9 1.7-2.8zm0-6c.2-.4.6-.5.9-.3.3.2.4.6.2 1L18 14c-.2.3-.7.4-1 0l-1.3-1.3a.7.7 0 010-1c.3-.2.7-.2 1 0l.7.9 1.7-2.8zm0-6c.2-.4.6-.5.9-.3.3.2.4.6.2 1L18 8c-.2.3-.7.4-1 0l-1.3-1.3a.7.7 0 010-1c.3-.2.7-.2 1 0l.7.9 1.7-2.8z" fill-rule="evenodd"/></svg>',
      "checklist": '<svg width="24" height="24"><path d="M11 17h8c.6 0 1 .4 1 1s-.4 1-1 1h-8a1 1 0 010-2zm0-6h8c.6 0 1 .4 1 1s-.4 1-1 1h-8a1 1 0 010-2zm0-6h8a1 1 0 010 2h-8a1 1 0 010-2zM7.2 16c.2-.4.6-.5.9-.3.3.2.4.6.2 1L6 20c-.2.3-.7.4-1 0l-1.3-1.3a.7.7 0 010-1c.3-.2.7-.2 1 0l.7.9 1.7-2.8zm0-6c.2-.4.6-.5.9-.3.3.2.4.6.2 1L6 14c-.2.3-.7.4-1 0l-1.3-1.3a.7.7 0 010-1c.3-.2.7-.2 1 0l.7.9 1.7-2.8zm0-6c.2-.4.6-.5.9-.3.3.2.4.6.2 1L6 8c-.2.3-.7.4-1 0L3.8 6.9a.7.7 0 010-1c.3-.2.7-.2 1 0l.7.9 1.7-2.8z" fill-rule="evenodd"/></svg>',
      "checkmark": '<svg width="24" height="24"><path d="M18.2 5.4a1 1 0 011.6 1.2l-8 12a1 1 0 01-1.5.1l-5-5a1 1 0 111.4-1.4l4.1 4.1 7.4-11z" fill-rule="nonzero"/></svg>',
      "chevron-down": '<svg width="10" height="10"><path d="M8.7 2.2c.3-.3.8-.3 1 0 .4.4.4.9 0 1.2L5.7 7.8c-.3.3-.9.3-1.2 0L.2 3.4a.8.8 0 010-1.2c.3-.3.8-.3 1.1 0L5 6l3.7-3.8z" fill-rule="nonzero"/></svg>',
      "chevron-left": '<svg width="10" height="10"><path d="M7.8 1.3L4 5l3.8 3.7c.3.3.3.8 0 1-.4.4-.9.4-1.2 0L2.2 5.7a.8.8 0 010-1.2L6.6.2C7 0 7.4 0 7.8.2c.3.3.3.8 0 1.1z" fill-rule="nonzero"/></svg>',
      "chevron-right": '<svg width="10" height="10"><path d="M2.2 1.3a.8.8 0 010-1c.4-.4.9-.4 1.2 0l4.4 4.1c.3.4.3.9 0 1.2L3.4 9.8c-.3.3-.8.3-1.2 0a.8.8 0 010-1.1L6 5 2.2 1.3z" fill-rule="nonzero"/></svg>',
      "chevron-up": '<svg width="10" height="10"><path d="M8.7 7.8L5 4 1.3 7.8c-.3.3-.8.3-1 0a.8.8 0 010-1.2l4.1-4.4c.3-.3.9-.3 1.2 0l4.2 4.4c.3.3.3.9 0 1.2-.3.3-.8.3-1.1 0z" fill-rule="nonzero"/></svg>',
      "close": '<svg width="24" height="24"><path d="M17.3 8.2L13.4 12l3.9 3.8a1 1 0 01-1.5 1.5L12 13.4l-3.8 3.9a1 1 0 01-1.5-1.5l3.9-3.8-3.9-3.8a1 1 0 011.5-1.5l3.8 3.9 3.8-3.9a1 1 0 011.5 1.5z" fill-rule="evenodd"/></svg>',
      "code-sample": '<svg width="24" height="26"><path d="M7.1 11a2.8 2.8 0 01-.8 2 2.8 2.8 0 01.8 2v1.7c0 .3.1.6.4.8.2.3.5.4.8.4.3 0 .4.2.4.4v.8c0 .2-.1.4-.4.4-.7 0-1.4-.3-2-.8-.5-.6-.8-1.3-.8-2V15c0-.3-.1-.6-.4-.8-.2-.3-.5-.4-.8-.4a.4.4 0 01-.4-.4v-.8c0-.2.2-.4.4-.4.3 0 .6-.1.8-.4.3-.2.4-.5.4-.8V9.3c0-.7.3-1.4.8-2 .6-.5 1.3-.8 2-.8.3 0 .4.2.4.4v.8c0 .2-.1.4-.4.4-.3 0-.6.1-.8.4-.3.2-.4.5-.4.8V11zm9.8 0V9.3c0-.3-.1-.6-.4-.8-.2-.3-.5-.4-.8-.4a.4.4 0 01-.4-.4V7c0-.2.1-.4.4-.4.7 0 1.4.3 2 .8.5.6.8 1.3.8 2V11c0 .3.1.6.4.8.2.3.5.4.8.4.2 0 .4.2.4.4v.8c0 .2-.2.4-.4.4-.3 0-.6.1-.8.4-.3.2-.4.5-.4.8v1.7c0 .7-.3 1.4-.8 2-.6.5-1.3.8-2 .8a.4.4 0 01-.4-.4v-.8c0-.2.1-.4.4-.4.3 0 .6-.1.8-.4.3-.2.4-.5.4-.8V15a2.8 2.8 0 01.8-2 2.8 2.8 0 01-.8-2zm-3.3-.4c0 .4-.1.8-.5 1.1-.3.3-.7.5-1.1.5-.4 0-.8-.2-1.1-.5-.4-.3-.5-.7-.5-1.1 0-.5.1-.9.5-1.2.3-.3.7-.4 1.1-.4.4 0 .8.1 1.1.4.4.3.5.7.5 1.2zM12 13c.4 0 .8.1 1.1.5.4.3.5.7.5 1.1 0 1-.1 1.6-.5 2a3 3 0 01-1.1 1c-.4.3-.8.4-1.1.4a.5.5 0 01-.5-.5V17a3 3 0 001-.2l.6-.6c-.6 0-1-.2-1.3-.5-.2-.3-.3-.7-.3-1 0-.5.1-1 .5-1.2.3-.4.7-.5 1.1-.5z" fill-rule="evenodd"/></svg>',
      "color-levels": '<svg width="24" height="24"><path d="M17.5 11.4A9 9 0 0118 14c0 .5 0 1-.2 1.4 0 .4-.3.9-.5 1.3a6.2 6.2 0 01-3.7 3 5.7 5.7 0 01-3.2 0A5.9 5.9 0 017.6 18a6.2 6.2 0 01-1.4-2.6 6.7 6.7 0 010-2.8c0-.4.1-.9.3-1.3a13.6 13.6 0 012.3-4A20 20 0 0112 4a26.4 26.4 0 013.2 3.4 18.2 18.2 0 012.3 4zm-2 4.5c.4-.7.5-1.4.5-2a7.3 7.3 0 00-1-3.2c.2.6.2 1.2.2 1.9a4.5 4.5 0 01-1.3 3 5.3 5.3 0 01-2.3 1.5 4.9 4.9 0 01-2 .1 4.3 4.3 0 002.4.8 4 4 0 002-.6 4 4 0 001.5-1.5z" fill-rule="evenodd"/></svg>',
      "color-picker": '<svg width="24" height="24"><path d="M12 3a9 9 0 000 18 1.5 1.5 0 001.1-2.5c-.2-.3-.4-.6-.4-1 0-.8.7-1.5 1.5-1.5H16a5 5 0 005-5c0-4.4-4-8-9-8zm-5.5 9a1.5 1.5 0 110-3 1.5 1.5 0 010 3zm3-4a1.5 1.5 0 110-3 1.5 1.5 0 010 3zm5 0a1.5 1.5 0 110-3 1.5 1.5 0 010 3zm3 4a1.5 1.5 0 110-3 1.5 1.5 0 010 3z" fill-rule="nonzero"/></svg>',
      "color-swatch-remove-color": '<svg width="24" height="24"><path stroke="#000" stroke-width="2" d="M21 3L3 21" fill-rule="evenodd"/></svg>',
      "color-swatch": '<svg width="24" height="24"><rect x="3" y="3" width="18" height="18" rx="1" fill-rule="evenodd"/></svg>',
      "comment-add": '<svg width="24" height="24"><g fill-rule="nonzero"><path d="M9 19l3-2h7c.6 0 1-.4 1-1V6c0-.6-.4-1-1-1H5a1 1 0 00-1 1v10c0 .6.4 1 1 1h4v2zm-2 4v-4H5a3 3 0 01-3-3V6a3 3 0 013-3h14a3 3 0 013 3v10a3 3 0 01-3 3h-6.4L7 23z"/><path d="M13 10h2a1 1 0 010 2h-2v2a1 1 0 01-2 0v-2H9a1 1 0 010-2h2V8a1 1 0 012 0v2z"/></g></svg>',
      "comment": '<svg width="24" height="24"><path fill-rule="nonzero" d="M9 19l3-2h7c.6 0 1-.4 1-1V6c0-.6-.4-1-1-1H5a1 1 0 00-1 1v10c0 .6.4 1 1 1h4v2zm-2 4v-4H5a3 3 0 01-3-3V6a3 3 0 013-3h14a3 3 0 013 3v10a3 3 0 01-3 3h-6.4L7 23z"/></svg>',
      "contrast": '<svg width="24" height="24"><path d="M12 4a7.8 7.8 0 015.7 2.3A8 8 0 1112 4zm-6 8a6 6 0 006 6V6a6 6 0 00-6 6z" fill-rule="evenodd"/></svg>',
      "copy": '<svg width="24" height="24"><path d="M16 3H6a2 2 0 00-2 2v11h2V5h10V3zm1 4a2 2 0 012 2v10a2 2 0 01-2 2h-7a2 2 0 01-2-2V9c0-1.2.9-2 2-2h7zm0 12V9h-7v10h7z" fill-rule="nonzero"/></svg>',
      "crop": '<svg width="24" height="24"><path d="M17 8v7h2c.6 0 1 .4 1 1s-.4 1-1 1h-2v2c0 .6-.4 1-1 1a1 1 0 01-1-1v-2H7V9H5a1 1 0 110-2h2V5c0-.6.4-1 1-1s1 .4 1 1v2h7l3-3 1 1-3 3zM9 9v5l5-5H9zm1 6h5v-5l-5 5z" fill-rule="evenodd"/></svg>',
      "cut-column": '<svg width="24" height="24"><path fill-rule="evenodd" d="M7.2 4.5c.9 0 1.6.4 2.2 1A3.7 3.7 0 0110.5 8v.5l1 1 4-4 1-.5a3.3 3.3 0 012 0c.4 0 .7.3 1 .5L17 8h4v13h-6V10l-1.5 1.5.5.5v4l-2.5-2.5-1 1v.5c0 .4 0 .8-.3 1.2-.2.5-.4.9-.8 1.2-.6.7-1.3 1-2.2 1-.8.2-1.5 0-2-.6l-.5-.8-.2-1c0-.4 0-.8.3-1.2A3.9 3.9 0 017 12.7c.5-.2 1-.3 1.5-.2l1-1-1-1c-.5 0-1 0-1.5-.2-.5-.1-1-.4-1.4-.9-.4-.3-.6-.7-.8-1.2L4.5 7c0-.4 0-.7.2-1 0-.3.3-.6.5-.8.5-.5 1.2-.8 2-.7zm12.3 5h-3v10h3v-10zM8 13.8h-.3l-.4.2a2.8 2.8 0 00-.7.4v.1a2.8 2.8 0 00-.6.8l-.1.4v.7l.2.5.5.2h.7a2.6 2.6 0 00.8-.3 2.4 2.4 0 00.7-.7 2.5 2.5 0 00.3-.8 1.5 1.5 0 000-.8 1 1 0 00-.2-.4 1 1 0 00-.5-.2H8zm3.5-3.7c-.4 0-.7.1-1 .4-.3.3-.4.6-.4 1s.1.7.4 1c.3.3.6.4 1 .4s.7-.1 1-.4c.3-.3.4-.6.4-1s-.1-.7-.4-1c-.3-.3-.6-.4-1-.4zM7 5.8h-.4a1 1 0 00-.5.3 1 1 0 00-.2.5v.7a2.5 2.5 0 00.3.8l.2.3h.1l.4.4.4.2.4.1h.7L9 9l.2-.4a1.6 1.6 0 000-.8 2.6 2.6 0 00-.3-.8A2.5 2.5 0 007.7 6l-.4-.1H7z"/></svg>',
      "cut-row": '<svg width="24" height="24"><path fill-rule="evenodd" d="M22 3v5H9l3 3 2-2h4l-4 4 1 1h.5c.4 0 .8 0 1.2.3.5.2.9.4 1.2.8.7.6 1 1.3 1 2.2.2.8 0 1.5-.6 2l-.8.5-1 .2c-.4 0-.8 0-1.2-.3a3.9 3.9 0 01-2.1-2.2c-.2-.5-.3-1-.2-1.5l-1-1-1 1c0 .5 0 1-.2 1.5-.1.5-.4 1-.9 1.4-.3.4-.7.6-1.2.8l-1.2.3c-.4 0-.7 0-1-.2-.3 0-.6-.3-.8-.5-.5-.5-.8-1.2-.7-2 0-.9.4-1.6 1-2.2A3.7 3.7 0 018.6 14H9l1-1-4-4-.5-1a3.3 3.3 0 010-2c0-.4.3-.7.5-1l2 2V3h14zM8.5 15.3h-.3a2.6 2.6 0 00-.8.4 2.5 2.5 0 00-.9 1.1l-.1.4v.7l.2.5.5.2h.7a2.5 2.5 0 00.8-.3L9 18V18l.4-.4.2-.4.1-.4v-.3-.4a1 1 0 00-.2-.5 1 1 0 00-.4-.2h-.5zm7 0H15a1 1 0 00-.4.3 1 1 0 00-.2.5 1.5 1.5 0 000 .7v.4a2.8 2.8 0 00.5.7h.1a2.8 2.8 0 00.8.6l.4.1h.7l.5-.2.2-.5v-.4-.3a2.6 2.6 0 00-.3-.8 2.4 2.4 0 00-.7-.7 2.5 2.5 0 00-.8-.3h-.3zM12 11.6c-.4 0-.7.1-1 .4-.3.3-.4.6-.4 1s.1.7.4 1c.3.3.6.4 1 .4s.7-.1 1-.4c.3-.3.4-.6.4-1s-.1-.7-.4-1c-.3-.3-.6-.4-1-.4zm8.5-7.1h-11v2h11v-2z"/></svg>',
      "cut": '<svg width="24" height="24"><path d="M18 15c.6.7 1 1.4 1 2.3 0 .8-.2 1.5-.7 2l-.8.5-1 .2c-.4 0-.8 0-1.2-.3a3.9 3.9 0 01-2.1-2.2c-.2-.5-.3-1-.2-1.5l-1-1-1 1c0 .5 0 1-.2 1.5-.1.5-.4 1-.9 1.4-.3.4-.7.6-1.2.8l-1.2.3c-.4 0-.7 0-1-.2-.3 0-.6-.3-.8-.5-.5-.5-.8-1.2-.7-2 0-.9.4-1.6 1-2.2A3.7 3.7 0 018.6 14H9l1-1-4-4-.5-1a3.3 3.3 0 010-2c0-.4.3-.7.5-1l6 6 6-6 .5 1a3.3 3.3 0 010 2c0 .4-.3.7-.5 1l-4 4 1 1h.5c.4 0 .8 0 1.2.3.5.2.9.4 1.2.8zm-8.5 2.2l.1-.4v-.3-.4a1 1 0 00-.2-.5 1 1 0 00-.4-.2 1.6 1.6 0 00-.8 0 2.6 2.6 0 00-.8.3 2.5 2.5 0 00-.9 1.1l-.1.4v.7l.2.5.5.2h.7a2.5 2.5 0 00.8-.3 2.8 2.8 0 001-1zm2.5-2.8c.4 0 .7-.1 1-.4.3-.3.4-.6.4-1s-.1-.7-.4-1c-.3-.3-.6-.4-1-.4s-.7.1-1 .4c-.3.3-.4.6-.4 1s.1.7.4 1c.3.3.6.4 1 .4zm5.4 4l.2-.5v-.4-.3a2.6 2.6 0 00-.3-.8 2.4 2.4 0 00-.7-.7 2.5 2.5 0 00-.8-.3 1.5 1.5 0 00-.8 0 1 1 0 00-.4.2 1 1 0 00-.2.5 1.5 1.5 0 000 .7v.4l.3.4.3.4a2.8 2.8 0 00.8.5l.4.1h.7l.5-.2z" fill-rule="evenodd"/></svg>',
      "document-properties": '<svg width="24" height="24"><path d="M14.4 3H7a2 2 0 00-2 2v14c0 1.1.9 2 2 2h10a2 2 0 002-2V7.6L14.4 3zM17 19H7V5h6v4h4v10z" fill-rule="nonzero"/></svg>',
      "drag": '<svg width="24" height="24"><path d="M13 5h2v2h-2V5zm0 4h2v2h-2V9zM9 9h2v2H9V9zm4 4h2v2h-2v-2zm-4 0h2v2H9v-2zm0 4h2v2H9v-2zm4 0h2v2h-2v-2zM9 5h2v2H9V5z" fill-rule="evenodd"/></svg>',
      "duplicate-column": '<svg width="24" height="24"><path d="M17 6v16h-7V6h7zm-2 2h-3v12h3V8zm-2-6v2H8v15H6V2h7z"/></svg>',
      "duplicate-row": '<svg width="24" height="24"><path d="M22 11v7H6v-7h16zm-2 2H8v3h12v-3zm-1-6v2H4v5H2V7h17z"/></svg>',
      "duplicate": '<svg width="24" height="24"><g fill-rule="nonzero"><path d="M16 3v2H6v11H4V5c0-1.1.9-2 2-2h10zm3 8h-2V9h-7v10h9a2 2 0 01-2 2h-7a2 2 0 01-2-2V9c0-1.2.9-2 2-2h7a2 2 0 012 2v2z"/><path d="M17 14h1a1 1 0 010 2h-1v1a1 1 0 01-2 0v-1h-1a1 1 0 010-2h1v-1a1 1 0 012 0v1z"/></g></svg>',
      "edit-block": '<svg width="24" height="24"><path fill-rule="nonzero" d="M19.8 8.8l-9.4 9.4c-.2.2-.5.4-.9.4l-5.4 1.2 1.2-5.4.5-.8 9.4-9.4c.7-.7 1.8-.7 2.5 0l2.1 2.1c.7.7.7 1.8 0 2.5zm-2-.2l1-.9v-.3l-2.2-2.2a.3.3 0 00-.3 0l-1 1L18 8.5zm-1 1l-2.5-2.4-6 6 2.5 2.5 6-6zm-7 7.1l-2.6-2.4-.3.3-.1.2-.7 3 3.1-.6h.1l.4-.5z"/></svg>',
      "edit-image": '<svg width="24" height="24"><path d="M18 16h2V7a2 2 0 00-2-2H7v2h11v9zM6 17h15a1 1 0 010 2h-1v1a1 1 0 01-2 0v-1H6a2 2 0 01-2-2V7H3a1 1 0 110-2h1V4a1 1 0 112 0v13zm3-5.3l1.3 2 3-4.7 3.7 6H7l2-3.3z" fill-rule="nonzero"/></svg>',
      "embed-page": '<svg width="24" height="24"><path d="M19 6V5H5v14h2A13 13 0 0119 6zm0 1.4c-.8.8-1.6 2.4-2.2 4.6H19V7.4zm0 5.6h-2.4c-.4 1.8-.6 3.8-.6 6h3v-6zm-4 6c0-2.2.2-4.2.6-6H13c-.7 1.8-1.1 3.8-1.1 6h3zm-4 0c0-2.2.4-4.2 1-6H9.6A12 12 0 008 19h3zM4 3h16c.6 0 1 .4 1 1v16c0 .6-.4 1-1 1H4a1 1 0 01-1-1V4c0-.6.4-1 1-1zm11.8 9c.4-1.9 1-3.4 1.8-4.5a9.2 9.2 0 00-4 4.5h2.2zm-3.4 0a12 12 0 012.8-4 12 12 0 00-5 4h2.2z" fill-rule="nonzero"/></svg>',
      "embed": '<svg width="24" height="24"><path d="M4 3h16c.6 0 1 .4 1 1v16c0 .6-.4 1-1 1H4a1 1 0 01-1-1V4c0-.6.4-1 1-1zm1 2v14h14V5H5zm4.8 2.6l5.6 4a.5.5 0 010 .8l-5.6 4A.5.5 0 019 16V8a.5.5 0 01.8-.4z" fill-rule="nonzero"/></svg>',
      "emoji": '<svg width="24" height="24"><path d="M9 11c.6 0 1-.4 1-1s-.4-1-1-1a1 1 0 00-1 1c0 .6.4 1 1 1zm6 0c.6 0 1-.4 1-1s-.4-1-1-1a1 1 0 00-1 1c0 .6.4 1 1 1zm-3 5.5c2.1 0 4-1.5 4.4-3.5H7.6c.5 2 2.3 3.5 4.4 3.5zM12 4a8 8 0 100 16 8 8 0 000-16zm0 14.5a6.5 6.5 0 110-13 6.5 6.5 0 010 13z" fill-rule="nonzero"/></svg>',
      "export": '<svg width="24" height="24"><g fill-rule="nonzero"><path d="M14.4 3L18 7v1h-5V5H7v14h9a1 1 0 012 0c0 1-.8 2-1.9 2H7c-1 0-2-.8-2-1.9V5c0-1 .8-2 1.9-2h7.5z"/><path d="M18.1 12c.5 0 .9.4.9 1 0 .5-.3 1-.8 1h-7.3c-.5 0-.9-.4-.9-1 0-.5.3-1 .8-1h7.3z"/><path d="M16.4 9.2a1 1 0 011.4.2l2.4 3.6-2.4 3.6a1 1 0 01-1.7-1v-.2l1.7-2.4-1.6-2.4a1 1 0 01.2-1.4z"/></g></svg>',
      "fill": '<svg width="24" height="26"><path d="M16.6 12l-9-9-1.4 1.4 2.4 2.4-5.2 5.1c-.5.6-.5 1.6 0 2.2L9 19.6a1.5 1.5 0 002.2 0l5.5-5.5c.5-.6.5-1.6 0-2.2zM5.2 13L10 8.2l4.8 4.8H5.2zM19 14.5s-2 2.2-2 3.5c0 1.1.9 2 2 2a2 2 0 002-2c0-1.3-2-3.5-2-3.5z" fill-rule="nonzero"/></svg>',
      "flip-horizontally": '<svg width="24" height="24"><path d="M14 19h2v-2h-2v2zm4-8h2V9h-2v2zM4 7v10c0 1.1.9 2 2 2h3v-2H6V7h3V5H6a2 2 0 00-2 2zm14-2v2h2a2 2 0 00-2-2zm-7 16h2V3h-2v18zm7-6h2v-2h-2v2zm-4-8h2V5h-2v2zm4 12a2 2 0 002-2h-2v2z" fill-rule="nonzero"/></svg>',
      "flip-vertically": '<svg width="24" height="24"><path d="M5 14v2h2v-2H5zm8 4v2h2v-2h-2zm4-14H7a2 2 0 00-2 2v3h2V6h10v3h2V6a2 2 0 00-2-2zm2 14h-2v2a2 2 0 002-2zM3 11v2h18v-2H3zm6 7v2h2v-2H9zm8-4v2h2v-2h-2zM5 18c0 1.1.9 2 2 2v-2H5z" fill-rule="nonzero"/></svg>',
      "format-painter": '<svg width="24" height="24"><path d="M18 5V4c0-.5-.4-1-1-1H5a1 1 0 00-1 1v4c0 .6.5 1 1 1h12c.6 0 1-.4 1-1V7h1v4H9v9c0 .6.4 1 1 1h2c.6 0 1-.4 1-1v-7h8V5h-3z" fill-rule="nonzero"/></svg>',
      "format": '<svg width="24" height="24"><path fill-rule="evenodd" d="M17 5a1 1 0 010 2h-4v11a1 1 0 01-2 0V7H7a1 1 0 110-2h10z"/></svg>',
      "fullscreen": '<svg width="24" height="24"><path d="M15.3 10l-1.2-1.3 2.9-3h-2.3a.9.9 0 110-1.7H19c.5 0 .9.4.9.9v4.4a.9.9 0 11-1.8 0V7l-2.9 3zm0 4l3 3v-2.3a.9.9 0 111.7 0V19c0 .5-.4.9-.9.9h-4.4a.9.9 0 110-1.8H17l-3-2.9 1.3-1.2zM10 15.4l-2.9 3h2.3a.9.9 0 110 1.7H5a.9.9 0 01-.9-.9v-4.4a.9.9 0 111.8 0V17l2.9-3 1.2 1.3zM8.7 10L5.7 7v2.3a.9.9 0 01-1.7 0V5c0-.5.4-.9.9-.9h4.4a.9.9 0 010 1.8H7l3 2.9-1.3 1.2z" fill-rule="nonzero"/></svg>',
      "gallery": '<svg width="24" height="24"><path fill-rule="nonzero" d="M5 15.7l2.3-2.2c.3-.3.7-.3 1 0L11 16l5.1-5c.3-.4.8-.4 1 0l2 1.9V8H5v7.7zM5 18V19h3l1.8-1.9-2-2L5 17.9zm14-3l-2.5-2.4-6.4 6.5H19v-4zM4 6h16c.6 0 1 .4 1 1v13c0 .6-.4 1-1 1H4a1 1 0 01-1-1V7c0-.6.4-1 1-1zm6 7a2 2 0 110-4 2 2 0 010 4zM4.5 4h15a.5.5 0 110 1h-15a.5.5 0 010-1zm2-2h11a.5.5 0 110 1h-11a.5.5 0 010-1z"/></svg>',
      "gamma": '<svg width="24" height="24"><path d="M4 3h16c.6 0 1 .4 1 1v16c0 .6-.4 1-1 1H4a1 1 0 01-1-1V4c0-.6.4-1 1-1zm1 2v14h14V5H5zm6.5 11.8V14L9.2 8.7a5.1 5.1 0 00-.4-.8l-.1-.2H8 8v-1l.3-.1.3-.1h.7a1 1 0 01.6.5l.1.3a8.5 8.5 0 01.3.6l1.9 4.6 2-5.2a1 1 0 011-.6.5.5 0 01.5.6L13 14v2.8a.7.7 0 01-1.4 0z" fill-rule="nonzero"/></svg>',
      "help": '<svg width="24" height="24"><g fill-rule="evenodd"><path d="M12 5.5a6.5 6.5 0 00-6 9 6.3 6.3 0 001.4 2l1 1a6.3 6.3 0 003.6 1 6.5 6.5 0 006-9 6.3 6.3 0 00-1.4-2l-1-1a6.3 6.3 0 00-3.6-1zM12 4a7.8 7.8 0 015.7 2.3A8 8 0 1112 4z"/><path d="M9.6 9.7a.7.7 0 01-.7-.8c0-1.1 1.5-1.8 3.2-1.8 1.8 0 3.2.8 3.2 2.4 0 1.4-.4 2.1-1.5 2.8-.2 0-.3.1-.3.2a2 2 0 00-.8.8.8.8 0 01-1.4-.6c.3-.7.8-1 1.3-1.5l.4-.2c.7-.4.8-.6.8-1.5 0-.5-.6-.9-1.7-.9-.5 0-1 .1-1.4.3-.2 0-.3.1-.3.2v-.2c0 .4-.4.8-.8.8z" fill-rule="nonzero"/><circle cx="12" cy="16" r="1"/></g></svg>',
      "highlight-bg-color": '<svg width="24" height="24"><g fill-rule="evenodd"><path id="tox-icon-highlight-bg-color__color" d="M3 18h18v3H3z"/><path fill-rule="nonzero" d="M7.7 16.7H3l3.3-3.3-.7-.8L10.2 8l4 4.1-4 4.2c-.2.2-.6.2-.8 0l-.6-.7-1.1 1.1zm5-7.5L11 7.4l3-2.9a2 2 0 012.6 0L18 6c.7.7.7 2 0 2.7l-2.9 2.9-1.8-1.8-.5-.6"/></g></svg>',
      "home": '<svg width="24" height="24"><path fill-rule="nonzero" d="M10 20v-6h4v6h5v-8h3L12 3 2 12h3v8z"/></svg>',
      "horizontal-rule": '<svg width="24" height="24"><path d="M4 11h16v2H4z" fill-rule="evenodd"/></svg>',
      "image-options": '<svg width="24" height="24"><path d="M6 10a2 2 0 00-2 2c0 1.1.9 2 2 2a2 2 0 002-2 2 2 0 00-2-2zm12 0a2 2 0 00-2 2c0 1.1.9 2 2 2a2 2 0 002-2 2 2 0 00-2-2zm-6 0a2 2 0 00-2 2c0 1.1.9 2 2 2a2 2 0 002-2 2 2 0 00-2-2z" fill-rule="nonzero"/></svg>',
      "image": '<svg width="24" height="24"><path d="M5 15.7l3.3-3.2c.3-.3.7-.3 1 0L12 15l4.1-4c.3-.4.8-.4 1 0l2 1.9V5H5v10.7zM5 18V19h3l2.8-2.9-2-2L5 17.9zm14-3l-2.5-2.4-6.4 6.5H19v-4zM4 3h16c.6 0 1 .4 1 1v16c0 .6-.4 1-1 1H4a1 1 0 01-1-1V4c0-.6.4-1 1-1zm6 8a2 2 0 100-4 2 2 0 000 4z" fill-rule="nonzero"/></svg>',
      "indent": '<svg width="24" height="24"><path d="M7 5h12c.6 0 1 .4 1 1s-.4 1-1 1H7a1 1 0 110-2zm5 4h7c.6 0 1 .4 1 1s-.4 1-1 1h-7a1 1 0 010-2zm0 4h7c.6 0 1 .4 1 1s-.4 1-1 1h-7a1 1 0 010-2zm-5 4h12a1 1 0 010 2H7a1 1 0 010-2zm-2.6-3.8L6.2 12l-1.8-1.2a1 1 0 011.2-1.6l3 2a1 1 0 010 1.6l-3 2a1 1 0 11-1.2-1.6z" fill-rule="evenodd"/></svg>',
      "info": '<svg width="24" height="24"><path d="M12 4a7.8 7.8 0 015.7 2.3A8 8 0 1112 4zm-1 3v2h2V7h-2zm3 10v-1h-1v-5h-3v1h1v4h-1v1h4z" fill-rule="evenodd"/></svg>',
      "insert-character": '<svg width="24" height="24"><path d="M15 18h4l1-2v4h-6v-3.3l1.4-1a6 6 0 001.8-2.9 6.3 6.3 0 00-.1-4.1 5.8 5.8 0 00-3-3.2c-.6-.3-1.3-.5-2.1-.5a5.1 5.1 0 00-3.9 1.8 6.3 6.3 0 00-1.3 6 6.2 6.2 0 001.8 3l1.4.9V20H4v-4l1 2h4v-.5l-2-1L5.4 15A6.5 6.5 0 014 11c0-1 .2-1.9.6-2.7A7 7 0 016.3 6C7.1 5.4 8 5 9 4.5c1-.3 2-.5 3.1-.5a8.8 8.8 0 015.7 2 7 7 0 011.7 2.3 6 6 0 01.2 4.8c-.2.7-.6 1.3-1 1.9a7.6 7.6 0 01-3.6 2.5v.5z" fill-rule="evenodd"/></svg>',
      "insert-time": '<svg width="24" height="24"><g fill-rule="nonzero"><path d="M12 19a7 7 0 100-14 7 7 0 000 14zm0 2a9 9 0 110-18 9 9 0 010 18z"/><path d="M16 12h-3V7c0-.6-.4-1-1-1a1 1 0 00-1 1v7h5c.6 0 1-.4 1-1s-.4-1-1-1z"/></g></svg>',
      "invert": '<svg width="24" height="24"><path d="M18 19.3L16.5 18a5.8 5.8 0 01-3.1 1.9 6.1 6.1 0 01-5.5-1.6A5.8 5.8 0 016 14v-.3l.1-1.2A13.9 13.9 0 017.7 9l-3-3 .7-.8 2.8 2.9 9 8.9 1.5 1.6-.7.6zm0-5.5v.3l-.1 1.1-.4 1-1.2-1.2a4.3 4.3 0 00.2-1v-.2c0-.4 0-.8-.2-1.3l-.5-1.4a14.8 14.8 0 00-3-4.2L12 6a26.1 26.1 0 00-2.2 2.5l-1-1a20.9 20.9 0 012.9-3.3L12 4l1 .8a22.2 22.2 0 014 5.4c.6 1.2 1 2.4 1 3.6z" fill-rule="evenodd"/></svg>',
      "italic": '<svg width="24" height="24"><path d="M16.7 4.7l-.1.9h-.3c-.6 0-1 0-1.4.3-.3.3-.4.6-.5 1.1l-2.1 9.8v.6c0 .5.4.8 1.4.8h.2l-.2.8H8l.2-.8h.2c1.1 0 1.8-.5 2-1.5l2-9.8.1-.5c0-.6-.4-.8-1.4-.8h-.3l.2-.9h5.8z" fill-rule="evenodd"/></svg>',
      "language": '<svg width="24" height="24"><path d="M12 3a9 9 0 110 18 9 9 0 010-18zm4.3 13.3c-.5 1-1.2 2-2 2.9a7.5 7.5 0 003.2-2.1l-.2-.2a6 6 0 00-1-.6zm-8.6 0c-.5.2-.9.5-1.2.8.9 1 2 1.7 3.2 2a10 10 0 01-2-2.8zm3.6-.8c-.8 0-1.6.1-2.2.3.5 1 1.2 1.9 2.1 2.7zm1.5 0v3c.9-.8 1.6-1.7 2.1-2.7-.6-.2-1.4-.3-2.1-.3zm-6-2.7H4.5c.2 1 .5 2.1 1 3h.3l1.3-1a10 10 0 01-.3-2zm12.7 0h-2.3c0 .7-.1 1.4-.3 2l1.6 1.1c.5-1 .9-2 1-3.1zm-3.8 0h-3V14c1 0 2 .1 2.7.4.2-.5.3-1 .3-1.6zm-4.4 0h-3l.3 1.6c.8-.3 1.7-.4 2.7-.4v-1.3zm-5.5-5c-.7 1-1.1 2.2-1.3 3.5h2.3c0-1 .2-1.8.5-2.6l-1.5-1zm2.9 1.4v.1c-.2.6-.4 1.3-.4 2h3V9.4c-1 0-1.8-.1-2.6-.3zm6.6 0h-.1l-2.4.3v1.8h3l-.5-2.1zm3-1.4l-.3.1-1.3.8c.3.8.5 1.6.5 2.6h2.3a7.5 7.5 0 00-1.3-3.5zm-9 0l2 .2V5.5a9 9 0 00-2 2.2zm3.5-2.3V8c.6 0 1.3 0 1.9-.2a9 9 0 00-2-2.3zm-3-.7h-.1c-1.1.4-2.1 1-3 1.8l1.2.7a10 10 0 011.9-2.5zm4.4 0l.1.1a10 10 0 011.8 2.4l1.1-.7a7.5 7.5 0 00-3-1.8z"/></svg>',
      "line-height": '<svg width="24" height="24"><path d="M21 5a1 1 0 01.1 2H13a1 1 0 01-.1-2H21zm0 4a1 1 0 01.1 2H13a1 1 0 01-.1-2H21zm0 4a1 1 0 01.1 2H13a1 1 0 01-.1-2H21zm0 4a1 1 0 01.1 2H13a1 1 0 01-.1-2H21zM7 3.6l3.7 3.7a1 1 0 01-1.3 1.5h-.1L8 7.3v9.2l1.3-1.3a1 1 0 011.3 0h.1c.4.4.4 1 0 1.3v.1L7 20.4l-3.7-3.7a1 1 0 011.3-1.5h.1L6 16.7V7.4L4.7 8.7a1 1 0 01-1.3 0h-.1a1 1 0 010-1.3v-.1L7 3.6z"/></svg>',
      "line": '<svg width="24" height="24"><path d="M15 9l-8 8H4v-3l8-8 3 3zm1-1l-3-3 1-1h1c-.2 0 0 0 0 0l2 2s0 .2 0 0v1l-1 1zM4 18h16v2H4v-2z" fill-rule="evenodd"/></svg>',
      "link": '<svg width="24" height="24"><path d="M6.2 12.3a1 1 0 011.4 1.4l-2.1 2a2 2 0 102.7 2.8l4.8-4.8a1 1 0 000-1.4 1 1 0 111.4-1.3 2.9 2.9 0 010 4L9.6 20a3.9 3.9 0 01-5.5-5.5l2-2zm11.6-.6a1 1 0 01-1.4-1.4l2-2a2 2 0 10-2.6-2.8L11 10.3a1 1 0 000 1.4A1 1 0 119.6 13a2.9 2.9 0 010-4L14.4 4a3.9 3.9 0 015.5 5.5l-2 2z" fill-rule="nonzero"/></svg>',
      "list-bull-circle": '<svg width="48" height="48"><g fill-rule="evenodd"><path d="M11 16a2 2 0 100-4 2 2 0 000 4zm0 1a3 3 0 110-6 3 3 0 010 6zM11 26a2 2 0 100-4 2 2 0 000 4zm0 1a3 3 0 110-6 3 3 0 010 6zM11 36a2 2 0 100-4 2 2 0 000 4zm0 1a3 3 0 110-6 3 3 0 010 6z" fill-rule="nonzero"/><path opacity=".2" d="M18 12h22v4H18zM18 22h22v4H18zM18 32h22v4H18z"/></g></svg>',
      "list-bull-default": '<svg width="48" height="48"><g fill-rule="evenodd"><circle cx="11" cy="14" r="3"/><circle cx="11" cy="24" r="3"/><circle cx="11" cy="34" r="3"/><path opacity=".2" d="M18 12h22v4H18zM18 22h22v4H18zM18 32h22v4H18z"/></g></svg>',
      "list-bull-square": '<svg width="48" height="48"><g fill-rule="evenodd"><path d="M8 11h6v6H8zM8 21h6v6H8zM8 31h6v6H8z"/><path opacity=".2" d="M18 12h22v4H18zM18 22h22v4H18zM18 32h22v4H18z"/></g></svg>',
      "list-num-default-rtl": '<svg width="48" height="48"><g fill-rule="evenodd"><path opacity=".2" d="M8 12h22v4H8zM8 22h22v4H8zM8 32h22v4H8z"/><path d="M37.4 17v-4.8l-1.6 1v-1.1l1.6-1h1.2V17zM33.3 17.1c-.5 0-.8-.3-.8-.7 0-.4.3-.7.8-.7.4 0 .7.3.7.7 0 .4-.3.7-.7.7zm1.7 5.7c0-1.2 1-2 2.2-2 1.3 0 2.1.8 2.1 1.8 0 .7-.3 1.2-1.3 2.2l-1.2 1v.2h2.6v1h-4.3v-.9l2-1.9c.8-.8 1-1.1 1-1.5 0-.5-.4-.8-1-.8-.5 0-.9.3-.9.9H35zm-1.7 4.3c-.5 0-.8-.3-.8-.7 0-.4.3-.7.8-.7.4 0 .7.3.7.7 0 .4-.3.7-.7.7zm3.2 7.3v-1h.7c.6 0 1-.3 1-.8 0-.4-.4-.7-1-.7s-1 .3-1 .8H35c0-1.1 1-1.8 2.2-1.8 1.2 0 2.1.6 2.1 1.6 0 .7-.4 1.2-1 1.3v.1c.7.1 1.3.7 1.3 1.4 0 1-1 1.9-2.4 1.9-1.3 0-2.2-.8-2.3-2h1.2c0 .6.5 1 1.1 1 .6 0 1-.4 1-1 0-.5-.3-.8-1-.8h-.7zm-3.3 2.7c-.4 0-.7-.3-.7-.7 0-.4.3-.7.7-.7.5 0 .8.3.8.7 0 .4-.3.7-.8.7z"/></g></svg>',
      "list-num-default": '<svg width="48" height="48"><g fill-rule="evenodd"><path opacity=".2" d="M18 12h22v4H18zM18 22h22v4H18zM18 32h22v4H18z"/><path d="M10 17v-4.8l-1.5 1v-1.1l1.6-1h1.2V17h-1.2zm3.6.1c-.4 0-.7-.3-.7-.7 0-.4.3-.7.7-.7.5 0 .7.3.7.7 0 .4-.2.7-.7.7zm-5 5.7c0-1.2.8-2 2.1-2s2.1.8 2.1 1.8c0 .7-.3 1.2-1.4 2.2l-1.1 1v.2h2.6v1H8.6v-.9l2-1.9c.8-.8 1-1.1 1-1.5 0-.5-.4-.8-1-.8-.5 0-.9.3-.9.9H8.5zm6.3 4.3c-.5 0-.7-.3-.7-.7 0-.4.2-.7.7-.7.4 0 .7.3.7.7 0 .4-.3.7-.7.7zM10 34.4v-1h.7c.6 0 1-.3 1-.8 0-.4-.4-.7-1-.7s-1 .3-1 .8H8.6c0-1.1 1-1.8 2.2-1.8 1.3 0 2.1.6 2.1 1.6 0 .7-.4 1.2-1 1.3v.1c.8.1 1.3.7 1.3 1.4 0 1-1 1.9-2.4 1.9-1.3 0-2.2-.8-2.3-2h1.2c0 .6.5 1 1.1 1 .7 0 1-.4 1-1 0-.5-.3-.8-1-.8h-.7zm4.7 2.7c-.4 0-.7-.3-.7-.7 0-.4.3-.7.7-.7.5 0 .8.3.8.7 0 .4-.3.7-.8.7z"/></g></svg>',
      "list-num-lower-alpha-rtl": '<svg width="48" height="48"><g fill-rule="evenodd"><path opacity=".2" d="M8 12h22v4H8zM8 22h22v4H8zM8 32h22v4H8z"/><path d="M36.5 16c-.9 0-1.5-.5-1.5-1.3s.6-1.3 1.8-1.4h1v-.4c0-.4-.2-.6-.7-.6-.4 0-.7.1-.8.4h-1.1c0-.8.8-1.4 2-1.4S39 12 39 13V16h-1.2v-.6c-.3.4-.8.7-1.4.7zm.4-.8c.6 0 1-.4 1-.9V14h-1c-.5.1-.7.3-.7.6 0 .4.3.6.7.6zM33.1 16.1c-.4 0-.7-.3-.7-.7 0-.4.3-.7.7-.7.5 0 .8.3.8.7 0 .4-.3.7-.8.7zM37.7 26c-.7 0-1.2-.2-1.5-.7v.7H35v-6.3h1.2v2.5c.3-.5.8-.9 1.5-.9 1.1 0 1.8 1 1.8 2.4 0 1.5-.7 2.4-1.8 2.4zm-.5-3.6c-.6 0-1 .5-1 1.3s.4 1.4 1 1.4c.7 0 1-.6 1-1.4 0-.8-.3-1.3-1-1.3zM33.2 26.1c-.4 0-.7-.3-.7-.7 0-.4.3-.7.7-.7.5 0 .8.3.8.7 0 .4-.3.7-.8.7zm6 7h-1c-.1-.5-.4-.8-1-.8s-1 .5-1 1.4c0 1 .4 1.4 1 1.4.5 0 .9-.2 1-.7h1c0 1-.8 1.7-2 1.7-1.4 0-2.2-.9-2.2-2.4s.8-2.4 2.2-2.4c1.2 0 2 .7 2 1.7zm-6.1 3c-.5 0-.7-.3-.7-.7 0-.4.2-.7.7-.7.4 0 .7.3.7.7 0 .4-.3.7-.7.7z"/></g></svg>',
      "list-num-lower-alpha": '<svg width="48" height="48"><g fill-rule="evenodd"><path opacity=".2" d="M18 12h22v4H18zM18 22h22v4H18zM18 32h22v4H18z"/><path d="M10.3 15.2c.5 0 1-.4 1-.9V14h-1c-.5.1-.8.3-.8.6 0 .4.3.6.8.6zm-.4.9c-1 0-1.5-.6-1.5-1.4 0-.8.6-1.3 1.7-1.4h1.1v-.4c0-.4-.2-.6-.7-.6-.5 0-.8.1-.9.4h-1c0-.8.8-1.4 2-1.4 1.1 0 1.8.6 1.8 1.6V16h-1.1v-.6h-.1c-.2.4-.7.7-1.3.7zm4.6 0c-.5 0-.7-.3-.7-.7 0-.4.2-.7.7-.7.4 0 .7.3.7.7 0 .4-.3.7-.7.7zm-3.2 10c-.6 0-1.2-.3-1.4-.8v.7H8.5v-6.3H10v2.5c.3-.5.8-.9 1.4-.9 1.2 0 1.9 1 1.9 2.4 0 1.5-.7 2.4-1.9 2.4zm-.4-3.7c-.7 0-1 .5-1 1.3s.3 1.4 1 1.4c.6 0 1-.6 1-1.4 0-.8-.4-1.3-1-1.3zm4 3.7c-.5 0-.7-.3-.7-.7 0-.4.2-.7.7-.7.4 0 .7.3.7.7 0 .4-.3.7-.7.7zm-2.2 7h-1.2c0-.5-.4-.8-.9-.8-.6 0-1 .5-1 1.4 0 1 .4 1.4 1 1.4.5 0 .8-.2 1-.7h1c0 1-.8 1.7-2 1.7-1.4 0-2.2-.9-2.2-2.4s.8-2.4 2.2-2.4c1.2 0 2 .7 2 1.7zm1.8 3c-.5 0-.8-.3-.8-.7 0-.4.3-.7.8-.7.4 0 .7.3.7.7 0 .4-.3.7-.7.7z"/></g></svg>',
      "list-num-lower-greek-rtl": '<svg width="48" height="48"><g fill-rule="evenodd"><path opacity=".2" d="M8 12h22v4H8zM8 22h22v4H8zM8 32h22v4H8z"/><path d="M37.4 16c-1.2 0-2-.8-2-2.3 0-1.5.8-2.4 2-2.4.6 0 1 .4 1.3 1v-.9H40v3.2c0 .4.1.5.4.5h.2v.9h-.6c-.6 0-1-.2-1-.7h-.2c-.2.4-.7.8-1.3.8zm.3-1c.6 0 1-.5 1-1.3s-.4-1.3-1-1.3-1 .5-1 1.3.4 1.4 1 1.4zM33.3 16.1c-.5 0-.8-.3-.8-.7 0-.4.3-.7.8-.7.4 0 .7.3.7.7 0 .4-.3.7-.7.7zM36 21.9c0-1.5.8-2.3 2.1-2.3 1.2 0 2 .6 2 1.6 0 .6-.3 1-.9 1.3.9.3 1.3.8 1.3 1.7 0 1.2-.7 1.9-1.8 1.9-.6 0-1.1-.3-1.4-.8v2.2H36V22zm1.8 1.2v-1h.3c.5 0 .9-.2.9-.7 0-.5-.3-.8-.9-.8-.5 0-.8.3-.8 1v2.2c0 .8.4 1.3 1 1.3s1-.4 1-1-.4-1-1.2-1h-.3zM33.3 26.1c-.5 0-.8-.3-.8-.7 0-.4.3-.7.8-.7.4 0 .7.3.7.7 0 .4-.3.7-.7.7zM37.1 34.6L34.8 30h1.4l1.7 3.5 1.7-3.5h1.1l-2.2 4.6v.1c.5.8.7 1.4.7 1.8 0 .4-.2.8-.4 1-.2.2-.6.3-1 .3-.9 0-1.3-.4-1.3-1.2 0-.5.2-1 .5-1.7l.1-.2zm.7 1a2 2 0 00-.4.9c0 .3.1.4.4.4.3 0 .4-.1.4-.4 0-.2-.1-.6-.4-1zM33.3 36.1c-.5 0-.8-.3-.8-.7 0-.4.3-.7.8-.7.4 0 .7.3.7.7 0 .4-.3.7-.7.7z"/></g></svg>',
      "list-num-lower-greek": '<svg width="48" height="48"><g fill-rule="evenodd"><path opacity=".2" d="M18 12h22v4H18zM18 22h22v4H18zM18 32h22v4H18z"/><path d="M10.5 15c.7 0 1-.5 1-1.3s-.3-1.3-1-1.3c-.5 0-.9.5-.9 1.3s.4 1.4 1 1.4zm-.3 1c-1.1 0-1.8-.8-1.8-2.3 0-1.5.7-2.4 1.8-2.4.7 0 1.1.4 1.3 1h.1v-.9h1.2v3.2c0 .4.1.5.4.5h.2v.9h-.6c-.6 0-1-.2-1.1-.7h-.1c-.2.4-.7.8-1.4.8zm5 .1c-.5 0-.8-.3-.8-.7 0-.4.3-.7.7-.7.5 0 .8.3.8.7 0 .4-.3.7-.8.7zm-4.9 7v-1h.3c.6 0 1-.2 1-.7 0-.5-.4-.8-1-.8-.5 0-.8.3-.8 1v2.2c0 .8.4 1.3 1.1 1.3.6 0 1-.4 1-1s-.5-1-1.3-1h-.3zM8.6 22c0-1.5.7-2.3 2-2.3 1.2 0 2 .6 2 1.6 0 .6-.3 1-.8 1.3.8.3 1.3.8 1.3 1.7 0 1.2-.8 1.9-1.9 1.9-.6 0-1.1-.3-1.3-.8v2.2H8.5V22zm6.2 4.2c-.4 0-.7-.3-.7-.7 0-.4.3-.7.7-.7.5 0 .7.3.7.7 0 .4-.2.7-.7.7zm-4.5 8.5L8 30h1.4l1.7 3.5 1.7-3.5h1.1l-2.2 4.6v.1c.5.8.7 1.4.7 1.8 0 .4-.1.8-.4 1-.2.2-.6.3-1 .3-.9 0-1.3-.4-1.3-1.2 0-.5.2-1 .5-1.7l.1-.2zm.7 1a2 2 0 00-.4.9c0 .3.1.4.4.4.3 0 .4-.1.4-.4 0-.2-.1-.6-.4-1zm4.5.5c-.5 0-.8-.3-.8-.7 0-.4.3-.7.8-.7.4 0 .7.3.7.7 0 .4-.3.7-.7.7z"/></g></svg>',
      "list-num-lower-roman-rtl": '<svg width="48" height="48"><g fill-rule="evenodd"><path opacity=".2" d="M8 12h22v4H8zM8 22h22v4H8zM8 32h22v4H8z"/><path d="M32.9 16v-1.2h-1.3V16H33zm0 10v-1.2h-1.3V26H33zm0 10v-1.2h-1.3V36H33z"/><path fill-rule="nonzero" d="M36 21h-1.5v5H36zM36 31h-1.5v5H36zM39 21h-1.5v5H39zM39 31h-1.5v5H39zM42 31h-1.5v5H42zM36 11h-1.5v5H36zM36 19h-1.5v1H36zM36 29h-1.5v1H36zM39 19h-1.5v1H39zM39 29h-1.5v1H39zM42 29h-1.5v1H42zM36 9h-1.5v1H36z"/></g></svg>',
      "list-num-lower-roman": '<svg width="48" height="48"><g fill-rule="evenodd"><path opacity=".2" d="M18 12h22v4H18zM18 22h22v4H18zM18 32h22v4H18z"/><path d="M15.1 16v-1.2h1.3V16H15zm0 10v-1.2h1.3V26H15zm0 10v-1.2h1.3V36H15z"/><path fill-rule="nonzero" d="M12 21h1.5v5H12zM12 31h1.5v5H12zM9 21h1.5v5H9zM9 31h1.5v5H9zM6 31h1.5v5H6zM12 11h1.5v5H12zM12 19h1.5v1H12zM12 29h1.5v1H12zM9 19h1.5v1H9zM9 29h1.5v1H9zM6 29h1.5v1H6zM12 9h1.5v1H12z"/></g></svg>',
      "list-num-upper-alpha-rtl": '<svg width="48" height="48"><g fill-rule="evenodd"><path opacity=".2" d="M8 12h22v4H8zM8 22h22v4H8zM8 32h22v4H8z"/><path d="M39.3 17l-.5-1.4h-2l-.5 1.4H35l2-6h1.6l2 6h-1.3zm-1.6-4.7l-.7 2.3h1.6l-.8-2.3zM33.4 17c-.4 0-.7-.3-.7-.7 0-.4.3-.7.7-.7.5 0 .7.3.7.7 0 .4-.2.7-.7.7zm4.7 9.9h-2.7v-6H38c1.2 0 1.9.6 1.9 1.5 0 .6-.5 1.2-1 1.3.7.1 1.3.7 1.3 1.5 0 1-.8 1.7-2 1.7zm-1.4-5v1.5h1c.6 0 1-.3 1-.8 0-.4-.4-.7-1-.7h-1zm0 4h1.1c.7 0 1.1-.3 1.1-.8 0-.6-.4-.9-1.1-.9h-1.1V26zM33 27.1c-.5 0-.8-.3-.8-.7 0-.4.3-.7.8-.7.4 0 .7.3.7.7 0 .4-.3.7-.7.7zm4.9 10c-1.8 0-2.8-1.1-2.8-3.1s1-3.1 2.8-3.1c1.4 0 2.5.9 2.6 2.2h-1.3c0-.7-.6-1.1-1.3-1.1-1 0-1.6.7-1.6 2s.6 2 1.6 2c.7 0 1.2-.4 1.4-1h1.2c-.1 1.3-1.2 2.2-2.6 2.2zm-4.5 0c-.5 0-.8-.3-.8-.7 0-.4.3-.7.8-.7.4 0 .7.3.7.7 0 .4-.3.7-.7.7z"/></g></svg>',
      "list-num-upper-alpha": '<svg width="48" height="48"><g fill-rule="evenodd"><path opacity=".2" d="M18 12h22v4H18zM18 22h22v4H18zM18 32h22v4H18z"/><path d="M12.6 17l-.5-1.4h-2L9.5 17H8.3l2-6H12l2 6h-1.3zM11 12.3l-.7 2.3h1.6l-.8-2.3zm4.7 4.8c-.4 0-.7-.3-.7-.7 0-.4.3-.7.7-.7.5 0 .7.3.7.7 0 .4-.2.7-.7.7zM11.4 27H8.7v-6h2.6c1.2 0 1.9.6 1.9 1.5 0 .6-.5 1.2-1 1.3.7.1 1.3.7 1.3 1.5 0 1-.8 1.7-2 1.7zM10 22v1.5h1c.6 0 1-.3 1-.8 0-.4-.4-.7-1-.7h-1zm0 4H11c.7 0 1.1-.3 1.1-.8 0-.6-.4-.9-1.1-.9H10V26zm5.4 1.1c-.5 0-.8-.3-.8-.7 0-.4.3-.7.8-.7.4 0 .7.3.7.7 0 .4-.3.7-.7.7zm-4.1 10c-1.8 0-2.8-1.1-2.8-3.1s1-3.1 2.8-3.1c1.4 0 2.5.9 2.6 2.2h-1.3c0-.7-.6-1.1-1.3-1.1-1 0-1.6.7-1.6 2s.6 2 1.6 2c.7 0 1.2-.4 1.4-1h1.2c-.1 1.3-1.2 2.2-2.6 2.2zm4.5 0c-.5 0-.8-.3-.8-.7 0-.4.3-.7.8-.7.4 0 .7.3.7.7 0 .4-.3.7-.7.7z"/></g></svg>',
      "list-num-upper-roman-rtl": '<svg width="48" height="48"><g fill-rule="evenodd"><path opacity=".2" d="M8 12h22v4H8zM8 22h22v4H8zM8 32h22v4H8z"/><path d="M31.6 17v-1.2H33V17h-1.3zm0 10v-1.2H33V27h-1.3zm0 10v-1.2H33V37h-1.3z"/><path fill-rule="nonzero" d="M34.5 20H36v7h-1.5zM34.5 30H36v7h-1.5zM37.5 20H39v7h-1.5zM37.5 30H39v7h-1.5zM40.5 30H42v7h-1.5zM34.5 10H36v7h-1.5z"/></g></svg>',
      "list-num-upper-roman": '<svg width="48" height="48"><g fill-rule="evenodd"><path opacity=".2" d="M18 12h22v4H18zM18 22h22v4H18zM18 32h22v4H18z"/><path d="M15.1 17v-1.2h1.3V17H15zm0 10v-1.2h1.3V27H15zm0 10v-1.2h1.3V37H15z"/><path fill-rule="nonzero" d="M12 20h1.5v7H12zM12 30h1.5v7H12zM9 20h1.5v7H9zM9 30h1.5v7H9zM6 30h1.5v7H6zM12 10h1.5v7H12z"/></g></svg>',
      "lock": '<svg width="24" height="24"><path d="M16.3 11c.2 0 .3 0 .5.2l.2.6v7.4c0 .3 0 .4-.2.6l-.6.2H7.8c-.3 0-.4 0-.6-.2a.7.7 0 01-.2-.6v-7.4c0-.3 0-.4.2-.6l.5-.2H8V8c0-.8.3-1.5.9-2.1.6-.6 1.3-.9 2.1-.9h2c.8 0 1.5.3 2.1.9.6.6.9 1.3.9 2.1v3h.3zM10 8v3h4V8a1 1 0 00-.3-.7A1 1 0 0013 7h-2a1 1 0 00-.7.3 1 1 0 00-.3.7z" fill-rule="evenodd"/></svg>',
      "ltr": '<svg width="24" height="24"><path d="M11 5h7a1 1 0 010 2h-1v11a1 1 0 01-2 0V7h-2v11a1 1 0 01-2 0v-6c-.5 0-1 0-1.4-.3A3.4 3.4 0 017.8 10a3.3 3.3 0 010-2.8 3.4 3.4 0 011.8-1.8L11 5zM4.4 16.2L6.2 15l-1.8-1.2a1 1 0 011.2-1.6l3 2a1 1 0 010 1.6l-3 2a1 1 0 11-1.2-1.6z" fill-rule="evenodd"/></svg>',
      "more-drawer": '<svg width="24" height="24"><path d="M6 10a2 2 0 00-2 2c0 1.1.9 2 2 2a2 2 0 002-2 2 2 0 00-2-2zm12 0a2 2 0 00-2 2c0 1.1.9 2 2 2a2 2 0 002-2 2 2 0 00-2-2zm-6 0a2 2 0 00-2 2c0 1.1.9 2 2 2a2 2 0 002-2 2 2 0 00-2-2z" fill-rule="nonzero"/></svg>',
      "new-document": '<svg width="24" height="24"><path d="M14.4 3H7a2 2 0 00-2 2v14c0 1.1.9 2 2 2h10a2 2 0 002-2V7.6L14.4 3zM17 19H7V5h6v4h4v10z" fill-rule="nonzero"/></svg>',
      "new-tab": '<svg width="24" height="24"><path d="M15 13l2-2v8H5V7h8l-2 2H7v8h8v-4zm4-8v5.5l-2-2-5.6 5.5H10v-1.4L15.5 7l-2-2H19z" fill-rule="evenodd"/></svg>',
      "non-breaking": '<svg width="24" height="24"><path d="M11 11H8a1 1 0 110-2h3V6c0-.6.4-1 1-1s1 .4 1 1v3h3c.6 0 1 .4 1 1s-.4 1-1 1h-3v3c0 .6-.4 1-1 1a1 1 0 01-1-1v-3zm10 4v5H3v-5c0-.6.4-1 1-1s1 .4 1 1v3h14v-3c0-.6.4-1 1-1s1 .4 1 1z" fill-rule="evenodd"/></svg>',
      "notice": '<svg width="24" height="24"><path d="M17.8 9.8L15.4 4 20 8.5v7L15.5 20h-7L4 15.5v-7L8.5 4h7l2.3 5.8zm0 0l2.2 5.7-2.3-5.8zM13 17v-2h-2v2h2zm0-4V7h-2v6h2z" fill-rule="evenodd"/></svg>',
      "ordered-list-rtl": '<svg width="24" height="24"><path d="M6 17h8a1 1 0 010 2H6a1 1 0 010-2zm0-6h8a1 1 0 010 2H6a1 1 0 010-2zm0-6h8a1 1 0 010 2H6a1 1 0 110-2zm13-1v3.5a.5.5 0 11-1 0V5h-.5a.5.5 0 110-1H19zm-1 8.8l.2.2h1.3a.5.5 0 110 1h-1.6a1 1 0 01-.9-1V13c0-.4.3-.8.6-1l1.2-.4.2-.3a.2.2 0 00-.2-.2h-1.3a.5.5 0 01-.5-.5c0-.3.2-.5.5-.5h1.6c.5 0 .9.4.9 1v.1c0 .4-.3.8-.6 1l-1.2.4-.2.3zm2 4.2v2c0 .6-.4 1-1 1h-1.5a.5.5 0 010-1h1.2a.3.3 0 100-.6h-1.3a.4.4 0 110-.8h1.3a.3.3 0 000-.6h-1.2a.5.5 0 110-1H19c.6 0 1 .4 1 1z" fill-rule="evenodd"/></svg>',
      "ordered-list": '<svg width="24" height="24"><path d="M10 17h8c.6 0 1 .4 1 1s-.4 1-1 1h-8a1 1 0 010-2zm0-6h8c.6 0 1 .4 1 1s-.4 1-1 1h-8a1 1 0 010-2zm0-6h8c.6 0 1 .4 1 1s-.4 1-1 1h-8a1 1 0 110-2zM6 4v3.5c0 .3-.2.5-.5.5a.5.5 0 01-.5-.5V5h-.5a.5.5 0 010-1H6zm-1 8.8l.2.2h1.3c.3 0 .5.2.5.5s-.2.5-.5.5H4.9a1 1 0 01-.9-1V13c0-.4.3-.8.6-1l1.2-.4.2-.3a.2.2 0 00-.2-.2H4.5a.5.5 0 01-.5-.5c0-.3.2-.5.5-.5h1.6c.5 0 .9.4.9 1v.1c0 .4-.3.8-.6 1l-1.2.4-.2.3zM7 17v2c0 .6-.4 1-1 1H4.5a.5.5 0 010-1h1.2c.2 0 .3-.1.3-.3 0-.2-.1-.3-.3-.3H4.4a.4.4 0 110-.8h1.3c.2 0 .3-.1.3-.3 0-.2-.1-.3-.3-.3H4.5a.5.5 0 110-1H6c.6 0 1 .4 1 1z" fill-rule="evenodd"/></svg>',
      "orientation": '<svg width="24" height="24"><path d="M7.3 6.4L1 13l6.4 6.5 6.5-6.5-6.5-6.5zM3.7 13l3.6-3.7L11 13l-3.7 3.7-3.6-3.7zM12 6l2.8 2.7c.3.3.3.8 0 1-.3.4-.9.4-1.2 0L9.2 5.7a.8.8 0 010-1.2L13.6.2c.3-.3.9-.3 1.2 0 .3.3.3.8 0 1.1L12 4h1a9 9 0 11-4.3 16.9l1.5-1.5A7 7 0 1013 6h-1z" fill-rule="nonzero"/></svg>',
      "outdent": '<svg width="24" height="24"><path d="M7 5h12c.6 0 1 .4 1 1s-.4 1-1 1H7a1 1 0 110-2zm5 4h7c.6 0 1 .4 1 1s-.4 1-1 1h-7a1 1 0 010-2zm0 4h7c.6 0 1 .4 1 1s-.4 1-1 1h-7a1 1 0 010-2zm-5 4h12a1 1 0 010 2H7a1 1 0 010-2zm1.6-3.8a1 1 0 01-1.2 1.6l-3-2a1 1 0 010-1.6l3-2a1 1 0 011.2 1.6L6.8 12l1.8 1.2z" fill-rule="evenodd"/></svg>',
      "page-break": '<svg width="24" height="24"><g fill-rule="evenodd"><path d="M5 11c.6 0 1 .4 1 1s-.4 1-1 1a1 1 0 010-2zm3 0h1c.6 0 1 .4 1 1s-.4 1-1 1H8a1 1 0 010-2zm4 0c.6 0 1 .4 1 1s-.4 1-1 1a1 1 0 010-2zm3 0h1c.6 0 1 .4 1 1s-.4 1-1 1h-1a1 1 0 010-2zm4 0c.6 0 1 .4 1 1s-.4 1-1 1a1 1 0 010-2zM7 3v5h10V3c0-.6.4-1 1-1s1 .4 1 1v7H5V3c0-.6.4-1 1-1s1 .4 1 1zM6 22a1 1 0 01-1-1v-7h14v7c0 .6-.4 1-1 1a1 1 0 01-1-1v-5H7v5c0 .6-.4 1-1 1z"/></g></svg>',
      "paragraph": '<svg width="24" height="24"><path fill-rule="evenodd" d="M10 5h7a1 1 0 010 2h-1v11a1 1 0 01-2 0V7h-2v11a1 1 0 01-2 0v-6c-.5 0-1 0-1.4-.3A3.4 3.4 0 016.8 10a3.3 3.3 0 010-2.8 3.4 3.4 0 011.8-1.8L10 5z"/></svg>',
      "paste-column-after": '<svg width="24" height="24"><path fill-rule="evenodd" d="M12 1a3 3 0 012.8 2H18c1 0 2 .8 2 1.9V7h-2V5h-2v1c0 .6-.4 1-1 1H9a1 1 0 01-1-1V5H6v13h7v2H6c-1 0-2-.8-2-1.9V5c0-1 .8-2 1.9-2H9.2A3 3 0 0112 1zm8 7v12h-6V8h6zm-1.5 1.5h-3v9h3v-9zM12 3a1 1 0 100 2 1 1 0 000-2z"/></svg>',
      "paste-column-before": '<svg width="24" height="24"><path fill-rule="evenodd" d="M12 1a3 3 0 012.8 2H18c1 0 2 .8 2 1.9V18c0 1-.8 2-1.9 2H11v-2h7V5h-2v1c0 .6-.4 1-1 1H9a1 1 0 01-1-1V5H6v2H4V5c0-1 .8-2 1.9-2H9.2A3 3 0 0112 1zm-2 7v12H4V8h6zM8.5 9.5h-3v9h3v-9zM12 3a1 1 0 100 2 1 1 0 000-2z"/></svg>',
      "paste-row-after": '<svg width="24" height="24"><path fill-rule="evenodd" d="M12 1a3 3 0 012.8 2H18c1 0 2 .8 2 1.9V11h-2V5h-2v1c0 .6-.4 1-1 1H9a1 1 0 01-1-1V5H6v13h14c0 1-.8 2-1.9 2H6c-1 0-2-.8-2-1.9V5c0-1 .8-2 1.9-2H9.2A3 3 0 0112 1zm10 11v5H8v-5h14zm-1.5 1.5h-11v2h11v-2zM12 3a1 1 0 100 2 1 1 0 000-2z"/></svg>',
      "paste-row-before": '<svg width="24" height="24"><path fill-rule="evenodd" d="M12 1a3 3 0 012.8 2H18c1 0 2 .8 2 1.9V7h-2V5h-2v1c0 .6-.4 1-1 1H9a1 1 0 01-1-1V5H6v13h12v-4h2v4c0 1-.8 2-1.9 2H6c-1 0-2-.8-2-1.9V5c0-1 .8-2 1.9-2H9.2A3 3 0 0112 1zm10 7v5H8V8h14zm-1.5 1.5h-11v2h11v-2zM12 3a1 1 0 100 2 1 1 0 000-2z"/></svg>',
      "paste-text": '<svg width="24" height="24"><path d="M18 9V5h-2v1c0 .6-.4 1-1 1H9a1 1 0 01-1-1V5H6v13h3V9h9zM9 20H6a2 2 0 01-2-2V5c0-1.1.9-2 2-2h3.2A3 3 0 0112 1a3 3 0 012.8 2H18a2 2 0 012 2v4h1v12H9v-1zm1.5-9.5v9h9v-9h-9zM12 3a1 1 0 00-1 1c0 .5.4 1 1 1s1-.5 1-1-.4-1-1-1zm0 9h6v2h-.5l-.5-1h-1v4h.8v1h-3.6v-1h.8v-4h-1l-.5 1H12v-2z" fill-rule="nonzero"/></svg>',
      "paste": '<svg width="24" height="24"><path d="M18 9V5h-2v1c0 .6-.4 1-1 1H9a1 1 0 01-1-1V5H6v13h3V9h9zM9 20H6a2 2 0 01-2-2V5c0-1.1.9-2 2-2h3.2A3 3 0 0112 1a3 3 0 012.8 2H18a2 2 0 012 2v4h1v12H9v-1zm1.5-9.5v9h9v-9h-9zM12 3a1 1 0 00-1 1c0 .5.4 1 1 1s1-.5 1-1-.4-1-1-1z" fill-rule="nonzero"/></svg>',
      "permanent-pen": '<svg width="24" height="24"><path d="M10.5 17.5L8 20H3v-3l3.5-3.5a2 2 0 010-3L14 3l1 1-7.3 7.3a1 1 0 000 1.4l3.6 3.6c.4.4 1 .4 1.4 0L20 9l1 1-7.6 7.6a2 2 0 01-2.8 0l-.1-.1z" fill-rule="nonzero"/></svg>',
      "plus": '<svg width="24" height="24"><path d="M12 4c.5 0 1 .4 1 .9V11h6a1 1 0 01.1 2H13v6a1 1 0 01-2 .1V13H5a1 1 0 01-.1-2H11V5c0-.6.4-1 1-1z"/></svg>',
      "preferences": '<svg width="24" height="24"><path d="M20.1 13.5l-1.9.2a5.8 5.8 0 01-.6 1.5l1.2 1.5c.4.4.3 1 0 1.4l-.7.7a1 1 0 01-1.4 0l-1.5-1.2a6.2 6.2 0 01-1.5.6l-.2 1.9c0 .5-.5.9-1 .9h-1a1 1 0 01-1-.9l-.2-1.9a5.8 5.8 0 01-1.5-.6l-1.5 1.2a1 1 0 01-1.4 0l-.7-.7a1 1 0 010-1.4l1.2-1.5a6.2 6.2 0 01-.6-1.5l-1.9-.2a1 1 0 01-.9-1v-1c0-.5.4-1 .9-1l1.9-.2a5.8 5.8 0 01.6-1.5L5.2 7.3a1 1 0 010-1.4l.7-.7a1 1 0 011.4 0l1.5 1.2a6.2 6.2 0 011.5-.6l.2-1.9c0-.5.5-.9 1-.9h1c.5 0 1 .4 1 .9l.2 1.9a5.8 5.8 0 011.5.6l1.5-1.2a1 1 0 011.4 0l.7.7c.3.4.4 1 0 1.4l-1.2 1.5a6.2 6.2 0 01.6 1.5l1.9.2c.5 0 .9.5.9 1v1c0 .5-.4 1-.9 1zM12 15a3 3 0 100-6 3 3 0 000 6z" fill-rule="evenodd"/></svg>',
      "preview": '<svg width="24" height="24"><path d="M3.5 12.5c.5.8 1.1 1.6 1.8 2.3 2 2 4.2 3.2 6.7 3.2s4.7-1.2 6.7-3.2a16.2 16.2 0 002.1-2.8 15.7 15.7 0 00-2.1-2.8c-2-2-4.2-3.2-6.7-3.2a9.3 9.3 0 00-6.7 3.2A16.2 16.2 0 003.2 12c0 .2.2.3.3.5zm-2.4-1l.7-1.2L4 7.8C6.2 5.4 8.9 4 12 4c3 0 5.8 1.4 8.1 3.8a18.2 18.2 0 012.8 3.7v1l-.7 1.2-2.1 2.5c-2.3 2.4-5 3.8-8.1 3.8-3 0-5.8-1.4-8.1-3.8a18.2 18.2 0 01-2.8-3.7 1 1 0 010-1zm12-3.3a2 2 0 102.7 2.6 4 4 0 11-2.6-2.6z" fill-rule="nonzero"/></svg>',
      "print": '<svg width="24" height="24"><path d="M18 8H6a3 3 0 00-3 3v6h2v3h14v-3h2v-6a3 3 0 00-3-3zm-1 10H7v-4h10v4zm.5-5c-.8 0-1.5-.7-1.5-1.5s.7-1.5 1.5-1.5 1.5.7 1.5 1.5-.7 1.5-1.5 1.5zm.5-8H6v2h12V5z" fill-rule="nonzero"/></svg>',
      "quote": '<svg width="24" height="24"><path d="M7.5 17h.9c.4 0 .7-.2.9-.6L11 13V8c0-.6-.4-1-1-1H6a1 1 0 00-1 1v4c0 .6.4 1 1 1h2l-1.3 2.7a1 1 0 00.8 1.3zm8 0h.9c.4 0 .7-.2.9-.6L19 13V8c0-.6-.4-1-1-1h-4a1 1 0 00-1 1v4c0 .6.4 1 1 1h2l-1.3 2.7a1 1 0 00.8 1.3z" fill-rule="nonzero"/></svg>',
      "redo": '<svg width="24" height="24"><path d="M17.6 10H12c-2.8 0-4.4 1.4-4.9 3.5-.4 2 .3 4 1.4 4.6a1 1 0 11-1 1.8c-2-1.2-2.9-4.1-2.3-6.8.6-3 3-5.1 6.8-5.1h5.6l-3.3-3.3a1 1 0 111.4-1.4l5 5a1 1 0 010 1.4l-5 5a1 1 0 01-1.4-1.4l3.3-3.3z" fill-rule="nonzero"/></svg>',
      "reload": '<svg width="24" height="24"><g fill-rule="nonzero"><path d="M5 22.1l-1.2-4.7v-.2a1 1 0 011-1l5 .4a1 1 0 11-.2 2l-2.2-.2a7.8 7.8 0 008.4.2 7.5 7.5 0 003.5-6.4 1 1 0 112 0 9.5 9.5 0 01-4.5 8 9.9 9.9 0 01-10.2 0l.4 1.4a1 1 0 11-2 .5zM13.6 7.4c0-.5.5-1 1-.9l2.8.2a8 8 0 00-9.5-1 7.5 7.5 0 00-3.6 7 1 1 0 01-2 0 9.5 9.5 0 014.5-8.6 10 10 0 0110.9.3l-.3-1a1 1 0 012-.5l1.1 4.8a1 1 0 01-1 1.2l-5-.4a1 1 0 01-.9-1z"/></g></svg>',
      "remove-formatting": '<svg width="24" height="24"><path d="M13.2 6a1 1 0 010 .2l-2.6 10a1 1 0 01-1 .8h-.2a.8.8 0 01-.8-1l2.6-10H8a1 1 0 110-2h9a1 1 0 010 2h-3.8zM5 18h7a1 1 0 010 2H5a1 1 0 010-2zm13 1.5L16.5 18 15 19.5a.7.7 0 01-1-1l1.5-1.5-1.5-1.5a.7.7 0 011-1l1.5 1.5 1.5-1.5a.7.7 0 011 1L17.5 17l1.5 1.5a.7.7 0 01-1 1z" fill-rule="evenodd"/></svg>',
      "remove": '<svg width="24" height="24"><path d="M16 7h3a1 1 0 010 2h-1v9a3 3 0 01-3 3H9a3 3 0 01-3-3V9H5a1 1 0 110-2h3V6a3 3 0 013-3h2a3 3 0 013 3v1zm-2 0V6c0-.6-.4-1-1-1h-2a1 1 0 00-1 1v1h4zm2 2H8v9c0 .6.4 1 1 1h6c.6 0 1-.4 1-1V9zm-7 3a1 1 0 012 0v4a1 1 0 01-2 0v-4zm4 0a1 1 0 012 0v4a1 1 0 01-2 0v-4z" fill-rule="nonzero"/></svg>',
      "resize-handle": '<svg width="10" height="10"><g fill-rule="nonzero"><path d="M8.1 1.1A.5.5 0 119 2l-7 7A.5.5 0 111 8l7-7zM8.1 5.1A.5.5 0 119 6l-3 3A.5.5 0 115 8l3-3z"/></g></svg>',
      "resize": '<svg width="24" height="24"><path d="M4 5c0-.3.1-.5.3-.7.2-.2.4-.3.7-.3h6c.3 0 .5.1.7.3.2.2.3.4.3.7 0 .3-.1.5-.3.7a1 1 0 01-.7.3H7.4L18 16.6V13c0-.3.1-.5.3-.7.2-.2.4-.3.7-.3.3 0 .5.1.7.3.2.2.3.4.3.7v6c0 .3-.1.5-.3.7a1 1 0 01-.7.3h-6a1 1 0 01-.7-.3 1 1 0 01-.3-.7c0-.3.1-.5.3-.7.2-.2.4-.3.7-.3h3.6L6 7.4V11c0 .3-.1.5-.3.7a1 1 0 01-.7.3 1 1 0 01-.7-.3A1 1 0 014 11V5z" fill-rule="evenodd"/></svg>',
      "restore-draft": '<svg width="24" height="24"><g fill-rule="evenodd"><path d="M17 13c0 .6-.4 1-1 1h-4V8c0-.6.4-1 1-1s1 .4 1 1v4h2c.6 0 1 .4 1 1z"/><path d="M4.7 10H9a1 1 0 010 2H3a1 1 0 01-1-1V5a1 1 0 112 0v3l2.5-2.4a9.2 9.2 0 0110.8-1.5A9 9 0 0113.4 21c-2.4.1-4.7-.7-6.5-2.2a1 1 0 111.3-1.5 7.2 7.2 0 0011.6-3.7 7 7 0 00-3.5-7.7A7.2 7.2 0 008 7L4.7 10z" fill-rule="nonzero"/></g></svg>',
      "rotate-left": '<svg width="24" height="24"><path d="M4.7 10H9a1 1 0 010 2H3a1 1 0 01-1-1V5a1 1 0 112 0v3l2.5-2.4a9.2 9.2 0 0110.8-1.5A9 9 0 0113.4 21c-2.4.1-4.7-.7-6.5-2.2a1 1 0 111.3-1.5 7.2 7.2 0 0011.6-3.7 7 7 0 00-3.5-7.7A7.2 7.2 0 008 7L4.7 10z" fill-rule="nonzero"/></svg>',
      "rotate-right": '<svg width="24" height="24"><path d="M20 8V5a1 1 0 012 0v6c0 .6-.4 1-1 1h-6a1 1 0 010-2h4.3L16 7A7.2 7.2 0 007.7 6a7 7 0 003 13.1c1.9.1 3.7-.5 5-1.7a1 1 0 011.4 1.5A9.2 9.2 0 012.2 14c-.9-3.9 1-8 4.5-9.9 3.5-1.9 8-1.3 10.8 1.5L20 8z" fill-rule="nonzero"/></svg>',
      "rtl": '<svg width="24" height="24"><path d="M8 5h8v2h-2v12h-2V7h-2v12H8v-7c-.5 0-1 0-1.4-.3A3.4 3.4 0 014.8 10a3.3 3.3 0 010-2.8 3.4 3.4 0 011.8-1.8L8 5zm12 11.2a1 1 0 11-1 1.6l-3-2a1 1 0 010-1.6l3-2a1 1 0 111 1.6L18.4 15l1.8 1.2z" fill-rule="evenodd"/></svg>',
      "save": '<svg width="24" height="24"><path d="M5 16h14a2 2 0 012 2v2a2 2 0 01-2 2H5a2 2 0 01-2-2v-2c0-1.1.9-2 2-2zm0 2v2h14v-2H5zm10 0h2v2h-2v-2zm-4-6.4L8.7 9.3a1 1 0 10-1.4 1.4l4 4c.4.4 1 .4 1.4 0l4-4a1 1 0 10-1.4-1.4L13 11.6V4a1 1 0 00-2 0v7.6z" fill-rule="nonzero"/></svg>',
      "search": '<svg width="24" height="24"><path d="M16 17.3a8 8 0 111.4-1.4l4.3 4.4a1 1 0 01-1.4 1.4l-4.4-4.3zm-5-.3a6 6 0 100-12 6 6 0 000 12z" fill-rule="nonzero"/></svg>',
      "select-all": '<svg width="24" height="24"><path d="M3 5h2V3a2 2 0 00-2 2zm0 8h2v-2H3v2zm4 8h2v-2H7v2zM3 9h2V7H3v2zm10-6h-2v2h2V3zm6 0v2h2a2 2 0 00-2-2zM5 21v-2H3c0 1.1.9 2 2 2zm-2-4h2v-2H3v2zM9 3H7v2h2V3zm2 18h2v-2h-2v2zm8-8h2v-2h-2v2zm0 8a2 2 0 002-2h-2v2zm0-12h2V7h-2v2zm0 8h2v-2h-2v2zm-4 4h2v-2h-2v2zm0-16h2V3h-2v2zM7 17h10V7H7v10zm2-8h6v6H9V9z" fill-rule="nonzero"/></svg>',
      "selected": '<svg width="24" height="24"><path fill-rule="nonzero" d="M6 4h12a2 2 0 012 2v12a2 2 0 01-2 2H6a2 2 0 01-2-2V6c0-1.1.9-2 2-2zm3.6 10.9L7 12.3a.7.7 0 00-1 1L9.6 17 18 8.6a.7.7 0 000-1 .7.7 0 00-1 0l-7.4 7.3z"/></svg>',
      "settings": '<svg width="24" height="24"><path d="M11 6h8c.6 0 1 .4 1 1s-.4 1-1 1h-8v.3c0 .2 0 .3-.2.5l-.6.2H7.8c-.3 0-.4 0-.6-.2a.7.7 0 01-.2-.6V8H5a1 1 0 110-2h2v-.3c0-.2 0-.3.2-.5l.5-.2h2.5c.3 0 .4 0 .6.2l.2.5V6zM8 8h2V6H8v2zm9 2.8v.2h2c.6 0 1 .4 1 1s-.4 1-1 1h-2v.3c0 .2 0 .3-.2.5l-.6.2h-2.4c-.3 0-.4 0-.6-.2a.7.7 0 01-.2-.6V13H5a1 1 0 010-2h8v-.3c0-.2 0-.3.2-.5l.6-.2h2.4c.3 0 .4 0 .6.2l.2.6zM14 13h2v-2h-2v2zm-3 2.8v.2h8c.6 0 1 .4 1 1s-.4 1-1 1h-8v.3c0 .2 0 .3-.2.5l-.6.2H7.8c-.3 0-.4 0-.6-.2a.7.7 0 01-.2-.6V18H5a1 1 0 010-2h2v-.3c0-.2 0-.3.2-.5l.5-.2h2.5c.3 0 .4 0 .6.2l.2.6zM8 18h2v-2H8v2z" fill-rule="evenodd"/></svg>',
      "sharpen": '<svg width="24" height="24"><path d="M16 6l4 4-8 9-8-9 4-4h8zm-4 10.2l5.5-6.2-.1-.1H12v-.3h5.1l-.2-.2H12V9h4.6l-.2-.2H12v-.3h4.1l-.2-.2H12V8h3.6l-.2-.2H8.7L6.5 10l.1.1H12v.3H6.9l.2.2H12v.3H7.3l.2.2H12v.3H7.7l.3.2h4v.3H8.2l.2.2H12v.3H8.6l.3.2H12v.3H9l.3.2H12v.3H9.5l.2.2H12v.3h-2l.2.2H12v.3h-1.6l.2.2H12v.3h-1.1l.2.2h.9v.3h-.7l.2.2h.5v.3h-.3l.3.2z" fill-rule="evenodd"/></svg>',
      "sourcecode": '<svg width="24" height="24"><g fill-rule="nonzero"><path d="M9.8 15.7c.3.3.3.8 0 1-.3.4-.9.4-1.2 0l-4.4-4.1a.8.8 0 010-1.2l4.4-4.2c.3-.3.9-.3 1.2 0 .3.3.3.8 0 1.1L6 12l3.8 3.7zM14.2 15.7c-.3.3-.3.8 0 1 .4.4.9.4 1.2 0l4.4-4.1c.3-.3.3-.9 0-1.2l-4.4-4.2a.8.8 0 00-1.2 0c-.3.3-.3.8 0 1.1L18 12l-3.8 3.7z"/></g></svg>',
      "spell-check": '<svg width="24" height="24"><path d="M6 8v3H5V5c0-.3.1-.5.3-.7.2-.2.4-.3.7-.3h2c.3 0 .5.1.7.3.2.2.3.4.3.7v6H8V8H6zm0-3v2h2V5H6zm13 0h-3v5h3v1h-3a1 1 0 01-.7-.3 1 1 0 01-.3-.7V5c0-.3.1-.5.3-.7.2-.2.4-.3.7-.3h3v1zm-5 1.5l-.1.7c-.1.2-.3.3-.6.3.3 0 .5.1.6.3l.1.7V10c0 .3-.1.5-.3.7a1 1 0 01-.7.3h-3V4h3c.3 0 .5.1.7.3.2.2.3.4.3.7v1.5zM13 10V8h-2v2h2zm0-3V5h-2v2h2zm3 5l1 1-6.5 7L7 15.5l1.3-1 2.2 2.2L16 12z" fill-rule="evenodd"/></svg>',
      "strike-through": '<svg width="24" height="24"><g fill-rule="evenodd"><path d="M15.6 8.5c-.5-.7-1-1.1-1.3-1.3-.6-.4-1.3-.6-2-.6-2.7 0-2.8 1.7-2.8 2.1 0 1.6 1.8 2 3.2 2.3 4.4.9 4.6 2.8 4.6 3.9 0 1.4-.7 4.1-5 4.1A6.2 6.2 0 017 16.4l1.5-1.1c.4.6 1.6 2 3.7 2 1.6 0 2.5-.4 3-1.2.4-.8.3-2-.8-2.6-.7-.4-1.6-.7-2.9-1-1-.2-3.9-.8-3.9-3.6C7.6 6 10.3 5 12.4 5c2.9 0 4.2 1.6 4.7 2.4l-1.5 1.1z"/><path d="M5 11h14a1 1 0 010 2H5a1 1 0 010-2z" fill-rule="nonzero"/></g></svg>',
      "subscript": '<svg width="24" height="24"><path d="M10.4 10l4.6 4.6-1.4 1.4L9 11.4 4.4 16 3 14.6 7.6 10 3 5.4 4.4 4 9 8.6 13.6 4 15 5.4 10.4 10zM21 19h-5v-1l1-.8 1.7-1.6c.3-.4.5-.8.5-1.2 0-.3 0-.6-.2-.7-.2-.2-.5-.3-.9-.3a2 2 0 00-.8.2l-.7.3-.4-1.1 1-.6 1.2-.2c.8 0 1.4.3 1.8.7.4.4.6.9.6 1.5s-.2 1.1-.5 1.6a8 8 0 01-1.3 1.3l-.6.6h2.6V19z" fill-rule="nonzero"/></svg>',
      "superscript": '<svg width="24" height="24"><path d="M15 9.4L10.4 14l4.6 4.6-1.4 1.4L9 15.4 4.4 20 3 18.6 7.6 14 3 9.4 4.4 8 9 12.6 13.6 8 15 9.4zm5.9 1.6h-5v-1l1-.8 1.7-1.6c.3-.5.5-.9.5-1.3 0-.3 0-.5-.2-.7-.2-.2-.5-.3-.9-.3l-.8.2-.7.4-.4-1.2c.2-.2.5-.4 1-.5.3-.2.8-.2 1.2-.2.8 0 1.4.2 1.8.6.4.4.6 1 .6 1.6 0 .5-.2 1-.5 1.5l-1.3 1.4-.6.5h2.6V11z" fill-rule="nonzero"/></svg>',
      "table-caption": '<svg width="24" height="24"><g fill-rule="nonzero"><rect width="12" height="2" x="3" y="4" rx="1"/><path d="M19 8a2 2 0 012 2v8a2 2 0 01-2 2H5a2 2 0 01-2-2v-8c0-1.1.9-2 2-2h14zM5 15v3h6v-3H5zm14 0h-6v3h6v-3zm0-5h-6v3h6v-3zM5 13h6v-3H5v3z"/></g></svg>',
      "table-cell-classes": '<svg width="24" height="24"><g fill-rule="evenodd"><path fill-rule="nonzero" d="M13 4v9H3V6c0-1.1.9-2 2-2h8zm-2 2H5v5h6V6z"/><path fill-rule="nonzero" d="M13 4h6a2 2 0 012 2v7h-8v-2h6V6h-6V4z" opacity=".2"/><path d="M18 20l-2.6 1.6.7-3-2.4-2 3.1-.2 1.2-2.9 1.2 2.9 3 .2-2.3 2 .7 3z"/><path fill-rule="nonzero" d="M3 13v5c0 1.1.9 2 2 2h8v-7h-2v5H5v-5H3z" opacity=".2"/></g></svg>',
      "table-cell-properties": '<svg width="24" height="24"><path fill-rule="nonzero" d="M19 4a2 2 0 012 2v12a2 2 0 01-2 2H5a2 2 0 01-2-2V6c0-1.1.9-2 2-2h14zm-8 9H5v5h6v-5zm8 0h-6v5h6v-5zm-8-7H5v5h6V6z"/></svg>',
      "table-cell-select-all": '<svg width="24" height="24"><g fill-rule="evenodd"><path fill-rule="nonzero" d="M19 4a2 2 0 012 2v12a2 2 0 01-2 2H5a2 2 0 01-2-2V6c0-1.1.9-2 2-2h14zm0 2H5v12h14V6z"/><path d="M13 6v5h6v2h-6v5h-2v-5H5v-2h6V6h2z" opacity=".2"/></g></svg>',
      "table-cell-select-inner": '<svg width="24" height="24"><g fill-rule="evenodd"><path fill-rule="nonzero" d="M19 4a2 2 0 012 2v12a2 2 0 01-2 2H5a2 2 0 01-2-2V6c0-1.1.9-2 2-2h14zm0 2H5v12h14V6z" opacity=".2"/><path d="M13 6v5h6v2h-6v5h-2v-5H5v-2h6V6h2z"/></g></svg>',
      "table-classes": '<svg width="24" height="24"><g fill-rule="evenodd"><path fill-rule="nonzero" d="M19 4a2 2 0 012 2v7h-8v7H5a2 2 0 01-2-2V6c0-1.1.9-2 2-2h14zm-8 9H5v5h6v-5zm8-7h-6v5h6V6zm-8 0H5v5h6V6z"/><path d="M18 20l-2.6 1.6.7-3-2.4-2 3.1-.2 1.2-2.9 1.2 2.9 3 .2-2.3 2 .7 3z"/></g></svg>',
      "table-delete-column": '<svg width="24" height="24"><path fill-rule="nonzero" d="M19 4a2 2 0 012 2v12a2 2 0 01-2 2H5a2 2 0 01-2-2V6c0-1.1.9-2 2-2h14zm-4 4h-2V6h-2v2H9V6H5v12h4v-2h2v2h2v-2h2v2h4V6h-4v2zm.3.5l1 1.2-3 2.3 3 2.3-1 1.2L12 13l-3.3 2.6-1-1.2 3-2.3-3-2.3 1-1.2L12 11l3.3-2.5z"/></svg>',
      "table-delete-row": '<svg width="24" height="24"><path fill-rule="nonzero" d="M19 4a2 2 0 012 2v12a2 2 0 01-2 2H5a2 2 0 01-2-2V6c0-1.1.9-2 2-2h14zm0 2H5v3h2.5v2H5v2h2.5v2H5v3h14v-3h-2.5v-2H19v-2h-2.5V9H19V6zm-4.7 1.8l1.2 1L13 12l2.6 3.3-1.2 1-2.3-3-2.3 3-1.2-1L11 12 8.5 8.7l1.2-1 2.3 3 2.3-3z"/></svg>',
      "table-delete-table": '<svg width="24" height="24"><g fill-rule="nonzero"><path d="M19 4a2 2 0 012 2v12a2 2 0 01-2 2H5a2 2 0 01-2-2V6c0-1.1.9-2 2-2h14zM5 6v12h14V6H5z"/><path d="M14.4 8.6l1 1-2.3 2.4 2.3 2.4-1 1-2.4-2.3-2.4 2.3-1-1 2.3-2.4-2.3-2.4 1-1 2.4 2.3z"/></g></svg>',
      "table-insert-column-after": '<svg width="24" height="24"><path fill-rule="nonzero" d="M20 4c.6 0 1 .4 1 1v2a1 1 0 01-2 0V6h-8v12h8v-1a1 1 0 012 0v2c0 .5-.4 1-.9 1H5a2 2 0 01-2-2V6c0-1.1.9-2 2-2h15zM9 13H5v5h4v-5zm7-5c.5 0 1 .4 1 .9V11h2a1 1 0 01.1 2H17v2a1 1 0 01-2 .1V13h-2a1 1 0 01-.1-2H15V9c0-.6.4-1 1-1zM9 6H5v5h4V6z"/></svg>',
      "table-insert-column-before": '<svg width="24" height="24"><path fill-rule="nonzero" d="M19 4a2 2 0 012 2v12a2 2 0 01-2 2H4a1 1 0 01-1-1v-2a1 1 0 012 0v1h8V6H5v1a1 1 0 11-2 0V5c0-.6.4-1 1-1h15zm0 9h-4v5h4v-5zM8 8c.5 0 1 .4 1 .9V11h2a1 1 0 01.1 2H9v2a1 1 0 01-2 .1V13H5a1 1 0 01-.1-2H7V9c0-.6.4-1 1-1zm11-2h-4v5h4V6z"/></svg>',
      "table-insert-row-above": '<svg width="24" height="24"><path fill-rule="nonzero" d="M6 4a1 1 0 110 2H5v6h14V6h-1a1 1 0 010-2h2c.6 0 1 .4 1 1v13a2 2 0 01-2 2H5a2 2 0 01-2-2V5c0-.6.4-1 1-1h2zm5 10H5v4h6v-4zm8 0h-6v4h6v-4zM12 3c.5 0 1 .4 1 .9V6h2a1 1 0 010 2h-2v2a1 1 0 01-2 .1V8H9a1 1 0 010-2h2V4c0-.6.4-1 1-1z"/></svg>',
      "table-insert-row-after": '<svg width="24" height="24"><path fill-rule="nonzero" d="M12 13c.5 0 1 .4 1 .9V16h2a1 1 0 01.1 2H13v2a1 1 0 01-2 .1V18H9a1 1 0 01-.1-2H11v-2c0-.6.4-1 1-1zm6 7a1 1 0 010-2h1v-6H5v6h1a1 1 0 010 2H4a1 1 0 01-1-1V6c0-1.1.9-2 2-2h14a2 2 0 012 2v13c0 .5-.4 1-.9 1H18zM11 6H5v4h6V6zm8 0h-6v4h6V6z"/></svg>',
      "table-left-header": '<svg width="24" height="24"><path d="M19 4a2 2 0 012 2v12a2 2 0 01-2 2H5a2 2 0 01-2-2V6c0-1.1.9-2 2-2h14zm0 9h-4v5h4v-5zm-6 0H9v5h4v-5zm0-7H9v5h4V6zm6 0h-4v5h4V6z"/></svg>',
      "table-merge-cells": '<svg width="24" height="24"><path fill-rule="nonzero" d="M19 4a2 2 0 012 2v12a2 2 0 01-2 2H5a2 2 0 01-2-2V6c0-1.1.9-2 2-2h14zM5 15.5V18h3v-2.5H5zm14-5h-9V18h9v-7.5zM19 6h-4v2.5h4V6zM8 6H5v2.5h3V6zm5 0h-3v2.5h3V6zm-8 7.5h3v-3H5v3z"/></svg>',
      "table-row-numbering-rtl": '<svg width="24" height="24"><path d="M6 4a2 2 0 00-2 2v13c0 1.1.9 2 2 2h12a2 2 0 002-2V6a2 2 0 00-2-2H6zm0 12h8v3H6v-3zm11 0c.6 0 1 .4 1 1v1a1 1 0 01-2 0v-1c0-.6.4-1 1-1zM6 11h8v3H6v-3zm11 0c.6 0 1 .4 1 1v1a1 1 0 01-2 0v-1c0-.6.4-1 1-1zM6 6h8v3H6V6zm11 0c.6 0 1 .4 1 1v1a1 1 0 11-2 0V7c0-.6.4-1 1-1z"/></svg>',
      "table-row-numbering": '<svg width="24" height="24"><path d="M18 4a2 2 0 012 2v13a2 2 0 01-2 2H6a2 2 0 01-2-2V6c0-1.1.9-2 2-2h12zm0 12h-8v3h8v-3zM7 16a1 1 0 00-1 1v1a1 1 0 002 0v-1c0-.6-.4-1-1-1zm11-5h-8v3h8v-3zM7 11a1 1 0 00-1 1v1a1 1 0 002 0v-1c0-.6-.4-1-1-1zm11-5h-8v3h8V6zM7 6a1 1 0 00-1 1v1a1 1 0 102 0V7c0-.6-.4-1-1-1z"/></svg>',
      "table-row-properties": '<svg width="24" height="24"><path fill-rule="nonzero" d="M19 4a2 2 0 012 2v12a2 2 0 01-2 2H5a2 2 0 01-2-2V6c0-1.1.9-2 2-2h14zM5 15v3h6v-3H5zm14 0h-6v3h6v-3zm0-9h-6v3h6V6zM5 9h6V6H5v3z"/></svg>',
      "table-split-cells": '<svg width="24" height="24"><path fill-rule="nonzero" d="M19 4a2 2 0 012 2v12a2 2 0 01-2 2H5a2 2 0 01-2-2V6c0-1.1.9-2 2-2h14zM8 15.5H5V18h3v-2.5zm11-5h-9V18h9v-7.5zm-2.5 1l1 1-2 2 2 2-1 1-2-2-2 2-1-1 2-2-2-2 1-1 2 2 2-2zm-8.5-1H5v3h3v-3zM19 6h-4v2.5h4V6zM8 6H5v2.5h3V6zm5 0h-3v2.5h3V6z"/></svg>',
      "table-top-header": '<svg width="24" height="24"><path d="M19 4a2 2 0 012 2v12a2 2 0 01-2 2H5a2 2 0 01-2-2V6c0-1.1.9-2 2-2h14zm-8 11H5v3h6v-3zm8 0h-6v3h6v-3zm0-5h-6v3h6v-3zM5 13h6v-3H5v3z"/></svg>',
      "table": '<svg width="24" height="24"><path fill-rule="nonzero" d="M19 4a2 2 0 012 2v12a2 2 0 01-2 2H5a2 2 0 01-2-2V6c0-1.1.9-2 2-2h14zM5 14v4h6v-4H5zm14 0h-6v4h6v-4zm0-6h-6v4h6V8zM5 12h6V8H5v4z"/></svg>',
      "template": '<svg width="24" height="24"><path d="M19 19v-1H5v1h14zM9 16v-4a5 5 0 116 0v4h4a2 2 0 012 2v3H3v-3c0-1.1.9-2 2-2h4zm4 0v-5l.8-.6a3 3 0 10-3.6 0l.8.6v5h2z" fill-rule="nonzero"/></svg>',
      "temporary-placeholder": '<svg width="24" height="24"><g fill-rule="evenodd"><path d="M9 7.6V6h2.5V4.5a.5.5 0 111 0V6H15v1.6a8 8 0 11-6 0zm-2.6 5.3a.5.5 0 00.3.6c.3 0 .6 0 .6-.3l.1-.2a5 5 0 013.3-2.8c.3-.1.4-.4.4-.6-.1-.3-.4-.5-.6-.4a6 6 0 00-4.1 3.7z"/><circle cx="14" cy="4" r="1"/><circle cx="12" cy="2" r="1"/><circle cx="10" cy="4" r="1"/></g></svg>',
      "text-color": '<svg width="24" height="24"><g fill-rule="evenodd"><path id="tox-icon-text-color__color" d="M3 18h18v3H3z"/><path d="M8.7 16h-.8a.5.5 0 01-.5-.6l2.7-9c.1-.3.3-.4.5-.4h2.8c.2 0 .4.1.5.4l2.7 9a.5.5 0 01-.5.6h-.8a.5.5 0 01-.4-.4l-.7-2.2c0-.3-.3-.4-.5-.4h-3.4c-.2 0-.4.1-.5.4l-.7 2.2c0 .3-.2.4-.4.4zm2.6-7.6l-.6 2a.5.5 0 00.5.6h1.6a.5.5 0 00.5-.6l-.6-2c0-.3-.3-.4-.5-.4h-.4c-.2 0-.4.1-.5.4z"/></g></svg>',
      "toc": '<svg width="24" height="24"><path d="M5 5c.6 0 1 .4 1 1s-.4 1-1 1a1 1 0 110-2zm3 0h11c.6 0 1 .4 1 1s-.4 1-1 1H8a1 1 0 110-2zm-3 8c.6 0 1 .4 1 1s-.4 1-1 1a1 1 0 010-2zm3 0h11c.6 0 1 .4 1 1s-.4 1-1 1H8a1 1 0 010-2zm0-4c.6 0 1 .4 1 1s-.4 1-1 1a1 1 0 110-2zm3 0h8c.6 0 1 .4 1 1s-.4 1-1 1h-8a1 1 0 010-2zm-3 8c.6 0 1 .4 1 1s-.4 1-1 1a1 1 0 010-2zm3 0h8c.6 0 1 .4 1 1s-.4 1-1 1h-8a1 1 0 010-2z" fill-rule="evenodd"/></svg>',
      "translate": '<svg width="24" height="24"><path d="M12.7 14.3l-.3.7-.4.7-2.2-2.2-3.1 3c-.3.4-.8.4-1 0a.7.7 0 010-1l3.1-3A12.4 12.4 0 016.7 9H8a10.1 10.1 0 001.7 2.4c.5-.5 1-1.1 1.4-1.8l.9-2H4.7a.7.7 0 110-1.5h4.4v-.7c0-.4.3-.8.7-.8.4 0 .7.4.7.8v.7H15c.4 0 .8.3.8.7 0 .4-.4.8-.8.8h-1.4a12.3 12.3 0 01-1 2.4 13.5 13.5 0 01-1.7 2.3l1.9 1.8zm4.3-3l2.7 7.3a.5.5 0 01-.4.7 1 1 0 01-1-.7l-.6-1.5h-3.4l-.6 1.5a1 1 0 01-1 .7.5.5 0 01-.4-.7l2.7-7.4a1 1 0 012 0zm-2.2 4.4h2.4L16 12.5l-1.2 3.2z" fill-rule="evenodd"/></svg>',
      "underline": '<svg width="24" height="24"><path d="M16 5c.6 0 1 .4 1 1v5.5a4 4 0 01-.4 1.8l-1 1.4a5.3 5.3 0 01-5.5 1 5 5 0 01-1.6-1c-.5-.4-.8-.9-1.1-1.4a4 4 0 01-.4-1.8V6c0-.6.4-1 1-1s1 .4 1 1v5.5c0 .3 0 .6.2 1l.6.7a3.3 3.3 0 002.2.8 3.4 3.4 0 002.2-.8c.3-.2.4-.5.6-.8l.2-.9V6c0-.6.4-1 1-1zM8 17h8c.6 0 1 .4 1 1s-.4 1-1 1H8a1 1 0 010-2z" fill-rule="evenodd"/></svg>',
      "undo": '<svg width="24" height="24"><path d="M6.4 8H12c3.7 0 6.2 2 6.8 5.1.6 2.7-.4 5.6-2.3 6.8a1 1 0 01-1-1.8c1.1-.6 1.8-2.7 1.4-4.6-.5-2.1-2.1-3.5-4.9-3.5H6.4l3.3 3.3a1 1 0 11-1.4 1.4l-5-5a1 1 0 010-1.4l5-5a1 1 0 011.4 1.4L6.4 8z" fill-rule="nonzero"/></svg>',
      "unlink": '<svg width="24" height="24"><path d="M6.2 12.3a1 1 0 011.4 1.4l-2 2a2 2 0 102.6 2.8l4.8-4.8a1 1 0 000-1.4 1 1 0 111.4-1.3 2.9 2.9 0 010 4L9.6 20a3.9 3.9 0 01-5.5-5.5l2-2zm11.6-.6a1 1 0 01-1.4-1.4l2.1-2a2 2 0 10-2.7-2.8L11 10.3a1 1 0 000 1.4A1 1 0 119.6 13a2.9 2.9 0 010-4L14.4 4a3.9 3.9 0 015.5 5.5l-2 2zM7.6 6.3a.8.8 0 01-1 1.1L3.3 4.2a.7.7 0 111-1l3.2 3.1zM5.1 8.6a.8.8 0 010 1.5H3a.8.8 0 010-1.5H5zm5-3.5a.8.8 0 01-1.5 0V3a.8.8 0 011.5 0V5zm6 11.8a.8.8 0 011-1l3.2 3.2a.8.8 0 01-1 1L16 17zm-2.2 2a.8.8 0 011.5 0V21a.8.8 0 01-1.5 0V19zm5-3.5a.7.7 0 110-1.5H21a.8.8 0 010 1.5H19z" fill-rule="nonzero"/></svg>',
      "unlock": '<svg width="24" height="24"><path d="M16 5c.8 0 1.5.3 2.1.9.6.6.9 1.3.9 2.1v3h-2V8a1 1 0 00-.3-.7A1 1 0 0016 7h-2a1 1 0 00-.7.3 1 1 0 00-.3.7v3h.3c.2 0 .3 0 .5.2l.2.6v7.4c0 .3 0 .4-.2.6l-.6.2H4.8c-.3 0-.4 0-.6-.2a.7.7 0 01-.2-.6v-7.4c0-.3 0-.4.2-.6l.5-.2H11V8c0-.8.3-1.5.9-2.1.6-.6 1.3-.9 2.1-.9h2z" fill-rule="evenodd"/></svg>',
      "unordered-list": '<svg width="24" height="24"><path d="M11 5h8c.6 0 1 .4 1 1s-.4 1-1 1h-8a1 1 0 010-2zm0 6h8c.6 0 1 .4 1 1s-.4 1-1 1h-8a1 1 0 010-2zm0 6h8c.6 0 1 .4 1 1s-.4 1-1 1h-8a1 1 0 010-2zM4.5 6c0-.4.1-.8.4-1 .3-.4.7-.5 1.1-.5.4 0 .8.1 1 .4.4.3.5.7.5 1.1 0 .4-.1.8-.4 1-.3.4-.7.5-1.1.5-.4 0-.8-.1-1-.4-.4-.3-.5-.7-.5-1.1zm0 6c0-.4.1-.8.4-1 .3-.4.7-.5 1.1-.5.4 0 .8.1 1 .4.4.3.5.7.5 1.1 0 .4-.1.8-.4 1-.3.4-.7.5-1.1.5-.4 0-.8-.1-1-.4-.4-.3-.5-.7-.5-1.1zm0 6c0-.4.1-.8.4-1 .3-.4.7-.5 1.1-.5.4 0 .8.1 1 .4.4.3.5.7.5 1.1 0 .4-.1.8-.4 1-.3.4-.7.5-1.1.5-.4 0-.8-.1-1-.4-.4-.3-.5-.7-.5-1.1z" fill-rule="evenodd"/></svg>',
      "unselected": '<svg width="24" height="24"><path fill-rule="nonzero" d="M6 4h12a2 2 0 012 2v12a2 2 0 01-2 2H6a2 2 0 01-2-2V6c0-1.1.9-2 2-2zm0 1a1 1 0 00-1 1v12c0 .6.4 1 1 1h12c.6 0 1-.4 1-1V6c0-.6-.4-1-1-1H6z"/></svg>',
      "upload": '<svg width="24" height="24"><path d="M18 19v-2a1 1 0 012 0v3c0 .6-.4 1-1 1H5a1 1 0 01-1-1v-3a1 1 0 012 0v2h12zM11 6.4L8.7 8.7a1 1 0 01-1.4-1.4l4-4a1 1 0 011.4 0l4 4a1 1 0 11-1.4 1.4L13 6.4V16a1 1 0 01-2 0V6.4z" fill-rule="nonzero"/></svg>',
      "user": '<svg width="24" height="24"><path d="M12 24a12 12 0 110-24 12 12 0 010 24zm-8.7-5.3a11 11 0 0017.4 0C19.4 16.3 14.6 15 12 15c-2.6 0-7.4 1.3-8.7 3.7zM12 13c2.2 0 4-2 4-4.5S14.2 4 12 4 8 6 8 8.5 9.8 13 12 13z" fill-rule="nonzero"/></svg>',
      "vertical-align": '<svg width="24" height="24"><g fill-rule="nonzero"><rect width="18" height="2" x="3" y="11" rx="1"/><path d="M12 2c.6 0 1 .4 1 1v4l2-1.3a1 1 0 011.2 1.5l-.1.1-4.1 3-4-3a1 1 0 011-1.7l2 1.5V3c0-.6.4-1 1-1zm0 11.8l4 2.9a1 1 0 01-1 1.7l-2-1.5V21c0 .5-.4 1-.9 1H12a1 1 0 01-1-1v-4l-2 1.3a1 1 0 01-1.2-.1l-.1-.1a1 1 0 01.1-1.3l.1-.1 4.1-3z"/></g></svg>',
      "visualblocks": '<svg width="24" height="24"><path d="M9 19v2H7v-2h2zm-4 0v2a2 2 0 01-2-2h2zm8 0v2h-2v-2h2zm8 0a2 2 0 01-2 2v-2h2zm-4 0v2h-2v-2h2zM15 7a1 1 0 010 2v7a1 1 0 01-2 0V9h-1v7a1 1 0 01-2 0v-4a2.5 2.5 0 01-.2-5H15zM5 15v2H3v-2h2zm16 0v2h-2v-2h2zM5 11v2H3v-2h2zm16 0v2h-2v-2h2zM5 7v2H3V7h2zm16 0v2h-2V7h2zM5 3v2H3c0-1.1.9-2 2-2zm8 0v2h-2V3h2zm6 0a2 2 0 012 2h-2V3zM9 3v2H7V3h2zm8 0v2h-2V3h2z" fill-rule="evenodd"/></svg>',
      "visualchars": '<svg width="24" height="24"><path d="M10 5h7a1 1 0 010 2h-1v11a1 1 0 01-2 0V7h-2v11a1 1 0 01-2 0v-6c-.5 0-1 0-1.4-.3A3.4 3.4 0 016.8 10a3.3 3.3 0 010-2.8 3.4 3.4 0 011.8-1.8L10 5z" fill-rule="evenodd"/></svg>',
      "warning": '<svg width="24" height="24"><path d="M19.8 18.3c.2.5.3.9 0 1.2-.1.3-.5.5-1 .5H5.2c-.5 0-.9-.2-1-.5-.3-.3-.2-.7 0-1.2L11 4.7l.5-.5.5-.2c.2 0 .3 0 .5.2.2 0 .3.3.5.5l6.8 13.6zM12 18c.3 0 .5-.1.7-.3.2-.2.3-.4.3-.7a1 1 0 00-.3-.7 1 1 0 00-.7-.3 1 1 0 00-.7.3 1 1 0 00-.3.7c0 .3.1.5.3.7.2.2.4.3.7.3zm.7-3l.3-4a1 1 0 00-.3-.7 1 1 0 00-.7-.3 1 1 0 00-.7.3 1 1 0 00-.3.7l.3 4h1.4z" fill-rule="evenodd"/></svg>',
      "zoom-in": '<svg width="24" height="24"><path d="M16 17.3a8 8 0 111.4-1.4l4.3 4.4a1 1 0 01-1.4 1.4l-4.4-4.3zm-5-.3a6 6 0 100-12 6 6 0 000 12zm-1-9a1 1 0 012 0v6a1 1 0 01-2 0V8zm-2 4a1 1 0 010-2h6a1 1 0 010 2H8z" fill-rule="nonzero"/></svg>',
      "zoom-out": '<svg width="24" height="24"><path d="M16 17.3a8 8 0 111.4-1.4l4.3 4.4a1 1 0 01-1.4 1.4l-4.4-4.3zm-5-.3a6 6 0 100-12 6 6 0 000 12zm-3-5a1 1 0 010-2h6a1 1 0 010 2H8z" fill-rule="nonzero"/></svg>'
    }
  });

  // src/components/TinymceEditor.vue
  var import_plugin_vue2_normalizer2 = __toESM(__require("lib/vue2/normalizer.js"));
  var _sfc_main2 = {
    components: {
      editor: import_tinymce.editor
    },
    data() {
      return {
        editorValue: "",
        plugins: {
          type: [String, Array],
          default: "link lists image code table textcolor wordcount contextmenu paste media fullscreen searchreplace "
        },
        toolbar: {
          type: [String, Array],
          default: "undo redo |fontsizeselect  formatselect | bold italic | alignleft aligncenter alignright alignjustify | bullist numlist outdent indent | lists image media table | removeformat |　paste | code | fullscreen | searchreplace "
        },
        init: {
          language_url: require_zh_CN(),
          language: "zh_CN",
          height: 500,
          width: 500,
          min_height: 500,
          max_height: 500,
          toolbar_mode: "wrap",
          plugins: this.plugins,
          toolbar: this.toolbar,
          content_style: "p {margin: 5px 0;}",
          fontsize_formats: "12px 14px 16px 18px 24px 36px 48px 56px 72px",
          font_formats: "微软雅黑=Microsoft YaHei,Helvetica Neue,PingFang SC,sans-serif;苹果苹方=PingFang SC,Microsoft YaHei,sans-serif;宋体=simsun,serif;仿宋体=FangSong,serif;黑体=SimHei,sans-serif;Arial=arial,helvetica,sans-serif;Arial Black=arial black,avant garde;Book Antiqua=book antiqua,palatino;",
          branding: false
        }
      };
    }
  };
  var _sfc_render2 = function render3() {
    var _vm = this, _c2 = _vm._self._c;
    return _c2("div", [_c2("editor", { attrs: { "init": _vm.init }, model: { value: _vm.editorValue, callback: function($$v) {
      _vm.editorValue = $$v;
    }, expression: "editorValue" } })], 1);
  };
  var _sfc_staticRenderFns2 = [];
  var __component__2 = /* @__PURE__ */ (0, import_plugin_vue2_normalizer2.default)(_sfc_main2, _sfc_render2, _sfc_staticRenderFns2, false, null, null, null, null);
  var TinymceEditor = __component__2.exports;

  // src/components/CodeMirror.vue
  var import_vue_codemirror = __toESM(require_vue_codemirror());
  var import_plugin_vue2_normalizer3 = __toESM(__require("lib/vue2/normalizer.js"));
  var _sfc_main3 = {
    components: {
      codemirror: import_vue_codemirror.codemirror
    },
    data() {
      return {
        code: "",
        options: {
          tabSize: 2,
          theme: "rubyblue",
          lineNumbers: true,
          line: true,
          styleActiveLine: true,
          hintOptions: {
            completeSingle: true
          }
        }
      };
    }
  };
  var _sfc_render3 = function render4() {
    var _vm = this, _c2 = _vm._self._c;
    return _c2("div", [_c2("codemirror", { attrs: { "options": _vm.options }, model: { value: _vm.code, callback: function($$v) {
      _vm.code = $$v;
    }, expression: "code" } })], 1);
  };
  var _sfc_staticRenderFns3 = [];
  var __component__3 = /* @__PURE__ */ (0, import_plugin_vue2_normalizer3.default)(_sfc_main3, _sfc_render3, _sfc_staticRenderFns3, false, null, null, null, null);
  var CodeMirror = __component__3.exports;

  // src/views/demo/example2.m.vue
  var import_enums_m = __require("enums/enums.js");
  var import_plugin_vue2_normalizer4 = __toESM(__require("lib/vue2/normalizer.js"));
  var _sfc_main4 = {
    components: {
      BarChart,
      TinymceEditor,
      CodeMirror
    },
    data() {
      return {
        statusEnum: import_enums_m.statusEnum
      };
    },
    methods: {},
    mounted() {
    }
  };
  var _sfc_render4 = function render5() {
    var _vm = this, _c2 = _vm._self._c;
    return _c2("div", { staticClass: "p20" }, [_c2("div", { staticClass: "sub_title" }, [_vm._v("echarts")]), _c2("bar-chart", { staticClass: "mt20" }), _c2("div", { staticClass: "sub_title" }, [_vm._v("tinymce")]), _c2("tinymce-editor"), _c2("div", { staticClass: "sub_title" }, [_vm._v("codemirror")]), _c2("code-mirror")], 1);
  };
  var _sfc_staticRenderFns4 = [];
  var __component__4 = /* @__PURE__ */ (0, import_plugin_vue2_normalizer4.default)(_sfc_main4, _sfc_render4, _sfc_staticRenderFns4, false, null, "50656a59", null, null);
  var example2_m = __component__4.exports;
  return __toCommonJS(example2_m_exports);
})();
/*!
* ZRender, a high performance 2d drawing library.
*
* Copyright (c) 2013, Baidu Inc.
* All rights reserved.
*
* LICENSE
* https://github.com/ecomfe/zrender/blob/master/LICENSE.txt
*/
/*! *****************************************************************************
Copyright (c) Microsoft Corporation.

Permission to use, copy, modify, and/or distribute this software for any
purpose with or without fee is hereby granted.

THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,
INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM
LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR
OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
PERFORMANCE OF THIS SOFTWARE.
***************************************************************************** */
//# sourceMappingURL=views/demo/example2.js.map